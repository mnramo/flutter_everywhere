// Generated by dart2js (fast startup emitter, strong), the Dart to JavaScript compiler version: 2.2.1-edge.c46deebfb63c5855dc4a1674ad885bd652590914.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error.
//
// dartCallInstrumentation(id, qualifiedName):
//    if this function is defined, it will be called at each entry of a
//    method or constructor. Used only when compiling programs with
//    --experiment-call-instrumentation.
//
// defaultPackagesBase:
//    Override the location where `package:` uris are resolved from. By default
//    they are resolved under "packages/" from the current window location.
{
}
(function dartProgram() {
  function copyProperties(from, to) {
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      to[key] = from[key];
    }
  }
  var supportsDirectProtoAccess = function() {
    var cls = function() {
    };
    cls.prototype = {p: {}};
    var object = new cls();
    if (!(object.__proto__ && object.__proto__.p === cls.prototype.p))
      return false;
    try {
      if (typeof navigator != "undefined" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Chrome/") >= 0)
        return true;
      if (typeof version == "function" && version.length == 0) {
        var v = version();
        if (/^\d+\.\d+\.\d+\.\d+$/.test(v))
          return true;
      }
    } catch (_) {
    }
    return false;
  }();
  function setFunctionNamesIfNecessary(holders) {
    function t() {
    }
    ;
    if (typeof t.name == "string")
      return;
    for (var i = 0; i < holders.length; i++) {
      var holder = holders[i];
      var keys = Object.keys(holder);
      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        var f = holder[key];
        if (typeof f == 'function')
          f.name = key;
      }
    }
  }
  function inherit(cls, sup) {
    cls.prototype.constructor = cls;
    cls.prototype["$is" + cls.name] = cls;
    if (sup != null) {
      if (supportsDirectProtoAccess) {
        cls.prototype.__proto__ = sup.prototype;
        return;
      }
      var clsPrototype = Object.create(sup.prototype);
      copyProperties(cls.prototype, clsPrototype);
      cls.prototype = clsPrototype;
    }
  }
  function inheritMany(sup, classes) {
    for (var i = 0; i < classes.length; i++)
      inherit(classes[i], sup);
  }
  function mixin(cls, mixin) {
    copyProperties(mixin.prototype, cls.prototype);
    cls.prototype.constructor = cls;
  }
  function lazy(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      holder[getterName] = function() {
        H.throwCyclicInit(name);
      };
      var result;
      var sentinelInProgress = initializer;
      try {
        if (holder[name] === uninitializedSentinel) {
          result = holder[name] = sentinelInProgress;
          result = holder[name] = initializer();
        } else
          result = holder[name];
      } finally {
        if (result === sentinelInProgress)
          holder[name] = null;
        holder[getterName] = function() {
          return this[name];
        };
      }
      return result;
    };
  }
  function makeConstList(list) {
    list.immutable$list = Array;
    list.fixed$length = Array;
    return list;
  }
  function convertToFastObject(properties) {
    function t() {
    }
    t.prototype = properties;
    new t();
    return properties;
  }
  function convertAllToFastObject(arrayOfObjects) {
    for (var i = 0; i < arrayOfObjects.length; ++i)
      convertToFastObject(arrayOfObjects[i]);
  }
  var functionCounter = 0;
  function tearOffGetter(funcs, applyTrampolineIndex, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "applyTrampolineIndex", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(receiver) {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, applyTrampolineIndex, reflectionInfo, false, true, name);" + "return new c(this, funcs[0], receiver, name);" + "}")(funcs, applyTrampolineIndex, reflectionInfo, name, H, null) : new Function("funcs", "applyTrampolineIndex", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, applyTrampolineIndex, reflectionInfo, false, false, name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, applyTrampolineIndex, reflectionInfo, name, H, null);
  }
  function tearOff(funcs, applyTrampolineIndex, reflectionInfo, isStatic, name, isIntercepted) {
    var cache = null;
    return isStatic ? function() {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, applyTrampolineIndex, reflectionInfo, true, false, name).prototype;
      return cache;
    } : tearOffGetter(funcs, applyTrampolineIndex, reflectionInfo, name, isIntercepted);
  }
  var typesOffset = 0;
  function installTearOff(container, getterName, isStatic, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    var funs = [];
    for (var i = 0; i < funsOrNames.length; i++) {
      var fun = funsOrNames[i];
      if (typeof fun == 'string')
        fun = container[fun];
      fun.$callName = callNames[i];
      funs.push(fun);
    }
    var fun = funs[0];
    fun.$requiredArgCount = requiredParameterCount;
    fun.$defaultValues = optionalParameterDefaultValues;
    var reflectionInfo = funType;
    if (typeof reflectionInfo == "number")
      reflectionInfo = reflectionInfo + typesOffset;
    var name = funsOrNames[0];
    fun.$stubName = name;
    var getterFunction = tearOff(funs, applyIndex || 0, reflectionInfo, isStatic, name, isIntercepted);
    container[getterName] = getterFunction;
    if (isStatic)
      fun.$tearOff = getterFunction;
  }
  function installStaticTearOff(container, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    return installTearOff(container, getterName, true, false, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex);
  }
  function installInstanceTearOff(container, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    return installTearOff(container, getterName, false, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex);
  }
  function setOrUpdateInterceptorsByTag(newTags) {
    var tags = init.interceptorsByTag;
    if (!tags) {
      init.interceptorsByTag = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function setOrUpdateLeafTags(newTags) {
    var tags = init.leafTags;
    if (!tags) {
      init.leafTags = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function updateTypes(newTypes) {
    var types = init.types;
    var length = types.length;
    types.push.apply(types, newTypes);
    return length;
  }
  function updateHolder(holder, newHolder) {
    copyProperties(newHolder, holder);
    return holder;
  }
  var hunkHelpers = function() {
    var mkInstance = function(isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installInstanceTearOff(container, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex);
        };
      },
      mkStatic = function(requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installStaticTearOff(container, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex);
        };
      };
    return {inherit: inherit, inheritMany: inheritMany, mixin: mixin, installStaticTearOff: installStaticTearOff, installInstanceTearOff: installInstanceTearOff, _instance_0u: mkInstance(0, 0, null, ["call$0"], 0), _instance_1u: mkInstance(0, 1, null, ["call$1"], 0), _instance_2u: mkInstance(0, 2, null, ["call$2"], 0), _instance_0i: mkInstance(1, 0, null, ["call$0"], 0), _instance_1i: mkInstance(1, 1, null, ["call$1"], 0), _instance_2i: mkInstance(1, 2, null, ["call$2"], 0), _static_0: mkStatic(0, null, ["call$0"], 0), _static_1: mkStatic(1, null, ["call$1"], 0), _static_2: mkStatic(2, null, ["call$2"], 0), makeConstList: makeConstList, lazy: lazy, updateHolder: updateHolder, convertToFastObject: convertToFastObject, setFunctionNamesIfNecessary: setFunctionNamesIfNecessary, updateTypes: updateTypes, setOrUpdateInterceptorsByTag: setOrUpdateInterceptorsByTag, setOrUpdateLeafTags: setOrUpdateLeafTags};
  }();
  function initializeDeferredHunk(hunk) {
    typesOffset = init.types.length;
    hunk(hunkHelpers, init, holders, $);
  }
  function getGlobalFromName(name) {
    for (var i = 0; i < holders.length; i++) {
      if (holders[i] == C)
        continue;
      if (holders[i][name])
        return holders[i][name];
    }
  }
  var C = {},
  H = {JS_CONST: function JS_CONST() {
    },
    hexDigitValue: function(char) {
      var digit, letter;
      H.assertHelper(char <= 65535);
      digit = char ^ 48;
      if (digit <= 9)
        return digit;
      letter = char | 32;
      if (97 <= letter && letter <= 102)
        return letter - 87;
      return -1;
    },
    SubListIterable$: function(_iterable, _start, _endOrLength, $E) {
      P.RangeError_checkNotNegative(_start, "start");
      if (_endOrLength != null) {
        P.RangeError_checkNotNegative(_endOrLength, "end");
        if (_start > _endOrLength)
          H.throwExpression(P.RangeError$range(_start, 0, _endOrLength, "start", null));
      }
      return new H.SubListIterable(_iterable, _start, _endOrLength, [$E]);
    },
    MappedIterable_MappedIterable: function(iterable, $function, $S, $T) {
      H.assertSubtype(iterable, "$isIterable", [$S], "$asIterable");
      H.functionTypeCheck($function, {func: 1, ret: $T, args: [$S]});
      if (!!J.getInterceptor$(iterable).$isEfficientLengthIterable)
        return new H.EfficientLengthMappedIterable(iterable, $function, [$S, $T]);
      return new H.MappedIterable(iterable, $function, [$S, $T]);
    },
    IterableElementError_noElement: function() {
      return new P.StateError("No element");
    },
    IterableElementError_tooMany: function() {
      return new P.StateError("Too many elements");
    },
    IterableElementError_tooFew: function() {
      return new P.StateError("Too few elements");
    },
    Sort_sort: function(a, compare, $E) {
      H.assertSubtype(a, "$isList", [$E], "$asList");
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [$E, $E]});
      H.Sort__doSort(a, 0, J.get$length$asx(a) - 1, compare, $E);
    },
    Sort__doSort: function(a, left, right, compare, $E) {
      H.assertSubtype(a, "$isList", [$E], "$asList");
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [$E, $E]});
      if (right - left <= 32)
        H.Sort__insertionSort(a, left, right, compare, $E);
      else
        H.Sort__dualPivotQuicksort(a, left, right, compare, $E);
    },
    Sort__insertionSort: function(a, left, right, compare, $E) {
      var i, t1, el, j, j0;
      H.assertSubtype(a, "$isList", [$E], "$asList");
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [$E, $E]});
      for (i = left + 1, t1 = J.getInterceptor$asx(a); i <= right; ++i) {
        el = t1.$index(a, i);
        j = i;
        while (true) {
          if (!(j > left && J.$gt$n(compare.call$2(t1.$index(a, j - 1), el), 0)))
            break;
          j0 = j - 1;
          t1.$indexSet(a, j, t1.$index(a, j0));
          j = j0;
        }
        t1.$indexSet(a, j, el);
      }
    },
    Sort__dualPivotQuicksort: function(a, left, right, compare, $E) {
      var t1, sixth, index1, index5, index3, index2, index4, el1, el2, el3, el4, el5, t0, less, great, k, ak, comp, great0, less0, pivots_are_equal, comp_pivot1, comp_pivot2, t2;
      H.assertSubtype(a, "$isList", [$E], "$asList");
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [$E, $E]});
      t1 = right - left;
      H.assertHelper(t1 > 32);
      sixth = C.JSInt_methods._tdivFast$1(t1 + 1, 6);
      index1 = left + sixth;
      index5 = right - sixth;
      index3 = C.JSInt_methods._tdivFast$1(left + right, 2);
      index2 = index3 - sixth;
      index4 = index3 + sixth;
      t1 = J.getInterceptor$asx(a);
      el1 = t1.$index(a, index1);
      el2 = t1.$index(a, index2);
      el3 = t1.$index(a, index3);
      el4 = t1.$index(a, index4);
      el5 = t1.$index(a, index5);
      if (J.$gt$n(compare.call$2(el1, el2), 0)) {
        t0 = el2;
        el2 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el4, el5), 0)) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      if (J.$gt$n(compare.call$2(el1, el3), 0)) {
        t0 = el3;
        el3 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el3), 0)) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el1, el4), 0)) {
        t0 = el4;
        el4 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el3, el4), 0)) {
        t0 = el4;
        el4 = el3;
        el3 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el5), 0)) {
        t0 = el5;
        el5 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el3), 0)) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el4, el5), 0)) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      t1.$indexSet(a, index1, el1);
      t1.$indexSet(a, index3, el3);
      t1.$indexSet(a, index5, el5);
      t1.$indexSet(a, index2, t1.$index(a, left));
      t1.$indexSet(a, index4, t1.$index(a, right));
      less = left + 1;
      great = right - 1;
      if (J.$eq$(compare.call$2(el2, el4), 0)) {
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          comp = compare.call$2(ak, el2);
          if (comp === 0)
            continue;
          if (typeof comp !== "number")
            return comp.$lt();
          if (comp < 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else
            for (; true;) {
              comp = compare.call$2(t1.$index(a, great), el2);
              if (typeof comp !== "number")
                return comp.$gt();
              if (comp > 0) {
                --great;
                continue;
              } else {
                great0 = great - 1;
                if (comp < 0) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  great = great0;
                  less = less0;
                  break;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  great = great0;
                  break;
                }
              }
            }
        }
        pivots_are_equal = true;
      } else {
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          comp_pivot1 = compare.call$2(ak, el2);
          if (typeof comp_pivot1 !== "number")
            return comp_pivot1.$lt();
          if (comp_pivot1 < 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else {
            comp_pivot2 = compare.call$2(ak, el4);
            if (typeof comp_pivot2 !== "number")
              return comp_pivot2.$gt();
            if (comp_pivot2 > 0)
              for (; true;) {
                comp = compare.call$2(t1.$index(a, great), el4);
                if (typeof comp !== "number")
                  return comp.$gt();
                if (comp > 0) {
                  --great;
                  if (great < k)
                    break;
                  continue;
                } else {
                  comp = compare.call$2(t1.$index(a, great), el2);
                  if (typeof comp !== "number")
                    return comp.$lt();
                  great0 = great - 1;
                  if (comp < 0) {
                    t1.$indexSet(a, k, t1.$index(a, less));
                    less0 = less + 1;
                    t1.$indexSet(a, less, t1.$index(a, great));
                    t1.$indexSet(a, great, ak);
                    less = less0;
                  } else {
                    t1.$indexSet(a, k, t1.$index(a, great));
                    t1.$indexSet(a, great, ak);
                  }
                  great = great0;
                  break;
                }
              }
          }
        }
        pivots_are_equal = false;
      }
      t2 = less - 1;
      t1.$indexSet(a, left, t1.$index(a, t2));
      t1.$indexSet(a, t2, el2);
      t2 = great + 1;
      t1.$indexSet(a, right, t1.$index(a, t2));
      t1.$indexSet(a, t2, el4);
      H.Sort__doSort(a, left, less - 2, compare, $E);
      H.Sort__doSort(a, great + 2, right, compare, $E);
      if (pivots_are_equal)
        return;
      if (less < index1 && great > index5) {
        for (; J.$eq$(compare.call$2(t1.$index(a, less), el2), 0);)
          ++less;
        for (; J.$eq$(compare.call$2(t1.$index(a, great), el4), 0);)
          --great;
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          if (compare.call$2(ak, el2) === 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else if (compare.call$2(ak, el4) === 0)
            for (; true;)
              if (compare.call$2(t1.$index(a, great), el4) === 0) {
                --great;
                if (great < k)
                  break;
                continue;
              } else {
                comp = compare.call$2(t1.$index(a, great), el2);
                if (typeof comp !== "number")
                  return comp.$lt();
                great0 = great - 1;
                if (comp < 0) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  less = less0;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                }
                great = great0;
                break;
              }
        }
        H.Sort__doSort(a, less, great, compare, $E);
      } else
        H.Sort__doSort(a, less, great, compare, $E);
    },
    EfficientLengthIterable: function EfficientLengthIterable() {
    },
    ListIterable: function ListIterable() {
    },
    SubListIterable: function SubListIterable(t0, t1, t2, t3) {
      var _ = this;
      _._iterable = t0;
      _._start = t1;
      _._endOrLength = t2;
      _.$ti = t3;
    },
    ListIterator: function ListIterator(t0, t1, t2) {
      var _ = this;
      _._iterable = t0;
      _.__internal$_length = t1;
      _._index = 0;
      _._current = null;
      _.$ti = t2;
    },
    MappedIterable: function MappedIterable(t0, t1, t2) {
      this._iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    EfficientLengthMappedIterable: function EfficientLengthMappedIterable(t0, t1, t2) {
      this._iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    MappedIterator: function MappedIterator(t0, t1, t2) {
      var _ = this;
      _._current = null;
      _._iterator = t0;
      _._f = t1;
      _.$ti = t2;
    },
    MappedListIterable: function MappedListIterable(t0, t1, t2) {
      this._source = t0;
      this._f = t1;
      this.$ti = t2;
    },
    WhereIterable: function WhereIterable(t0, t1, t2) {
      this._iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    WhereIterator: function WhereIterator(t0, t1, t2) {
      this._iterator = t0;
      this._f = t1;
      this.$ti = t2;
    },
    ExpandIterable: function ExpandIterable(t0, t1, t2) {
      this._iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    ExpandIterator: function ExpandIterator(t0, t1, t2, t3) {
      var _ = this;
      _._iterator = t0;
      _._f = t1;
      _._currentExpansion = t2;
      _._current = null;
      _.$ti = t3;
    },
    EmptyIterator: function EmptyIterator(t0) {
      this.$ti = t0;
    },
    WhereTypeIterable: function WhereTypeIterable(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    WhereTypeIterator: function WhereTypeIterator(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    FixedLengthListMixin: function FixedLengthListMixin() {
    },
    ReversedListIterable: function ReversedListIterable(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    ConstantMap__throwUnmodifiable: function() {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable Map"));
    },
    instantiate1: function(f, T1) {
      var t1;
      H.interceptedTypeCheck(f, "$isClosure");
      t1 = new H.Instantiation1(f, [T1]);
      t1.Instantiation$1(f);
      return t1;
    },
    instantiate2: function(f, T1, T2) {
      var t1;
      H.interceptedTypeCheck(f, "$isClosure");
      t1 = new H.Instantiation2(f, [T1, T2]);
      t1.Instantiation$1(f);
      return t1;
    },
    unminifyOrTag: function(rawClassName) {
      var preserved = H.stringTypeCheck(init.mangledGlobalNames[rawClassName]);
      if (typeof preserved === "string")
        return preserved;
      return rawClassName;
    },
    getType: function(index) {
      return init.types[H.intTypeCheck(index)];
    },
    isJsIndexable: function(object, record) {
      var result;
      if (record != null) {
        result = record.x;
        if (result != null)
          return result;
      }
      return !!J.getInterceptor$(object).$isJavaScriptIndexingBehavior;
    },
    S: function(value) {
      var res;
      if (typeof value === "string")
        return value;
      if (typeof value === "number") {
        if (value !== 0)
          return "" + value;
      } else if (true === value)
        return "true";
      else if (false === value)
        return "false";
      else if (value == null)
        return "null";
      res = J.toString$0$(value);
      if (typeof res !== "string")
        throw H.wrapException(H.argumentErrorValue(value));
      return res;
    },
    Primitives_objectHashCode: function(object) {
      var hash = object.$identityHash;
      if (hash == null) {
        hash = Math.random() * 0x3fffffff | 0;
        object.$identityHash = hash;
      }
      return hash;
    },
    Primitives_parseInt: function(source, radix) {
      var decimalMatch, maxCharCode, t1, digitsPart, i,
        match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
      if (match == null)
        return;
      if (3 >= match.length)
        return H.ioore(match, 3);
      decimalMatch = H.stringTypeCheck(match[3]);
      if (radix == null) {
        if (decimalMatch != null)
          return parseInt(source, 10);
        if (match[2] != null)
          return parseInt(source, 16);
        return;
      }
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
      if (radix === 10 && decimalMatch != null)
        return parseInt(source, 10);
      if (radix < 10 || decimalMatch == null) {
        maxCharCode = radix <= 10 ? 47 + radix : 86 + radix;
        t1 = match[1];
        H.assertHelper(typeof t1 === "string");
        digitsPart = match[1];
        for (t1 = digitsPart.length, i = 0; i < t1; ++i)
          if ((C.JSString_methods._codeUnitAt$1(digitsPart, i) | 32) > maxCharCode)
            return;
      }
      return parseInt(source, radix);
    },
    Primitives_parseDouble: function(source) {
      var result, trimmed;
      if (typeof source !== "string")
        H.throwExpression(H.argumentErrorValue(source));
      if (!/^\s*[+-]?(?:Infinity|NaN|(?:\.\d+|\d+(?:\.\d*)?)(?:[eE][+-]?\d+)?)\s*$/.test(source))
        return;
      result = parseFloat(source);
      if (isNaN(result)) {
        trimmed = J.trim$0$s(source);
        if (trimmed === "NaN" || trimmed === "+NaN" || trimmed === "-NaN")
          return result;
        return;
      }
      return result;
    },
    Primitives_objectTypeName: function(object) {
      return H.Primitives__objectClassName(object) + H._joinArguments(H.getRuntimeTypeInfo(object), 0, null);
    },
    Primitives__objectClassName: function(object) {
      var interceptorConstructorName, $name, t1, dispatchName, objectConstructor, match, decompiledName,
        interceptor = J.getInterceptor$(object),
        interceptorConstructor = interceptor.constructor;
      if (typeof interceptorConstructor == "function") {
        interceptorConstructorName = interceptorConstructor.name;
        $name = typeof interceptorConstructorName === "string" ? interceptorConstructorName : null;
      } else
        $name = null;
      t1 = $name == null;
      if (t1 || interceptor === C.Interceptor_methods || !!interceptor.$isUnknownJavaScriptObject) {
        dispatchName = C.C_JS_CONST(object);
        if (t1)
          $name = dispatchName;
        if (dispatchName === "Object") {
          objectConstructor = object.constructor;
          if (typeof objectConstructor == "function") {
            match = String(objectConstructor).match(/^\s*function\s*([\w$]*)\s*\(/);
            decompiledName = match == null ? null : match[1];
            if (typeof decompiledName === "string" && /^\w+$/.test(decompiledName))
              $name = decompiledName;
          }
        }
        return $name;
      }
      $name = $name;
      return H.unminifyOrTag($name.length > 1 && C.JSString_methods._codeUnitAt$1($name, 0) === 36 ? C.JSString_methods.substring$1($name, 1) : $name);
    },
    Primitives_dateNow: function() {
      return Date.now();
    },
    Primitives_initTicker: function() {
      var $window, performance;
      if ($.Primitives_timerFrequency != null)
        return;
      $.Primitives_timerFrequency = 1000;
      $.Primitives_timerTicks = H._js_helper_Primitives_dateNow$closure();
      if (typeof window == "undefined")
        return;
      $window = window;
      if ($window == null)
        return;
      performance = $window.performance;
      if (performance == null)
        return;
      if (typeof performance.now != "function")
        return;
      $.Primitives_timerFrequency = 1000000;
      $.Primitives_timerTicks = new H.Primitives_initTicker_closure(performance);
    },
    Primitives__fromCharCodeApply: function(array) {
      var result, i, i0, chunkEnd,
        end = array.length;
      if (end <= 500)
        return String.fromCharCode.apply(null, array);
      for (result = "", i = 0; i < end; i = i0) {
        i0 = i + 500;
        chunkEnd = i0 < end ? i0 : end;
        result += String.fromCharCode.apply(null, array.slice(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCodePoints: function(codePoints) {
      var t1, _i, i,
        a = H.setRuntimeTypeInfo([], [P.int]);
      for (t1 = codePoints.length, _i = 0; _i < codePoints.length; codePoints.length === t1 || (0, H.throwConcurrentModificationError)(codePoints), ++_i) {
        i = codePoints[_i];
        if (typeof i !== "number" || Math.floor(i) !== i)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i <= 65535)
          C.JSArray_methods.add$1(a, i);
        else if (i <= 1114111) {
          C.JSArray_methods.add$1(a, 55296 + (C.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
          C.JSArray_methods.add$1(a, 56320 + (i & 1023));
        } else
          throw H.wrapException(H.argumentErrorValue(i));
      }
      return H.Primitives__fromCharCodeApply(a);
    },
    Primitives_stringFromCharCodes: function(charCodes) {
      var t1, _i, i;
      for (t1 = charCodes.length, _i = 0; _i < t1; ++_i) {
        i = charCodes[_i];
        if (typeof i !== "number" || Math.floor(i) !== i)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i < 0)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i > 65535)
          return H.Primitives_stringFromCodePoints(charCodes);
      }
      return H.Primitives__fromCharCodeApply(charCodes);
    },
    Primitives_stringFromNativeUint8List: function(charCodes, start, end) {
      var i, result, i0, chunkEnd;
      if (end <= 500 && start === 0 && end === charCodes.length)
        return String.fromCharCode.apply(null, charCodes);
      for (i = start, result = ""; i < end; i = i0) {
        i0 = i + 500;
        chunkEnd = i0 < end ? i0 : end;
        result += String.fromCharCode.apply(null, charCodes.subarray(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCharCode: function(charCode) {
      var bits;
      if (0 <= charCode) {
        if (charCode <= 65535)
          return String.fromCharCode(charCode);
        if (charCode <= 1114111) {
          bits = charCode - 65536;
          return String.fromCharCode((55296 | C.JSInt_methods._shrOtherPositive$1(bits, 10)) >>> 0, 56320 | bits & 1023);
        }
      }
      throw H.wrapException(P.RangeError$range(charCode, 0, 1114111, null, null));
    },
    iae: function(argument) {
      throw H.wrapException(H.argumentErrorValue(argument));
    },
    ioore: function(receiver, index) {
      if (receiver == null)
        J.get$length$asx(receiver);
      throw H.wrapException(H.diagnoseIndexError(receiver, index));
    },
    diagnoseIndexError: function(indexable, index) {
      var $length, _s5_ = "index";
      if (typeof index !== "number" || Math.floor(index) !== index)
        return new P.ArgumentError(true, index, _s5_, null);
      $length = H.intTypeCheck(J.get$length$asx(indexable));
      if (index < 0 || index >= $length)
        return P.IndexError$(index, indexable, _s5_, null, $length);
      return P.RangeError$value(index, _s5_);
    },
    diagnoseRangeError: function(start, end, $length) {
      var _s13_ = "Invalid value";
      if (start > $length)
        return new P.RangeError(0, $length, true, start, "start", _s13_);
      if (end != null)
        if (end < start || end > $length)
          return new P.RangeError(start, $length, true, end, "end", _s13_);
      return new P.ArgumentError(true, end, "end", null);
    },
    argumentErrorValue: function(object) {
      return new P.ArgumentError(true, object, null, null);
    },
    checkNum: function(value) {
      if (typeof value !== "number")
        throw H.wrapException(H.argumentErrorValue(value));
      return value;
    },
    wrapException: function(ex) {
      var wrapper;
      if (ex == null)
        ex = new P.NullThrownError();
      wrapper = new Error();
      wrapper.dartException = ex;
      if ("defineProperty" in Object) {
        Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
        wrapper.name = "";
      } else
        wrapper.toString = H.toStringWrapper;
      return wrapper;
    },
    toStringWrapper: function() {
      return J.toString$0$(this.dartException);
    },
    throwExpression: function(ex) {
      throw H.wrapException(ex);
    },
    throwConcurrentModificationError: function(collection) {
      throw H.wrapException(P.ConcurrentModificationError$(collection));
    },
    TypeErrorDecoder_extractPattern: function(message) {
      var match, $arguments, argumentsExpr, expr, method, receiver;
      message = H.quoteStringForRegExp(message.replace(String({}), '$receiver$'));
      match = message.match(/\\\$[a-zA-Z]+\\\$/g);
      if (match == null)
        match = H.setRuntimeTypeInfo([], [P.String]);
      $arguments = match.indexOf("\\$arguments\\$");
      argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
      expr = match.indexOf("\\$expr\\$");
      method = match.indexOf("\\$method\\$");
      receiver = match.indexOf("\\$receiver\\$");
      return new H.TypeErrorDecoder(message.replace(new RegExp('\\\\\\$arguments\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$argumentsExpr\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$expr\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$method\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$receiver\\\\\\$', 'g'), '((?:x|[^x])*)'), $arguments, argumentsExpr, expr, method, receiver);
    },
    TypeErrorDecoder_provokeCallErrorOn: function(expression) {
      return function($expr$) {
        var $argumentsExpr$ = '$arguments$';
        try {
          $expr$.$method$($argumentsExpr$);
        } catch (e) {
          return e.message;
        }
      }(expression);
    },
    TypeErrorDecoder_provokePropertyErrorOn: function(expression) {
      return function($expr$) {
        try {
          $expr$.$method$;
        } catch (e) {
          return e.message;
        }
      }(expression);
    },
    NullError$: function(_message, match) {
      return new H.NullError(_message, match == null ? null : match.method);
    },
    JsNoSuchMethodError$: function(_message, match) {
      var t1 = match == null,
        t2 = t1 ? null : match.method;
      return new H.JsNoSuchMethodError(_message, t2, t1 ? null : match.receiver);
    },
    unwrapException: function(ex) {
      var message, number, ieErrorCode, nsme, notClosure, nullCall, nullLiteralCall, undefCall, undefLiteralCall, nullProperty, undefProperty, undefLiteralProperty, match, t2, _null = null,
        t1 = new H.unwrapException_saveStackTrace(ex);
      if (ex == null)
        return;
      if (ex instanceof H.ExceptionAndStackTrace)
        return t1.call$1(ex.dartException);
      if (typeof ex !== "object")
        return ex;
      if ("dartException" in ex)
        return t1.call$1(ex.dartException);
      else if (!("message" in ex))
        return ex;
      message = ex.message;
      if ("number" in ex && typeof ex.number == "number") {
        number = ex.number;
        ieErrorCode = number & 65535;
        if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
          switch (ieErrorCode) {
            case 438:
              return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", _null));
            case 445:
            case 5007:
              return t1.call$1(H.NullError$(H.S(message) + " (Error " + ieErrorCode + ")", _null));
          }
      }
      if (ex instanceof TypeError) {
        nsme = $.$get$TypeErrorDecoder_noSuchMethodPattern();
        notClosure = $.$get$TypeErrorDecoder_notClosurePattern();
        nullCall = $.$get$TypeErrorDecoder_nullCallPattern();
        nullLiteralCall = $.$get$TypeErrorDecoder_nullLiteralCallPattern();
        undefCall = $.$get$TypeErrorDecoder_undefinedCallPattern();
        undefLiteralCall = $.$get$TypeErrorDecoder_undefinedLiteralCallPattern();
        nullProperty = $.$get$TypeErrorDecoder_nullPropertyPattern();
        $.$get$TypeErrorDecoder_nullLiteralPropertyPattern();
        undefProperty = $.$get$TypeErrorDecoder_undefinedPropertyPattern();
        undefLiteralProperty = $.$get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
        match = nsme.matchTypeError$1(message);
        if (match != null)
          return t1.call$1(H.JsNoSuchMethodError$(H.stringTypeCheck(message), match));
        else {
          match = notClosure.matchTypeError$1(message);
          if (match != null) {
            match.method = "call";
            return t1.call$1(H.JsNoSuchMethodError$(H.stringTypeCheck(message), match));
          } else {
            match = nullCall.matchTypeError$1(message);
            if (match == null) {
              match = nullLiteralCall.matchTypeError$1(message);
              if (match == null) {
                match = undefCall.matchTypeError$1(message);
                if (match == null) {
                  match = undefLiteralCall.matchTypeError$1(message);
                  if (match == null) {
                    match = nullProperty.matchTypeError$1(message);
                    if (match == null) {
                      match = nullLiteralCall.matchTypeError$1(message);
                      if (match == null) {
                        match = undefProperty.matchTypeError$1(message);
                        if (match == null) {
                          match = undefLiteralProperty.matchTypeError$1(message);
                          t2 = match != null;
                        } else
                          t2 = true;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
            if (t2)
              return t1.call$1(H.NullError$(H.stringTypeCheck(message), match));
          }
        }
        return t1.call$1(new H.UnknownJsTypeError(typeof message === "string" ? message : ""));
      }
      if (ex instanceof RangeError) {
        if (typeof message === "string" && message.indexOf("call stack") !== -1)
          return new P.StackOverflowError();
        message = function(ex) {
          try {
            return String(ex);
          } catch (e) {
          }
          return null;
        }(ex);
        return t1.call$1(new P.ArgumentError(false, _null, _null, typeof message === "string" ? message.replace(/^RangeError:\s*/, "") : message));
      }
      if (typeof InternalError == "function" && ex instanceof InternalError)
        if (typeof message === "string" && message === "too much recursion")
          return new P.StackOverflowError();
      return ex;
    },
    getTraceFromException: function(exception) {
      var trace;
      if (exception instanceof H.ExceptionAndStackTrace)
        return exception.stackTrace;
      if (exception == null)
        return new H._StackTrace(exception);
      trace = exception.$cachedTrace;
      if (trace != null)
        return trace;
      return exception.$cachedTrace = new H._StackTrace(exception);
    },
    objectHashCode: function(object) {
      if (object == null || typeof object != 'object')
        return J.get$hashCode$(object);
      else
        return H.Primitives_objectHashCode(object);
    },
    fillLiteralMap: function(keyValuePairs, result) {
      var $length, index, index0, key,
        t1 = typeof keyValuePairs === "object" && keyValuePairs !== null && keyValuePairs.constructor === Array;
      H.assertHelper(t1);
      $length = keyValuePairs.length;
      for (index = 0; index < $length;) {
        index0 = index + 1;
        H.assertHelper(t1);
        key = keyValuePairs[index];
        index = index0 + 1;
        H.assertHelper(t1);
        result.$indexSet(0, key, keyValuePairs[index0]);
      }
      return result;
    },
    invokeClosure: function(closure, numberOfArguments, arg1, arg2, arg3, arg4) {
      H.interceptedTypeCheck(closure, "$isFunction");
      switch (H.intTypeCheck(numberOfArguments)) {
        case 0:
          return closure.call$0();
        case 1:
          return closure.call$1(arg1);
        case 2:
          return closure.call$2(arg1, arg2);
        case 3:
          return closure.call$3(arg1, arg2, arg3);
        case 4:
          return closure.call$4(arg1, arg2, arg3, arg4);
      }
      throw H.wrapException(P.Exception_Exception("Unsupported number of arguments for wrapped closure"));
    },
    convertDartClosureToJS: function(closure, arity) {
      var $function = closure.$identity;
      if (!!$function)
        return $function;
      $function = function(closure, arity, invoke) {
        return function(a1, a2, a3, a4) {
          return invoke(closure, arity, a1, a2, a3, a4);
        };
      }(closure, arity, H.invokeClosure);
      closure.$identity = $function;
      return $function;
    },
    Closure_fromTearOff: function(receiver, functions, applyTrampolineIndex, reflectionInfo, isStatic, isIntercepted, propertyName) {
      var $constructor, t1, trampoline, signatureFunction, getReceiver, applyTrampoline, i, stub, stubCallName, _null = null,
        $function = functions[0],
        callName = $function.$callName,
        $prototype = isStatic ? Object.create(new H.StaticClosure().constructor.prototype) : Object.create(new H.BoundClosure(_null, _null, _null, _null).constructor.prototype);
      $prototype.$initialize = $prototype.constructor;
      if (isStatic)
        $constructor = function static_tear_off() {
          this.$initialize();
        };
      else {
        t1 = $.Closure_functionCounter;
        if (typeof t1 !== "number")
          return t1.$add();
        $.Closure_functionCounter = t1 + 1;
        t1 = new Function("a,b,c,d" + t1, "this.$initialize(a,b,c,d" + t1 + ")");
        $constructor = t1;
      }
      $prototype.constructor = $constructor;
      $constructor.prototype = $prototype;
      if (!isStatic) {
        trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
        trampoline.$reflectionInfo = reflectionInfo;
      } else {
        $prototype.$static_name = propertyName;
        trampoline = $function;
      }
      if (typeof reflectionInfo == "number")
        signatureFunction = function(getType, t) {
          return function() {
            return getType(t);
          };
        }(H.getType, reflectionInfo);
      else if (typeof reflectionInfo == "function")
        if (isStatic)
          signatureFunction = reflectionInfo;
        else {
          getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
          signatureFunction = function(f, r) {
            return function() {
              return f.apply({$receiver: r(this)}, arguments);
            };
          }(reflectionInfo, getReceiver);
        }
      else
        throw H.wrapException("Error in reflectionInfo.");
      $prototype.$signature = signatureFunction;
      $prototype[callName] = trampoline;
      for (applyTrampoline = trampoline, i = 1; i < functions.length; ++i) {
        stub = functions[i];
        stubCallName = stub.$callName;
        if (stubCallName != null) {
          stub = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
          $prototype[stubCallName] = stub;
        }
        if (i === applyTrampolineIndex) {
          stub.$reflectionInfo = reflectionInfo;
          applyTrampoline = stub;
        }
      }
      $prototype["call*"] = applyTrampoline;
      $prototype.$requiredArgCount = $function.$requiredArgCount;
      $prototype.$defaultValues = $function.$defaultValues;
      return $constructor;
    },
    Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
      var getSelf = H.BoundClosure_selfOf;
      switch (isSuperCall ? -1 : arity) {
        case 0:
          return function(n, S) {
            return function() {
              return S(this)[n]();
            };
          }(stubName, getSelf);
        case 1:
          return function(n, S) {
            return function(a) {
              return S(this)[n](a);
            };
          }(stubName, getSelf);
        case 2:
          return function(n, S) {
            return function(a, b) {
              return S(this)[n](a, b);
            };
          }(stubName, getSelf);
        case 3:
          return function(n, S) {
            return function(a, b, c) {
              return S(this)[n](a, b, c);
            };
          }(stubName, getSelf);
        case 4:
          return function(n, S) {
            return function(a, b, c, d) {
              return S(this)[n](a, b, c, d);
            };
          }(stubName, getSelf);
        case 5:
          return function(n, S) {
            return function(a, b, c, d, e) {
              return S(this)[n](a, b, c, d, e);
            };
          }(stubName, getSelf);
        default:
          return function(f, s) {
            return function() {
              return f.apply(s(this), arguments);
            };
          }($function, getSelf);
      }
    },
    Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
      var stubName, arity, lookedUpFunction, t1, t2, selfName, $arguments;
      if (isIntercepted)
        return H.Closure_forwardInterceptedCallTo(receiver, $function);
      stubName = $function.$stubName;
      arity = $function.length;
      lookedUpFunction = receiver[stubName];
      t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
      t2 = !t1 || arity >= 27;
      if (t2)
        return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
      if (arity === 0) {
        t1 = $.Closure_functionCounter;
        if (typeof t1 !== "number")
          return t1.$add();
        $.Closure_functionCounter = t1 + 1;
        selfName = "self" + t1;
        t1 = "return function(){var " + selfName + " = this.";
        t2 = $.BoundClosure_selfFieldNameCache;
        return new Function(t1 + H.S(t2 == null ? $.BoundClosure_selfFieldNameCache = H.BoundClosure_computeFieldNamed("self") : t2) + ";return " + selfName + "." + H.S(stubName) + "();}")();
      }
      H.assertHelper(1 <= arity && arity < 27);
      $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
      t1 = $.Closure_functionCounter;
      if (typeof t1 !== "number")
        return t1.$add();
      $.Closure_functionCounter = t1 + 1;
      $arguments += t1;
      t1 = "return function(" + $arguments + "){return this.";
      t2 = $.BoundClosure_selfFieldNameCache;
      return new Function(t1 + H.S(t2 == null ? $.BoundClosure_selfFieldNameCache = H.BoundClosure_computeFieldNamed("self") : t2) + "." + H.S(stubName) + "(" + $arguments + ");}")();
    },
    Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
      var getSelf = H.BoundClosure_selfOf,
        getReceiver = H.BoundClosure_receiverOf;
      switch (isSuperCall ? -1 : arity) {
        case 0:
          throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
        case 1:
          return function(n, s, r) {
            return function() {
              return s(this)[n](r(this));
            };
          }($name, getSelf, getReceiver);
        case 2:
          return function(n, s, r) {
            return function(a) {
              return s(this)[n](r(this), a);
            };
          }($name, getSelf, getReceiver);
        case 3:
          return function(n, s, r) {
            return function(a, b) {
              return s(this)[n](r(this), a, b);
            };
          }($name, getSelf, getReceiver);
        case 4:
          return function(n, s, r) {
            return function(a, b, c) {
              return s(this)[n](r(this), a, b, c);
            };
          }($name, getSelf, getReceiver);
        case 5:
          return function(n, s, r) {
            return function(a, b, c, d) {
              return s(this)[n](r(this), a, b, c, d);
            };
          }($name, getSelf, getReceiver);
        case 6:
          return function(n, s, r) {
            return function(a, b, c, d, e) {
              return s(this)[n](r(this), a, b, c, d, e);
            };
          }($name, getSelf, getReceiver);
        default:
          return function(f, s, r, a) {
            return function() {
              a = [r(this)];
              Array.prototype.push.apply(a, arguments);
              return f.apply(s(this), a);
            };
          }($function, getSelf, getReceiver);
      }
    },
    Closure_forwardInterceptedCallTo: function(receiver, $function) {
      var t2, stubName, arity, lookedUpFunction, t3, t4, $arguments,
        t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null)
        t1 = $.BoundClosure_selfFieldNameCache = H.BoundClosure_computeFieldNamed("self");
      t2 = $.BoundClosure_receiverFieldNameCache;
      if (t2 == null)
        t2 = $.BoundClosure_receiverFieldNameCache = H.BoundClosure_computeFieldNamed("receiver");
      stubName = $function.$stubName;
      arity = $function.length;
      lookedUpFunction = receiver[stubName];
      t3 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
      t4 = !t3 || arity >= 28;
      if (t4)
        return H.Closure_cspForwardInterceptedCall(arity, !t3, stubName, $function);
      if (arity === 1) {
        t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "(this." + H.S(t2) + ");";
        t2 = $.Closure_functionCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.Closure_functionCounter = t2 + 1;
        return new Function(t1 + t2 + "}")();
      }
      H.assertHelper(1 < arity && arity < 28);
      $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
      t1 = "return function(" + $arguments + "){return this." + H.S(t1) + "." + H.S(stubName) + "(this." + H.S(t2) + ", " + $arguments + ");";
      t2 = $.Closure_functionCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.Closure_functionCounter = t2 + 1;
      return new Function(t1 + t2 + "}")();
    },
    closureFromTearOff: function(receiver, functions, applyTrampolineIndex, reflectionInfo, isStatic, isIntercepted, $name) {
      return H.Closure_fromTearOff(receiver, functions, H.intTypeCheck(applyTrampolineIndex), reflectionInfo, !!isStatic, !!isIntercepted, $name);
    },
    BoundClosure_selfOf: function(closure) {
      return closure._self;
    },
    BoundClosure_receiverOf: function(closure) {
      return closure._receiver;
    },
    BoundClosure_computeFieldNamed: function(fieldName) {
      var t1, i, $name,
        template = new H.BoundClosure("self", "target", "receiver", "name"),
        names = J.JSArray_markFixedList(Object.getOwnPropertyNames(template));
      for (t1 = names.length, i = 0; i < t1; ++i) {
        $name = names[i];
        if (template[$name] === fieldName)
          return $name;
      }
    },
    boolConversionCheck: function(value) {
      if (value == null)
        H.assertThrow("boolean expression must not be null");
      return value;
    },
    stringTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "String"));
    },
    doubleTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "number")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "double"));
    },
    numTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "number")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "num"));
    },
    boolTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "boolean")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "bool"));
    },
    intTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "number" && Math.floor(value) === value)
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "int"));
    },
    propertyTypeError: function(value, property) {
      throw H.wrapException(H.TypeErrorImplementation$(value, H.unminifyOrTag(H.stringTypeCheck(property).substring(3))));
    },
    interceptedTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if ((typeof value === "object" || typeof value === "function") && J.getInterceptor$(value)[property])
        return value;
      H.propertyTypeError(value, property);
    },
    numberOrStringSuperNativeTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      if (typeof value === "number")
        return value;
      if (J.getInterceptor$(value)[property])
        return value;
      H.propertyTypeError(value, property);
    },
    stringSuperNativeTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      if (J.getInterceptor$(value)[property])
        return value;
      H.propertyTypeError(value, property);
    },
    listTypeCheck: function(value) {
      if (value == null)
        return value;
      if (!!J.getInterceptor$(value).$isList)
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "List<dynamic>"));
    },
    listSuperNativeTypeCheck: function(value, property) {
      var t1;
      if (value == null)
        return value;
      t1 = J.getInterceptor$(value);
      if (!!t1.$isList)
        return value;
      if (t1[property])
        return value;
      H.propertyTypeError(value, property);
    },
    extractFunctionTypeObjectFromInternal: function(o) {
      var signature;
      if ("$signature" in o) {
        signature = o.$signature;
        if (typeof signature == "number")
          return init.types[H.intTypeCheck(signature)];
        else
          return o.$signature();
      }
      return;
    },
    functionTypeTest: function(value, functionTypeRti) {
      var functionTypeObject;
      if (typeof value == "function")
        return true;
      functionTypeObject = H.extractFunctionTypeObjectFromInternal(J.getInterceptor$(value));
      if (functionTypeObject == null)
        return false;
      return H._isFunctionSubtype(functionTypeObject, null, functionTypeRti, null);
    },
    functionTypeCheck: function(value, functionTypeRti) {
      var $self, t1;
      if (value == null)
        return value;
      if ($._inTypeAssertion)
        return value;
      $._inTypeAssertion = true;
      try {
        if (H.functionTypeTest(value, functionTypeRti))
          return value;
        $self = H.runtimeTypeToString(functionTypeRti);
        t1 = H.TypeErrorImplementation$(value, $self);
        throw H.wrapException(t1);
      } finally {
        $._inTypeAssertion = false;
      }
    },
    futureOrCheck: function(o, futureOrRti) {
      if (o != null && !H.checkSubtypeOfRuntimeType(o, futureOrRti))
        H.throwExpression(H.TypeErrorImplementation$(o, H.runtimeTypeToString(futureOrRti)));
      return o;
    },
    TypeErrorImplementation$: function(value, type) {
      return new H.TypeErrorImplementation("TypeError: " + P.Error_safeToString(value) + ": type '" + H._typeDescription(value) + "' is not a subtype of type '" + type + "'");
    },
    _typeDescription: function(value) {
      var functionTypeObject,
        t1 = J.getInterceptor$(value);
      if (!!t1.$isClosure) {
        functionTypeObject = H.extractFunctionTypeObjectFromInternal(t1);
        if (functionTypeObject != null)
          return H.runtimeTypeToString(functionTypeObject);
        return "Closure";
      }
      return H.Primitives_objectTypeName(value);
    },
    assertTest: function(condition) {
      if (true === condition)
        return false;
      if (typeof condition === "boolean")
        return !condition;
      throw H.wrapException(H.TypeErrorImplementation$(condition, "bool"));
    },
    assertThrow: function(message) {
      throw H.wrapException(new H._AssertionError(message));
    },
    assertHelper: function(condition) {
      if (H.assertTest(condition))
        throw H.wrapException(P.AssertionError$(null));
    },
    throwCyclicInit: function(staticName) {
      throw H.wrapException(new P.CyclicInitializationError(H.stringTypeCheck(staticName)));
    },
    RuntimeError$: function(message) {
      return new H.RuntimeError(message);
    },
    getIsolateAffinityTag: function($name) {
      return init.getIsolateTag($name);
    },
    createRuntimeType: function(rti) {
      return new H.TypeImpl(rti);
    },
    TypeImpl$: function(_rti) {
      return new H.TypeImpl(_rti);
    },
    setRuntimeTypeInfo: function(target, rti) {
      H.assertHelper(rti == null || typeof rti === "object" && rti !== null && rti.constructor === Array);
      target.$ti = rti;
      return target;
    },
    getRuntimeTypeInfo: function(target) {
      if (target == null)
        return;
      return target.$ti;
    },
    getRuntimeTypeArguments: function(interceptor, object, substitutionName) {
      return H.substitute(interceptor["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(object));
    },
    getRuntimeTypeArgumentIntercepted: function(interceptor, target, substitutionName, index) {
      var $arguments, t1;
      H.stringTypeCheck(substitutionName);
      H.intTypeCheck(index);
      $arguments = H.substitute(interceptor["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
      if ($arguments == null)
        t1 = null;
      else {
        H.assertHelper(typeof $arguments === "object" && $arguments !== null && $arguments.constructor === Array);
        t1 = $arguments[index];
      }
      return t1;
    },
    getRuntimeTypeArgument: function(target, substitutionName, index) {
      var $arguments, t1;
      H.stringTypeCheck(substitutionName);
      H.intTypeCheck(index);
      $arguments = H.substitute(target["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
      if ($arguments == null)
        t1 = null;
      else {
        H.assertHelper(typeof $arguments === "object" && $arguments !== null && $arguments.constructor === Array);
        t1 = $arguments[index];
      }
      return t1;
    },
    getTypeArgumentByIndex: function(target, index) {
      var rti, t1;
      H.intTypeCheck(index);
      rti = H.getRuntimeTypeInfo(target);
      if (rti == null)
        t1 = null;
      else {
        H.assertHelper(typeof rti === "object" && rti !== null && rti.constructor === Array);
        t1 = rti[index];
      }
      return t1;
    },
    runtimeTypeToString: function(rti) {
      return H._runtimeTypeToString(rti, null);
    },
    _runtimeTypeToString: function(rti, genericContext) {
      var t1, t2;
      H.assertSubtype(genericContext, "$isList", [P.String], "$asList");
      if (rti == null)
        return "dynamic";
      if (rti === -1)
        return "void";
      if (typeof rti === "object" && rti !== null && rti.constructor === Array)
        return H.unminifyOrTag(rti[0].name) + H._joinArguments(rti, 1, genericContext);
      if (typeof rti == "function")
        return H.unminifyOrTag(rti.name);
      if (rti === -2)
        return "dynamic";
      H.assertHelper(!(rti === -1));
      if (typeof rti === "number") {
        H.intTypeCheck(rti);
        if (genericContext == null || rti < 0 || rti >= genericContext.length)
          return "unexpected-generic-index:" + rti;
        t1 = genericContext.length;
        t2 = t1 - rti - 1;
        if (t2 < 0 || t2 >= t1)
          return H.ioore(genericContext, t2);
        return H.S(genericContext[t2]);
      }
      t1 = rti != null;
      if (t1)
        t2 = typeof rti === "string";
      else
        t2 = true;
      H.assertHelper(!t2);
      if ('func' in rti)
        return H._functionRtiToString(rti, genericContext);
      if (t1)
        t2 = typeof rti === "string";
      else
        t2 = true;
      H.assertHelper(!t2);
      if ('futureOr' in rti) {
        if (t1)
          t1 = typeof rti === "string";
        else
          t1 = true;
        H.assertHelper(!t1);
        H.assertHelper('futureOr' in rti);
        return "FutureOr<" + H._runtimeTypeToString("type" in rti ? rti.type : null, genericContext) + ">";
      }
      return "unknown-reified-type";
    },
    _functionRtiToString: function(rti, genericContext) {
      var boundsRti, outerContextLength, offset, i, i0, typeParameters, typeSep, t2, boundRti, returnTypeText, $arguments, argumentsText, sep, _i, argument, optionalArguments, namedArguments, t3, _s2_ = ", ",
        t1 = [P.String];
      H.assertSubtype(genericContext, "$isList", t1, "$asList");
      if ("bounds" in rti) {
        boundsRti = rti.bounds;
        if (genericContext == null) {
          genericContext = H.setRuntimeTypeInfo([], t1);
          outerContextLength = null;
        } else
          outerContextLength = genericContext.length;
        offset = genericContext.length;
        for (i = boundsRti.length, i0 = i; i0 > 0; --i0)
          C.JSArray_methods.add$1(genericContext, "T" + (offset + i0));
        for (typeParameters = "<", typeSep = "", i0 = 0; i0 < i; ++i0, typeSep = _s2_) {
          typeParameters += typeSep;
          t1 = genericContext.length;
          t2 = t1 - i0 - 1;
          if (t2 < 0)
            return H.ioore(genericContext, t2);
          typeParameters = C.JSString_methods.$add(typeParameters, genericContext[t2]);
          boundRti = boundsRti[i0];
          if (boundRti != null && boundRti !== P.Object)
            typeParameters += " extends " + H._runtimeTypeToString(boundRti, genericContext);
        }
        typeParameters += ">";
      } else {
        typeParameters = "";
        outerContextLength = null;
      }
      returnTypeText = !!rti.v ? "void" : H._runtimeTypeToString(rti.ret, genericContext);
      if ("args" in rti) {
        $arguments = rti.args;
        for (t1 = $arguments.length, argumentsText = "", sep = "", _i = 0; _i < t1; ++_i, sep = _s2_) {
          argument = $arguments[_i];
          argumentsText = argumentsText + sep + H._runtimeTypeToString(argument, genericContext);
        }
      } else {
        argumentsText = "";
        sep = "";
      }
      if ("opt" in rti) {
        optionalArguments = rti.opt;
        argumentsText += sep + "[";
        for (t1 = optionalArguments.length, sep = "", _i = 0; _i < t1; ++_i, sep = _s2_) {
          argument = optionalArguments[_i];
          argumentsText = argumentsText + sep + H._runtimeTypeToString(argument, genericContext);
        }
        argumentsText += "]";
      }
      if ("named" in rti) {
        namedArguments = rti.named;
        argumentsText += sep + "{";
        for (t1 = H.extractKeys(namedArguments), t2 = t1.length, sep = "", _i = 0; _i < t2; ++_i, sep = _s2_) {
          t3 = H.stringTypeCheck(t1[_i]);
          argumentsText = argumentsText + sep + H._runtimeTypeToString(namedArguments[t3], genericContext) + (" " + H.S(t3));
        }
        argumentsText += "}";
      }
      if (outerContextLength != null)
        genericContext.length = outerContextLength;
      return typeParameters + "(" + argumentsText + ") => " + returnTypeText;
    },
    _joinArguments: function(types, startIndex, genericContext) {
      var t1, buffer, index, separator, allDynamic, argument;
      H.assertSubtype(genericContext, "$isList", [P.String], "$asList");
      if (types == null)
        return "";
      t1 = typeof types === "object" && types !== null && types.constructor === Array;
      H.assertHelper(t1);
      buffer = new P.StringBuffer("");
      for (index = startIndex, separator = "", allDynamic = true; H.assertHelper(t1), index < types.length; ++index, separator = ", ") {
        buffer._contents += separator;
        H.assertHelper(t1);
        argument = types[index];
        if (argument != null)
          allDynamic = false;
        buffer._contents += H._runtimeTypeToString(argument, genericContext);
      }
      return "<" + buffer.toString$0(0) + ">";
    },
    getRti: function(o) {
      var functionRti, type, rti,
        t1 = J.getInterceptor$(o);
      if (!!t1.$isClosure) {
        functionRti = H.extractFunctionTypeObjectFromInternal(t1);
        if (functionRti != null)
          return functionRti;
      }
      type = t1.constructor;
      if (typeof o != "object")
        return type;
      rti = H.getRuntimeTypeInfo(o);
      if (rti != null) {
        rti = rti.slice();
        rti.splice(0, 0, type);
        type = rti;
      }
      return type;
    },
    getRuntimeType: function(object) {
      return new H.TypeImpl(H.getRti(object));
    },
    substitute: function(substitution, $arguments) {
      if (substitution == null)
        return $arguments;
      H.assertHelper(typeof substitution == "function");
      H.assertHelper($arguments == null || typeof $arguments === "object" && $arguments !== null && $arguments.constructor === Array);
      substitution = H.invokeOn(substitution, null, $arguments);
      if (substitution == null)
        return;
      if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
        return substitution;
      if (typeof substitution == "function")
        return H.invokeOn(substitution, null, $arguments);
      return $arguments;
    },
    checkSubtype: function(object, isField, checks, asField) {
      var $arguments, interceptor;
      H.stringTypeCheck(isField);
      H.listTypeCheck(checks);
      H.stringTypeCheck(asField);
      if (object == null)
        return false;
      $arguments = H.getRuntimeTypeInfo(object);
      interceptor = J.getInterceptor$(object);
      if (interceptor[isField] == null)
        return false;
      return H.areSubtypes(H.substitute(interceptor[asField], $arguments), null, checks, null);
    },
    assertSubtype: function(object, isField, checks, asField) {
      H.stringTypeCheck(isField);
      H.listTypeCheck(checks);
      H.stringTypeCheck(asField);
      if (object == null)
        return object;
      if (H.checkSubtype(object, isField, checks, asField))
        return object;
      throw H.wrapException(H.TypeErrorImplementation$(object, function(str, names) {
        return str.replace(/[^<,> ]+/g, function(m) {
          return names[m] || m;
        });
      }(H.unminifyOrTag(isField.substring(3)) + H._joinArguments(checks, 0, null), init.mangledGlobalNames)));
    },
    areSubtypes: function(s, sEnv, t, tEnv) {
      var t1, len, i, t2, t3;
      if (t == null)
        return true;
      if (s == null) {
        t1 = typeof t === "object" && t !== null && t.constructor === Array;
        H.assertHelper(t1);
        len = t.length;
        for (i = 0; i < len; ++i) {
          H.assertHelper(t1);
          if (!H._isSubtype(null, null, t[i], tEnv))
            return false;
        }
        return true;
      }
      t1 = typeof s === "object" && s !== null && s.constructor === Array;
      H.assertHelper(t1);
      t2 = typeof t === "object" && t !== null && t.constructor === Array;
      H.assertHelper(t2);
      H.assertHelper(t1);
      t3 = s.length;
      H.assertHelper(t2);
      H.assertHelper(t3 === t.length);
      H.assertHelper(t1);
      len = s.length;
      for (i = 0; i < len; ++i) {
        H.assertHelper(t1);
        t3 = s[i];
        H.assertHelper(t2);
        if (!H._isSubtype(t3, sEnv, t[i], tEnv))
          return false;
      }
      return true;
    },
    computeSignature: function(signature, context, contextName) {
      return H.invokeOn(signature, context, H.substitute(J.getInterceptor$(context)["$as" + H.S(contextName)], H.getRuntimeTypeInfo(context)));
    },
    isSupertypeOfNullRecursive: function(type) {
      var t1, t2, typeArgument;
      H.assertHelper(!(type === -1));
      if (typeof type === "number")
        return false;
      t1 = type != null;
      if (t1)
        t2 = typeof type === "string";
      else
        t2 = true;
      H.assertHelper(!t2);
      if ('futureOr' in type) {
        if (t1)
          t1 = typeof type === "string";
        else
          t1 = true;
        H.assertHelper(!t1);
        H.assertHelper('futureOr' in type);
        typeArgument = "type" in type ? type.type : null;
        return type == null || type.name === "Object" || type.name === "Null" || type === -1 || type === -2 || H.isSupertypeOfNullRecursive(typeArgument);
      }
      return false;
    },
    checkSubtypeOfRuntimeType: function(o, t) {
      var t1, type, rti;
      if (o == null)
        return t == null || t.name === "Object" || t.name === "Null" || t === -1 || t === -2 || H.isSupertypeOfNullRecursive(t);
      if (t == null || t === -1 || t.name === "Object" || t === -2)
        return true;
      if (typeof t == "object") {
        t1 = t != null;
        H.assertHelper(!(!t1 || typeof t === "number" || typeof t === "string"));
        if ('futureOr' in t) {
          H.assertHelper(!(!t1 || typeof t === "number" || typeof t === "string"));
          H.assertHelper('futureOr' in t);
          if (H.checkSubtypeOfRuntimeType(o, "type" in t ? t.type : null))
            return true;
        }
        H.assertHelper(!(!t1 || typeof t === "number" || typeof t === "string"));
        if ('func' in t)
          return H.functionTypeTest(o, t);
      }
      type = J.getInterceptor$(o).constructor;
      rti = H.getRuntimeTypeInfo(o);
      if (rti != null) {
        rti = rti.slice();
        rti.splice(0, 0, type);
        type = rti;
      }
      return H._isSubtype(type, null, t, null);
    },
    assertSubtypeOfRuntimeType: function(object, type) {
      if (object != null && !H.checkSubtypeOfRuntimeType(object, type))
        throw H.wrapException(H.TypeErrorImplementation$(object, H.runtimeTypeToString(type)));
      return object;
    },
    _isSubtype: function(s, sEnv, t, tEnv) {
      var t1, t2, t3, typeOfS, t4, tTypeArgument, futureSubstitution, futureArguments, typeOfT, typeOfTString, substitution, _null = null;
      if (s === t)
        return true;
      if (t == null || t === -1 || t.name === "Object" || t === -2)
        return true;
      if (s === -2)
        return true;
      if (s == null || s === -1 || s.name === "Object" || s === -2) {
        H.assertHelper(!(t === -1));
        if (typeof t === "number")
          return false;
        t1 = t != null;
        if (t1)
          t2 = typeof t === "string";
        else
          t2 = true;
        H.assertHelper(!t2);
        if ('futureOr' in t) {
          if (t1)
            t1 = typeof t === "string";
          else
            t1 = true;
          H.assertHelper(!t1);
          H.assertHelper('futureOr' in t);
          return H._isSubtype(s, sEnv, "type" in t ? t.type : _null, tEnv);
        }
        return false;
      }
      H.assertHelper(!(s === -1));
      if (typeof s === "number")
        return false;
      H.assertHelper(!(t === -1));
      if (typeof t === "number")
        return false;
      if (s.name === "Null")
        return true;
      t1 = t != null;
      if (t1)
        t2 = typeof t === "string";
      else
        t2 = true;
      H.assertHelper(!t2);
      if ('func' in t)
        return H._isFunctionSubtype(s, sEnv, t, tEnv);
      t2 = s != null;
      if (t2)
        t3 = typeof s === "string";
      else
        t3 = true;
      H.assertHelper(!t3);
      if ('func' in s)
        return t.name === "Function";
      t3 = typeof s === "object" && s !== null && s.constructor === Array;
      typeOfS = t3 ? s[0] : s;
      if (t1)
        t4 = typeof t === "string";
      else
        t4 = true;
      H.assertHelper(!t4);
      if ('futureOr' in t) {
        if (t1)
          t1 = typeof t === "string";
        else
          t1 = true;
        H.assertHelper(!t1);
        H.assertHelper('futureOr' in t);
        tTypeArgument = "type" in t ? t.type : _null;
        if (t2)
          t1 = typeof s === "string";
        else
          t1 = true;
        H.assertHelper(!t1);
        if ('futureOr' in s) {
          if (t2)
            t1 = typeof s === "string";
          else
            t1 = true;
          H.assertHelper(!t1);
          H.assertHelper('futureOr' in s);
          return H._isSubtype("type" in s ? s.type : _null, sEnv, tTypeArgument, tEnv);
        } else if (H._isSubtype(s, sEnv, tTypeArgument, tEnv))
          return true;
        else {
          if (!('$is' + "Future" in typeOfS.prototype))
            return false;
          futureSubstitution = typeOfS.prototype["$as" + "Future"];
          futureArguments = H.substitute(futureSubstitution, t3 ? s.slice(1) : _null);
          return H._isSubtype(typeof futureArguments === "object" && futureArguments !== null && futureArguments.constructor === Array ? futureArguments[0] : _null, sEnv, tTypeArgument, tEnv);
        }
      }
      t1 = typeof t === "object" && t !== null && t.constructor === Array;
      typeOfT = t1 ? t[0] : t;
      if (typeOfT !== typeOfS) {
        typeOfTString = typeOfT.name;
        if (!('$is' + typeOfTString in typeOfS.prototype))
          return false;
        substitution = typeOfS.prototype["$as" + typeOfTString];
      } else
        substitution = _null;
      if (!t1)
        return true;
      t1 = t3 ? s.slice(1) : _null;
      t2 = t.slice(1);
      return H.areSubtypes(H.substitute(substitution, t1), sEnv, t2, tEnv);
    },
    _isFunctionSubtype: function(s, sEnv, t, tEnv) {
      var sBounds, tBounds, sGenericParameters, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, t1, t2, pos, t3, tPos, sPos, sNamedParameters, tNamedParameters;
      H.assertHelper(!(t == null || typeof t === "number" || typeof t === "string"));
      H.assertHelper('func' in t);
      H.assertHelper(!(s == null || typeof s === "number" || typeof s === "string"));
      if (!('func' in s))
        return false;
      if ("bounds" in s) {
        if (!("bounds" in t))
          return false;
        sBounds = s.bounds;
        tBounds = t.bounds;
        H.assertHelper(typeof sBounds === "object" && sBounds !== null && sBounds.constructor === Array);
        sGenericParameters = sBounds.length;
        H.assertHelper(typeof tBounds === "object" && tBounds !== null && tBounds.constructor === Array);
        if (sGenericParameters !== tBounds.length)
          return false;
      } else if ("bounds" in t)
        return false;
      if (!H._isSubtype(s.ret, sEnv, t.ret, tEnv))
        return false;
      sParameterTypes = s.args;
      tParameterTypes = t.args;
      sOptionalParameterTypes = s.opt;
      tOptionalParameterTypes = t.opt;
      if (sParameterTypes != null) {
        H.assertHelper(typeof sParameterTypes === "object" && sParameterTypes !== null && sParameterTypes.constructor === Array);
        sParametersLen = sParameterTypes.length;
      } else
        sParametersLen = 0;
      if (tParameterTypes != null) {
        H.assertHelper(typeof tParameterTypes === "object" && tParameterTypes !== null && tParameterTypes.constructor === Array);
        tParametersLen = tParameterTypes.length;
      } else
        tParametersLen = 0;
      if (sOptionalParameterTypes != null) {
        H.assertHelper(typeof sOptionalParameterTypes === "object" && sOptionalParameterTypes !== null && sOptionalParameterTypes.constructor === Array);
        sOptionalParametersLen = sOptionalParameterTypes.length;
      } else
        sOptionalParametersLen = 0;
      if (tOptionalParameterTypes != null) {
        H.assertHelper(typeof tOptionalParameterTypes === "object" && tOptionalParameterTypes !== null && tOptionalParameterTypes.constructor === Array);
        tOptionalParametersLen = tOptionalParameterTypes.length;
      } else
        tOptionalParametersLen = 0;
      if (sParametersLen > tParametersLen)
        return false;
      if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
        return false;
      for (t1 = typeof tParameterTypes === "object" && tParameterTypes !== null && tParameterTypes.constructor === Array, t2 = typeof sParameterTypes === "object" && sParameterTypes !== null && sParameterTypes.constructor === Array, pos = 0; pos < sParametersLen; ++pos) {
        H.assertHelper(t1);
        t3 = tParameterTypes[pos];
        H.assertHelper(t2);
        if (!H._isSubtype(t3, tEnv, sParameterTypes[pos], sEnv))
          return false;
      }
      for (t2 = typeof sOptionalParameterTypes === "object" && sOptionalParameterTypes !== null && sOptionalParameterTypes.constructor === Array, tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos) {
        H.assertHelper(t1);
        t3 = tParameterTypes[tPos];
        H.assertHelper(t2);
        if (!H._isSubtype(t3, tEnv, sOptionalParameterTypes[sPos], sEnv))
          return false;
      }
      for (t1 = typeof tOptionalParameterTypes === "object" && tOptionalParameterTypes !== null && tOptionalParameterTypes.constructor === Array, tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos) {
        H.assertHelper(t1);
        t3 = tOptionalParameterTypes[tPos];
        H.assertHelper(t2);
        if (!H._isSubtype(t3, tEnv, sOptionalParameterTypes[sPos], sEnv))
          return false;
      }
      sNamedParameters = s.named;
      tNamedParameters = t.named;
      if (tNamedParameters == null)
        return true;
      if (sNamedParameters == null)
        return false;
      return H.namedParametersSubtypeCheck(sNamedParameters, sEnv, tNamedParameters, tEnv);
    },
    namedParametersSubtypeCheck: function(s, sEnv, t, tEnv) {
      var names, t1, i, $name;
      H.assertHelper(typeof s == 'object');
      H.assertHelper(typeof t == 'object');
      names = Object.getOwnPropertyNames(t);
      for (t1 = names.length, i = 0; i < t1; ++i) {
        $name = names[i];
        if (!Object.hasOwnProperty.call(s, $name))
          return false;
        if (!H._isSubtype(t[$name], tEnv, s[$name], sEnv))
          return false;
      }
      return true;
    },
    instantiatedGenericFunctionType: function(genericFunctionRti, parameters) {
      var t1, bounds, boundLength;
      if (genericFunctionRti == null)
        return;
      t1 = typeof genericFunctionRti === "number" || typeof genericFunctionRti === "string";
      H.assertHelper(!t1);
      H.assertHelper('func' in genericFunctionRti);
      H.assertHelper("bounds" in genericFunctionRti);
      bounds = genericFunctionRti.bounds;
      H.assertHelper(typeof bounds === "object" && bounds !== null && bounds.constructor === Array);
      boundLength = bounds.length;
      H.assertHelper(typeof parameters === "object" && parameters !== null && parameters.constructor === Array);
      H.assertHelper(boundLength === parameters.length);
      return H.finishBindInstantiatedFunctionType(genericFunctionRti, {func: 1}, parameters, 0);
    },
    finishBindInstantiatedFunctionType: function(rti, result, parameters, depth) {
      var namedParameters, boundNamed, names, t1, _i, $name;
      if ("v" in rti)
        result.v = rti.v;
      else if ("ret" in rti)
        result.ret = H.bindInstantiatedType(rti.ret, parameters, depth);
      if ("args" in rti)
        result.args = H.bindInstantiatedTypes(rti.args, parameters, depth);
      if ("opt" in rti)
        result.opt = H.bindInstantiatedTypes(rti.opt, parameters, depth);
      if ("named" in rti) {
        namedParameters = rti.named;
        boundNamed = {};
        names = Object.keys(namedParameters);
        for (t1 = names.length, _i = 0; _i < t1; ++_i) {
          $name = H.stringTypeCheck(names[_i]);
          boundNamed[$name] = H.bindInstantiatedType(namedParameters[$name], parameters, depth);
        }
        result.named = boundNamed;
      }
      return result;
    },
    bindInstantiatedType: function(rti, parameters, depth) {
      var t1, result, bounds;
      if (rti == null)
        return rti;
      if (rti === -1)
        return rti;
      if (typeof rti == "function")
        return rti;
      H.assertHelper(!(rti === -1));
      if (typeof rti === "number") {
        if (rti < depth)
          return rti;
        return parameters[rti - depth];
      }
      if (typeof rti === "object" && rti !== null && rti.constructor === Array)
        return H.bindInstantiatedTypes(rti, parameters, depth);
      if (rti != null)
        t1 = typeof rti === "string";
      else
        t1 = true;
      H.assertHelper(!t1);
      if ('func' in rti) {
        result = {func: 1};
        if ("bounds" in rti) {
          bounds = rti.bounds;
          H.assertHelper(typeof bounds === "object" && bounds !== null && bounds.constructor === Array);
          depth += bounds.length;
          result.bounds = H.bindInstantiatedTypes(bounds, parameters, depth);
        }
        return H.finishBindInstantiatedFunctionType(rti, result, parameters, depth);
      }
      throw H.wrapException(P.ArgumentError$("Unknown RTI format in bindInstantiatedType."));
    },
    bindInstantiatedTypes: function(rti, parameters, depth) {
      var t1, i,
        array = rti.slice();
      for (t1 = array.length, i = 0; i < t1; ++i)
        C.JSArray_methods.$indexSet(array, i, H.bindInstantiatedType(array[i], parameters, depth));
      return array;
    },
    invokeOn: function($function, receiver, $arguments) {
      H.assertHelper(typeof $function == "function");
      H.assertHelper($arguments == null || typeof $arguments === "object" && $arguments !== null && $arguments.constructor === Array);
      return $function.apply(receiver, $arguments);
    },
    JsLinkedHashMap_JsLinkedHashMap$es6: function($K, $V) {
      return new H.JsLinkedHashMap([$K, $V]);
    },
    defineProperty: function(obj, property, value) {
      Object.defineProperty(obj, H.stringTypeCheck(property), {value: value, enumerable: false, writable: true, configurable: true});
    },
    lookupAndCacheInterceptor: function(obj) {
      var tag, record, interceptor, interceptorClass, mark, t1;
      H.assertHelper(!(obj instanceof P.Object));
      tag = H.stringTypeCheck($.getTagFunction.call$1(obj));
      record = $.dispatchRecordsForInstanceTags[tag];
      if (record != null) {
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      interceptor = $.interceptorsForUncacheableTags[tag];
      if (interceptor != null)
        return interceptor;
      interceptorClass = init.interceptorsByTag[tag];
      if (interceptorClass == null) {
        tag = H.stringTypeCheck($.alternateTagFunction.call$2(obj, tag));
        if (tag != null) {
          record = $.dispatchRecordsForInstanceTags[tag];
          if (record != null) {
            Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            return record.i;
          }
          interceptor = $.interceptorsForUncacheableTags[tag];
          if (interceptor != null)
            return interceptor;
          interceptorClass = init.interceptorsByTag[tag];
        }
      }
      if (interceptorClass == null)
        return;
      interceptor = interceptorClass.prototype;
      mark = tag[0];
      if (mark === "!") {
        record = H.makeLeafDispatchRecord(interceptor);
        $.dispatchRecordsForInstanceTags[tag] = record;
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      if (mark === "~") {
        $.interceptorsForUncacheableTags[tag] = interceptor;
        return interceptor;
      }
      if (mark === "-") {
        t1 = H.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      }
      if (mark === "+")
        return H.patchInteriorProto(obj, interceptor);
      if (mark === "*")
        throw H.wrapException(P.UnimplementedError$(tag));
      if (init.leafTags[tag] === true) {
        t1 = H.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      } else
        return H.patchInteriorProto(obj, interceptor);
    },
    patchInteriorProto: function(obj, interceptor) {
      var proto = Object.getPrototypeOf(obj);
      Object.defineProperty(proto, init.dispatchPropertyName, {value: J.makeDispatchRecord(interceptor, proto, null, null), enumerable: false, writable: true, configurable: true});
      return interceptor;
    },
    makeLeafDispatchRecord: function(interceptor) {
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    },
    makeDefaultDispatchRecord: function(tag, interceptorClass, proto) {
      var interceptor = interceptorClass.prototype;
      if (init.leafTags[tag] === true)
        return H.makeLeafDispatchRecord(interceptor);
      else
        return J.makeDispatchRecord(interceptor, proto, null, null);
    },
    initNativeDispatch: function() {
      if (true === $.initNativeDispatchFlag)
        return;
      $.initNativeDispatchFlag = true;
      H.initNativeDispatchContinue();
    },
    initNativeDispatchContinue: function() {
      var map, tags, fun, i, tag, proto, record, interceptorClass;
      $.dispatchRecordsForInstanceTags = Object.create(null);
      $.interceptorsForUncacheableTags = Object.create(null);
      H.initHooks();
      map = init.interceptorsByTag;
      tags = Object.getOwnPropertyNames(map);
      if (typeof window != "undefined") {
        window;
        fun = function() {
        };
        for (i = 0; i < tags.length; ++i) {
          tag = tags[i];
          proto = $.prototypeForTagFunction.call$1(tag);
          if (proto != null) {
            record = H.makeDefaultDispatchRecord(tag, map[tag], proto);
            if (record != null) {
              Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
              fun.prototype = proto;
            }
          }
        }
      }
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        if (/^[A-Za-z_]/.test(tag)) {
          interceptorClass = map[tag];
          map["!" + tag] = interceptorClass;
          map["~" + tag] = interceptorClass;
          map["-" + tag] = interceptorClass;
          map["+" + tag] = interceptorClass;
          map["*" + tag] = interceptorClass;
        }
      }
    },
    initHooks: function() {
      var transformers, i, transformer, getTag, getUnknownTag, prototypeForTag,
        hooks = C.C_JS_CONST0();
      hooks = H.applyHooksTransformer(C.C_JS_CONST1, H.applyHooksTransformer(C.C_JS_CONST2, H.applyHooksTransformer(C.C_JS_CONST3, H.applyHooksTransformer(C.C_JS_CONST3, H.applyHooksTransformer(C.C_JS_CONST4, H.applyHooksTransformer(C.C_JS_CONST5, H.applyHooksTransformer(C.C_JS_CONST6(C.C_JS_CONST), hooks)))))));
      if (typeof dartNativeDispatchHooksTransformer != "undefined") {
        transformers = dartNativeDispatchHooksTransformer;
        if (typeof transformers == "function")
          transformers = [transformers];
        if (transformers.constructor == Array)
          for (i = 0; i < transformers.length; ++i) {
            transformer = transformers[i];
            if (typeof transformer == "function")
              hooks = transformer(hooks) || hooks;
          }
      }
      getTag = hooks.getTag;
      getUnknownTag = hooks.getUnknownTag;
      prototypeForTag = hooks.prototypeForTag;
      $.getTagFunction = new H.initHooks_closure(getTag);
      $.alternateTagFunction = new H.initHooks_closure0(getUnknownTag);
      $.prototypeForTagFunction = new H.initHooks_closure1(prototypeForTag);
    },
    applyHooksTransformer: function(transformer, hooks) {
      return transformer(hooks) || hooks;
    },
    JSSyntaxRegExp_makeNative: function(source, multiLine, caseSensitive, global) {
      var m = multiLine ? "m" : "",
        i = caseSensitive ? "" : "i",
        g = global ? "g" : "",
        regexp = function(source, modifiers) {
          try {
            return new RegExp(source, modifiers);
          } catch (e) {
            return e;
          }
        }(source, m + i + g);
      if (regexp instanceof RegExp)
        return regexp;
      throw H.wrapException(P.FormatException$("Illegal RegExp pattern (" + String(regexp) + ")", source, null));
    },
    _MatchImplementation$: function(pattern, _match) {
      var t1 = _match.input;
      H.assertHelper(typeof t1 === "string");
      t1 = _match.index;
      H.assertHelper(typeof t1 === "number" && Math.floor(t1) === t1);
      return new H._MatchImplementation(_match);
    },
    stringContainsUnchecked: function(receiver, other, startIndex) {
      var t1 = receiver.indexOf(other, startIndex);
      return t1 >= 0;
    },
    escapeReplacement: function(replacement) {
      if (replacement.indexOf("$", 0) >= 0)
        return replacement.replace(/\$/g, "$$$$");
      return replacement;
    },
    quoteStringForRegExp: function(string) {
      if (/[[\]{}()*+?.\\^$|]/.test(string))
        return string.replace(/[[\]{}()*+?.\\^$|]/g, "\\$&");
      return string;
    },
    stringReplaceAllUnchecked: function(receiver, pattern, replacement) {
      var t1 = H.stringReplaceAllUncheckedString(receiver, pattern, replacement);
      return t1;
    },
    stringReplaceAllUncheckedString: function(receiver, pattern, replacement) {
      var $length, t1, i, index;
      if (pattern === "") {
        if (receiver === "")
          return replacement;
        $length = receiver.length;
        for (t1 = replacement, i = 0; i < $length; ++i)
          t1 = t1 + receiver[i] + replacement;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      index = receiver.indexOf(pattern, 0);
      if (index < 0)
        return receiver;
      if (receiver.length < 500 || replacement.indexOf("$", 0) >= 0)
        return receiver.split(pattern).join(replacement);
      return receiver.replace(new RegExp(H.quoteStringForRegExp(pattern), 'g'), H.escapeReplacement(replacement));
    },
    ConstantMap: function ConstantMap() {
    },
    ConstantStringMap: function ConstantStringMap(t0, t1, t2, t3) {
      var _ = this;
      _.__js_helper$_length = t0;
      _._jsObject = t1;
      _._keys = t2;
      _.$ti = t3;
    },
    ConstantStringMap_values_closure: function ConstantStringMap_values_closure(t0) {
      this.$this = t0;
    },
    _ConstantMapKeyIterable: function _ConstantMapKeyIterable(t0, t1) {
      this._map = t0;
      this.$ti = t1;
    },
    GeneralConstantMap: function GeneralConstantMap(t0, t1) {
      this._jsData = t0;
      this.$ti = t1;
    },
    Instantiation: function Instantiation() {
    },
    Instantiation1: function Instantiation1(t0, t1) {
      this._genericClosure = t0;
      this.$ti = t1;
    },
    Instantiation2: function Instantiation2(t0, t1) {
      this._genericClosure = t0;
      this.$ti = t1;
    },
    Primitives_initTicker_closure: function Primitives_initTicker_closure(t0) {
      this.performance = t0;
    },
    TypeErrorDecoder: function TypeErrorDecoder(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._pattern = t0;
      _._arguments = t1;
      _._argumentsExpr = t2;
      _._expr = t3;
      _._method = t4;
      _._receiver = t5;
    },
    NullError: function NullError(t0, t1) {
      this._message = t0;
      this._method = t1;
    },
    JsNoSuchMethodError: function JsNoSuchMethodError(t0, t1, t2) {
      this._message = t0;
      this._method = t1;
      this._receiver = t2;
    },
    UnknownJsTypeError: function UnknownJsTypeError(t0) {
      this._message = t0;
    },
    ExceptionAndStackTrace: function ExceptionAndStackTrace(t0, t1) {
      this.dartException = t0;
      this.stackTrace = t1;
    },
    unwrapException_saveStackTrace: function unwrapException_saveStackTrace(t0) {
      this.ex = t0;
    },
    _StackTrace: function _StackTrace(t0) {
      this.__js_helper$_exception = t0;
      this._trace = null;
    },
    Closure: function Closure() {
    },
    TearOffClosure: function TearOffClosure() {
    },
    StaticClosure: function StaticClosure() {
    },
    BoundClosure: function BoundClosure(t0, t1, t2, t3) {
      var _ = this;
      _._self = t0;
      _._target = t1;
      _._receiver = t2;
      _.__js_helper$_name = t3;
    },
    TypeErrorImplementation: function TypeErrorImplementation(t0) {
      this.message = t0;
    },
    RuntimeError: function RuntimeError(t0) {
      this.message = t0;
    },
    _AssertionError: function _AssertionError(t0) {
      this.message = t0;
    },
    TypeImpl: function TypeImpl(t0) {
      this._rti = t0;
      this._hashCode = this.__typeName = null;
    },
    JsLinkedHashMap: function JsLinkedHashMap(t0) {
      var _ = this;
      _.__js_helper$_length = 0;
      _._last = _._first = _._rest = _._nums = _._strings = null;
      _._modifications = 0;
      _.$ti = t0;
    },
    JsLinkedHashMap_values_closure: function JsLinkedHashMap_values_closure(t0) {
      this.$this = t0;
    },
    JsLinkedHashMap_containsValue_closure: function JsLinkedHashMap_containsValue_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    JsLinkedHashMap_addAll_closure: function JsLinkedHashMap_addAll_closure(t0) {
      this.$this = t0;
    },
    LinkedHashMapCell: function LinkedHashMapCell(t0, t1) {
      var _ = this;
      _.hashMapCellKey = t0;
      _.hashMapCellValue = t1;
      _._previous = _._next = null;
    },
    LinkedHashMapKeyIterable: function LinkedHashMapKeyIterable(t0, t1) {
      this._map = t0;
      this.$ti = t1;
    },
    LinkedHashMapKeyIterator: function LinkedHashMapKeyIterator(t0, t1, t2) {
      var _ = this;
      _._map = t0;
      _._modifications = t1;
      _.__js_helper$_current = _._cell = null;
      _.$ti = t2;
    },
    initHooks_closure: function initHooks_closure(t0) {
      this.getTag = t0;
    },
    initHooks_closure0: function initHooks_closure0(t0) {
      this.getUnknownTag = t0;
    },
    initHooks_closure1: function initHooks_closure1(t0) {
      this.prototypeForTag = t0;
    },
    JSSyntaxRegExp: function JSSyntaxRegExp(t0, t1) {
      var _ = this;
      _.pattern = t0;
      _._nativeRegExp = t1;
      _._nativeAnchoredRegExp = _._nativeGlobalRegExp = null;
    },
    _MatchImplementation: function _MatchImplementation(t0) {
      this._match = t0;
    },
    StringMatch: function StringMatch(t0, t1) {
      this.start = t0;
      this.pattern = t1;
    },
    _checkViewArguments: function(buffer, offsetInBytes, $length) {
      if (typeof offsetInBytes !== "number" || Math.floor(offsetInBytes) !== offsetInBytes)
        throw H.wrapException(P.ArgumentError$("Invalid view offsetInBytes " + H.S(offsetInBytes)));
    },
    _ensureNativeList: function(list) {
      return list;
    },
    NativeByteData_NativeByteData$view: function(buffer, offsetInBytes, $length) {
      H._checkViewArguments(buffer, offsetInBytes, $length);
      return $length == null ? new DataView(buffer, offsetInBytes) : new DataView(buffer, offsetInBytes, $length);
    },
    NativeInt32List_NativeInt32List: function($length) {
      return new Int32Array($length);
    },
    NativeInt8List__create1: function(arg) {
      return new Int8Array(arg);
    },
    NativeUint16List__create1: function(arg) {
      return new Uint16Array(arg);
    },
    NativeUint8List_NativeUint8List$view: function(buffer, offsetInBytes, $length) {
      H._checkViewArguments(buffer, offsetInBytes, $length);
      return $length == null ? new Uint8Array(buffer, offsetInBytes) : new Uint8Array(buffer, offsetInBytes, $length);
    },
    _checkValidIndex: function(index, list, $length) {
      if (index >>> 0 !== index || index >= $length)
        throw H.wrapException(H.diagnoseIndexError(list, index));
    },
    _checkValidRange: function(start, end, $length) {
      var t1;
      if (!(start >>> 0 !== start))
        t1 = end >>> 0 !== end || start > end || end > $length;
      else
        t1 = true;
      if (t1)
        throw H.wrapException(H.diagnoseRangeError(start, end, $length));
      return end;
    },
    NativeByteBuffer: function NativeByteBuffer() {
    },
    NativeTypedData: function NativeTypedData() {
    },
    NativeByteData: function NativeByteData() {
    },
    NativeTypedArray: function NativeTypedArray() {
    },
    NativeTypedArrayOfDouble: function NativeTypedArrayOfDouble() {
    },
    NativeTypedArrayOfInt: function NativeTypedArrayOfInt() {
    },
    NativeFloat64List: function NativeFloat64List() {
    },
    NativeInt32List: function NativeInt32List() {
    },
    NativeInt8List: function NativeInt8List() {
    },
    NativeUint16List: function NativeUint16List() {
    },
    NativeUint8List: function NativeUint8List() {
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin: function _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin() {
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin: function _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin() {
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin: function _NativeTypedArrayOfInt_NativeTypedArray_ListMixin() {
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin: function _NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin() {
    },
    extractKeys: function(victim) {
      return J.JSArray_JSArray$markFixed(victim ? Object.keys(victim) : [], null);
    },
    printString: function(string) {
      if (typeof dartPrint == "function") {
        dartPrint(string);
        return;
      }
      if (typeof console == "object" && typeof console.log != "undefined") {
        console.log(string);
        return;
      }
      if (typeof window == "object")
        return;
      if (typeof print == "function") {
        print(string);
        return;
      }
      throw "Unable to print message: " + String(string);
    }
  },
  J = {
    makeDispatchRecord: function(interceptor, proto, extension, indexability) {
      return {i: interceptor, p: proto, e: extension, x: indexability};
    },
    getNativeInterceptor: function(object) {
      var proto, objectProto, $constructor, interceptor,
        record = object[init.dispatchPropertyName];
      if (record == null)
        if ($.initNativeDispatchFlag == null) {
          H.initNativeDispatch();
          record = object[init.dispatchPropertyName];
        }
      if (record != null) {
        proto = record.p;
        if (false === proto)
          return record.i;
        if (true === proto)
          return object;
        objectProto = Object.getPrototypeOf(object);
        if (proto === objectProto)
          return record.i;
        if (record.e === objectProto)
          throw H.wrapException(P.UnimplementedError$("Return interceptor for " + H.S(proto(object, record))));
      }
      $constructor = object.constructor;
      interceptor = $constructor == null ? null : $constructor[$.$get$JS_INTEROP_INTERCEPTOR_TAG()];
      if (interceptor != null)
        return interceptor;
      interceptor = H.lookupAndCacheInterceptor(object);
      if (interceptor != null)
        return interceptor;
      if (typeof object == "function")
        return C.JavaScriptFunction_methods;
      proto = Object.getPrototypeOf(object);
      if (proto == null)
        return C.PlainJavaScriptObject_methods;
      if (proto === Object.prototype)
        return C.PlainJavaScriptObject_methods;
      if (typeof $constructor == "function") {
        Object.defineProperty($constructor, $.$get$JS_INTEROP_INTERCEPTOR_TAG(), {value: C.UnknownJavaScriptObject_methods, enumerable: false, writable: true, configurable: true});
        return C.UnknownJavaScriptObject_methods;
      }
      return C.UnknownJavaScriptObject_methods;
    },
    JSArray_JSArray$fixed: function($length, $E) {
      if (typeof $length !== "number" || Math.floor($length) !== $length)
        throw H.wrapException(P.ArgumentError$value($length, "length", "is not an integer"));
      if ($length < 0 || $length > 4294967295)
        throw H.wrapException(P.RangeError$range($length, 0, 4294967295, "length", null));
      return J.JSArray_JSArray$markFixed(new Array($length), $E);
    },
    JSArray_JSArray$markFixed: function(allocation, $E) {
      return J.JSArray_markFixedList(H.setRuntimeTypeInfo(allocation, [$E]));
    },
    JSArray_markFixedList: function(list) {
      H.listTypeCheck(list);
      list.fixed$length = Array;
      return list;
    },
    JSArray__compareAny: function(a, b) {
      return J.compareTo$1$ns(H.numberOrStringSuperNativeTypeCheck(a, "$isComparable"), H.numberOrStringSuperNativeTypeCheck(b, "$isComparable"));
    },
    JSString__isWhitespace: function(codeUnit) {
      if (codeUnit < 256)
        switch (codeUnit) {
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 32:
          case 133:
          case 160:
            return true;
          default:
            return false;
        }
      switch (codeUnit) {
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8232:
        case 8233:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    },
    JSString__skipLeadingWhitespace: function(string, index) {
      var t1, codeUnit;
      for (t1 = string.length; index < t1;) {
        codeUnit = C.JSString_methods._codeUnitAt$1(string, index);
        if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
          break;
        ++index;
      }
      return index;
    },
    JSString__skipTrailingWhitespace: function(string, index) {
      var index0, codeUnit;
      for (; index > 0; index = index0) {
        index0 = index - 1;
        codeUnit = C.JSString_methods.codeUnitAt$1(string, index0);
        if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
          break;
      }
      return index;
    },
    getInterceptor$: function(receiver) {
      if (typeof receiver == "number") {
        if (Math.floor(receiver) == receiver)
          return J.JSInt.prototype;
        return J.JSDouble.prototype;
      }
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return J.JSNull.prototype;
      if (typeof receiver == "boolean")
        return J.JSBool.prototype;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$ansx: function(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$asx: function(receiver) {
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$ax: function(receiver) {
      if (receiver == null)
        return receiver;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$in: function(receiver) {
      if (typeof receiver == "number") {
        if (Math.floor(receiver) == receiver)
          return J.JSInt.prototype;
        return J.JSNumber.prototype;
      }
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$n: function(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$ns: function(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$s: function(receiver) {
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$x: function(receiver) {
      if (receiver == null)
        return receiver;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$z: function(receiver) {
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    get$hashCode$: function(receiver) {
      return J.getInterceptor$(receiver).get$hashCode(receiver);
    },
    get$isEmpty$asx: function(receiver) {
      return J.getInterceptor$asx(receiver).get$isEmpty(receiver);
    },
    get$iterator$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).get$iterator(receiver);
    },
    get$length$asx: function(receiver) {
      return J.getInterceptor$asx(receiver).get$length(receiver);
    },
    get$runtimeType$: function(receiver) {
      return J.getInterceptor$(receiver).get$runtimeType(receiver);
    },
    get$sign$in: function(receiver) {
      if (typeof receiver === "number")
        return receiver > 0 ? 1 : receiver < 0 ? -1 : receiver;
      return J.getInterceptor$in(receiver).get$sign(receiver);
    },
    get$target$z: function(receiver) {
      return J.getInterceptor$z(receiver).get$target(receiver);
    },
    $add$ansx: function(receiver, a0) {
      if (typeof receiver == "number" && typeof a0 == "number")
        return receiver + a0;
      return J.getInterceptor$ansx(receiver).$add(receiver, a0);
    },
    $eq$: function(receiver, a0) {
      if (receiver == null)
        return a0 == null;
      if (typeof receiver != "object")
        return a0 != null && receiver === a0;
      return J.getInterceptor$(receiver).$eq(receiver, a0);
    },
    $ge$n: function(receiver, a0) {
      if (typeof receiver == "number" && typeof a0 == "number")
        return receiver >= a0;
      return J.getInterceptor$n(receiver).$ge(receiver, a0);
    },
    $gt$n: function(receiver, a0) {
      if (typeof receiver == "number" && typeof a0 == "number")
        return receiver > a0;
      return J.getInterceptor$n(receiver).$gt(receiver, a0);
    },
    $index$asx: function(receiver, a0) {
      if (typeof a0 === "number")
        if (receiver.constructor == Array || typeof receiver == "string" || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
          if (a0 >>> 0 === a0 && a0 < receiver.length)
            return receiver[a0];
      return J.getInterceptor$asx(receiver).$index(receiver, a0);
    },
    $indexSet$ax: function(receiver, a0, a1) {
      return J.getInterceptor$ax(receiver).$indexSet(receiver, a0, a1);
    },
    $le$n: function(receiver, a0) {
      if (typeof receiver == "number" && typeof a0 == "number")
        return receiver <= a0;
      return J.getInterceptor$n(receiver).$le(receiver, a0);
    },
    $lt$n: function(receiver, a0) {
      if (typeof receiver == "number" && typeof a0 == "number")
        return receiver < a0;
      return J.getInterceptor$n(receiver).$lt(receiver, a0);
    },
    $mul$ns: function(receiver, a0) {
      if (typeof receiver == "number" && typeof a0 == "number")
        return receiver * a0;
      return J.getInterceptor$ns(receiver).$mul(receiver, a0);
    },
    $sub$n: function(receiver, a0) {
      if (typeof receiver == "number" && typeof a0 == "number")
        return receiver - a0;
      return J.getInterceptor$n(receiver).$sub(receiver, a0);
    },
    _codeUnitAt$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver)._codeUnitAt$1(receiver, a0);
    },
    addAll$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).addAll$1(receiver, a0);
    },
    clamp$2$n: function(receiver, a0, a1) {
      return J.getInterceptor$n(receiver).clamp$2(receiver, a0, a1);
    },
    compareTo$1$ns: function(receiver, a0) {
      return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
    },
    elementAt$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).elementAt$1(receiver, a0);
    },
    fillRange$3$x: function(receiver, a0, a1, a2) {
      return J.getInterceptor$x(receiver).fillRange$3(receiver, a0, a1, a2);
    },
    floor$0$n: function(receiver) {
      return J.getInterceptor$n(receiver).floor$0(receiver);
    },
    forEach$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).forEach$1(receiver, a0);
    },
    join$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).join$1(receiver, a0);
    },
    map$1$1$ax: function(receiver, a0, $T1) {
      return J.getInterceptor$ax(receiver).map$1$1(receiver, a0, $T1);
    },
    matchAsPrefix$2$s: function(receiver, a0, a1) {
      return J.getInterceptor$s(receiver).matchAsPrefix$2(receiver, a0, a1);
    },
    remove$0$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).remove$0(receiver);
    },
    remove$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).remove$1(receiver, a0);
    },
    replaceRange$3$s: function(receiver, a0, a1, a2) {
      return J.getInterceptor$s(receiver).replaceRange$3(receiver, a0, a1, a2);
    },
    round$0$n: function(receiver) {
      return J.getInterceptor$n(receiver).round$0(receiver);
    },
    sort$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).sort$1(receiver, a0);
    },
    startsWith$2$s: function(receiver, a0, a1) {
      return J.getInterceptor$s(receiver).startsWith$2(receiver, a0, a1);
    },
    substring$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver).substring$1(receiver, a0);
    },
    substring$2$s: function(receiver, a0, a1) {
      return J.getInterceptor$s(receiver).substring$2(receiver, a0, a1);
    },
    toInt$0$n: function(receiver) {
      return J.getInterceptor$n(receiver).toInt$0(receiver);
    },
    toString$0$: function(receiver) {
      return J.getInterceptor$(receiver).toString$0(receiver);
    },
    toString$1$debugIncludeStack$: function(receiver, a0) {
      return J.getInterceptor$(receiver).toString$1$debugIncludeStack(receiver, a0);
    },
    toStringAsFixed$1$n: function(receiver, a0) {
      return J.getInterceptor$n(receiver).toStringAsFixed$1(receiver, a0);
    },
    trim$0$s: function(receiver) {
      return J.getInterceptor$s(receiver).trim$0(receiver);
    },
    trimLeft$0$s: function(receiver) {
      return J.getInterceptor$s(receiver).trimLeft$0(receiver);
    },
    trimRight$0$s: function(receiver) {
      return J.getInterceptor$s(receiver).trimRight$0(receiver);
    },
    Interceptor: function Interceptor() {
    },
    JSBool: function JSBool() {
    },
    JSNull: function JSNull() {
    },
    JSObject: function JSObject() {
    },
    JavaScriptObject: function JavaScriptObject() {
    },
    PlainJavaScriptObject: function PlainJavaScriptObject() {
    },
    UnknownJavaScriptObject: function UnknownJavaScriptObject() {
    },
    JavaScriptFunction: function JavaScriptFunction() {
    },
    JSArray: function JSArray(t0) {
      this.$ti = t0;
    },
    JSUnmodifiableArray: function JSUnmodifiableArray(t0) {
      this.$ti = t0;
    },
    ArrayIterator: function ArrayIterator(t0, t1, t2) {
      var _ = this;
      _.__interceptors$_iterable = t0;
      _.__interceptors$_length = t1;
      _.__interceptors$_index = 0;
      _.__interceptors$_current = null;
      _.$ti = t2;
    },
    JSNumber: function JSNumber() {
    },
    JSInt: function JSInt() {
    },
    JSDouble: function JSDouble() {
    },
    JSString: function JSString() {
    }
  },
  P = {
    _AsyncRun__initializeScheduleImmediate: function() {
      var div, span, t1 = {};
      if (self.scheduleImmediate != null)
        return P.async__AsyncRun__scheduleImmediateJsOverride$closure();
      if (self.MutationObserver != null && self.document != null) {
        div = self.document.createElement("div");
        span = self.document.createElement("span");
        t1.storedCallback = null;
        new self.MutationObserver(H.convertDartClosureToJS(new P._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
        return new P._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
      } else if (self.setImmediate != null)
        return P.async__AsyncRun__scheduleImmediateWithSetImmediate$closure();
      return P.async__AsyncRun__scheduleImmediateWithTimer$closure();
    },
    _AsyncRun__scheduleImmediateJsOverride: function(callback) {
      self.scheduleImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateJsOverride_internalCallback(H.functionTypeCheck(callback, {func: 1, ret: -1})), 0));
    },
    _AsyncRun__scheduleImmediateWithSetImmediate: function(callback) {
      self.setImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(H.functionTypeCheck(callback, {func: 1, ret: -1})), 0));
    },
    _AsyncRun__scheduleImmediateWithTimer: function(callback) {
      P.Timer__createTimer(C.Duration_0, H.functionTypeCheck(callback, {func: 1, ret: -1}));
    },
    Timer__createTimer: function(duration, callback) {
      var milliseconds;
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      milliseconds = C.JSInt_methods._tdivFast$1(duration._duration, 1000);
      return P._TimerImpl$(milliseconds < 0 ? 0 : milliseconds, callback);
    },
    _TimerImpl$: function(milliseconds, callback) {
      var t1 = new P._TimerImpl();
      t1._TimerImpl$2(milliseconds, callback);
      return t1;
    },
    _makeAsyncAwaitCompleter: function($T) {
      return new P._AsyncAwaitCompleter(new P._SyncCompleter(new P._Future($.Zone__current, [$T]), [$T]), [$T]);
    },
    _asyncStartSync: function(bodyFunction, completer) {
      H.functionTypeCheck(bodyFunction, {func: 1, ret: -1, args: [P.int,,]});
      H.interceptedTypeCheck(completer, "$is_AsyncAwaitCompleter");
      bodyFunction.call$2(0, null);
      completer.isSync = true;
      return completer._completer.future;
    },
    _asyncAwait: function(object, bodyFunction) {
      P._awaitOnObject(object, H.functionTypeCheck(bodyFunction, {func: 1, ret: -1, args: [P.int,,]}));
    },
    _asyncReturn: function(object, completer) {
      H.interceptedTypeCheck(completer, "$isCompleter").complete$1(object);
    },
    _asyncRethrow: function(object, completer) {
      H.interceptedTypeCheck(completer, "$isCompleter").completeError$2(H.unwrapException(object), H.getTraceFromException(object));
    },
    _awaitOnObject: function(object, bodyFunction) {
      var thenCallback, errorCallback, t1, future, _null = null;
      H.functionTypeCheck(bodyFunction, {func: 1, ret: -1, args: [P.int,,]});
      thenCallback = new P._awaitOnObject_closure(bodyFunction);
      errorCallback = new P._awaitOnObject_closure0(bodyFunction);
      t1 = J.getInterceptor$(object);
      if (!!t1.$is_Future)
        object._thenNoZoneRegistration$1$2(thenCallback, errorCallback, _null);
      else if (!!t1.$isFuture)
        object.then$1$2$onError(thenCallback, errorCallback, _null);
      else {
        future = new P._Future($.Zone__current, [null]);
        H.assertSubtypeOfRuntimeType(object, null);
        future._state = 4;
        future._resultOrListeners = object;
        future._thenNoZoneRegistration$1$2(thenCallback, _null, _null);
      }
    },
    _wrapJsFunctionForAsync: function($function) {
      var $protected = function(fn, ERROR) {
        return function(errorCode, result) {
          while (true)
            try {
              fn(errorCode, result);
              break;
            } catch (error) {
              result = error;
              errorCode = ERROR;
            }
        };
      }($function, 1);
      return $.Zone__current.registerBinaryCallback$3$1(new P._wrapJsFunctionForAsync_closure($protected), P.Null, P.int, null);
    },
    _asyncStarHelper: function(object, bodyFunctionOrErrorCode, controller) {
      var t1, error, stackTrace, t2;
      H.interceptedTypeCheck(controller, "$is_AsyncStarStreamController");
      if (bodyFunctionOrErrorCode === 0) {
        t1 = controller.cancelationCompleter;
        if (t1 != null)
          t1.complete$0();
        else
          controller.controller.close$0();
        return;
      } else if (bodyFunctionOrErrorCode === 1) {
        t1 = controller.cancelationCompleter;
        if (t1 != null)
          t1.completeError$2(H.unwrapException(object), H.getTraceFromException(object));
        else {
          error = H.unwrapException(object);
          stackTrace = H.getTraceFromException(object);
          t1 = controller.controller;
          if (t1._state >= 4)
            H.throwExpression(t1._badEventState$0());
          if (error == null)
            error = new P.NullThrownError();
          $.Zone__current.toString;
          t1._addError$2(error, stackTrace);
          controller.controller.close$0();
        }
        return;
      }
      if (object instanceof P._IterationMarker) {
        if (controller.cancelationCompleter != null) {
          bodyFunctionOrErrorCode.call$2(2, null);
          return;
        }
        t1 = object.state;
        if (t1 === 0) {
          t1 = object.value;
          t2 = controller.controller;
          H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(controller, 0));
          t2.toString;
          H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(t2, 0));
          if (t2._state >= 4)
            H.throwExpression(t2._badEventState$0());
          t2._async$_add$1(t1);
          P.scheduleMicrotask(new P._asyncStarHelper_closure(controller, bodyFunctionOrErrorCode));
          return;
        } else if (t1 === 1) {
          t1 = H.assertSubtype(H.interceptedTypeCheck(object.value, "$isStream"), "$isStream", [H.getTypeArgumentByIndex(controller, 0)], "$asStream");
          controller.controller.addStream$2$cancelOnError(t1, false).then$1(new P._asyncStarHelper_closure0(controller, bodyFunctionOrErrorCode));
          return;
        }
      }
      P._awaitOnObject(object, H.functionTypeCheck(bodyFunctionOrErrorCode, {func: 1, ret: -1, args: [P.int,,]}));
    },
    _streamOfController: function(controller) {
      var t1 = H.interceptedTypeCheck(controller, "$is_AsyncStarStreamController").controller;
      t1.toString;
      return new P._ControllerStream(t1, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    _AsyncStarStreamController$: function(body, $T) {
      var t1 = new P._AsyncStarStreamController([$T]);
      t1._AsyncStarStreamController$1(body, $T);
      return t1;
    },
    _makeAsyncStarStreamController: function(body, $T) {
      return P._AsyncStarStreamController$(H.functionTypeCheck(body, {func: 1, ret: -1, args: [P.int,,]}), $T);
    },
    _IterationMarker_yieldStar: function(values) {
      return new P._IterationMarker(values, 1);
    },
    _IterationMarker_endOfIteration: function() {
      return C._IterationMarker_null_2;
    },
    _IterationMarker_yieldSingle: function(value) {
      return new P._IterationMarker(value, 0);
    },
    _IterationMarker_uncaughtError: function(error) {
      return new P._IterationMarker(error, 3);
    },
    _makeSyncStarIterable: function(body, $T) {
      return new P._SyncStarIterable(body, [$T]);
    },
    Future_Future$error: function(error, stackTrace, $T) {
      var t1;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      t1 = $.Zone__current;
      if (t1 !== C.C__RootZone)
        t1.toString;
      t1 = new P._Future(t1, [$T]);
      t1._asyncCompleteError$2(error, stackTrace);
      return t1;
    },
    Future_Future$delayed: function(duration, $T) {
      var result = new P._Future($.Zone__current, [$T]);
      P.Timer_Timer(duration, new P.Future_Future$delayed_closure(null, result));
      return result;
    },
    Future_wait: function(futures, $T) {
      var result, handleError, future, pos, e, st, t1, t2, t3, exception, _box_0 = {}, cleanUp = null,
        eagerError = false;
      H.assertSubtype(futures, "$isIterable", [[P.Future, $T]], "$asIterable");
      t1 = [P.List, $T];
      t2 = [t1];
      result = new P._Future($.Zone__current, t2);
      _box_0.values = null;
      _box_0.remaining = 0;
      _box_0.stackTrace = _box_0.error = null;
      handleError = new P.Future_wait_handleError(_box_0, cleanUp, eagerError, result);
      try {
        for (t3 = J.get$iterator$ax(futures); t3.moveNext$0();) {
          future = t3.get$current();
          pos = _box_0.remaining;
          future.then$1$2$onError(new P.Future_wait_closure(_box_0, pos, result, cleanUp, eagerError, $T), handleError, null);
          ++_box_0.remaining;
        }
        t3 = _box_0.remaining;
        if (t3 === 0) {
          t2 = new P._Future($.Zone__current, t2);
          t2._asyncComplete$1(C.List_empty0);
          return t2;
        }
        t2 = new Array(t3);
        t2.fixed$length = Array;
        _box_0.values = H.setRuntimeTypeInfo(t2, [$T]);
      } catch (exception) {
        e = H.unwrapException(exception);
        st = H.getTraceFromException(exception);
        if (_box_0.remaining === 0 || H.boolConversionCheck(eagerError))
          return P.Future_Future$error(e, st, t1);
        else {
          _box_0.error = e;
          _box_0.stackTrace = st;
        }
      }
      return result;
    },
    _Future$zoneValue: function(value, _zone, $T) {
      var t1 = new P._Future(_zone, [$T]);
      H.assertSubtypeOfRuntimeType(value, $T);
      t1._state = 4;
      t1._resultOrListeners = value;
      return t1;
    },
    _Future__chainForeignFuture: function(source, target) {
      var e, s, exception;
      H.assertHelper(target._state < 4);
      H.assertHelper(!(source instanceof P._Future));
      H.assertHelper(target._state === 0);
      target._state = 1;
      try {
        source.then$1$2$onError(new P._Future__chainForeignFuture_closure(target), new P._Future__chainForeignFuture_closure0(target), null);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P.scheduleMicrotask(new P._Future__chainForeignFuture_closure1(target, e, s));
      }
    },
    _Future__chainCoreFuture: function(source, target) {
      var t1, t2, listeners;
      H.assertHelper(target._state <= 1);
      for (; t1 = source._state, t2 = t1 === 2, t2;) {
        H.assertHelper(t2);
        source = H.interceptedTypeCheck(source._resultOrListeners, "$is_Future");
      }
      if (t1 >= 4) {
        listeners = target._removeListeners$0();
        target._cloneResult$1(source);
        P._Future__propagateToListeners(target, listeners);
      } else {
        listeners = H.interceptedTypeCheck(target._resultOrListeners, "$is_FutureListener");
        H.assertHelper(target._state <= 1);
        target._state = 2;
        target._resultOrListeners = source;
        source._prependListeners$1(listeners);
      }
    },
    _Future__propagateToListeners: function(source, listeners) {
      var _box_0, hasError, asyncError, t2, t3, listeners0, sourceResult, zone, t4, previous, oldZone, current, result, _null = null, _box_1 = {},
        t1 = _box_1.source = source;
      for (; true;) {
        _box_0 = {};
        H.assertHelper(t1._state >= 4);
        t1 = _box_1.source;
        hasError = t1._state === 8;
        if (listeners == null) {
          if (hasError) {
            asyncError = H.interceptedTypeCheck(t1._resultOrListeners, "$isAsyncError");
            t1 = t1._zone;
            t2 = asyncError.error;
            t3 = asyncError.stackTrace;
            t1.toString;
            P._rootHandleUncaughtError(_null, _null, t1, t2, t3);
          }
          return;
        }
        for (; listeners0 = listeners._nextListener, listeners0 != null; listeners = listeners0) {
          listeners._nextListener = null;
          P._Future__propagateToListeners(_box_1.source, listeners);
        }
        t1 = _box_1.source;
        sourceResult = t1._resultOrListeners;
        _box_0.listenerHasError = hasError;
        _box_0.listenerValueOrError = sourceResult;
        t2 = !hasError;
        if (t2) {
          t3 = listeners.state;
          t3 = (t3 & 1) !== 0 || t3 === 8;
        } else
          t3 = true;
        if (t3) {
          t3 = listeners.result;
          zone = t3._zone;
          if (hasError) {
            t4 = t1._zone;
            t4.toString;
            t4 = t4 == zone;
            if (!t4)
              zone.toString;
            else
              t4 = true;
            t4 = !t4;
          } else
            t4 = false;
          if (t4) {
            H.assertHelper(t1._state === 8);
            asyncError = H.interceptedTypeCheck(t1._resultOrListeners, "$isAsyncError");
            t1 = _box_1.source._zone;
            t2 = asyncError.error;
            t3 = asyncError.stackTrace;
            t1.toString;
            P._rootHandleUncaughtError(_null, _null, t1, t2, t3);
            return;
          }
          if ($.Zone__current != zone) {
            H.assertHelper(zone != null);
            H.assertHelper(zone != $.Zone__current);
            previous = $.Zone__current;
            $.Zone__current = zone;
            oldZone = previous;
          } else
            oldZone = _null;
          t1 = listeners.state;
          if (t1 === 8)
            new P._Future__propagateToListeners_handleWhenCompleteCallback(_box_1, _box_0, listeners, hasError).call$0();
          else if (t2) {
            if ((t1 & 1) !== 0)
              new P._Future__propagateToListeners_handleValueCallback(_box_0, listeners, sourceResult).call$0();
          } else if ((t1 & 2) !== 0)
            new P._Future__propagateToListeners_handleError(_box_1, _box_0, listeners).call$0();
          if (oldZone != null)
            $.Zone__current = oldZone;
          t1 = _box_0.listenerValueOrError;
          if (!!J.getInterceptor$(t1).$isFuture) {
            if (!!t1.$is_Future)
              if (t1._state >= 4) {
                H.assertHelper(t3._state < 4);
                current = H.interceptedTypeCheck(t3._resultOrListeners, "$is_FutureListener");
                t3._resultOrListeners = null;
                listeners = t3._reverseListeners$1(current);
                H.assertHelper(t3._state < 4);
                H.assertHelper(t1._state >= 4);
                t3._state = t1._state;
                t3._resultOrListeners = t1._resultOrListeners;
                _box_1.source = t1;
                continue;
              } else
                P._Future__chainCoreFuture(t1, t3);
            else
              P._Future__chainForeignFuture(t1, t3);
            return;
          }
        }
        result = listeners.result;
        H.assertHelper(result._state < 4);
        current = H.interceptedTypeCheck(result._resultOrListeners, "$is_FutureListener");
        result._resultOrListeners = null;
        listeners = result._reverseListeners$1(current);
        t1 = _box_0.listenerHasError;
        t2 = _box_0.listenerValueOrError;
        t3 = result._state >= 4;
        if (!t1) {
          H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(result, 0));
          H.assertHelper(!t3);
          result._state = 4;
          result._resultOrListeners = t2;
        } else {
          H.interceptedTypeCheck(t2, "$isAsyncError");
          H.assertHelper(!t3);
          result._state = 8;
          result._resultOrListeners = t2;
        }
        _box_1.source = result;
        t1 = result;
      }
    },
    _registerErrorHandler: function(errorHandler, zone) {
      if (H.functionTypeTest(errorHandler, {func: 1, args: [P.Object, P.StackTrace]}))
        return zone.registerBinaryCallback$3$1(errorHandler, null, P.Object, P.StackTrace);
      if (H.functionTypeTest(errorHandler, {func: 1, args: [P.Object]}))
        return H.functionTypeCheck(errorHandler, {func: 1, ret: null, args: [P.Object]});
      throw H.wrapException(P.ArgumentError$value(errorHandler, "onError", "Error handler must accept one Object or one Object and a StackTrace as arguments, and return a a valid result"));
    },
    _microtaskLoop: function() {
      var t1, t2;
      for (; t1 = $._nextCallback, t1 != null;) {
        $._lastPriorityCallback = null;
        t2 = t1.next;
        $._nextCallback = t2;
        if (t2 == null)
          $._lastCallback = null;
        t1.callback.call$0();
      }
    },
    _startMicrotaskLoop: function() {
      $._isInCallbackLoop = true;
      try {
        P._microtaskLoop();
      } finally {
        $._lastPriorityCallback = null;
        $._isInCallbackLoop = false;
        if ($._nextCallback != null)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(P.async___startMicrotaskLoop$closure());
      }
    },
    _scheduleAsyncCallback: function(callback) {
      var newEntry = new P._AsyncCallbackEntry(H.functionTypeCheck(callback, {func: 1, ret: -1}));
      if ($._nextCallback == null) {
        $._nextCallback = $._lastCallback = newEntry;
        if (!$._isInCallbackLoop)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(P.async___startMicrotaskLoop$closure());
      } else
        $._lastCallback = $._lastCallback.next = newEntry;
    },
    _schedulePriorityAsyncCallback: function(callback) {
      var t1, entry, t2;
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      t1 = $._nextCallback;
      if (t1 == null) {
        P._scheduleAsyncCallback(callback);
        $._lastPriorityCallback = $._lastCallback;
        return;
      }
      entry = new P._AsyncCallbackEntry(callback);
      t2 = $._lastPriorityCallback;
      if (t2 == null) {
        entry.next = t1;
        $._nextCallback = $._lastPriorityCallback = entry;
      } else {
        entry.next = t2.next;
        $._lastPriorityCallback = t2.next = entry;
        if (entry.next == null)
          $._lastCallback = entry;
      }
    },
    scheduleMicrotask: function(callback) {
      var currentZone, _null = null,
        t1 = {func: 1, ret: -1};
      H.functionTypeCheck(callback, t1);
      currentZone = $.Zone__current;
      if (C.C__RootZone === currentZone) {
        P._rootScheduleMicrotask(_null, _null, C.C__RootZone, callback);
        return;
      }
      currentZone.toString;
      P._rootScheduleMicrotask(_null, _null, currentZone, H.functionTypeCheck(currentZone.bindCallbackGuarded$1(callback), t1));
    },
    Stream_Stream$fromIterable: function(elements, $T) {
      return new P._GeneratedStreamImpl(new P.Stream_Stream$fromIterable_closure(H.assertSubtype(elements, "$isIterable", [$T], "$asIterable"), $T), [$T]);
    },
    StreamIterator_StreamIterator: function(stream, $T) {
      return new P._StreamIterator(H.assertSubtype(stream, "$isStream", [$T], "$asStream"), [$T]);
    },
    _runGuarded: function(notificationHandler) {
      var e, s, exception, t1;
      H.functionTypeCheck(notificationHandler, {func: 1});
      if (notificationHandler == null)
        return;
      try {
        notificationHandler.call$0();
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        t1 = $.Zone__current;
        t1.toString;
        P._rootHandleUncaughtError(null, null, t1, e, H.interceptedTypeCheck(s, "$isStackTrace"));
      }
    },
    _BufferingStreamSubscription$: function(onData, onError, onDone, cancelOnError, $T) {
      var t1 = $.Zone__current,
        t2 = cancelOnError ? 1 : 0;
      t2 = new P._BufferingStreamSubscription(t1, t2, [$T]);
      t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
      return t2;
    },
    _cancelAndValue: function(subscription, future, value) {
      var cancelFuture = subscription.cancel$0();
      if (cancelFuture != null && cancelFuture !== $.$get$Future__nullFuture())
        cancelFuture.whenComplete$1(new P._cancelAndValue_closure(future, false));
      else
        future._complete$1(false);
    },
    Timer_Timer: function(duration, callback) {
      var t2,
        t1 = {func: 1, ret: -1};
      H.functionTypeCheck(callback, t1);
      t2 = $.Zone__current;
      if (t2 === C.C__RootZone) {
        t2.toString;
        return P.Timer__createTimer(duration, callback);
      }
      return P.Timer__createTimer(duration, H.functionTypeCheck(t2.bindCallbackGuarded$1(callback), t1));
    },
    Zone__enter: function(zone) {
      var previous;
      H.assertHelper(zone != null);
      H.assertHelper(zone != $.Zone__current);
      previous = $.Zone__current;
      $.Zone__current = zone;
      return previous;
    },
    _rootHandleUncaughtError: function($self, $parent, zone, error, stackTrace) {
      var t1 = {};
      t1.error = error;
      P._schedulePriorityAsyncCallback(new P._rootHandleUncaughtError_closure(t1, stackTrace));
    },
    _rootRun: function($self, $parent, zone, f, $R) {
      var old, t1;
      H.functionTypeCheck(f, {func: 1, ret: $R});
      if ($.Zone__current === zone)
        return f.call$0();
      old = P.Zone__enter(zone);
      try {
        t1 = f.call$0();
        return t1;
      } finally {
        t1 = old;
        H.assertHelper(t1 != null);
        $.Zone__current = t1;
      }
    },
    _rootRunUnary: function($self, $parent, zone, f, arg, $R, $T) {
      var old, t1;
      H.functionTypeCheck(f, {func: 1, ret: $R, args: [$T]});
      H.assertSubtypeOfRuntimeType(arg, $T);
      if ($.Zone__current === zone)
        return f.call$1(arg);
      old = P.Zone__enter(zone);
      try {
        t1 = f.call$1(arg);
        return t1;
      } finally {
        t1 = old;
        H.assertHelper(t1 != null);
        $.Zone__current = t1;
      }
    },
    _rootRunBinary: function($self, $parent, zone, f, arg1, arg2, $R, T1, T2) {
      var old, t1;
      H.functionTypeCheck(f, {func: 1, ret: $R, args: [T1, T2]});
      H.assertSubtypeOfRuntimeType(arg1, T1);
      H.assertSubtypeOfRuntimeType(arg2, T2);
      if ($.Zone__current === zone)
        return f.call$2(arg1, arg2);
      old = P.Zone__enter(zone);
      try {
        t1 = f.call$2(arg1, arg2);
        return t1;
      } finally {
        t1 = old;
        H.assertHelper(t1 != null);
        $.Zone__current = t1;
      }
    },
    _rootScheduleMicrotask: function($self, $parent, zone, f) {
      var t1;
      H.functionTypeCheck(f, {func: 1, ret: -1});
      t1 = C.C__RootZone !== zone;
      if (t1)
        f = !(!t1 || false) ? zone.bindCallbackGuarded$1(f) : zone.bindCallback$1$1(f, -1);
      P._scheduleAsyncCallback(f);
    },
    _AsyncRun__initializeScheduleImmediate_internalCallback: function _AsyncRun__initializeScheduleImmediate_internalCallback(t0) {
      this._box_0 = t0;
    },
    _AsyncRun__initializeScheduleImmediate_closure: function _AsyncRun__initializeScheduleImmediate_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.div = t1;
      this.span = t2;
    },
    _AsyncRun__scheduleImmediateJsOverride_internalCallback: function _AsyncRun__scheduleImmediateJsOverride_internalCallback(t0) {
      this.callback = t0;
    },
    _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback: function _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(t0) {
      this.callback = t0;
    },
    _TimerImpl: function _TimerImpl() {
      this._handle = null;
    },
    _TimerImpl_internalCallback: function _TimerImpl_internalCallback(t0, t1) {
      this.$this = t0;
      this.callback = t1;
    },
    _AsyncAwaitCompleter: function _AsyncAwaitCompleter(t0, t1) {
      this._completer = t0;
      this.isSync = false;
      this.$ti = t1;
    },
    _AsyncAwaitCompleter_complete_closure: function _AsyncAwaitCompleter_complete_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _AsyncAwaitCompleter_completeError_closure: function _AsyncAwaitCompleter_completeError_closure(t0, t1, t2) {
      this.$this = t0;
      this.e = t1;
      this.st = t2;
    },
    _awaitOnObject_closure: function _awaitOnObject_closure(t0) {
      this.bodyFunction = t0;
    },
    _awaitOnObject_closure0: function _awaitOnObject_closure0(t0) {
      this.bodyFunction = t0;
    },
    _wrapJsFunctionForAsync_closure: function _wrapJsFunctionForAsync_closure(t0) {
      this.$protected = t0;
    },
    _asyncStarHelper_closure: function _asyncStarHelper_closure(t0, t1) {
      this.controller = t0;
      this.bodyFunctionOrErrorCode = t1;
    },
    _asyncStarHelper_closure0: function _asyncStarHelper_closure0(t0, t1) {
      this.controller = t0;
      this.bodyFunctionOrErrorCode = t1;
    },
    _AsyncStarStreamController: function _AsyncStarStreamController(t0) {
      var _ = this;
      _.controller = null;
      _.isSuspended = false;
      _.cancelationCompleter = null;
      _.$ti = t0;
    },
    _AsyncStarStreamController__resumeBody: function _AsyncStarStreamController__resumeBody(t0) {
      this.body = t0;
    },
    _AsyncStarStreamController__resumeBody_closure: function _AsyncStarStreamController__resumeBody_closure(t0) {
      this.body = t0;
    },
    _AsyncStarStreamController_closure: function _AsyncStarStreamController_closure(t0) {
      this._resumeBody = t0;
    },
    _AsyncStarStreamController_closure0: function _AsyncStarStreamController_closure0(t0, t1) {
      this.$this = t0;
      this._resumeBody = t1;
    },
    _AsyncStarStreamController_closure1: function _AsyncStarStreamController_closure1(t0, t1) {
      this.$this = t0;
      this.body = t1;
    },
    _AsyncStarStreamController__closure: function _AsyncStarStreamController__closure(t0) {
      this.body = t0;
    },
    _IterationMarker: function _IterationMarker(t0, t1) {
      this.value = t0;
      this.state = t1;
    },
    _SyncStarIterator: function _SyncStarIterator(t0, t1) {
      var _ = this;
      _._body = t0;
      _._suspendedBodies = _._nestedIterator = _._async$_current = null;
      _.$ti = t1;
    },
    _SyncStarIterable: function _SyncStarIterable(t0, t1) {
      this._outerHelper = t0;
      this.$ti = t1;
    },
    Future: function Future() {
    },
    Future_Future$delayed_closure: function Future_Future$delayed_closure(t0, t1) {
      this.computation = t0;
      this.result = t1;
    },
    Future_wait_handleError: function Future_wait_handleError(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.cleanUp = t1;
      _.eagerError = t2;
      _.result = t3;
    },
    Future_wait_closure: function Future_wait_closure(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._box_0 = t0;
      _.pos = t1;
      _.result = t2;
      _.cleanUp = t3;
      _.eagerError = t4;
      _.T = t5;
    },
    _Completer: function _Completer() {
    },
    _AsyncCompleter: function _AsyncCompleter(t0, t1) {
      this.future = t0;
      this.$ti = t1;
    },
    _SyncCompleter: function _SyncCompleter(t0, t1) {
      this.future = t0;
      this.$ti = t1;
    },
    _FutureListener: function _FutureListener(t0, t1, t2, t3, t4) {
      var _ = this;
      _._nextListener = null;
      _.result = t0;
      _.state = t1;
      _.callback = t2;
      _.errorCallback = t3;
      _.$ti = t4;
    },
    _Future: function _Future(t0, t1) {
      var _ = this;
      _._state = 0;
      _._zone = t0;
      _._resultOrListeners = null;
      _.$ti = t1;
    },
    _Future__addListener_closure: function _Future__addListener_closure(t0, t1) {
      this.$this = t0;
      this.listener = t1;
    },
    _Future__prependListeners_closure: function _Future__prependListeners_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    _Future__chainForeignFuture_closure: function _Future__chainForeignFuture_closure(t0) {
      this.target = t0;
    },
    _Future__chainForeignFuture_closure0: function _Future__chainForeignFuture_closure0(t0) {
      this.target = t0;
    },
    _Future__chainForeignFuture_closure1: function _Future__chainForeignFuture_closure1(t0, t1, t2) {
      this.target = t0;
      this.e = t1;
      this.s = t2;
    },
    _Future__asyncComplete_closure: function _Future__asyncComplete_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _Future__chainFuture_closure: function _Future__chainFuture_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _Future__asyncCompleteError_closure: function _Future__asyncCompleteError_closure(t0, t1, t2) {
      this.$this = t0;
      this.error = t1;
      this.stackTrace = t2;
    },
    _Future__propagateToListeners_handleWhenCompleteCallback: function _Future__propagateToListeners_handleWhenCompleteCallback(t0, t1, t2, t3) {
      var _ = this;
      _._box_1 = t0;
      _._box_0 = t1;
      _.listener = t2;
      _.hasError = t3;
    },
    _Future__propagateToListeners_handleWhenCompleteCallback_closure: function _Future__propagateToListeners_handleWhenCompleteCallback_closure(t0) {
      this.originalSource = t0;
    },
    _Future__propagateToListeners_handleValueCallback: function _Future__propagateToListeners_handleValueCallback(t0, t1, t2) {
      this._box_0 = t0;
      this.listener = t1;
      this.sourceResult = t2;
    },
    _Future__propagateToListeners_handleError: function _Future__propagateToListeners_handleError(t0, t1, t2) {
      this._box_1 = t0;
      this._box_0 = t1;
      this.listener = t2;
    },
    _AsyncCallbackEntry: function _AsyncCallbackEntry(t0) {
      this.callback = t0;
      this.next = null;
    },
    Stream: function Stream() {
    },
    Stream_Stream$fromIterable_closure: function Stream_Stream$fromIterable_closure(t0, t1) {
      this.elements = t0;
      this.T = t1;
    },
    Stream_length_closure: function Stream_length_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    Stream_length_closure0: function Stream_length_closure0(t0, t1) {
      this._box_0 = t0;
      this.future = t1;
    },
    Stream_isEmpty_closure: function Stream_isEmpty_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.future = t2;
    },
    Stream_isEmpty_closure0: function Stream_isEmpty_closure0(t0) {
      this.future = t0;
    },
    StreamTransformerBase: function StreamTransformerBase() {
    },
    _StreamController: function _StreamController() {
    },
    _StreamController__subscribe_closure: function _StreamController__subscribe_closure(t0) {
      this.$this = t0;
    },
    _StreamController__recordCancel_complete: function _StreamController__recordCancel_complete(t0) {
      this.$this = t0;
    },
    _AsyncStreamControllerDispatch: function _AsyncStreamControllerDispatch() {
    },
    _AsyncStreamController: function _AsyncStreamController(t0, t1, t2, t3, t4) {
      var _ = this;
      _._varData = null;
      _._state = 0;
      _._doneFuture = null;
      _.onListen = t0;
      _.onPause = t1;
      _.onResume = t2;
      _.onCancel = t3;
      _.$ti = t4;
    },
    _ControllerStream: function _ControllerStream(t0, t1) {
      this._async$_controller = t0;
      this.$ti = t1;
    },
    _ControllerSubscription: function _ControllerSubscription(t0, t1, t2, t3) {
      var _ = this;
      _._async$_controller = t0;
      _._onDone = _._onError = _._onData = null;
      _._zone = t1;
      _._state = t2;
      _._pending = _._cancelFuture = null;
      _.$ti = t3;
    },
    _AddStreamState: function _AddStreamState() {
    },
    _AddStreamState_cancel_closure: function _AddStreamState_cancel_closure(t0) {
      this.$this = t0;
    },
    _StreamControllerAddStreamState: function _StreamControllerAddStreamState(t0, t1, t2, t3) {
      var _ = this;
      _.varData = t0;
      _.addStreamFuture = t1;
      _.addSubscription = t2;
      _.$ti = t3;
    },
    _BufferingStreamSubscription: function _BufferingStreamSubscription(t0, t1, t2) {
      var _ = this;
      _._onDone = _._onError = _._onData = null;
      _._zone = t0;
      _._state = t1;
      _._pending = _._cancelFuture = null;
      _.$ti = t2;
    },
    _BufferingStreamSubscription__sendError_sendError: function _BufferingStreamSubscription__sendError_sendError(t0, t1, t2) {
      this.$this = t0;
      this.error = t1;
      this.stackTrace = t2;
    },
    _BufferingStreamSubscription__sendDone_sendDone: function _BufferingStreamSubscription__sendDone_sendDone(t0) {
      this.$this = t0;
    },
    _StreamImpl: function _StreamImpl() {
    },
    _GeneratedStreamImpl: function _GeneratedStreamImpl(t0, t1) {
      this._pending = t0;
      this._isUsed = false;
      this.$ti = t1;
    },
    _IterablePendingEvents: function _IterablePendingEvents(t0, t1) {
      this._async$_iterator = t0;
      this._state = 0;
      this.$ti = t1;
    },
    _DelayedEvent: function _DelayedEvent() {
    },
    _DelayedData: function _DelayedData(t0, t1) {
      this.value = t0;
      this.next = null;
      this.$ti = t1;
    },
    _DelayedError: function _DelayedError(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
      this.next = null;
    },
    _DelayedDone: function _DelayedDone() {
    },
    _PendingEvents: function _PendingEvents() {
    },
    _PendingEvents_schedule_closure: function _PendingEvents_schedule_closure(t0, t1) {
      this.$this = t0;
      this.dispatch = t1;
    },
    _StreamImplEvents: function _StreamImplEvents(t0) {
      var _ = this;
      _.lastPendingEvent = _.firstPendingEvent = null;
      _._state = 0;
      _.$ti = t0;
    },
    _StreamIterator: function _StreamIterator(t0, t1) {
      var _ = this;
      _._subscription = null;
      _._stateData = t0;
      _._isPaused = false;
      _.$ti = t1;
    },
    _cancelAndValue_closure: function _cancelAndValue_closure(t0, t1) {
      this.future = t0;
      this.value = t1;
    },
    AsyncError: function AsyncError(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
    },
    _Zone: function _Zone() {
    },
    _rootHandleUncaughtError_closure: function _rootHandleUncaughtError_closure(t0, t1) {
      this._box_0 = t0;
      this.stackTrace = t1;
    },
    _RootZone: function _RootZone() {
    },
    _RootZone_bindCallback_closure: function _RootZone_bindCallback_closure(t0, t1, t2) {
      this.$this = t0;
      this.f = t1;
      this.R = t2;
    },
    _RootZone_bindCallbackGuarded_closure: function _RootZone_bindCallbackGuarded_closure(t0, t1) {
      this.$this = t0;
      this.f = t1;
    },
    HashMap_HashMap: function($K, $V) {
      return new P._HashMap([$K, $V]);
    },
    _HashMap__getTableEntry: function(table, key) {
      var entry = table[key];
      return entry === table ? null : entry;
    },
    _HashMap__setTableEntry: function(table, key, value) {
      if (value == null)
        table[key] = table;
      else
        table[key] = value;
    },
    _HashMap__newHashTable: function() {
      var table = Object.create(null);
      P._HashMap__setTableEntry(table, "<non-identifier-key>", table);
      delete table["<non-identifier-key>"];
      return table;
    },
    LinkedHashMap_LinkedHashMap: function($K, $V) {
      return new H.JsLinkedHashMap([$K, $V]);
    },
    LinkedHashMap_LinkedHashMap$_literal: function(keyValuePairs, $K, $V) {
      H.listTypeCheck(keyValuePairs);
      return H.assertSubtype(H.fillLiteralMap(keyValuePairs, new H.JsLinkedHashMap([$K, $V])), "$isLinkedHashMap", [$K, $V], "$asLinkedHashMap");
    },
    LinkedHashMap_LinkedHashMap$_empty: function($K, $V) {
      return new H.JsLinkedHashMap([$K, $V]);
    },
    LinkedHashMap__makeEmpty: function() {
      return new H.JsLinkedHashMap([null, null]);
    },
    _LinkedIdentityHashMap__LinkedIdentityHashMap$es6: function($K, $V) {
      return new P._LinkedIdentityHashMap([$K, $V]);
    },
    HashSet_HashSet: function($E) {
      return new P._HashSet([$E]);
    },
    _HashSet__newHashTable: function() {
      var table = Object.create(null);
      H.assertHelper(table != null);
      table["<non-identifier-key>"] = table;
      delete table["<non-identifier-key>"];
      return table;
    },
    LinkedHashSet_LinkedHashSet: function($E) {
      return new P._LinkedHashSet([$E]);
    },
    LinkedHashSet_LinkedHashSet$_empty: function($E) {
      return new P._LinkedHashSet([$E]);
    },
    _LinkedHashSet__newHashTable: function() {
      var table = Object.create(null);
      H.assertHelper(table != null);
      table["<non-identifier-key>"] = table;
      delete table["<non-identifier-key>"];
      return table;
    },
    _LinkedHashSetIterator$: function(_set, _modifications, $E) {
      var t1 = new P._LinkedHashSetIterator(_set, _modifications, [$E]);
      t1._collection$_cell = _set._collection$_first;
      return t1;
    },
    HashMap_HashMap$from: function(other, $K, $V) {
      var result = P.HashMap_HashMap($K, $V);
      other.forEach$1(0, new P.HashMap_HashMap$from_closure(result, $K, $V));
      return H.assertSubtype(result, "$isHashMap", [$K, $V], "$asHashMap");
    },
    HashSet_HashSet$from: function(elements, $E) {
      var t1, _i,
        result = P.HashSet_HashSet($E);
      for (t1 = elements.length, _i = 0; _i < elements.length; elements.length === t1 || (0, H.throwConcurrentModificationError)(elements), ++_i)
        result.add$1(0, H.assertSubtypeOfRuntimeType(elements[_i], $E));
      return result;
    },
    IterableBase_iterableToShortString: function(iterable, leftDelimiter, rightDelimiter) {
      var parts, t1;
      if (P._isToStringVisiting(iterable)) {
        if (leftDelimiter === "(" && rightDelimiter === ")")
          return "(...)";
        return leftDelimiter + "..." + rightDelimiter;
      }
      parts = H.setRuntimeTypeInfo([], [P.String]);
      C.JSArray_methods.add$1($._toStringVisiting, iterable);
      try {
        P._iterablePartsToStrings(iterable, parts);
      } finally {
        H.assertHelper(C.JSArray_methods.get$last($._toStringVisiting) === iterable);
        if (0 >= $._toStringVisiting.length)
          return H.ioore($._toStringVisiting, -1);
        $._toStringVisiting.pop();
      }
      t1 = P.StringBuffer__writeAll(leftDelimiter, H.listSuperNativeTypeCheck(parts, "$isIterable"), ", ") + rightDelimiter;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
      var buffer, t1;
      if (P._isToStringVisiting(iterable))
        return leftDelimiter + "..." + rightDelimiter;
      buffer = new P.StringBuffer(leftDelimiter);
      C.JSArray_methods.add$1($._toStringVisiting, iterable);
      try {
        t1 = buffer;
        t1._contents = P.StringBuffer__writeAll(t1._contents, iterable, ", ");
      } finally {
        H.assertHelper(C.JSArray_methods.get$last($._toStringVisiting) === iterable);
        if (0 >= $._toStringVisiting.length)
          return H.ioore($._toStringVisiting, -1);
        $._toStringVisiting.pop();
      }
      buffer._contents += rightDelimiter;
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _isToStringVisiting: function(o) {
      var t1, i;
      for (t1 = $._toStringVisiting.length, i = 0; i < t1; ++i)
        if (o === $._toStringVisiting[i])
          return true;
      return false;
    },
    _iterablePartsToStrings: function(iterable, parts) {
      var it, $length, count, next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, elision;
      H.assertSubtype(parts, "$isList", [P.String], "$asList");
      it = J.get$iterator$ax(iterable);
      $length = 0;
      count = 0;
      while (true) {
        if (!($length < 80 || count < 3))
          break;
        if (!it.moveNext$0())
          return;
        next = H.S(it.get$current());
        C.JSArray_methods.add$1(parts, next);
        $length += next.length + 2;
        ++count;
      }
      if (!it.moveNext$0()) {
        if (count <= 5)
          return;
        if (0 >= parts.length)
          return H.ioore(parts, -1);
        ultimateString = parts.pop();
        if (0 >= parts.length)
          return H.ioore(parts, -1);
        penultimateString = parts.pop();
      } else {
        penultimate = it.get$current();
        ++count;
        if (!it.moveNext$0()) {
          if (count <= 4) {
            C.JSArray_methods.add$1(parts, H.S(penultimate));
            return;
          }
          ultimateString = H.S(penultimate);
          if (0 >= parts.length)
            return H.ioore(parts, -1);
          penultimateString = parts.pop();
          $length += ultimateString.length + 2;
        } else {
          ultimate = it.get$current();
          ++count;
          H.assertHelper(count < 100);
          for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
            ultimate0 = it.get$current();
            ++count;
            if (count > 100) {
              while (true) {
                if (!($length > 75 && count > 3))
                  break;
                if (0 >= parts.length)
                  return H.ioore(parts, -1);
                $length -= parts.pop().length + 2;
                --count;
              }
              C.JSArray_methods.add$1(parts, "...");
              return;
            }
          }
          penultimateString = H.S(penultimate);
          ultimateString = H.S(ultimate);
          $length += ultimateString.length + penultimateString.length + 4;
        }
      }
      if (count > parts.length + 2) {
        $length += 5;
        elision = "...";
      } else
        elision = null;
      while (true) {
        if (!($length > 80 && parts.length > 3))
          break;
        if (0 >= parts.length)
          return H.ioore(parts, -1);
        $length -= parts.pop().length + 2;
        if (elision == null) {
          $length += 5;
          elision = "...";
        }
      }
      if (elision != null)
        C.JSArray_methods.add$1(parts, elision);
      C.JSArray_methods.add$1(parts, penultimateString);
      C.JSArray_methods.add$1(parts, ultimateString);
    },
    LinkedHashMap_LinkedHashMap$from: function(other, $K, $V) {
      var result = P.LinkedHashMap_LinkedHashMap($K, $V);
      other.forEach$1(0, new P.LinkedHashMap_LinkedHashMap$from_closure(result, $K, $V));
      return result;
    },
    LinkedHashSet_LinkedHashSet$from: function(elements, $E) {
      var t1,
        result = P.LinkedHashSet_LinkedHashSet($E);
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        result.add$1(0, H.assertSubtypeOfRuntimeType(t1.get$current(), $E));
      return result;
    },
    MapBase_mapToString: function(m) {
      var result, t1 = {};
      if (P._isToStringVisiting(m))
        return "{...}";
      result = new P.StringBuffer("");
      try {
        C.JSArray_methods.add$1($._toStringVisiting, m);
        result._contents += "{";
        t1.first = true;
        m.forEach$1(0, new P.MapBase_mapToString_closure(t1, result));
        result._contents += "}";
      } finally {
        H.assertHelper(C.JSArray_methods.get$last($._toStringVisiting) === m);
        if (0 >= $._toStringVisiting.length)
          return H.ioore($._toStringVisiting, -1);
        $._toStringVisiting.pop();
      }
      t1 = result._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    ListQueue$: function($E) {
      var t1 = new P.ListQueue([$E]),
        t2 = new Array(8);
      t2.fixed$length = Array;
      t1.set$_table(H.setRuntimeTypeInfo(t2, [$E]));
      return t1;
    },
    ListQueue__nextPowerOf2: function(number) {
      var nextNumber;
      H.assertHelper(number > 0);
      number = (number << 1 >>> 0) - 1;
      for (; true; number = nextNumber) {
        nextNumber = (number & number - 1) >>> 0;
        if (nextNumber === 0)
          return number;
      }
    },
    _dynamicCompare: function(a, b) {
      return J.compareTo$1$ns(H.numberOrStringSuperNativeTypeCheck(a, "$isComparable"), H.numberOrStringSuperNativeTypeCheck(b, "$isComparable"));
    },
    _defaultCompare: function($K) {
      if (H.functionTypeTest(P.core_Comparable_compare$closure(), {func: 1, ret: P.int, args: [$K, $K]}))
        return P.core_Comparable_compare$closure();
      return P.collection___dynamicCompare$closure();
    },
    SplayTreeSet$: function(compare, isValidKey, $E) {
      var t1 = compare == null ? P._defaultCompare($E) : compare,
        t2 = isValidKey == null ? new P.SplayTreeSet_closure($E) : isValidKey;
      return new P.SplayTreeSet(new P._SplayTreeNode(null, [$E]), t1, t2, [$E]);
    },
    _HashMap: function _HashMap(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._collection$_keys = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _.$ti = t0;
    },
    _HashMap_addAll_closure: function _HashMap_addAll_closure(t0) {
      this.$this = t0;
    },
    _HashMapKeyIterable: function _HashMapKeyIterable(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    _HashMapKeyIterator: function _HashMapKeyIterator(t0, t1, t2) {
      var _ = this;
      _._collection$_map = t0;
      _._collection$_keys = t1;
      _._offset = 0;
      _._collection$_current = null;
      _.$ti = t2;
    },
    _LinkedIdentityHashMap: function _LinkedIdentityHashMap(t0) {
      var _ = this;
      _.__js_helper$_length = 0;
      _._last = _._first = _._rest = _._nums = _._strings = null;
      _._modifications = 0;
      _.$ti = t0;
    },
    _HashSet: function _HashSet(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._collection$_elements = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _.$ti = t0;
    },
    _HashSetIterator: function _HashSetIterator(t0, t1, t2) {
      var _ = this;
      _._collection$_set = t0;
      _._collection$_elements = t1;
      _._offset = 0;
      _._collection$_current = null;
      _.$ti = t2;
    },
    _LinkedHashSet: function _LinkedHashSet(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._collection$_last = _._collection$_first = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _._collection$_modifications = 0;
      _.$ti = t0;
    },
    _LinkedIdentityHashSet: function _LinkedIdentityHashSet(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._collection$_last = _._collection$_first = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _._collection$_modifications = 0;
      _.$ti = t0;
    },
    _LinkedHashSetCell: function _LinkedHashSetCell(t0) {
      this._collection$_element = t0;
      this._collection$_previous = this._collection$_next = null;
    },
    _LinkedHashSetIterator: function _LinkedHashSetIterator(t0, t1, t2) {
      var _ = this;
      _._collection$_set = t0;
      _._collection$_modifications = t1;
      _._collection$_current = _._collection$_cell = null;
      _.$ti = t2;
    },
    HashMap_HashMap$from_closure: function HashMap_HashMap$from_closure(t0, t1, t2) {
      this.result = t0;
      this.K = t1;
      this.V = t2;
    },
    HashSet: function HashSet() {
    },
    IterableMixin: function IterableMixin() {
    },
    IterableBase: function IterableBase() {
    },
    LinkedHashMap_LinkedHashMap$from_closure: function LinkedHashMap_LinkedHashMap$from_closure(t0, t1, t2) {
      this.result = t0;
      this.K = t1;
      this.V = t2;
    },
    LinkedHashSet: function LinkedHashSet() {
    },
    ListBase: function ListBase() {
    },
    ListMixin: function ListMixin() {
    },
    MapBase: function MapBase() {
    },
    MapBase_mapToString_closure: function MapBase_mapToString_closure(t0, t1) {
      this._box_0 = t0;
      this.result = t1;
    },
    MapMixin: function MapMixin() {
    },
    ListQueue: function ListQueue(t0) {
      var _ = this;
      _._table = null;
      _._modificationCount = _._tail = _._head = 0;
      _.$ti = t0;
    },
    _ListQueueIterator: function _ListQueueIterator(t0, t1, t2, t3, t4) {
      var _ = this;
      _._queue = t0;
      _._end = t1;
      _._modificationCount = t2;
      _._position = t3;
      _._collection$_current = null;
      _.$ti = t4;
    },
    SetMixin: function SetMixin() {
    },
    _SetBase: function _SetBase() {
    },
    _SplayTreeNode: function _SplayTreeNode(t0, t1) {
      var _ = this;
      _.key = t0;
      _.right = _.left = null;
      _.$ti = t1;
    },
    _SplayTree: function _SplayTree() {
    },
    _SplayTreeIterator: function _SplayTreeIterator() {
    },
    _SplayTreeKeyIterator: function _SplayTreeKeyIterator(t0, t1, t2, t3, t4) {
      var _ = this;
      _._tree = t0;
      _._workList = t1;
      _._modificationCount = t2;
      _._splayCount = t3;
      _._currentNode = null;
      _.$ti = t4;
    },
    SplayTreeSet: function SplayTreeSet(t0, t1, t2, t3) {
      var _ = this;
      _._root = null;
      _._dummy = t0;
      _._comparator = t1;
      _._validKey = t2;
      _._splayCount = _._modificationCount = _._count = 0;
      _.$ti = t3;
    },
    SplayTreeSet_closure: function SplayTreeSet_closure(t0) {
      this.E = t0;
    },
    _ListBase_Object_ListMixin: function _ListBase_Object_ListMixin() {
    },
    _SplayTreeSet__SplayTree_IterableMixin: function _SplayTreeSet__SplayTree_IterableMixin() {
    },
    _SplayTreeSet__SplayTree_IterableMixin_SetMixin: function _SplayTreeSet__SplayTree_IterableMixin_SetMixin() {
    },
    _parseJson: function(source, reviver) {
      var parsed, e, exception, t1;
      if (typeof source !== "string")
        throw H.wrapException(H.argumentErrorValue(source));
      parsed = null;
      try {
        parsed = JSON.parse(source);
      } catch (exception) {
        e = H.unwrapException(exception);
        t1 = P.FormatException$(String(e), null, null);
        throw H.wrapException(t1);
      }
      t1 = P._convertJsonToDartLazy(parsed);
      return t1;
    },
    _convertJsonToDartLazy: function(object) {
      var i;
      if (object == null)
        return;
      if (typeof object != "object")
        return object;
      if (Object.getPrototypeOf(object) !== Array.prototype)
        return new P._JsonMap(object, Object.create(null));
      for (i = 0; i < object.length; ++i)
        object[i] = P._convertJsonToDartLazy(object[i]);
      return object;
    },
    Utf8Decoder__convertIntercepted: function(allowMalformed, codeUnits, start, end) {
      H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
      if (codeUnits instanceof Uint8Array)
        return P.Utf8Decoder__convertInterceptedUint8List(false, codeUnits, start, end);
      return;
    },
    Utf8Decoder__convertInterceptedUint8List: function(allowMalformed, codeUnits, start, end) {
      var t1, $length,
        decoder = $.$get$Utf8Decoder__decoder();
      if (decoder == null)
        return;
      t1 = 0 === start;
      if (t1 && true)
        return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits);
      $length = codeUnits.length;
      end = P.RangeError_checkValidRange(start, end, $length);
      if (t1 && end === $length)
        return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits);
      return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits.subarray(start, end));
    },
    Utf8Decoder__useTextDecoderChecked: function(decoder, codeUnits) {
      if (P.Utf8Decoder__unsafe(codeUnits))
        return;
      return P.Utf8Decoder__useTextDecoderUnchecked(decoder, codeUnits);
    },
    Utf8Decoder__useTextDecoderUnchecked: function(decoder, codeUnits) {
      var t1, exception;
      try {
        t1 = decoder.decode(codeUnits);
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
      }
      return;
    },
    Utf8Decoder__unsafe: function(codeUnits) {
      var i,
        limit = codeUnits.length - 2;
      for (i = 0; i < limit; ++i)
        if (codeUnits[i] === 237)
          if ((codeUnits[i + 1] & 224) === 160)
            return true;
      return false;
    },
    Utf8Decoder__makeDecoder: function() {
      var t1, exception;
      try {
        t1 = new TextDecoder("utf-8", {fatal: true});
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
      }
      return;
    },
    _scanOneByteCharacters: function(units, from, endIndex) {
      var t1, i, unit;
      H.assertSubtype(units, "$isList", [P.int], "$asList");
      for (t1 = units.length, i = from; i < endIndex; ++i) {
        if (i < 0 || i >= t1)
          return H.ioore(units, i);
        unit = units[i];
        if ((unit & 127) !== unit)
          return i - from;
      }
      return endIndex - from;
    },
    Base64Codec__checkPadding: function(source, sourceIndex, sourceEnd, firstPadding, paddingCount, $length) {
      if (C.JSInt_methods.$mod($length, 4) !== 0)
        throw H.wrapException(P.FormatException$("Invalid base64 padding, padded length must be multiple of four, is " + $length, source, sourceEnd));
      if (firstPadding + paddingCount !== $length)
        throw H.wrapException(P.FormatException$("Invalid base64 padding, '=' not at the end", source, sourceIndex));
      if (paddingCount > 2)
        throw H.wrapException(P.FormatException$("Invalid base64 padding, more than two '=' characters", source, sourceIndex));
    },
    JsonUnsupportedObjectError$: function(unsupportedObject, cause, partialResult) {
      return new P.JsonUnsupportedObjectError(unsupportedObject, cause);
    },
    _defaultToEncodable: function(object) {
      return object.toJson$0();
    },
    _JsonStringStringifier_stringify: function(object, toEncodable, indent) {
      var t1,
        output = new P.StringBuffer(""),
        stringifier = new P._JsonStringStringifier(output, [], P.convert___defaultToEncodable$closure());
      stringifier.writeObject$1(object);
      t1 = output._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _JsonMap: function _JsonMap(t0, t1) {
      this._original = t0;
      this._processed = t1;
      this._data = null;
    },
    _JsonMap_addAll_closure: function _JsonMap_addAll_closure(t0) {
      this.$this = t0;
    },
    _JsonMapKeyIterable: function _JsonMapKeyIterable(t0) {
      this._convert$_parent = t0;
    },
    Base64Codec: function Base64Codec() {
    },
    Base64Encoder: function Base64Encoder() {
    },
    Codec: function Codec() {
    },
    Converter: function Converter() {
    },
    Encoding: function Encoding() {
    },
    JsonUnsupportedObjectError: function JsonUnsupportedObjectError(t0, t1) {
      this.unsupportedObject = t0;
      this.cause = t1;
    },
    JsonCyclicError: function JsonCyclicError(t0, t1) {
      this.unsupportedObject = t0;
      this.cause = t1;
    },
    JsonCodec: function JsonCodec() {
    },
    JsonEncoder: function JsonEncoder(t0) {
      this._toEncodable = t0;
    },
    JsonDecoder: function JsonDecoder(t0) {
      this._reviver = t0;
    },
    _JsonStringifier: function _JsonStringifier() {
    },
    _JsonStringifier_writeMap_closure: function _JsonStringifier_writeMap_closure(t0, t1) {
      this._box_0 = t0;
      this.keyValueList = t1;
    },
    _JsonStringStringifier: function _JsonStringStringifier(t0, t1, t2) {
      this._sink = t0;
      this._seen = t1;
      this._toEncodable = t2;
    },
    Utf8Codec: function Utf8Codec() {
    },
    Utf8Encoder: function Utf8Encoder() {
    },
    _Utf8Encoder: function _Utf8Encoder(t0) {
      this._bufferIndex = 0;
      this._convert$_buffer = t0;
    },
    Utf8Decoder: function Utf8Decoder(t0) {
      this._allowMalformed = t0;
    },
    _Utf8Decoder: function _Utf8Decoder(t0, t1) {
      var _ = this;
      _._allowMalformed = t0;
      _._stringSink = t1;
      _._isFirstCharacter = true;
      _._extraUnits = _._expectedUnits = _._convert$_value = 0;
    },
    int_parse: function(source, onError, radix) {
      var value;
      H.functionTypeCheck(onError, {func: 1, ret: P.int, args: [P.String]});
      value = H.Primitives_parseInt(source, radix);
      if (value != null)
        return value;
      if (onError != null)
        return onError.call$1(source);
      throw H.wrapException(P.FormatException$(source, null, null));
    },
    double_parse: function(source) {
      var value = H.Primitives_parseDouble(source);
      if (value != null)
        return value;
      throw H.wrapException(P.FormatException$("Invalid double", source, null));
    },
    Error__objectToString: function(object) {
      if (object instanceof H.Closure)
        return object.toString$0(0);
      return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
    },
    List_List$filled: function($length, fill, $E) {
      var result, i;
      H.assertSubtypeOfRuntimeType(fill, $E);
      result = J.JSArray_JSArray$fixed($length, $E);
      if ($length !== 0 && true)
        for (i = 0; i < result.length; ++i)
          C.JSArray_methods.$indexSet(result, i, fill);
      return H.assertSubtype(result, "$isList", [$E], "$asList");
    },
    List_List$from: function(elements, growable, $E) {
      var t1,
        list = H.setRuntimeTypeInfo([], [$E]);
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        C.JSArray_methods.add$1(list, H.assertSubtypeOfRuntimeType(t1.get$current(), $E));
      return list;
    },
    String_String$fromCharCodes: function(charCodes, start, end) {
      var len,
        t1 = P.int;
      H.assertSubtype(charCodes, "$isIterable", [t1], "$asIterable");
      if (typeof charCodes === "object" && charCodes !== null && charCodes.constructor === Array) {
        H.assertSubtype(charCodes, "$isJSArray", [t1], "$asJSArray");
        len = charCodes.length;
        end = P.RangeError_checkValidRange(start, end, len);
        return H.Primitives_stringFromCharCodes(start > 0 || end < len ? C.JSArray_methods.sublist$2(charCodes, start, end) : charCodes);
      }
      if (!!J.getInterceptor$(charCodes).$isNativeUint8List)
        return H.Primitives_stringFromNativeUint8List(charCodes, start, P.RangeError_checkValidRange(start, end, charCodes.length));
      return P.String__stringFromIterable(charCodes, start, end);
    },
    String__stringFromIterable: function(charCodes, start, end) {
      var t1, it, i, list, _null = null;
      H.assertSubtype(charCodes, "$isIterable", [P.int], "$asIterable");
      if (start < 0)
        throw H.wrapException(P.RangeError$range(start, 0, charCodes.length, _null, _null));
      t1 = end == null;
      if (!t1 && end < start)
        throw H.wrapException(P.RangeError$range(end, start, charCodes.length, _null, _null));
      it = J.get$iterator$ax(charCodes);
      for (i = 0; i < start; ++i)
        if (!it.moveNext$0())
          throw H.wrapException(P.RangeError$range(start, 0, i, _null, _null));
      list = [];
      if (t1)
        for (; it.moveNext$0();)
          list.push(it.get$current());
      else
        for (i = start; i < end; ++i) {
          if (!it.moveNext$0())
            throw H.wrapException(P.RangeError$range(end, start, i, _null, _null));
          list.push(it.get$current());
        }
      return H.Primitives_stringFromCharCodes(list);
    },
    RegExp_RegExp: function(source) {
      return new H.JSSyntaxRegExp(source, H.JSSyntaxRegExp_makeNative(source, false, true, false));
    },
    StringBuffer__writeAll: function(string, objects, separator) {
      var iterator = J.get$iterator$ax(objects);
      if (!iterator.moveNext$0())
        return string;
      if (separator.length === 0) {
        do
          string += H.S(iterator.get$current());
        while (iterator.moveNext$0());
      } else {
        string += H.S(iterator.get$current());
        for (; iterator.moveNext$0();)
          string = string + separator + H.S(iterator.get$current());
      }
      return string;
    },
    _Uri__uriEncode: function(canonicalTable, text, encoding, spaceToPlus) {
      var t1, bytes, i, t2, byte, t3,
        _s16_ = "0123456789ABCDEF";
      H.assertSubtype(canonicalTable, "$isList", [P.int], "$asList");
      if (encoding === C.C_Utf8Codec) {
        t1 = $.$get$_Uri__needsNoEncoding()._nativeRegExp;
        t1 = t1.test(text);
      } else
        t1 = false;
      if (t1)
        return text;
      H.assertSubtypeOfRuntimeType(text, H.getRuntimeTypeArgument(encoding, "Codec", 0));
      bytes = encoding.get$encoder().convert$1(text);
      for (t1 = bytes.length, i = 0, t2 = ""; i < t1; ++i) {
        byte = bytes[i];
        if (byte < 128) {
          t3 = byte >>> 4;
          if (t3 >= 8)
            return H.ioore(canonicalTable, t3);
          t3 = (canonicalTable[t3] & 1 << (byte & 15)) !== 0;
        } else
          t3 = false;
        if (t3)
          t2 += H.Primitives_stringFromCharCode(byte);
        else
          t2 = spaceToPlus && byte === 32 ? t2 + "+" : t2 + "%" + _s16_[byte >>> 4 & 15] + _s16_[byte & 15];
      }
      return t2.charCodeAt(0) == 0 ? t2 : t2;
    },
    StackTrace_current: function() {
      var stackTrace, exception;
      if (H.boolConversionCheck($.$get$_hasErrorStackProperty()))
        return H.getTraceFromException(new Error());
      try {
        throw H.wrapException("");
      } catch (exception) {
        H.unwrapException(exception);
        stackTrace = H.getTraceFromException(exception);
        return stackTrace;
      }
    },
    Comparable_compare: function(a, b) {
      return J.compareTo$1$ns(H.numberOrStringSuperNativeTypeCheck(a, "$isComparable"), H.numberOrStringSuperNativeTypeCheck(b, "$isComparable"));
    },
    Duration$: function(microseconds, milliseconds, seconds) {
      return new P.Duration(1000000 * seconds + 1000 * milliseconds + microseconds);
    },
    Error_safeToString: function(object) {
      if (typeof object === "number" || typeof object === "boolean" || null == object)
        return J.toString$0$(object);
      if (typeof object === "string")
        return JSON.stringify(object);
      return P.Error__objectToString(object);
    },
    AssertionError$: function(message) {
      return new P.AssertionError(message);
    },
    ArgumentError$: function(message) {
      return new P.ArgumentError(false, null, null, message);
    },
    ArgumentError$value: function(value, $name, message) {
      return new P.ArgumentError(true, value, $name, message);
    },
    ArgumentError$notNull: function($name) {
      return new P.ArgumentError(false, null, $name, "Must not be null");
    },
    RangeError$value: function(value, $name) {
      return new P.RangeError(null, null, true, value, $name, "Value not in range");
    },
    RangeError$range: function(invalidValue, minValue, maxValue, $name, message) {
      return new P.RangeError(minValue, maxValue, true, invalidValue, $name, "Invalid value");
    },
    RangeError_checkValueInInterval: function(value, minValue, maxValue, $name) {
      if (value < minValue || value > maxValue)
        throw H.wrapException(P.RangeError$range(value, minValue, maxValue, $name, null));
    },
    RangeError_checkValidIndex: function(index, indexable, $name, $length) {
      if ($length == null)
        $length = indexable.get$length(indexable);
      if (0 > index || index >= $length)
        throw H.wrapException(P.IndexError$(index, indexable, $name == null ? "index" : $name, null, $length));
    },
    RangeError_checkValidRange: function(start, end, $length) {
      if (0 > start || start > $length)
        throw H.wrapException(P.RangeError$range(start, 0, $length, "start", null));
      if (end != null) {
        if (start > end || end > $length)
          throw H.wrapException(P.RangeError$range(end, start, $length, "end", null));
        return end;
      }
      return $length;
    },
    RangeError_checkNotNegative: function(value, $name) {
      if (typeof value !== "number")
        return value.$lt();
      if (value < 0)
        throw H.wrapException(P.RangeError$range(value, 0, null, $name, null));
    },
    IndexError$: function(invalidValue, indexable, $name, message, $length) {
      var t1 = H.intTypeCheck($length == null ? J.get$length$asx(indexable) : $length);
      return new P.IndexError(t1, true, invalidValue, $name, "Index out of range");
    },
    UnsupportedError$: function(message) {
      return new P.UnsupportedError(message);
    },
    UnimplementedError$: function(message) {
      return new P.UnimplementedError(message);
    },
    StateError$: function(message) {
      return new P.StateError(message);
    },
    ConcurrentModificationError$: function(modifiedObject) {
      return new P.ConcurrentModificationError(modifiedObject);
    },
    Exception_Exception: function(message) {
      return new P._Exception(message);
    },
    FormatException$: function(message, source, offset) {
      return new P.FormatException(message, source, offset);
    },
    List_List$generate: function($length, generator, growable, $E) {
      var result, t1, i;
      H.functionTypeCheck(generator, {func: 1, ret: $E, args: [P.int]});
      if (growable) {
        result = H.setRuntimeTypeInfo([], [$E]);
        C.JSArray_methods.set$length(result, $length);
      } else {
        t1 = new Array($length);
        t1.fixed$length = Array;
        result = H.setRuntimeTypeInfo(t1, [$E]);
      }
      for (i = 0; i < $length; ++i)
        C.JSArray_methods.$indexSet(result, i, generator.call$1(i));
      return result;
    },
    Stopwatch$: function() {
      if ($.Stopwatch__frequency == null) {
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      }
      return new P.Stopwatch();
    },
    Uri_parse: function(uri) {
      var delta, t1, indices, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, isSimple, scheme, t2, schemeAuth, queryStart0, pathStart0, _null = null,
        end = uri.length;
      if (end >= 5) {
        delta = ((J._codeUnitAt$1$s(uri, 4) ^ 58) * 3 | C.JSString_methods._codeUnitAt$1(uri, 0) ^ 100 | C.JSString_methods._codeUnitAt$1(uri, 1) ^ 97 | C.JSString_methods._codeUnitAt$1(uri, 2) ^ 116 | C.JSString_methods._codeUnitAt$1(uri, 3) ^ 97) >>> 0;
        if (delta === 0)
          return P.UriData__parse(end < end ? C.JSString_methods.substring$2(uri, 0, end) : uri, 5, _null).get$uri();
        else if (delta === 32)
          return P.UriData__parse(C.JSString_methods.substring$2(uri, 5, end), 0, _null).get$uri();
      }
      t1 = new Array(8);
      t1.fixed$length = Array;
      indices = H.setRuntimeTypeInfo(t1, [P.int]);
      C.JSArray_methods.$indexSet(indices, 0, 0);
      C.JSArray_methods.$indexSet(indices, 1, -1);
      C.JSArray_methods.$indexSet(indices, 2, -1);
      C.JSArray_methods.$indexSet(indices, 7, -1);
      C.JSArray_methods.$indexSet(indices, 3, 0);
      C.JSArray_methods.$indexSet(indices, 4, 0);
      C.JSArray_methods.$indexSet(indices, 5, end);
      C.JSArray_methods.$indexSet(indices, 6, end);
      if (P._scan(uri, 0, end, 0, indices) >= 14)
        C.JSArray_methods.$indexSet(indices, 7, end);
      schemeEnd = indices[1];
      if (typeof schemeEnd !== "number")
        return schemeEnd.$ge();
      if (schemeEnd >= 0)
        if (P._scan(uri, 0, schemeEnd, 20, indices) === 20)
          indices[7] = schemeEnd;
      t1 = indices[2];
      if (typeof t1 !== "number")
        return t1.$add();
      hostStart = t1 + 1;
      portStart = indices[3];
      pathStart = indices[4];
      queryStart = indices[5];
      fragmentStart = indices[6];
      if (typeof fragmentStart !== "number")
        return fragmentStart.$lt();
      if (typeof queryStart !== "number")
        return H.iae(queryStart);
      if (fragmentStart < queryStart)
        queryStart = fragmentStart;
      if (typeof pathStart !== "number")
        return pathStart.$lt();
      if (pathStart < hostStart)
        pathStart = queryStart;
      else if (pathStart <= schemeEnd)
        pathStart = schemeEnd + 1;
      if (typeof portStart !== "number")
        return portStart.$lt();
      if (portStart < hostStart)
        portStart = pathStart;
      H.assertHelper(hostStart === 0 || schemeEnd <= hostStart);
      H.assertHelper(hostStart <= portStart);
      H.assertHelper(schemeEnd <= pathStart);
      H.assertHelper(portStart <= pathStart);
      H.assertHelper(pathStart <= queryStart);
      H.assertHelper(queryStart <= fragmentStart);
      t1 = indices[7];
      if (typeof t1 !== "number")
        return t1.$lt();
      isSimple = t1 < 0;
      if (isSimple)
        if (hostStart > schemeEnd + 3) {
          scheme = _null;
          isSimple = false;
        } else {
          t1 = portStart > 0;
          if (t1 && portStart + 1 === pathStart) {
            scheme = _null;
            isSimple = false;
          } else {
            if (!(queryStart < end && queryStart === pathStart + 2 && J.startsWith$2$s(uri, "..", pathStart)))
              t2 = queryStart > pathStart + 2 && J.startsWith$2$s(uri, "/..", queryStart - 3);
            else
              t2 = true;
            if (t2) {
              scheme = _null;
              isSimple = false;
            } else {
              if (schemeEnd === 4)
                if (J.startsWith$2$s(uri, "file", 0)) {
                  if (hostStart <= 0) {
                    if (!C.JSString_methods.startsWith$2(uri, "/", pathStart)) {
                      schemeAuth = "file:///";
                      delta = 3;
                    } else {
                      schemeAuth = "file://";
                      delta = 2;
                    }
                    uri = schemeAuth + C.JSString_methods.substring$2(uri, pathStart, end);
                    schemeEnd -= 0;
                    t1 = delta - 0;
                    queryStart += t1;
                    fragmentStart += t1;
                    end = uri.length;
                    hostStart = 7;
                    portStart = 7;
                    pathStart = 7;
                  } else if (pathStart === queryStart) {
                    queryStart0 = queryStart + 1;
                    ++fragmentStart;
                    uri = C.JSString_methods.replaceRange$3(uri, pathStart, queryStart, "/");
                    ++end;
                    queryStart = queryStart0;
                  }
                  scheme = "file";
                } else if (C.JSString_methods.startsWith$2(uri, "http", 0)) {
                  if (t1 && portStart + 3 === pathStart && C.JSString_methods.startsWith$2(uri, "80", portStart + 1)) {
                    pathStart0 = pathStart - 3;
                    queryStart -= 3;
                    fragmentStart -= 3;
                    uri = C.JSString_methods.replaceRange$3(uri, portStart, pathStart, "");
                    end -= 3;
                    pathStart = pathStart0;
                  }
                  scheme = "http";
                } else
                  scheme = _null;
              else if (schemeEnd === 5 && J.startsWith$2$s(uri, "https", 0)) {
                if (t1 && portStart + 4 === pathStart && J.startsWith$2$s(uri, "443", portStart + 1)) {
                  pathStart0 = pathStart - 4;
                  queryStart -= 4;
                  fragmentStart -= 4;
                  uri = J.replaceRange$3$s(uri, portStart, pathStart, "");
                  end -= 3;
                  pathStart = pathStart0;
                }
                scheme = "https";
              } else
                scheme = _null;
              isSimple = true;
            }
          }
        }
      else
        scheme = _null;
      if (isSimple) {
        t1 = uri.length;
        if (end < t1) {
          uri = J.substring$2$s(uri, 0, end);
          schemeEnd -= 0;
          hostStart -= 0;
          portStart -= 0;
          pathStart -= 0;
          queryStart -= 0;
          fragmentStart -= 0;
        }
        return new P._SimpleUri(uri, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme);
      }
      return P._Uri__Uri$notSimple(uri, 0, end, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme);
    },
    Uri__parseIPv4Address: function(host, start, end) {
      var t1, i, partStart, partIndex, char, part, partIndex0, _null = null,
        _s43_ = "IPv4 address should contain exactly 4 parts",
        _s37_ = "each part must be in the range 0..255",
        error = new P.Uri__parseIPv4Address_error(host),
        result = new Uint8Array(4);
      for (t1 = result.length, i = start, partStart = i, partIndex = 0; i < end; ++i) {
        char = C.JSString_methods.codeUnitAt$1(host, i);
        if (char !== 46) {
          if ((char ^ 48) > 9)
            error.call$2("invalid character", i);
        } else {
          if (partIndex === 3)
            error.call$2(_s43_, i);
          part = P.int_parse(C.JSString_methods.substring$2(host, partStart, i), _null, _null);
          if (typeof part !== "number")
            return part.$gt();
          if (part > 255)
            error.call$2(_s37_, partStart);
          partIndex0 = partIndex + 1;
          if (partIndex >= t1)
            return H.ioore(result, partIndex);
          result[partIndex] = part;
          partStart = i + 1;
          partIndex = partIndex0;
        }
      }
      if (partIndex !== 3)
        error.call$2(_s43_, end);
      part = P.int_parse(C.JSString_methods.substring$2(host, partStart, end), _null, _null);
      if (typeof part !== "number")
        return part.$gt();
      if (part > 255)
        error.call$2(_s37_, partStart);
      if (partIndex >= t1)
        return H.ioore(result, partIndex);
      result[partIndex] = part;
      return result;
    },
    Uri_parseIPv6Address: function(host, start, end) {
      var parts, i, partStart, wildcardSeen, seenDot, char, atEnd, t1, last, bytes, t2, wildCardLength, index, value, j, t3,
        error = new P.Uri_parseIPv6Address_error(host),
        parseHex = new P.Uri_parseIPv6Address_parseHex(error, host);
      if (host.length < 2)
        error.call$1("address is too short");
      parts = H.setRuntimeTypeInfo([], [P.int]);
      for (i = start, partStart = i, wildcardSeen = false, seenDot = false; i < end; ++i) {
        char = C.JSString_methods.codeUnitAt$1(host, i);
        if (char === 58) {
          if (i === start) {
            ++i;
            if (C.JSString_methods.codeUnitAt$1(host, i) !== 58)
              error.call$2("invalid start colon.", i);
            partStart = i;
          }
          if (i === partStart) {
            if (wildcardSeen)
              error.call$2("only one wildcard `::` is allowed", i);
            C.JSArray_methods.add$1(parts, -1);
            wildcardSeen = true;
          } else
            C.JSArray_methods.add$1(parts, parseHex.call$2(partStart, i));
          partStart = i + 1;
        } else if (char === 46)
          seenDot = true;
      }
      if (parts.length === 0)
        error.call$1("too few parts");
      atEnd = partStart === end;
      t1 = C.JSArray_methods.get$last(parts);
      if (atEnd && t1 !== -1)
        error.call$2("expected a part after last `:`", end);
      if (!atEnd)
        if (!seenDot)
          C.JSArray_methods.add$1(parts, parseHex.call$2(partStart, end));
        else {
          last = P.Uri__parseIPv4Address(host, partStart, end);
          C.JSArray_methods.add$1(parts, (last[0] << 8 | last[1]) >>> 0);
          C.JSArray_methods.add$1(parts, (last[2] << 8 | last[3]) >>> 0);
        }
      if (wildcardSeen) {
        if (parts.length > 7)
          error.call$1("an address with a wildcard must have less than 7 parts");
      } else if (parts.length !== 8)
        error.call$1("an address without a wildcard must contain exactly 8 parts");
      bytes = new Uint8Array(16);
      for (t1 = parts.length, t2 = bytes.length, wildCardLength = 9 - t1, i = 0, index = 0; i < t1; ++i) {
        value = parts[i];
        if (value === -1)
          for (j = 0; j < wildCardLength; ++j) {
            if (index < 0 || index >= t2)
              return H.ioore(bytes, index);
            bytes[index] = 0;
            t3 = index + 1;
            if (t3 >= t2)
              return H.ioore(bytes, t3);
            bytes[t3] = 0;
            index += 2;
          }
        else {
          t3 = C.JSInt_methods._shrOtherPositive$1(value, 8);
          if (index < 0 || index >= t2)
            return H.ioore(bytes, index);
          bytes[index] = t3;
          t3 = index + 1;
          if (t3 >= t2)
            return H.ioore(bytes, t3);
          bytes[t3] = value & 255;
          index += 2;
        }
      }
      return bytes;
    },
    _Uri__Uri$notSimple: function(uri, start, end, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme) {
      var userInfoStart, userInfo, host, t1, port, path, query, _null = null;
      if (scheme == null)
        if (schemeEnd > start)
          scheme = P._Uri__makeScheme(uri, start, schemeEnd);
        else {
          if (schemeEnd === start)
            P._Uri__fail(uri, start, "Invalid empty scheme");
          scheme = "";
        }
      if (hostStart > start) {
        userInfoStart = schemeEnd + 3;
        userInfo = userInfoStart < hostStart ? P._Uri__makeUserInfo(uri, userInfoStart, hostStart - 1) : "";
        host = P._Uri__makeHost(uri, hostStart, portStart, false);
        t1 = portStart + 1;
        port = t1 < pathStart ? P._Uri__makePort(P.int_parse(J.substring$2$s(uri, t1, pathStart), new P._Uri__Uri$notSimple_closure(uri, portStart), _null), scheme) : _null;
      } else {
        port = _null;
        host = port;
        userInfo = "";
      }
      path = P._Uri__makePath(uri, pathStart, queryStart, _null, scheme, host != null);
      query = queryStart < fragmentStart ? P._Uri__makeQuery(uri, queryStart + 1, fragmentStart, _null) : _null;
      return new P._Uri(scheme, userInfo, host, port, path, query, fragmentStart < end ? P._Uri__makeFragment(uri, fragmentStart + 1, end) : _null);
    },
    _Uri__defaultPort: function(scheme) {
      if (scheme === "http")
        return 80;
      if (scheme === "https")
        return 443;
      return 0;
    },
    _Uri__fail: function(uri, index, message) {
      throw H.wrapException(P.FormatException$(message, uri, index));
    },
    _Uri__makePort: function(port, scheme) {
      if (port != null && port === P._Uri__defaultPort(scheme))
        return;
      return port;
    },
    _Uri__makeHost: function(host, start, end, strictIPv6) {
      var t1, i;
      if (host == null)
        return;
      if (start === end)
        return "";
      if (C.JSString_methods.codeUnitAt$1(host, start) === 91) {
        t1 = end - 1;
        if (C.JSString_methods.codeUnitAt$1(host, t1) !== 93)
          P._Uri__fail(host, start, "Missing end `]` to match `[` in host");
        P.Uri_parseIPv6Address(host, start + 1, t1);
        return C.JSString_methods.substring$2(host, start, end).toLowerCase();
      }
      for (i = start; i < end; ++i)
        if (C.JSString_methods.codeUnitAt$1(host, i) === 58) {
          P.Uri_parseIPv6Address(host, start, end);
          return "[" + host + "]";
        }
      return P._Uri__normalizeRegName(host, start, end);
    },
    _Uri__normalizeRegName: function(host, start, end) {
      var index, sectionStart, buffer, isNormalized, char, replacement, t1, slice, t2, sourceLength, tail;
      for (index = start, sectionStart = index, buffer = null, isNormalized = true; index < end;) {
        char = C.JSString_methods.codeUnitAt$1(host, index);
        if (char === 37) {
          replacement = P._Uri__normalizeEscape(host, index, true);
          t1 = replacement == null;
          if (t1 && isNormalized) {
            index += 3;
            continue;
          }
          if (buffer == null)
            buffer = new P.StringBuffer("");
          slice = C.JSString_methods.substring$2(host, sectionStart, index);
          t2 = buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
          if (t1) {
            replacement = C.JSString_methods.substring$2(host, index, index + 3);
            sourceLength = 3;
          } else if (replacement === "%") {
            replacement = "%25";
            sourceLength = 1;
          } else
            sourceLength = 3;
          buffer._contents = t2 + replacement;
          index += sourceLength;
          sectionStart = index;
          isNormalized = true;
        } else {
          if (char < 127) {
            t1 = char >>> 4;
            if (t1 >= 8)
              return H.ioore(C.List_qNA, t1);
            t1 = (C.List_qNA[t1] & 1 << (char & 15)) !== 0;
          } else
            t1 = false;
          if (t1) {
            if (isNormalized && 65 <= char && 90 >= char) {
              if (buffer == null)
                buffer = new P.StringBuffer("");
              if (sectionStart < index) {
                buffer._contents += C.JSString_methods.substring$2(host, sectionStart, index);
                sectionStart = index;
              }
              isNormalized = false;
            }
            ++index;
          } else {
            if (char <= 93) {
              t1 = char >>> 4;
              if (t1 >= 8)
                return H.ioore(C.List_2Vk, t1);
              t1 = (C.List_2Vk[t1] & 1 << (char & 15)) !== 0;
            } else
              t1 = false;
            if (t1)
              P._Uri__fail(host, index, "Invalid character");
            else {
              if ((char & 64512) === 55296 && index + 1 < end) {
                tail = C.JSString_methods.codeUnitAt$1(host, index + 1);
                if ((tail & 64512) === 56320) {
                  char = 65536 | (char & 1023) << 10 | tail & 1023;
                  sourceLength = 2;
                } else
                  sourceLength = 1;
              } else
                sourceLength = 1;
              if (buffer == null)
                buffer = new P.StringBuffer("");
              slice = C.JSString_methods.substring$2(host, sectionStart, index);
              buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
              buffer._contents += P._Uri__escapeChar(char);
              index += sourceLength;
              sectionStart = index;
            }
          }
        }
      }
      if (buffer == null)
        return C.JSString_methods.substring$2(host, start, end);
      if (sectionStart < end) {
        slice = C.JSString_methods.substring$2(host, sectionStart, end);
        buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
      }
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _Uri__makeScheme: function(scheme, start, end) {
      var i, containsUpperCase, codeUnit, t1;
      if (start === end)
        return "";
      if (!P._Uri__isAlphabeticCharacter(J.getInterceptor$s(scheme)._codeUnitAt$1(scheme, start)))
        P._Uri__fail(scheme, start, "Scheme not starting with alphabetic character");
      for (i = start, containsUpperCase = false; i < end; ++i) {
        codeUnit = C.JSString_methods._codeUnitAt$1(scheme, i);
        if (codeUnit < 128) {
          t1 = codeUnit >>> 4;
          if (t1 >= 8)
            return H.ioore(C.List_JYB, t1);
          t1 = (C.List_JYB[t1] & 1 << (codeUnit & 15)) !== 0;
        } else
          t1 = false;
        if (!t1)
          P._Uri__fail(scheme, i, "Illegal scheme character");
        if (65 <= codeUnit && codeUnit <= 90)
          containsUpperCase = true;
      }
      scheme = C.JSString_methods.substring$2(scheme, start, end);
      return P._Uri__canonicalizeScheme(containsUpperCase ? scheme.toLowerCase() : scheme);
    },
    _Uri__canonicalizeScheme: function(scheme) {
      if (scheme === "http")
        return "http";
      if (scheme === "file")
        return "file";
      if (scheme === "https")
        return "https";
      if (scheme === "package")
        return "package";
      return scheme;
    },
    _Uri__makeUserInfo: function(userInfo, start, end) {
      if (userInfo == null)
        return "";
      return P._Uri__normalizeOrSubstring(userInfo, start, end, C.List_gRj, false);
    },
    _Uri__makePath: function(path, start, end, pathSegments, scheme, hasAuthority) {
      var result,
        isFile = scheme === "file",
        ensureLeadingSlash = isFile || hasAuthority,
        t1 = path == null;
      if (t1 && true)
        return isFile ? "/" : "";
      result = !t1 ? P._Uri__normalizeOrSubstring(path, start, end, C.List_qg4, true) : C.JSNull_methods.map$1$1(pathSegments, new P._Uri__makePath_closure(), P.String).join$1(0, "/");
      if (result.length === 0) {
        if (isFile)
          return "/";
      } else if (ensureLeadingSlash && !C.JSString_methods.startsWith$1(result, "/"))
        result = "/" + result;
      return P._Uri__normalizePath(result, scheme, hasAuthority);
    },
    _Uri__normalizePath: function(path, scheme, hasAuthority) {
      var t1 = scheme.length === 0;
      if (t1 && !hasAuthority && !C.JSString_methods.startsWith$1(path, "/"))
        return P._Uri__normalizeRelativePath(path, !t1 || hasAuthority);
      return P._Uri__removeDotSegments(path);
    },
    _Uri__makeQuery: function(query, start, end, queryParameters) {
      if (query != null)
        return P._Uri__normalizeOrSubstring(query, start, end, C.List_CVk, true);
      return;
    },
    _Uri__makeFragment: function(fragment, start, end) {
      if (fragment == null)
        return;
      return P._Uri__normalizeOrSubstring(fragment, start, end, C.List_CVk, true);
    },
    _Uri__normalizeEscape: function(source, index, lowerCase) {
      var t1, firstDigit, secondDigit, firstDigitValue, secondDigitValue, value;
      H.assertHelper(C.JSString_methods.codeUnitAt$1(source, index) === 37);
      t1 = index + 2;
      if (t1 >= source.length)
        return "%";
      firstDigit = C.JSString_methods.codeUnitAt$1(source, index + 1);
      secondDigit = C.JSString_methods.codeUnitAt$1(source, t1);
      firstDigitValue = H.hexDigitValue(firstDigit);
      secondDigitValue = H.hexDigitValue(secondDigit);
      if (firstDigitValue < 0 || secondDigitValue < 0)
        return "%";
      value = firstDigitValue * 16 + secondDigitValue;
      if (value < 127) {
        t1 = C.JSInt_methods._shrOtherPositive$1(value, 4);
        if (t1 >= 8)
          return H.ioore(C.List_nxB, t1);
        t1 = (C.List_nxB[t1] & 1 << (value & 15)) !== 0;
      } else
        t1 = false;
      if (t1)
        return H.Primitives_stringFromCharCode(lowerCase && 65 <= value && 90 >= value ? (value | 32) >>> 0 : value);
      if (firstDigit >= 97 || secondDigit >= 97)
        return C.JSString_methods.substring$2(source, index, index + 3).toUpperCase();
      return;
    },
    _Uri__escapeChar: function(char) {
      var t1, codeUnits, flag, encodedBytes, index, byte,
        _s16_ = "0123456789ABCDEF";
      H.assertHelper(char <= 1114111);
      if (char < 128) {
        t1 = new Array(3);
        t1.fixed$length = Array;
        codeUnits = H.setRuntimeTypeInfo(t1, [P.int]);
        C.JSArray_methods.$indexSet(codeUnits, 0, 37);
        C.JSArray_methods.$indexSet(codeUnits, 1, C.JSString_methods._codeUnitAt$1(_s16_, char >>> 4));
        C.JSArray_methods.$indexSet(codeUnits, 2, C.JSString_methods._codeUnitAt$1(_s16_, char & 15));
      } else {
        if (char > 2047)
          if (char > 65535) {
            flag = 240;
            encodedBytes = 4;
          } else {
            flag = 224;
            encodedBytes = 3;
          }
        else {
          flag = 192;
          encodedBytes = 2;
        }
        t1 = new Array(3 * encodedBytes);
        t1.fixed$length = Array;
        codeUnits = H.setRuntimeTypeInfo(t1, [P.int]);
        for (index = 0; --encodedBytes, encodedBytes >= 0; flag = 128) {
          byte = C.JSInt_methods._shrReceiverPositive$1(char, 6 * encodedBytes) & 63 | flag;
          C.JSArray_methods.$indexSet(codeUnits, index, 37);
          C.JSArray_methods.$indexSet(codeUnits, index + 1, C.JSString_methods._codeUnitAt$1(_s16_, byte >>> 4));
          C.JSArray_methods.$indexSet(codeUnits, index + 2, C.JSString_methods._codeUnitAt$1(_s16_, byte & 15));
          index += 3;
        }
      }
      return P.String_String$fromCharCodes(codeUnits, 0, null);
    },
    _Uri__normalizeOrSubstring: function(component, start, end, charTable, escapeDelimiters) {
      var t1 = P._Uri__normalize(component, start, end, H.assertSubtype(charTable, "$isList", [P.int], "$asList"), escapeDelimiters);
      return t1 == null ? C.JSString_methods.substring$2(component, start, end) : t1;
    },
    _Uri__normalize: function(component, start, end, charTable, escapeDelimiters) {
      var t1, index, sectionStart, buffer, char, t2, replacement, sourceLength, tail;
      H.assertSubtype(charTable, "$isList", [P.int], "$asList");
      for (t1 = !escapeDelimiters, index = start, sectionStart = index, buffer = null; index < end;) {
        char = C.JSString_methods.codeUnitAt$1(component, index);
        if (char < 127) {
          t2 = char >>> 4;
          if (t2 >= 8)
            return H.ioore(charTable, t2);
          t2 = (charTable[t2] & 1 << (char & 15)) !== 0;
        } else
          t2 = false;
        if (t2)
          ++index;
        else {
          if (char === 37) {
            replacement = P._Uri__normalizeEscape(component, index, false);
            if (replacement == null) {
              index += 3;
              continue;
            }
            if ("%" === replacement) {
              replacement = "%25";
              sourceLength = 1;
            } else
              sourceLength = 3;
          } else {
            if (t1)
              if (char <= 93) {
                t2 = char >>> 4;
                if (t2 >= 8)
                  return H.ioore(C.List_2Vk, t2);
                t2 = (C.List_2Vk[t2] & 1 << (char & 15)) !== 0;
              } else
                t2 = false;
            else
              t2 = false;
            if (t2) {
              P._Uri__fail(component, index, "Invalid character");
              replacement = null;
              sourceLength = null;
            } else {
              if ((char & 64512) === 55296) {
                t2 = index + 1;
                if (t2 < end) {
                  tail = C.JSString_methods.codeUnitAt$1(component, t2);
                  if ((tail & 64512) === 56320) {
                    char = 65536 | (char & 1023) << 10 | tail & 1023;
                    sourceLength = 2;
                  } else
                    sourceLength = 1;
                } else
                  sourceLength = 1;
              } else
                sourceLength = 1;
              replacement = P._Uri__escapeChar(char);
            }
          }
          if (buffer == null)
            buffer = new P.StringBuffer("");
          buffer._contents += C.JSString_methods.substring$2(component, sectionStart, index);
          buffer._contents += H.S(replacement);
          if (typeof sourceLength !== "number")
            return H.iae(sourceLength);
          index += sourceLength;
          sectionStart = index;
        }
      }
      if (buffer == null)
        return;
      if (sectionStart < end)
        buffer._contents += C.JSString_methods.substring$2(component, sectionStart, end);
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _Uri__mayContainDotSegments: function(path) {
      if (C.JSString_methods.startsWith$1(path, "."))
        return true;
      return C.JSString_methods.indexOf$1(path, "/.") !== -1;
    },
    _Uri__removeDotSegments: function(path) {
      var output, t1, t2, appendSlash, _i, segment, t3;
      if (!P._Uri__mayContainDotSegments(path))
        return path;
      H.assertHelper(path.length !== 0);
      output = H.setRuntimeTypeInfo([], [P.String]);
      for (t1 = path.split("/"), t2 = t1.length, appendSlash = false, _i = 0; _i < t2; ++_i) {
        segment = t1[_i];
        if (J.$eq$(segment, "..")) {
          t3 = output.length;
          if (t3 !== 0) {
            if (0 >= t3)
              return H.ioore(output, -1);
            output.pop();
            if (output.length === 0)
              C.JSArray_methods.add$1(output, "");
          }
          appendSlash = true;
        } else if ("." === segment)
          appendSlash = true;
        else {
          C.JSArray_methods.add$1(output, segment);
          appendSlash = false;
        }
      }
      if (appendSlash)
        C.JSArray_methods.add$1(output, "");
      return C.JSArray_methods.join$1(output, "/");
    },
    _Uri__normalizeRelativePath: function(path, allowScheme) {
      var output, t1, t2, appendSlash, _i, segment;
      H.assertHelper(!C.JSString_methods.startsWith$1(path, "/"));
      if (!P._Uri__mayContainDotSegments(path))
        return !allowScheme ? P._Uri__escapeScheme(path) : path;
      H.assertHelper(path.length !== 0);
      output = H.setRuntimeTypeInfo([], [P.String]);
      for (t1 = path.split("/"), t2 = t1.length, appendSlash = false, _i = 0; _i < t2; ++_i) {
        segment = t1[_i];
        if (".." === segment)
          if (output.length !== 0 && C.JSArray_methods.get$last(output) !== "..") {
            if (0 >= output.length)
              return H.ioore(output, -1);
            output.pop();
            appendSlash = true;
          } else {
            C.JSArray_methods.add$1(output, "..");
            appendSlash = false;
          }
        else if ("." === segment)
          appendSlash = true;
        else {
          C.JSArray_methods.add$1(output, segment);
          appendSlash = false;
        }
      }
      t1 = output.length;
      if (t1 !== 0)
        if (t1 === 1) {
          if (0 >= t1)
            return H.ioore(output, 0);
          t1 = output[0].length === 0;
        } else
          t1 = false;
      else
        t1 = true;
      if (t1)
        return "./";
      if (appendSlash || C.JSArray_methods.get$last(output) === "..")
        C.JSArray_methods.add$1(output, "");
      if (!allowScheme) {
        if (0 >= output.length)
          return H.ioore(output, 0);
        C.JSArray_methods.$indexSet(output, 0, P._Uri__escapeScheme(output[0]));
      }
      return C.JSArray_methods.join$1(output, "/");
    },
    _Uri__escapeScheme: function(path) {
      var i, char, t2,
        t1 = path.length;
      if (t1 >= 2 && P._Uri__isAlphabeticCharacter(J._codeUnitAt$1$s(path, 0)))
        for (i = 1; i < t1; ++i) {
          char = C.JSString_methods._codeUnitAt$1(path, i);
          if (char === 58)
            return C.JSString_methods.substring$2(path, 0, i) + "%3A" + C.JSString_methods.substring$1(path, i + 1);
          if (char <= 127) {
            t2 = char >>> 4;
            if (t2 >= 8)
              return H.ioore(C.List_JYB, t2);
            t2 = (C.List_JYB[t2] & 1 << (char & 15)) === 0;
          } else
            t2 = true;
          if (t2)
            break;
        }
      return path;
    },
    _Uri__isAlphabeticCharacter: function(codeUnit) {
      var lowerCase = codeUnit | 32;
      return 97 <= lowerCase && lowerCase <= 122;
    },
    UriData__parse: function(text, start, sourceUri) {
      var indices, t1, i, slashIndex, char, equalsIndex, lastSeparator, t2, data,
        _s17_ = "Invalid MIME type";
      H.assertHelper(start === 0 || start === 5);
      H.assertHelper(start === 5 === C.JSString_methods.startsWith$1(text, "data:"));
      indices = H.setRuntimeTypeInfo([start - 1], [P.int]);
      for (t1 = text.length, i = start, slashIndex = -1, char = null; i < t1; ++i) {
        char = C.JSString_methods._codeUnitAt$1(text, i);
        if (char === 44 || char === 59)
          break;
        if (char === 47) {
          if (slashIndex < 0) {
            slashIndex = i;
            continue;
          }
          throw H.wrapException(P.FormatException$(_s17_, text, i));
        }
      }
      if (slashIndex < 0 && i > start)
        throw H.wrapException(P.FormatException$(_s17_, text, i));
      for (; char !== 44;) {
        C.JSArray_methods.add$1(indices, i);
        ++i;
        for (equalsIndex = -1; i < t1; ++i) {
          char = C.JSString_methods._codeUnitAt$1(text, i);
          if (char === 61) {
            if (equalsIndex < 0)
              equalsIndex = i;
          } else if (char === 59 || char === 44)
            break;
        }
        if (equalsIndex >= 0)
          C.JSArray_methods.add$1(indices, equalsIndex);
        else {
          lastSeparator = C.JSArray_methods.get$last(indices);
          if (char !== 44 || i !== lastSeparator + 7 || !C.JSString_methods.startsWith$2(text, "base64", lastSeparator + 1))
            throw H.wrapException(P.FormatException$("Expecting '='", text, i));
          break;
        }
      }
      C.JSArray_methods.add$1(indices, i);
      t2 = i + 1;
      if ((indices.length & 1) === 1)
        text = C.C_Base64Codec.normalize$3(text, t2, t1);
      else {
        data = P._Uri__normalize(text, t2, t1, C.List_CVk, true);
        if (data != null)
          text = C.JSString_methods.replaceRange$3(text, t2, t1, data);
      }
      return new P.UriData(text, indices, sourceUri);
    },
    _createTables: function() {
      var _s77_ = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=",
        _s1_ = ".", _s1_0 = ":", _s1_1 = "/", _s1_2 = "?", _s1_3 = "#",
        tables = P.List_List$generate(22, new P._createTables_closure(), true, P.Uint8List),
        t1 = new P._createTables_build(tables),
        t2 = new P._createTables_setChars(),
        t3 = new P._createTables_setRange(),
        b = H.interceptedTypeCheck(t1.call$2(0, 225), "$isUint8List");
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, _s1_, 14);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 3);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(14, 225), "$isUint8List");
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, _s1_, 15);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(15, 225), "$isUint8List");
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, "%", 225);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 9);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(1, 225), "$isUint8List");
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 10);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(2, 235), "$isUint8List");
      t2.call$3(b, _s77_, 139);
      t2.call$3(b, _s1_1, 131);
      t2.call$3(b, _s1_, 146);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(3, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 68);
      t2.call$3(b, _s1_, 18);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(4, 229), "$isUint8List");
      t2.call$3(b, _s77_, 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, _s1_0, 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "[", 232);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(5, 229), "$isUint8List");
      t2.call$3(b, _s77_, 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, _s1_0, 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(6, 231), "$isUint8List");
      t3.call$3(b, "19", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(7, 231), "$isUint8List");
      t3.call$3(b, "09", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      t2.call$3(H.interceptedTypeCheck(t1.call$2(8, 8), "$isUint8List"), "]", 5);
      b = H.interceptedTypeCheck(t1.call$2(9, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 16);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(16, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 17);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(17, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 9);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(10, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 18);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(18, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 19);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(19, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(11, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 10);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(12, 236), "$isUint8List");
      t2.call$3(b, _s77_, 12);
      t2.call$3(b, _s1_2, 12);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(13, 237), "$isUint8List");
      t2.call$3(b, _s77_, 13);
      t2.call$3(b, _s1_2, 13);
      t3.call$3(H.interceptedTypeCheck(t1.call$2(20, 245), "$isUint8List"), "az", 21);
      b = H.interceptedTypeCheck(t1.call$2(21, 245), "$isUint8List");
      t3.call$3(b, "az", 21);
      t3.call$3(b, "09", 21);
      t2.call$3(b, "+-.", 21);
      return tables;
    },
    _scan: function(uri, start, end, state, indices) {
      var tables, t1, i, table, char, transition;
      H.assertSubtype(indices, "$isList", [P.int], "$asList");
      tables = $.$get$_scannerTables();
      H.assertHelper(end <= uri.length);
      for (t1 = J.getInterceptor$s(uri), i = start; i < end; ++i) {
        if (state < 0 || state >= tables.length)
          return H.ioore(tables, state);
        table = tables[state];
        char = t1._codeUnitAt$1(uri, i) ^ 96;
        if (char > 95)
          char = 31;
        if (char >= table.length)
          return H.ioore(table, char);
        transition = table[char];
        state = transition & 31;
        C.JSArray_methods.$indexSet(indices, transition >>> 5, i);
      }
      return state;
    },
    bool: function bool() {
    },
    Comparable: function Comparable() {
    },
    double: function double() {
    },
    Duration: function Duration(t0) {
      this._duration = t0;
    },
    Duration_toString_sixDigits: function Duration_toString_sixDigits() {
    },
    Duration_toString_twoDigits: function Duration_toString_twoDigits() {
    },
    Error: function Error() {
    },
    AssertionError: function AssertionError(t0) {
      this.message = t0;
    },
    NullThrownError: function NullThrownError() {
    },
    ArgumentError: function ArgumentError(t0, t1, t2, t3) {
      var _ = this;
      _._hasValue = t0;
      _.invalidValue = t1;
      _.name = t2;
      _.message = t3;
    },
    RangeError: function RangeError(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.start = t0;
      _.end = t1;
      _._hasValue = t2;
      _.invalidValue = t3;
      _.name = t4;
      _.message = t5;
    },
    IndexError: function IndexError(t0, t1, t2, t3, t4) {
      var _ = this;
      _.length = t0;
      _._hasValue = t1;
      _.invalidValue = t2;
      _.name = t3;
      _.message = t4;
    },
    UnsupportedError: function UnsupportedError(t0) {
      this.message = t0;
    },
    UnimplementedError: function UnimplementedError(t0) {
      this.message = t0;
    },
    StateError: function StateError(t0) {
      this.message = t0;
    },
    ConcurrentModificationError: function ConcurrentModificationError(t0) {
      this.modifiedObject = t0;
    },
    OutOfMemoryError: function OutOfMemoryError() {
    },
    StackOverflowError: function StackOverflowError() {
    },
    CyclicInitializationError: function CyclicInitializationError(t0) {
      this.variableName = t0;
    },
    _Exception: function _Exception(t0) {
      this.message = t0;
    },
    FormatException: function FormatException(t0, t1, t2) {
      this.message = t0;
      this.source = t1;
      this.offset = t2;
    },
    int: function int() {
    },
    Iterable: function Iterable() {
    },
    Iterator: function Iterator() {
    },
    List: function List() {
    },
    Map: function Map() {
    },
    Null: function Null() {
    },
    num: function num() {
    },
    Object: function Object() {
    },
    Set: function Set() {
    },
    StackTrace: function StackTrace() {
    },
    Stopwatch: function Stopwatch() {
      this._stop = this._core$_start = 0;
    },
    String: function String() {
    },
    StringBuffer: function StringBuffer(t0) {
      this._contents = t0;
    },
    Type: function Type() {
    },
    Uri__parseIPv4Address_error: function Uri__parseIPv4Address_error(t0) {
      this.host = t0;
    },
    Uri_parseIPv6Address_error: function Uri_parseIPv6Address_error(t0) {
      this.host = t0;
    },
    Uri_parseIPv6Address_parseHex: function Uri_parseIPv6Address_parseHex(t0, t1) {
      this.error = t0;
      this.host = t1;
    },
    _Uri: function _Uri(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.scheme = t0;
      _._userInfo = t1;
      _._host = t2;
      _._port = t3;
      _.path = t4;
      _._query = t5;
      _._fragment = t6;
      _._hashCodeCache = _._core$_text = null;
    },
    _Uri__Uri$notSimple_closure: function _Uri__Uri$notSimple_closure(t0, t1) {
      this.uri = t0;
      this.portStart = t1;
    },
    _Uri__makePath_closure: function _Uri__makePath_closure() {
    },
    UriData: function UriData(t0, t1, t2) {
      this._core$_text = t0;
      this._separatorIndices = t1;
      this._uriCache = t2;
    },
    _createTables_closure: function _createTables_closure() {
    },
    _createTables_build: function _createTables_build(t0) {
      this.tables = t0;
    },
    _createTables_setChars: function _createTables_setChars() {
    },
    _createTables_setRange: function _createTables_setRange() {
    },
    _SimpleUri: function _SimpleUri(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _._uri = t0;
      _._schemeEnd = t1;
      _._hostStart = t2;
      _._portStart = t3;
      _._pathStart = t4;
      _._queryStart = t5;
      _._fragmentStart = t6;
      _._schemeCache = t7;
      _._hashCodeCache = null;
    },
    _DataUri: function _DataUri(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.scheme = t0;
      _._userInfo = t1;
      _._host = t2;
      _._port = t3;
      _.path = t4;
      _._query = t5;
      _._fragment = t6;
      _._hashCodeCache = _._core$_text = null;
    },
    ServiceExtensionResponse__validateErrorCode: function(errorCode) {
      var _s9_ = "errorCode";
      if (errorCode == null)
        H.throwExpression(P.ArgumentError$notNull(_s9_));
      if (errorCode === -32602)
        return;
      if (typeof errorCode !== "number")
        return errorCode.$ge();
      if (errorCode >= -32016 && errorCode <= -32000)
        return;
      throw H.wrapException(P.ArgumentError$value(errorCode, _s9_, "Out of range"));
    },
    postEvent: function(eventKind, eventData) {
      C.C_JsonCodec.encode$1(eventData);
    },
    Timeline_startSync: function($name, $arguments, flow) {
      var t1 = $.$get$Timeline__stack();
      (t1 && C.JSArray_methods).add$1(t1, null);
      return;
    },
    Timeline_finishSync: function() {
      var block,
        t1 = $.$get$Timeline__stack(),
        t2 = t1.length;
      if (t2 === 0)
        throw H.wrapException(P.StateError$("Uneven calls to startSync and finishSync"));
      if (0 >= t2)
        return H.ioore(t1, -1);
      block = t1.pop();
      if (block == null)
        return;
      P._argumentsAsJson(block._developer$_arguments);
      if (block._flow != null)
        P._argumentsAsJson(null);
    },
    Timeline_instantSync: function($name) {
      return;
    },
    Timeline_timeSync: function($name, $function, flow, $T) {
      var t1;
      H.functionTypeCheck($function, {func: 1, ret: $T});
      P.Timeline_startSync($name, null, flow);
      try {
        t1 = $function.call$0();
        return t1;
      } finally {
        P.Timeline_finishSync();
      }
    },
    _argumentsAsJson: function($arguments) {
      if ($arguments == null || $arguments.get$length($arguments) === 0)
        return "{}";
      return C.C_JsonCodec.encode$1($arguments);
    },
    ServiceExtensionResponse: function ServiceExtensionResponse(t0, t1, t2) {
      this._developer$_result = t0;
      this._errorCode = t1;
      this._errorDetail = t2;
    },
    Flow: function Flow(t0, t1) {
      this._developer$_type = t0;
      this.id = t1;
    },
    _SyncBlock: function _SyncBlock() {
    },
    Isolate_spawn: function(entryPoint, message, errorsAreFatal, onError, onExit, $T) {
      H.functionTypeCheck(entryPoint, {func: 1, ret: -1, args: [$T]});
      H.assertSubtypeOfRuntimeType(message, $T);
      throw H.wrapException(P.UnsupportedError$("Isolate.spawn"));
    },
    _ReceivePortImpl: function _ReceivePortImpl() {
    },
    ByteData_ByteData$view: function(buffer, offsetInBytes, $length) {
      buffer.toString;
      return H.NativeByteData_NativeByteData$view(buffer, offsetInBytes, $length);
    },
    ByteBuffer: function ByteBuffer() {
    },
    Endian: function Endian() {
    },
    ByteData: function ByteData() {
    },
    Int8List: function Int8List() {
    },
    Uint8List: function Uint8List() {
    },
    Uint16List: function Uint16List() {
    },
    Int32List: function Int32List() {
    },
    Float64List: function Float64List() {
    },
    Offset_lerp: function(a, b, t) {
      var t1;
      H.assertHelper(t != null);
      t1 = a == null;
      if (t1 && b == null)
        return;
      if (t1)
        return b.$mul(0, t);
      if (b == null) {
        if (typeof t !== "number")
          return H.iae(t);
        return a.$mul(0, 1 - t);
      }
      return new P.Offset(P.lerpDouble(a._dx, b._dx, t), P.lerpDouble(a._dy, b._dy, t));
    },
    Rect$fromLTRB: function(left, $top, right, bottom) {
      return new P.Rect(left, $top, right, bottom);
    },
    Rect$fromLTWH: function(left, $top, width, height) {
      if (typeof left !== "number")
        return left.$add();
      if (typeof width !== "number")
        return H.iae(width);
      if (typeof $top !== "number")
        return $top.$add();
      if (typeof height !== "number")
        return H.iae(height);
      return new P.Rect(left, $top, left + width, $top + height);
    },
    Rect$fromCircle: function(center, radius) {
      var t3,
        t1 = center._dx,
        t2 = radius * 2 / 2;
      if (typeof t1 !== "number")
        return t1.$sub();
      t3 = center._dy;
      if (typeof t3 !== "number")
        return t3.$sub();
      return new P.Rect(t1 - t2, t3 - t2, t1 + t2, t3 + t2);
    },
    Rect$fromPoints: function(a, b) {
      var t1 = a._dx,
        t2 = b._dx,
        t3 = Math.min(H.checkNum(t1), H.checkNum(t2)),
        t4 = a._dy,
        t5 = b._dy;
      return new P.Rect(t3, Math.min(H.checkNum(t4), H.checkNum(t5)), Math.max(H.checkNum(t1), H.checkNum(t2)), Math.max(H.checkNum(t4), H.checkNum(t5)));
    },
    Rect_lerp: function(a, b, t) {
      var t1, t2, t3, t4, k;
      H.assertHelper(t != null);
      t1 = a == null;
      if (t1 && b == null)
        return;
      if (t1) {
        t1 = b.left;
        if (typeof t1 !== "number")
          return t1.$mul();
        if (typeof t !== "number")
          return H.iae(t);
        t2 = b.top;
        if (typeof t2 !== "number")
          return t2.$mul();
        t3 = b.right;
        if (typeof t3 !== "number")
          return t3.$mul();
        t4 = b.bottom;
        if (typeof t4 !== "number")
          return t4.$mul();
        return P.Rect$fromLTRB(t1 * t, t2 * t, t3 * t, t4 * t);
      }
      if (b == null) {
        if (typeof t !== "number")
          return H.iae(t);
        k = 1 - t;
        t1 = a.left;
        if (typeof t1 !== "number")
          return t1.$mul();
        t2 = a.top;
        if (typeof t2 !== "number")
          return t2.$mul();
        t3 = a.right;
        if (typeof t3 !== "number")
          return t3.$mul();
        t4 = a.bottom;
        if (typeof t4 !== "number")
          return t4.$mul();
        return P.Rect$fromLTRB(t1 * k, t2 * k, t3 * k, t4 * k);
      }
      return P.Rect$fromLTRB(P.lerpDouble(a.left, b.left, t), P.lerpDouble(a.top, b.top, t), P.lerpDouble(a.right, b.right, t), P.lerpDouble(a.bottom, b.bottom, t));
    },
    Radius_lerp: function(a, b, t) {
      var t2, k,
        t1 = a == null;
      if (t1 && b == null)
        return;
      if (t1) {
        t1 = b.x;
        if (typeof t1 !== "number")
          return t1.$mul();
        t2 = b.y;
        if (typeof t2 !== "number")
          return t2.$mul();
        return new P.Radius(t1 * t, t2 * t);
      }
      if (b == null) {
        k = 1 - t;
        t1 = a.x;
        if (typeof t1 !== "number")
          return t1.$mul();
        t2 = a.y;
        if (typeof t2 !== "number")
          return t2.$mul();
        return new P.Radius(t1 * k, t2 * k);
      }
      return new P.Radius(P.lerpDouble(a.x, b.x, t), P.lerpDouble(a.y, b.y, t));
    },
    RRect$fromRectAndRadius: function(rect, radius) {
      var t1 = radius.x,
        t2 = radius.y;
      return new P.RRect(rect.left, rect.top, rect.right, rect.bottom, t1, t2, t1, t2, t1, t2, t1, t2);
    },
    RRect$fromRectAndCorners: function(rect, bottomLeft, bottomRight, topLeft, topRight) {
      var t1 = bottomLeft.x,
        t2 = bottomLeft.y,
        t3 = rect.bottom,
        t4 = bottomRight.x,
        t5 = bottomRight.y,
        t6 = rect.left,
        t7 = rect.right,
        t8 = topLeft.x,
        t9 = topLeft.y;
      return new P.RRect(t6, rect.top, t7, t3, t8, t9, topRight.x, topRight.y, t4, t5, t1, t2);
    },
    RRect$_raw: function(blRadiusX, blRadiusY, bottom, brRadiusX, brRadiusY, left, right, tlRadiusX, tlRadiusY, $top, trRadiusX, trRadiusY) {
      return new P.RRect(left, $top, right, bottom, tlRadiusX, tlRadiusY, trRadiusX, trRadiusY, brRadiusX, brRadiusY, blRadiusX, blRadiusY);
    },
    _Jenkins_combine: function(hash, o) {
      var t1 = J.getInterceptor$(o);
      H.assertHelper(!t1.$isIterable);
      hash = 536870911 & hash + t1.get$hashCode(o);
      hash = 536870911 & hash + ((524287 & hash) << 10);
      return hash ^ hash >>> 6;
    },
    _Jenkins_finish: function(hash) {
      hash = 536870911 & hash + ((67108863 & hash) << 3);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    },
    hashValues: function(arg01, arg02, arg03, arg04, arg05, arg06, arg07, arg08, arg09, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20) {
      var result = P._Jenkins_combine(P._Jenkins_combine(0, arg01), arg02);
      if (!J.$eq$(arg03, C.C__HashEnd)) {
        result = P._Jenkins_combine(result, arg03);
        if (!J.$eq$(arg04, C.C__HashEnd)) {
          result = P._Jenkins_combine(result, arg04);
          if (!J.$eq$(arg05, C.C__HashEnd)) {
            result = P._Jenkins_combine(result, arg05);
            if (!J.$eq$(arg06, C.C__HashEnd)) {
              result = P._Jenkins_combine(result, arg06);
              if (!J.$eq$(arg07, C.C__HashEnd)) {
                result = P._Jenkins_combine(result, arg07);
                if (!J.$eq$(arg08, C.C__HashEnd)) {
                  result = P._Jenkins_combine(result, arg08);
                  if (!J.$eq$(arg09, C.C__HashEnd)) {
                    result = P._Jenkins_combine(result, arg09);
                    if (!J.$eq$(arg10, C.C__HashEnd)) {
                      result = P._Jenkins_combine(result, arg10);
                      if (!J.$eq$(arg11, C.C__HashEnd)) {
                        result = P._Jenkins_combine(result, arg11);
                        if (!J.$eq$(arg12, C.C__HashEnd)) {
                          result = P._Jenkins_combine(result, arg12);
                          if (!J.$eq$(arg13, C.C__HashEnd)) {
                            result = P._Jenkins_combine(result, arg13);
                            if (!J.$eq$(arg14, C.C__HashEnd)) {
                              result = P._Jenkins_combine(result, arg14);
                              if (!J.$eq$(arg15, C.C__HashEnd)) {
                                result = P._Jenkins_combine(result, arg15);
                                if (!J.$eq$(arg16, C.C__HashEnd)) {
                                  result = P._Jenkins_combine(result, arg16);
                                  if (!J.$eq$(arg17, C.C__HashEnd)) {
                                    result = P._Jenkins_combine(result, arg17);
                                    if (!J.$eq$(arg18, C.C__HashEnd)) {
                                      result = P._Jenkins_combine(result, arg18);
                                      if (!J.$eq$(arg19, C.C__HashEnd)) {
                                        result = P._Jenkins_combine(result, arg19);
                                        if (!J.$eq$(arg20, C.C__HashEnd))
                                          result = P._Jenkins_combine(result, arg20);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return P._Jenkins_finish(result);
    },
    hashList: function($arguments) {
      var t1, result;
      H.assertSubtype($arguments, "$isIterable", [P.Object], "$asIterable");
      if ($arguments != null)
        for (t1 = J.get$iterator$ax($arguments), result = 0; t1.moveNext$0();)
          result = P._Jenkins_combine(result, t1.get$current());
      else
        result = 0;
      return P._Jenkins_finish(result);
    },
    lerpDouble: function(a, b, t) {
      var t1 = a == null;
      if (t1 && b == null)
        return;
      if (t1)
        a = 0;
      if (b == null)
        b = 0;
      if (typeof t !== "number")
        return H.iae(t);
      return a + (b - a) * t;
    },
    saveCompilationTrace: function() {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    _rectIsValid: function(rect) {
      var t1;
      if (H.assertTest(rect != null))
        H.assertThrow("Rect argument was null.");
      t1 = rect.left;
      t1.toString;
      if (!isNaN(t1)) {
        t1 = rect.top;
        t1.toString;
        if (!isNaN(t1)) {
          t1 = rect.right;
          t1.toString;
          if (!isNaN(t1)) {
            t1 = rect.bottom;
            t1.toString;
            t1 = isNaN(t1);
          } else
            t1 = true;
        } else
          t1 = true;
      } else
        t1 = true;
      if (H.assertTest(!t1))
        H.assertThrow("Rect argument contained a NaN value.");
      return true;
    },
    _rrectIsValid: function(rrect) {
      var t1 = rrect.left;
      t1.toString;
      if (!isNaN(t1)) {
        t1 = rrect.top;
        t1.toString;
        if (!isNaN(t1)) {
          t1 = rrect.right;
          t1.toString;
          if (!isNaN(t1)) {
            t1 = rrect.bottom;
            t1.toString;
            if (!isNaN(t1)) {
              t1 = rrect.trRadiusX;
              t1.toString;
              if (!isNaN(t1)) {
                t1 = rrect.trRadiusY;
                t1.toString;
                if (!isNaN(t1)) {
                  t1 = rrect.tlRadiusX;
                  t1.toString;
                  if (!isNaN(t1)) {
                    t1 = rrect.tlRadiusY;
                    t1.toString;
                    if (!isNaN(t1)) {
                      t1 = rrect.brRadiusX;
                      t1.toString;
                      if (!isNaN(t1)) {
                        t1 = rrect.brRadiusY;
                        t1.toString;
                        if (!isNaN(t1)) {
                          t1 = rrect.blRadiusX;
                          t1.toString;
                          if (!isNaN(t1)) {
                            t1 = rrect.blRadiusY;
                            t1.toString;
                            t1 = isNaN(t1);
                          } else
                            t1 = true;
                        } else
                          t1 = true;
                      } else
                        t1 = true;
                    } else
                      t1 = true;
                  } else
                    t1 = true;
                } else
                  t1 = true;
              } else
                t1 = true;
            } else
              t1 = true;
          } else
            t1 = true;
        } else
          t1 = true;
      } else
        t1 = true;
      if (H.assertTest(!t1))
        H.assertThrow("RRect argument contained a NaN value.");
      return true;
    },
    _offsetIsValid: function(offset) {
      var t1;
      if (H.assertTest(offset != null))
        H.assertThrow("Offset argument was null.");
      t1 = offset._dx;
      t1.toString;
      if (!isNaN(t1)) {
        t1 = offset._dy;
        t1.toString;
        t1 = !isNaN(t1);
      } else
        t1 = false;
      if (H.assertTest(t1))
        H.assertThrow("Offset argument contained a NaN value.");
      return true;
    },
    _scaleAlpha: function(a, factor) {
      var t1 = a.value;
      return P.Color$fromARGB(H.intTypeCheck(C.JSInt_methods.clamp$2(C.JSNumber_methods.round$0(((4278190080 & t1) >>> 24) * factor), 0, 255)), (16711680 & t1) >>> 16, (65280 & t1) >>> 8, (255 & t1) >>> 0);
    },
    Color$fromARGB: function(a, r, g, b) {
      if (typeof a !== "number")
        return a.$and();
      return new P.Color((((a & 255) << 24 | (r & 255) << 16 | (g & 255) << 8 | (b & 255) << 0) & 4294967295) >>> 0);
    },
    Color__linearizeColorComponent: function(component) {
      if (component <= 0.03928)
        return component / 12.92;
      return Math.pow((component + 0.055) / 1.055, 2.4);
    },
    Color_lerp: function(a, b, t) {
      var t1, t2;
      H.assertHelper(t != null);
      t1 = a == null;
      if (t1 && b == null)
        return;
      if (t1)
        return P._scaleAlpha(b, t);
      if (b == null) {
        if (typeof t !== "number")
          return H.iae(t);
        return P._scaleAlpha(a, 1 - t);
      }
      t1 = a.value;
      t2 = b.value;
      return P.Color$fromARGB(H.intTypeCheck(C.JSInt_methods.clamp$2(J.toInt$0$n(P.lerpDouble((4278190080 & t1) >>> 24, (4278190080 & t2) >>> 24, t)), 0, 255)), H.intTypeCheck(C.JSInt_methods.clamp$2(J.toInt$0$n(P.lerpDouble((16711680 & t1) >>> 16, (16711680 & t2) >>> 16, t)), 0, 255)), H.intTypeCheck(C.JSInt_methods.clamp$2(J.toInt$0$n(P.lerpDouble((65280 & t1) >>> 8, (65280 & t2) >>> 8, t)), 0, 255)), H.intTypeCheck(C.JSInt_methods.clamp$2(J.toInt$0$n(P.lerpDouble((255 & t1) >>> 0, (255 & t2) >>> 0, t)), 0, 255)));
    },
    Paint$: function() {
      return new P.Paint(new DataView(new ArrayBuffer(75)));
    },
    Path_combine: function(operation, path1, path2) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    MaskFilter$blur: function(_style, _sigma) {
      return new P.MaskFilter(_style, _sigma);
    },
    Gradient$linear: function(from, to, colors, colorStops, tileMode) {
      return new P.Gradient0();
    },
    FontWeight_lerp: function(a, b, t) {
      var t2,
        t1 = a == null ? null : a.index;
      if (t1 == null)
        t1 = 3;
      t2 = b == null ? null : b.index;
      t1 = H.intTypeCheck(C.JSInt_methods.clamp$2(J.round$0$n(P.lerpDouble(t1, t2 == null ? 3 : t2, t)), 0, 8));
      if (t1 < 0 || t1 >= 9)
        return H.ioore(C.List_27p, t1);
      return C.List_27p[t1];
    },
    _listEquals: function(a, b, $T) {
      return true;
    },
    TextStyle$: function(background, color, decoration, decorationColor, decorationStyle, decorationThickness, fontFamily, fontFamilyFallback, fontSize, fontStyle, fontWeight, foreground, height, letterSpacing, locale, shadows, textBaseline, wordSpacing) {
      var t1, t2,
        result = new Int32Array(8);
      if (color != null) {
        t1 = result.length;
        if (0 >= t1)
          return H.ioore(result, 0);
        result[0] = (result[0] | 2) >>> 0;
        t2 = color.value;
        if (1 >= t1)
          return H.ioore(result, 1);
        result[1] = t2;
      }
      if (decoration != null) {
        t1 = result.length;
        if (0 >= t1)
          return H.ioore(result, 0);
        result[0] = (result[0] | 4) >>> 0;
        t2 = decoration._mask;
        if (2 >= t1)
          return H.ioore(result, 2);
        result[2] = t2;
      }
      if (decorationColor != null) {
        t1 = result.length;
        if (0 >= t1)
          return H.ioore(result, 0);
        result[0] = (result[0] | 8) >>> 0;
        t2 = decorationColor.value;
        if (3 >= t1)
          return H.ioore(result, 3);
        result[3] = t2;
      }
      if (decorationStyle != null) {
        t1 = result.length;
        if (0 >= t1)
          return H.ioore(result, 0);
        result[0] = (result[0] | 16) >>> 0;
        t2 = decorationStyle.index;
        if (4 >= t1)
          return H.ioore(result, 4);
        result[4] = t2;
      }
      if (decorationThickness != null) {
        if (0 >= result.length)
          return H.ioore(result, 0);
        result[0] = (result[0] | 32) >>> 0;
      }
      if (fontWeight != null) {
        t1 = result.length;
        if (0 >= t1)
          return H.ioore(result, 0);
        result[0] = (result[0] | 64) >>> 0;
        t2 = fontWeight.index;
        if (5 >= t1)
          return H.ioore(result, 5);
        result[5] = t2;
      }
      if (textBaseline != null) {
        t1 = result.length;
        if (0 >= t1)
          return H.ioore(result, 0);
        result[0] = (result[0] | 256) >>> 0;
        t2 = textBaseline.index;
        if (7 >= t1)
          return H.ioore(result, 7);
        result[7] = t2;
      }
      t1 = fontFamily == null;
      if (t1)
        t2 = false;
      else
        t2 = true;
      if (t2) {
        if (0 >= result.length)
          return H.ioore(result, 0);
        result[0] = (result[0] | 512) >>> 0;
      }
      if (fontSize != null) {
        if (0 >= result.length)
          return H.ioore(result, 0);
        result[0] = (result[0] | 512) >>> 0;
      }
      if (letterSpacing != null) {
        if (0 >= result.length)
          return H.ioore(result, 0);
        result[0] = (result[0] | 1024) >>> 0;
      }
      if (wordSpacing != null) {
        if (0 >= result.length)
          return H.ioore(result, 0);
        result[0] = (result[0] | 2048) >>> 0;
      }
      if (height != null) {
        if (0 >= result.length)
          return H.ioore(result, 0);
        result[0] = (result[0] | 4096) >>> 0;
      }
      if (background != null) {
        if (0 >= result.length)
          return H.ioore(result, 0);
        result[0] = (result[0] | 16384) >>> 0;
      }
      if (foreground != null) {
        if (0 >= result.length)
          return H.ioore(result, 0);
        result[0] = (result[0] | 32768) >>> 0;
      }
      return new P.TextStyle(result, t1 ? "" : fontFamily, fontFamilyFallback, fontSize, letterSpacing, wordSpacing, height, decorationThickness, locale, background, foreground, shadows);
    },
    ParagraphStyle$: function(ellipsis, fontFamily, fontSize, fontStyle, fontWeight, height, locale, maxLines, strutStyle, textAlign, textDirection) {
      var t1, t2,
        result = new Int32Array(6);
      if (textAlign != null) {
        t1 = result.length;
        if (0 >= t1)
          return H.ioore(result, 0);
        result[0] = (result[0] | 2) >>> 0;
        t2 = textAlign.index;
        if (1 >= t1)
          return H.ioore(result, 1);
        result[1] = t2;
      }
      if (textDirection != null) {
        t1 = result.length;
        if (0 >= t1)
          return H.ioore(result, 0);
        result[0] = (result[0] | 4) >>> 0;
        t2 = textDirection.index;
        if (2 >= t1)
          return H.ioore(result, 2);
        result[2] = t2;
      }
      if (fontWeight != null) {
        t1 = result.length;
        if (0 >= t1)
          return H.ioore(result, 0);
        result[0] = (result[0] | 8) >>> 0;
        t2 = fontWeight.index;
        if (3 >= t1)
          return H.ioore(result, 3);
        result[3] = t2;
      }
      if (maxLines != null) {
        t1 = result.length;
        if (0 >= t1)
          return H.ioore(result, 0);
        result[0] = (result[0] | 32) >>> 0;
        if (5 >= t1)
          return H.ioore(result, 5);
        result[5] = maxLines;
      }
      if (fontFamily != null) {
        if (0 >= result.length)
          return H.ioore(result, 0);
        result[0] = (result[0] | 64) >>> 0;
      }
      if (fontSize != null) {
        if (0 >= result.length)
          return H.ioore(result, 0);
        result[0] = (result[0] | 128) >>> 0;
      }
      if (height != null) {
        if (0 >= result.length)
          return H.ioore(result, 0);
        result[0] = (result[0] | 256) >>> 0;
      }
      if (strutStyle != null) {
        if (0 >= result.length)
          return H.ioore(result, 0);
        result[0] = (result[0] | 512) >>> 0;
      }
      if (ellipsis != null) {
        if (0 >= result.length)
          return H.ioore(result, 0);
        result[0] = (result[0] | 1024) >>> 0;
      }
      if (locale != null) {
        if (0 >= result.length)
          return H.ioore(result, 0);
        result[0] = (result[0] | 2048) >>> 0;
      }
      return new P.ParagraphStyle(result, fontFamily, fontSize, height, strutStyle, ellipsis, locale);
    },
    Locale__replaceDeprecatedLanguageSubtag: function(languageCode) {
      var _s3_ = "dtp";
      switch (languageCode) {
        case "in":
          return "id";
        case "iw":
          return "he";
        case "ji":
          return "yi";
        case "jw":
          return "jv";
        case "mo":
          return "ro";
        case "aam":
          return "aas";
        case "adp":
          return "dz";
        case "aue":
          return "ktz";
        case "ayx":
          return "nun";
        case "bgm":
          return "bcg";
        case "bjd":
          return "drl";
        case "ccq":
          return "rki";
        case "cjr":
          return "mom";
        case "cka":
          return "cmr";
        case "cmk":
          return "xch";
        case "coy":
          return "pij";
        case "cqu":
          return "quh";
        case "drh":
          return "khk";
        case "drw":
          return "prs";
        case "gav":
          return "dev";
        case "gfx":
          return "vaj";
        case "ggn":
          return "gvr";
        case "gti":
          return "nyc";
        case "guv":
          return "duz";
        case "hrr":
          return "jal";
        case "ibi":
          return "opa";
        case "ilw":
          return "gal";
        case "jeg":
          return "oyb";
        case "kgc":
          return "tdf";
        case "kgh":
          return "kml";
        case "koj":
          return "kwv";
        case "krm":
          return "bmf";
        case "ktr":
          return _s3_;
        case "kvs":
          return "gdj";
        case "kwq":
          return "yam";
        case "kxe":
          return "tvd";
        case "kzj":
          return _s3_;
        case "kzt":
          return _s3_;
        case "lii":
          return "raq";
        case "lmm":
          return "rmx";
        case "meg":
          return "cir";
        case "mst":
          return "mry";
        case "mwj":
          return "vaj";
        case "myt":
          return "mry";
        case "nad":
          return "xny";
        case "ncp":
          return "kdz";
        case "nnx":
          return "ngv";
        case "nts":
          return "pij";
        case "oun":
          return "vaj";
        case "pcr":
          return "adx";
        case "pmc":
          return "huw";
        case "pmu":
          return "phr";
        case "ppa":
          return "bfy";
        case "ppr":
          return "lcq";
        case "pry":
          return "prt";
        case "puz":
          return "pub";
        case "sca":
          return "hle";
        case "skk":
          return "oyb";
        case "tdu":
          return _s3_;
        case "thc":
          return "tpo";
        case "thx":
          return "oyb";
        case "tie":
          return "ras";
        case "tkk":
          return "twm";
        case "tlw":
          return "weo";
        case "tmp":
          return "tyj";
        case "tne":
          return "kak";
        case "tnf":
          return "prs";
        case "tsf":
          return "taj";
        case "uok":
          return "ema";
        case "xba":
          return "cax";
        case "xia":
          return "acn";
        case "xkh":
          return "waw";
        case "xsj":
          return "suj";
        case "ybd":
          return "rki";
        case "yma":
          return "lrr";
        case "ymt":
          return "mtm";
        case "yos":
          return "zom";
        case "yuu":
          return "yug";
        default:
          return languageCode;
      }
    },
    Locale__replaceDeprecatedRegionSubtag: function(regionCode) {
      switch (regionCode) {
        case "BU":
          return "MM";
        case "DD":
          return "DE";
        case "FX":
          return "FR";
        case "TP":
          return "TL";
        case "YD":
          return "YE";
        case "ZR":
          return "CD";
        default:
          return regionCode;
      }
    },
    SceneBuilder: function SceneBuilder() {
    },
    OffsetBase: function OffsetBase() {
    },
    Offset: function Offset(t0, t1) {
      this._dx = t0;
      this._dy = t1;
    },
    Size: function Size(t0, t1) {
      this._dx = t0;
      this._dy = t1;
    },
    Rect: function Rect(t0, t1, t2, t3) {
      var _ = this;
      _.left = t0;
      _.top = t1;
      _.right = t2;
      _.bottom = t3;
    },
    Radius: function Radius(t0, t1) {
      this.x = t0;
      this.y = t1;
    },
    RRect: function RRect(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _.left = t0;
      _.top = t1;
      _.right = t2;
      _.bottom = t3;
      _.tlRadiusX = t4;
      _.tlRadiusY = t5;
      _.trRadiusX = t6;
      _.trRadiusY = t7;
      _.brRadiusX = t8;
      _.brRadiusY = t9;
      _.blRadiusX = t10;
      _.blRadiusY = t11;
    },
    _HashEnd: function _HashEnd() {
    },
    Color: function Color(t0) {
      this.value = t0;
    },
    BlendMode: function BlendMode(t0, t1) {
      this.index = t0;
      this._ui$_name = t1;
    },
    FilterQuality: function FilterQuality(t0) {
      this._ui$_name = t0;
    },
    StrokeCap: function StrokeCap(t0) {
      this._ui$_name = t0;
    },
    StrokeJoin: function StrokeJoin(t0) {
      this._ui$_name = t0;
    },
    PaintingStyle: function PaintingStyle(t0, t1) {
      this.index = t0;
      this._ui$_name = t1;
    },
    Clip: function Clip(t0) {
      this._ui$_name = t0;
    },
    Paint: function Paint(t0) {
      this._ui$_data = t0;
      this._objects = null;
    },
    Image: function Image() {
    },
    PathFillType: function PathFillType(t0) {
      this._ui$_name = t0;
    },
    PathOperation: function PathOperation(t0) {
      this._ui$_name = t0;
    },
    Path: function Path() {
    },
    BlurStyle: function BlurStyle(t0, t1) {
      this.index = t0;
      this._ui$_name = t1;
    },
    MaskFilter: function MaskFilter(t0, t1) {
      this._style = t0;
      this._sigma = t1;
    },
    ColorFilter: function ColorFilter(t0, t1, t2, t3) {
      var _ = this;
      _._color = t0;
      _._blendMode = t1;
      _._matrix = t2;
      _._type = t3;
    },
    Shader: function Shader() {
    },
    TileMode: function TileMode(t0) {
      this._ui$_name = t0;
    },
    Gradient0: function Gradient0() {
    },
    ClipOp: function ClipOp(t0) {
      this._ui$_name = t0;
    },
    Canvas: function Canvas() {
    },
    PictureRecorder: function PictureRecorder() {
    },
    Shadow: function Shadow() {
    },
    PointerDeviceKind: function PointerDeviceKind(t0) {
      this._ui$_name = t0;
    },
    PointerSignalKind: function PointerSignalKind(t0) {
      this._ui$_name = t0;
    },
    PointerData: function PointerData() {
    },
    PointerDataPacket: function PointerDataPacket() {
    },
    SemanticsAction: function SemanticsAction(t0) {
      this.index = t0;
    },
    SemanticsFlag: function SemanticsFlag(t0) {
      this.index = t0;
    },
    SemanticsUpdateBuilder: function SemanticsUpdateBuilder() {
    },
    FontStyle: function FontStyle(t0, t1) {
      this.index = t0;
      this._ui$_name = t1;
    },
    FontWeight: function FontWeight(t0) {
      this.index = t0;
    },
    TextAlign: function TextAlign(t0, t1) {
      this.index = t0;
      this._ui$_name = t1;
    },
    TextBaseline: function TextBaseline(t0, t1) {
      this.index = t0;
      this._ui$_name = t1;
    },
    TextDecoration: function TextDecoration(t0) {
      this._mask = t0;
    },
    TextDecorationStyle: function TextDecorationStyle(t0, t1) {
      this.index = t0;
      this._ui$_name = t1;
    },
    TextStyle: function TextStyle(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _._encoded = t0;
      _._fontFamily = t1;
      _._fontFamilyFallback = t2;
      _._fontSize = t3;
      _._letterSpacing = t4;
      _._wordSpacing = t5;
      _._height = t6;
      _._decorationThickness = t7;
      _._locale = t8;
      _._background = t9;
      _._foreground = t10;
      _._shadows = t11;
    },
    ParagraphStyle: function ParagraphStyle(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._encoded = t0;
      _._fontFamily = t1;
      _._fontSize = t2;
      _._height = t3;
      _._strutStyle = t4;
      _._ellipsis = t5;
      _._locale = t6;
    },
    TextDirection: function TextDirection(t0, t1) {
      this.index = t0;
      this._ui$_name = t1;
    },
    TextAffinity: function TextAffinity(t0) {
      this._ui$_name = t0;
    },
    ParagraphConstraints: function ParagraphConstraints(t0) {
      this.width = t0;
    },
    ParagraphBuilder: function ParagraphBuilder() {
    },
    AppLifecycleState: function AppLifecycleState(t0) {
      this._ui$_name = t0;
    },
    WindowPadding: function WindowPadding(t0, t1, t2, t3) {
      var _ = this;
      _.left = t0;
      _.top = t1;
      _.right = t2;
      _.bottom = t3;
    },
    Locale: function Locale(t0, t1) {
      this._languageCode = t0;
      this._countryCode = t1;
    },
    Window: function Window() {
    },
    Brightness: function Brightness(t0) {
      this._ui$_name = t0;
    },
    _Platform__operatingSystem: function() {
      throw H.wrapException(P.UnsupportedError$("Platform._operatingSystem"));
    },
    _Platform__environment: function() {
      throw H.wrapException(P.UnsupportedError$("Platform._environment"));
    },
    _ProcessUtils__exit: function($status) {
      throw H.wrapException(P.UnsupportedError$("ProcessUtils._exit"));
    },
    _Platform_operatingSystem: function() {
      return P._Platform__operatingSystem();
    },
    _Platform_environment: function() {
      var t2,
        t1 = $._Platform__environmentCache;
      if (t1 == null)
        P._Platform__environment();
      t2 = P.String;
      H.assertSubtype(t1, "$isMap", [t2, t2], "$asMap");
      return t1;
    }
  },
  W = {DomException: function DomException() {
    }},
  Y = {HeapPriorityQueue: function HeapPriorityQueue(t0, t1, t2) {
      var _ = this;
      _.comparison = t0;
      _._priority_queue$_queue = t1;
      _._length = 0;
      _.$ti = t2;
    },
    TextTreeConfiguration$: function(addBlankLineIfNoChildren, afterDescriptionIfBody, afterName, afterProperties, beforeProperties, bodyIndent, footer, isBlankLineBetweenPropertiesAndChildren, isNameOnOwnLine, lineBreak, lineBreakProperties, linkCharacter, prefixLastChildLineOne, prefixLineOne, prefixOtherLines, prefixOtherLinesRootNode, propertyPrefixIfChildren, propertyPrefixNoChildren, propertySeparator, showChildren) {
      return new Y.TextTreeConfiguration(prefixLineOne, prefixOtherLines, prefixLastChildLineOne, prefixOtherLinesRootNode, propertyPrefixIfChildren, propertyPrefixNoChildren, linkCharacter, C.JSString_methods.$mul(" ", linkCharacter.length), lineBreak, lineBreakProperties, afterName, afterDescriptionIfBody, beforeProperties, afterProperties, propertySeparator, bodyIndent, showChildren, addBlankLineIfNoChildren, isNameOnOwnLine, footer, isBlankLineBetweenPropertiesAndChildren);
    },
    DiagnosticsNode_DiagnosticsNode$message: function(message, style) {
      var _null = null;
      return Y.DiagnosticsProperty$("", _null, C.C__NoDefaultValue, message, _null, _null, C.DiagnosticLevel_3, false, false, true, style, _null, -1);
    },
    MessageProperty$: function($name, message) {
      var _null = null;
      return new Y.MessageProperty(message, _null, _null, _null, false, _null, C.C__NoDefaultValue, C.DiagnosticLevel_3, $name, true, true, C.DiagnosticsTreeStyle_5);
    },
    StringProperty$: function($name, value, defaultValue, quoted, showName) {
      var _null = null;
      return new Y.StringProperty(quoted, _null, _null, _null, _null, false, value, defaultValue, C.DiagnosticLevel_3, $name, true, showName, C.DiagnosticsTreeStyle_5);
    },
    DoubleProperty$: function($name, value, defaultValue, ifNull, level, showName, tooltip, unit) {
      var t1;
      if (ifNull == null)
        t1 = null;
      else
        t1 = ifNull;
      return new Y.DoubleProperty(unit, null, t1, null, tooltip, false, value, defaultValue, level, $name, true, true, C.DiagnosticsTreeStyle_5);
    },
    IntProperty$: function($name, value, defaultValue, ifNull, level, unit) {
      var t1, _null = null;
      if (ifNull == null)
        t1 = _null;
      else
        t1 = ifNull;
      return new Y.IntProperty(unit, _null, t1, _null, _null, false, value, defaultValue, level, $name, true, true, C.DiagnosticsTreeStyle_5);
    },
    FlagProperty$: function($name, defaultValue, ifFalse, ifTrue, level, showName, value) {
      var _null = null;
      return new Y.FlagProperty(ifTrue, ifFalse, _null, _null, _null, _null, false, value, defaultValue, level, $name, true, showName, C.DiagnosticsTreeStyle_5);
    },
    IterableProperty$: function($name, value, defaultValue, ifEmpty, level, style, $T) {
      return new Y.IterableProperty(null, null, ifEmpty, null, false, value, defaultValue, level, $name, true, true, style, [$T]);
    },
    ObjectFlagProperty$: function($name, value, ifNull, $T) {
      var _null = null;
      return new Y.ObjectFlagProperty(_null, _null, ifNull, _null, _null, false, value, C.C__NoDefaultValue, C.DiagnosticLevel_3, $name, true, false, C.DiagnosticsTreeStyle_5, [$T]);
    },
    DiagnosticsProperty$: function($name, value, defaultValue, description, ifEmpty, ifNull, level, missingIfNull, showName, showSeparator, style, tooltip, $T) {
      var t1;
      if (ifNull == null)
        t1 = missingIfNull ? "MISSING" : null;
      else
        t1 = ifNull;
      return new Y.DiagnosticsProperty(description, t1, ifEmpty, tooltip, missingIfNull, value, defaultValue, level, $name, showSeparator, showName, style, [$T]);
    },
    DiagnosticableNode$: function($name, style, value, $T) {
      return new Y.DiagnosticableNode(value, $name, true, true, style, [$T]);
    },
    shortHash: function(object) {
      return C.JSString_methods.padLeft$2(C.JSInt_methods.toRadixString$1(J.get$hashCode$(object) & 1048575, 16), 5, "0");
    },
    describeEnum: function(enumEntry) {
      var description = J.toString$0$(enumEntry),
        indexOfDot = J.getInterceptor$asx(description).indexOf$1(description, ".");
      H.assertHelper(indexOfDot !== -1 && indexOfDot < description.length - 1);
      return C.JSString_methods.substring$1(description, indexOfDot + 1);
    },
    DiagnosticLevel: function DiagnosticLevel(t0, t1) {
      this.index = t0;
      this._diagnostics$_name = t1;
    },
    DiagnosticsTreeStyle: function DiagnosticsTreeStyle(t0) {
      this._diagnostics$_name = t0;
    },
    TextTreeConfiguration: function TextTreeConfiguration(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20) {
      var _ = this;
      _.prefixLineOne = t0;
      _.prefixOtherLines = t1;
      _.prefixLastChildLineOne = t2;
      _.prefixOtherLinesRootNode = t3;
      _.propertyPrefixIfChildren = t4;
      _.propertyPrefixNoChildren = t5;
      _.linkCharacter = t6;
      _.childLinkSpace = t7;
      _.lineBreak = t8;
      _.lineBreakProperties = t9;
      _.afterName = t10;
      _.afterDescriptionIfBody = t11;
      _.beforeProperties = t12;
      _.afterProperties = t13;
      _.propertySeparator = t14;
      _.bodyIndent = t15;
      _.showChildren = t16;
      _.addBlankLineIfNoChildren = t17;
      _.isNameOnOwnLine = t18;
      _.footer = t19;
      _.isBlankLineBetweenPropertiesAndChildren = t20;
    },
    _PrefixedStringBuilder: function _PrefixedStringBuilder(t0, t1, t2) {
      var _ = this;
      _.prefixLineOne = t0;
      _.prefixOtherLines = t1;
      _._buffer = t2;
      _._atLineStart = true;
      _._hasMultipleLines = false;
    },
    _NoDefaultValue: function _NoDefaultValue() {
    },
    DiagnosticsNode: function DiagnosticsNode() {
    },
    DiagnosticsNode_toStringDeep_closure: function DiagnosticsNode_toStringDeep_closure(t0) {
      this.minLevel = t0;
    },
    MessageProperty: function MessageProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _._description = t0;
      _.ifNull = t1;
      _.ifEmpty = t2;
      _.tooltip = t3;
      _.missingIfNull = t4;
      _._value = t5;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t6;
      _._defaultLevel = t7;
      _.name = t8;
      _.showSeparator = t9;
      _.showName = t10;
      _.style = t11;
    },
    StringProperty: function StringProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _.quoted = t0;
      _._description = t1;
      _.ifNull = t2;
      _.ifEmpty = t3;
      _.tooltip = t4;
      _.missingIfNull = t5;
      _._value = t6;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t7;
      _._defaultLevel = t8;
      _.name = t9;
      _.showSeparator = t10;
      _.showName = t11;
      _.style = t12;
    },
    _NumProperty: function _NumProperty() {
    },
    DoubleProperty: function DoubleProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _.unit = t0;
      _._description = t1;
      _.ifNull = t2;
      _.ifEmpty = t3;
      _.tooltip = t4;
      _.missingIfNull = t5;
      _._value = t6;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t7;
      _._defaultLevel = t8;
      _.name = t9;
      _.showSeparator = t10;
      _.showName = t11;
      _.style = t12;
    },
    IntProperty: function IntProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _.unit = t0;
      _._description = t1;
      _.ifNull = t2;
      _.ifEmpty = t3;
      _.tooltip = t4;
      _.missingIfNull = t5;
      _._value = t6;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t7;
      _._defaultLevel = t8;
      _.name = t9;
      _.showSeparator = t10;
      _.showName = t11;
      _.style = t12;
    },
    PercentProperty: function PercentProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _.unit = t0;
      _._description = t1;
      _.ifNull = t2;
      _.ifEmpty = t3;
      _.tooltip = t4;
      _.missingIfNull = t5;
      _._value = t6;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t7;
      _._defaultLevel = t8;
      _.name = t9;
      _.showSeparator = t10;
      _.showName = t11;
      _.style = t12;
    },
    FlagProperty: function FlagProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) {
      var _ = this;
      _.ifTrue = t0;
      _.ifFalse = t1;
      _._description = t2;
      _.ifNull = t3;
      _.ifEmpty = t4;
      _.tooltip = t5;
      _.missingIfNull = t6;
      _._value = t7;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t8;
      _._defaultLevel = t9;
      _.name = t10;
      _.showSeparator = t11;
      _.showName = t12;
      _.style = t13;
    },
    IterableProperty: function IterableProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _._description = t0;
      _.ifNull = t1;
      _.ifEmpty = t2;
      _.tooltip = t3;
      _.missingIfNull = t4;
      _._value = t5;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t6;
      _._defaultLevel = t7;
      _.name = t8;
      _.showSeparator = t9;
      _.showName = t10;
      _.style = t11;
      _.$ti = t12;
    },
    IterableProperty_toJsonMap_closure: function IterableProperty_toJsonMap_closure(t0) {
      this.$this = t0;
    },
    EnumProperty: function EnumProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _._description = t0;
      _.ifNull = t1;
      _.ifEmpty = t2;
      _.tooltip = t3;
      _.missingIfNull = t4;
      _._value = t5;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t6;
      _._defaultLevel = t7;
      _.name = t8;
      _.showSeparator = t9;
      _.showName = t10;
      _.style = t11;
      _.$ti = t12;
    },
    ObjectFlagProperty: function ObjectFlagProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) {
      var _ = this;
      _.ifPresent = t0;
      _._description = t1;
      _.ifNull = t2;
      _.ifEmpty = t3;
      _.tooltip = t4;
      _.missingIfNull = t5;
      _._value = t6;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t7;
      _._defaultLevel = t8;
      _.name = t9;
      _.showSeparator = t10;
      _.showName = t11;
      _.style = t12;
      _.$ti = t13;
    },
    DiagnosticsProperty: function DiagnosticsProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _._description = t0;
      _.ifNull = t1;
      _.ifEmpty = t2;
      _.tooltip = t3;
      _.missingIfNull = t4;
      _._value = t5;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t6;
      _._defaultLevel = t7;
      _.name = t8;
      _.showSeparator = t9;
      _.showName = t10;
      _.style = t11;
      _.$ti = t12;
    },
    DiagnosticableNode: function DiagnosticableNode(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.value = t0;
      _._cachedBuilder = null;
      _.name = t1;
      _.showSeparator = t2;
      _.showName = t3;
      _.style = t4;
      _.$ti = t5;
    },
    _DiagnosticableTreeNode: function _DiagnosticableTreeNode(t0, t1, t2, t3, t4) {
      var _ = this;
      _.value = t0;
      _._cachedBuilder = null;
      _.name = t1;
      _.showSeparator = t2;
      _.showName = t3;
      _.style = t4;
    },
    DiagnosticPropertiesBuilder: function DiagnosticPropertiesBuilder(t0, t1) {
      this.properties = t0;
      this.defaultDiagnosticsTreeStyle = t1;
      this.emptyBodyDescription = null;
    },
    Diagnosticable: function Diagnosticable() {
    },
    Diagnosticable_toString_closure: function Diagnosticable_toString_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.minLevel = t2;
    },
    DiagnosticableTree: function DiagnosticableTree() {
    },
    DiagnosticableTreeMixin: function DiagnosticableTreeMixin() {
    },
    DiagnosticableTreeMixin_toStringShallow_closure: function DiagnosticableTreeMixin_toStringShallow_closure(t0) {
      this.minLevel = t0;
    },
    MouseTrackerAnnotation: function MouseTrackerAnnotation() {
    },
    _TrackedAnnotation: function _TrackedAnnotation(t0, t1) {
      this.annotation = t0;
      this.activeDevices = t1;
    },
    MouseTracker: function MouseTracker(t0, t1, t2) {
      this.annotationFinder = t0;
      this._trackedAnnotations = t1;
      this._lastMouseEvent = t2;
    },
    MouseTracker__scheduleMousePositionCheck_closure: function MouseTracker__scheduleMousePositionCheck_closure(t0) {
      this.$this = t0;
    },
    MouseTracker_collectMousePositions_exitAnnotation: function MouseTracker_collectMousePositions_exitAnnotation(t0) {
      this.$this = t0;
    },
    MouseTracker_collectMousePositions_exitAllDevices: function MouseTracker_collectMousePositions_exitAllDevices(t0) {
      this.exitAnnotation = t0;
    },
    DialogTheme: function DialogTheme(t0, t1, t2, t3, t4) {
      var _ = this;
      _.backgroundColor = t0;
      _.elevation = t1;
      _.shape = t2;
      _.titleTextStyle = t3;
      _.contentTextStyle = t4;
    },
    InkHighlight: function InkHighlight(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _._shape = t0;
      _._borderRadius = t1;
      _._customBorder = t2;
      _._rectCallback = t3;
      _._ink_highlight$_textDirection = t4;
      _._ink_highlight$_alphaController = _._ink_highlight$_alpha = null;
      _._ink_highlight$_active = true;
      _._ink_well$_color = t5;
      _._material$_controller = t6;
      _.referenceBox = t7;
      _.onRemoved = t8;
      _._debugDisposed = false;
    },
    BorderSide$: function(color, style, width) {
      return new Y.BorderSide(color, width, style);
    },
    BorderSide_merge: function(a, b) {
      var t1, aIsNone, t2, bIsNone, t3;
      H.assertHelper(Y.BorderSide_canMerge(a, b));
      t1 = a.style;
      aIsNone = t1 === C.BorderStyle_0 && a.width === 0;
      t2 = b.style;
      bIsNone = t2 === C.BorderStyle_0 && b.width === 0;
      if (aIsNone && bIsNone)
        return C.BorderSide_m7u;
      if (aIsNone)
        return b;
      if (bIsNone)
        return a;
      t3 = a.color;
      H.assertHelper(J.$eq$(t3, b.color));
      H.assertHelper(t1 === t2);
      return Y.BorderSide$(t3, t1, a.width + b.width);
    },
    BorderSide_canMerge: function(a, b) {
      var t2,
        t1 = a.style;
      if (!(t1 === C.BorderStyle_0 && a.width === 0))
        t2 = b.style === C.BorderStyle_0 && b.width === 0;
      else
        t2 = true;
      if (t2)
        return true;
      return t1 === b.style && J.$eq$(a.color, b.color);
    },
    BorderSide_lerp: function(a, b, t) {
      var width, t1, t2, colorA, colorB;
      if (t === 0)
        return a;
      if (t === 1)
        return b;
      width = P.lerpDouble(a.width, b.width, t);
      if (typeof width !== "number")
        return width.$lt();
      if (width < 0)
        return C.BorderSide_m7u;
      t1 = a.style;
      t2 = b.style;
      if (t1 === t2)
        return Y.BorderSide$(P.Color_lerp(a.color, b.color, t), t1, width);
      switch (t1) {
        case C.BorderStyle_1:
          colorA = a.color;
          break;
        case C.BorderStyle_0:
          t1 = a.color.value;
          colorA = P.Color$fromARGB(0, (16711680 & t1) >>> 16, (65280 & t1) >>> 8, (255 & t1) >>> 0);
          break;
        default:
          colorA = null;
      }
      switch (t2) {
        case C.BorderStyle_1:
          colorB = b.color;
          break;
        case C.BorderStyle_0:
          t1 = b.color.value;
          colorB = P.Color$fromARGB(0, (16711680 & t1) >>> 16, (65280 & t1) >>> 8, (255 & t1) >>> 0);
          break;
        default:
          colorB = null;
      }
      return Y.BorderSide$(P.Color_lerp(colorA, colorB, t), C.BorderStyle_1, width);
    },
    ShapeBorder_lerp: function(a, b, t) {
      var result, t1;
      H.assertHelper(t != null);
      result = b != null ? b.lerpFrom$2(a, t) : null;
      if (result == null && a != null)
        result = a.lerpTo$2(b, t);
      if (result == null) {
        if (typeof t !== "number")
          return t.$lt();
        t1 = t < 0.5 ? a : b;
      } else
        t1 = result;
      return t1;
    },
    _CompoundBorder$: function(borders) {
      return new Y._CompoundBorder(borders);
    },
    _CompoundBorder_lerp: function(a, b, t) {
      var aList, bList, results, $length, index, localA, localB, t2, localResult,
        t1 = a instanceof Y._CompoundBorder;
      H.assertHelper(t1 || b instanceof Y._CompoundBorder);
      aList = t1 ? a.borders : H.setRuntimeTypeInfo([a], [Y.ShapeBorder]);
      bList = b instanceof Y._CompoundBorder ? b.borders : H.setRuntimeTypeInfo([b], [Y.ShapeBorder]);
      results = H.setRuntimeTypeInfo([], [Y.ShapeBorder]);
      $length = Math.max(aList.length, bList.length);
      for (t1 = 1 - t, index = 0; index < $length; ++index) {
        localA = index < aList.length ? aList[index] : null;
        localB = index < bList.length ? bList[index] : null;
        t2 = localA != null;
        if (t2 && localB != null) {
          localResult = localA.lerpTo$2(localB, t);
          if (localResult == null)
            localResult = localB.lerpFrom$2(localA, t);
          if (localResult != null) {
            C.JSArray_methods.add$1(results, localResult);
            continue;
          }
        }
        if (localB != null)
          C.JSArray_methods.add$1(results, localB.scale$1(t));
        if (t2)
          C.JSArray_methods.add$1(results, localA.scale$1(t1));
      }
      return Y._CompoundBorder$(results);
    },
    paintBorder: function(canvas, rect, bottom, left, right, $top) {
      H.assertHelper(canvas != null);
      H.assertHelper(right != null);
      H.assertHelper(left != null);
      new P.Paint(new DataView(new ArrayBuffer(75))).set$strokeWidth(0);
      H.throwExpression(P.UnimplementedError$(null));
    },
    BorderStyle: function BorderStyle(t0) {
      this._borders$_name = t0;
    },
    BorderSide: function BorderSide(t0, t1, t2) {
      this.color = t0;
      this.width = t1;
      this.style = t2;
    },
    ShapeBorder: function ShapeBorder() {
    },
    _CompoundBorder: function _CompoundBorder(t0) {
      this.borders = t0;
    },
    _CompoundBorder_dimensions_closure: function _CompoundBorder_dimensions_closure() {
    },
    _CompoundBorder_scale_closure: function _CompoundBorder_scale_closure(t0) {
      this.t = t0;
    },
    _CompoundBorder_toString_closure: function _CompoundBorder_toString_closure() {
    },
    IconTheme$: function(child, data, key) {
      return new Y.IconTheme(data, child, key);
    },
    IconTheme_merge: function(child, data) {
      return T.Builder$(new Y.IconTheme_merge_closure(null, data, child));
    },
    IconTheme__getInheritedIconThemeData: function(context) {
      var iconTheme = H.interceptedTypeCheck(context.inheritFromWidgetOfExactType$1(C.Type_IconTheme_U8c), "$isIconTheme"),
        t1 = iconTheme == null ? null : iconTheme.data;
      return t1 == null ? C.IconThemeData_Color_4278190080_1_24 : t1;
    },
    IconTheme: function IconTheme(t0, t1, t2) {
      this.data = t0;
      this.child = t1;
      this.key = t2;
    },
    IconTheme_merge_closure: function IconTheme_merge_closure(t0, t1, t2) {
      this.key = t0;
      this.data = t1;
      this.child = t2;
    }
  },
  X = {AnimationStatus: function AnimationStatus(t0) {
      this._animation$_name = t0;
    }, Animation: function Animation() {
    },
    ThemeData_ThemeData: function(brightness, fontFamily, platform, primarySwatch, textTheme) {
      var isDark, primaryColor, primaryColorBrightness, primaryColorLight, primaryColorDark, primaryIsDark, toggleableActiveColor, accentColor, accentColorBrightness, accentIsDark, canvasColor, bottomAppBarColor, cardColor, dividerColor, primaryIsDark0, secondary, t1, t2, t3, t4, t5, t6, t7, t8, t9, colorScheme, selectedRowColor, unselectedWidgetColor, secondaryHeaderColor, textSelectionColor, textSelectionHandleColor, backgroundColor, dialogBackgroundColor, indicatorColor, hintColor, errorColor, primaryIconTheme, accentIconTheme, iconTheme, typography, primaryTextTheme, accentTextTheme, buttonColor, buttonTheme, disabledColor, highlightColor, splashColor, chipTheme, _null = null;
      if (brightness == null)
        brightness = C.Brightness_1;
      isDark = brightness === C.Brightness_0;
      if (primarySwatch == null)
        primarySwatch = C.MaterialColor_Map_JNwaj_4280391411;
      primaryColor = isDark ? C.Map_HFpTk.$index(0, 900) : primarySwatch;
      primaryColorBrightness = X.ThemeData_estimateBrightnessForColor(primaryColor);
      primaryColorLight = isDark ? C.Map_HFpTk.$index(0, 500) : primarySwatch._swatch.$index(0, H.assertSubtypeOfRuntimeType(100, H.getRuntimeTypeArgument(primarySwatch, "ColorSwatch", 0)));
      primaryColorDark = isDark ? C.Color_4278190080 : primarySwatch._swatch.$index(0, H.assertSubtypeOfRuntimeType(700, H.getRuntimeTypeArgument(primarySwatch, "ColorSwatch", 0)));
      primaryIsDark = primaryColorBrightness === C.Brightness_0;
      if (isDark)
        toggleableActiveColor = C.Map_iTYZn.$index(0, 200);
      else
        toggleableActiveColor = primarySwatch._swatch.$index(0, H.assertSubtypeOfRuntimeType(600, H.getRuntimeTypeArgument(primarySwatch, "ColorSwatch", 0)));
      accentColor = isDark ? C.Map_iTYZn.$index(0, 200) : primarySwatch._swatch.$index(0, H.assertSubtypeOfRuntimeType(500, H.getRuntimeTypeArgument(primarySwatch, "ColorSwatch", 0)));
      accentColorBrightness = X.ThemeData_estimateBrightnessForColor(accentColor);
      accentIsDark = accentColorBrightness === C.Brightness_0;
      canvasColor = isDark ? C.Map_HFpTk.$index(0, 850) : C.Map_HFpTk.$index(0, 50);
      bottomAppBarColor = isDark ? C.Map_HFpTk.$index(0, 800) : C.Color_4294967295;
      cardColor = isDark ? C.Map_HFpTk.$index(0, 800) : C.Color_4294967295;
      dividerColor = isDark ? C.Color_536870911 : C.Color_520093696;
      primaryIsDark0 = X.ThemeData_estimateBrightnessForColor(primarySwatch) === C.Brightness_0;
      if (accentColor == null)
        secondary = isDark ? C.Map_iTYZn.$index(0, 200) : primarySwatch;
      else
        secondary = accentColor;
      t1 = X.ThemeData_estimateBrightnessForColor(secondary);
      if (primaryColorDark == null)
        t2 = isDark ? C.Color_4278190080 : primarySwatch._swatch.$index(0, H.assertSubtypeOfRuntimeType(700, H.getRuntimeTypeArgument(primarySwatch, "ColorSwatch", 0)));
      else
        t2 = primaryColorDark;
      t3 = isDark ? C.Map_iTYZn.$index(0, 700) : primarySwatch._swatch.$index(0, H.assertSubtypeOfRuntimeType(700, H.getRuntimeTypeArgument(primarySwatch, "ColorSwatch", 0)));
      if (cardColor == null)
        t4 = isDark ? C.Map_HFpTk.$index(0, 800) : C.Color_4294967295;
      else
        t4 = cardColor;
      t5 = isDark ? C.Map_HFpTk.$index(0, 700) : primarySwatch._swatch.$index(0, H.assertSubtypeOfRuntimeType(200, H.getRuntimeTypeArgument(primarySwatch, "ColorSwatch", 0)));
      t6 = C.Map_JNc9P.$index(0, 700);
      t7 = primaryIsDark0 ? C.Color_4294967295 : C.Color_4278190080;
      t1 = t1 === C.Brightness_0 ? C.Color_4294967295 : C.Color_4278190080;
      t8 = isDark ? C.Color_4294967295 : C.Color_4278190080;
      t9 = primaryIsDark0 ? C.Color_4294967295 : C.Color_4278190080;
      colorScheme = A.ColorScheme$(t5, brightness, t6, t9, isDark ? C.Color_4278190080 : C.Color_4294967295, t7, t1, t8, primarySwatch, t2, secondary, t3, t4);
      selectedRowColor = C.Map_HFpTk.$index(0, 100);
      unselectedWidgetColor = isDark ? C.Color_3019898879 : C.Color_2315255808;
      secondaryHeaderColor = isDark ? C.Map_HFpTk.$index(0, 700) : primarySwatch._swatch.$index(0, H.assertSubtypeOfRuntimeType(50, H.getRuntimeTypeArgument(primarySwatch, "ColorSwatch", 0)));
      textSelectionColor = isDark ? accentColor : primarySwatch._swatch.$index(0, H.assertSubtypeOfRuntimeType(200, H.getRuntimeTypeArgument(primarySwatch, "ColorSwatch", 0)));
      textSelectionHandleColor = isDark ? C.Map_iTYZn.$index(0, 400) : primarySwatch._swatch.$index(0, H.assertSubtypeOfRuntimeType(300, H.getRuntimeTypeArgument(primarySwatch, "ColorSwatch", 0)));
      backgroundColor = isDark ? C.Map_HFpTk.$index(0, 700) : primarySwatch._swatch.$index(0, H.assertSubtypeOfRuntimeType(200, H.getRuntimeTypeArgument(primarySwatch, "ColorSwatch", 0)));
      dialogBackgroundColor = isDark ? C.Map_HFpTk.$index(0, 800) : C.Color_4294967295;
      indicatorColor = J.$eq$(accentColor, primaryColor) ? C.Color_4294967295 : accentColor;
      hintColor = isDark ? C.Color_2164260863 : C.Color_2315255808;
      errorColor = C.Map_JNc9P.$index(0, 700);
      primaryIconTheme = primaryIsDark ? C.IconThemeData_Color_4294967295_null_null : C.IconThemeData_Color_4278190080_null_null;
      accentIconTheme = accentIsDark ? C.IconThemeData_Color_4294967295_null_null : C.IconThemeData_Color_4278190080_null_null;
      iconTheme = isDark ? C.IconThemeData_Color_4294967295_null_null : C.IconThemeData_Color_3707764736_null_null;
      if (platform == null)
        platform = T.defaultTargetPlatform();
      typography = U.Typography_Typography(_null, _null, _null, platform, _null, _null);
      textTheme = (isDark ? typography.white : typography.black).merge$1(textTheme);
      primaryTextTheme = (primaryIsDark ? typography.white : typography.black).merge$1(_null);
      accentTextTheme = (accentIsDark ? typography.white : typography.black).merge$1(_null);
      if (fontFamily != null) {
        textTheme = textTheme.apply$1$fontFamily(fontFamily);
        primaryTextTheme = primaryTextTheme.apply$1$fontFamily(fontFamily);
        accentTextTheme = accentTextTheme.apply$1$fontFamily(fontFamily);
      }
      buttonColor = isDark ? primarySwatch._swatch.$index(0, H.assertSubtypeOfRuntimeType(600, H.getRuntimeTypeArgument(primarySwatch, "ColorSwatch", 0))) : C.Map_HFpTk.$index(0, 300);
      buttonTheme = M.ButtonThemeData$(false, buttonColor, colorScheme, _null, 36, _null, C.ButtonBarLayoutBehavior_1, C.MaterialTapTargetSize_0, 88, _null, _null, _null, C.ButtonTextTheme_0);
      disabledColor = isDark ? C.Color_1308622847 : C.Color_1627389952;
      highlightColor = isDark ? C.Color_1087163596 : C.Color_1723645116;
      splashColor = isDark ? C.Color_1087163596 : C.Color_1724434632;
      chipTheme = K.ChipThemeData_ChipThemeData$fromDefaults(brightness, textTheme.body2, primaryColor);
      return X.ThemeData$raw(accentColor, accentColorBrightness, accentIconTheme, accentTextTheme, C.AppBarTheme_ccN, backgroundColor, bottomAppBarColor, C.BottomAppBarTheme_null_null_null, brightness, buttonColor, buttonTheme, canvasColor, cardColor, C.CardTheme_eHw, chipTheme, colorScheme, _null, C.Color_4282549748, dialogBackgroundColor, C.DialogTheme_maI, disabledColor, dividerColor, errorColor, C.FloatingActionButtonThemeData_OQe, highlightColor, hintColor, iconTheme, indicatorColor, C.C_InputDecorationTheme, C.MaterialTapTargetSize_0, C.C_PageTransitionsTheme, platform, primaryColor, primaryColorBrightness, primaryColorDark, primaryColorLight, primaryIconTheme, primaryTextTheme, canvasColor, secondaryHeaderColor, selectedRowColor, C.SliderThemeData_b1k, C.SnackBarThemeData_cWd, splashColor, C.C__InkSplashFactory, C.TabBarTheme_Srx, textSelectionColor, textSelectionHandleColor, textTheme, toggleableActiveColor, typography, unselectedWidgetColor);
    },
    ThemeData$raw: function(accentColor, accentColorBrightness, accentIconTheme, accentTextTheme, appBarTheme, backgroundColor, bottomAppBarColor, bottomAppBarTheme, brightness, buttonColor, buttonTheme, canvasColor, cardColor, cardTheme, chipTheme, colorScheme, cupertinoOverrideTheme, cursorColor, dialogBackgroundColor, dialogTheme, disabledColor, dividerColor, errorColor, floatingActionButtonTheme, highlightColor, hintColor, iconTheme, indicatorColor, inputDecorationTheme, materialTapTargetSize, pageTransitionsTheme, platform, primaryColor, primaryColorBrightness, primaryColorDark, primaryColorLight, primaryIconTheme, primaryTextTheme, scaffoldBackgroundColor, secondaryHeaderColor, selectedRowColor, sliderTheme, snackBarTheme, splashColor, splashFactory, tabBarTheme, textSelectionColor, textSelectionHandleColor, textTheme, toggleableActiveColor, typography, unselectedWidgetColor) {
      return new X.ThemeData(brightness, primaryColor, primaryColorBrightness, primaryColorLight, primaryColorDark, canvasColor, accentColor, accentColorBrightness, scaffoldBackgroundColor, bottomAppBarColor, cardColor, dividerColor, highlightColor, splashColor, splashFactory, selectedRowColor, unselectedWidgetColor, disabledColor, buttonTheme, buttonColor, secondaryHeaderColor, textSelectionColor, cursorColor, textSelectionHandleColor, backgroundColor, dialogBackgroundColor, indicatorColor, hintColor, errorColor, toggleableActiveColor, textTheme, primaryTextTheme, accentTextTheme, inputDecorationTheme, iconTheme, primaryIconTheme, accentIconTheme, sliderTheme, tabBarTheme, cardTheme, chipTheme, platform, materialTapTargetSize, pageTransitionsTheme, appBarTheme, bottomAppBarTheme, colorScheme, snackBarTheme, dialogTheme, floatingActionButtonTheme, typography, cupertinoOverrideTheme);
    },
    ThemeData_ThemeData$fallback: function() {
      var _null = null;
      return X.ThemeData_ThemeData(C.Brightness_1, _null, _null, _null, _null);
    },
    ThemeData_localize: function(baseTheme, localTextGeometry) {
      H.assertHelper(baseTheme != null);
      H.assertHelper(localTextGeometry != null);
      return $.$get$ThemeData__localizedThemeDataCache().putIfAbsent$2(new X._IdentityThemeDataCacheKey(baseTheme, localTextGeometry), new X.ThemeData_localize_closure(baseTheme, localTextGeometry));
    },
    ThemeData_estimateBrightnessForColor: function(color) {
      var t1 = color.value;
      t1 = 0.2126 * P.Color__linearizeColorComponent(((16711680 & t1) >>> 16) / 255) + 0.7152 * P.Color__linearizeColorComponent(((65280 & t1) >>> 8) / 255) + 0.0722 * P.Color__linearizeColorComponent(((255 & t1) >>> 0) / 255) + 0.05;
      if (t1 * t1 > 0.15)
        return C.Brightness_1;
      return C.Brightness_0;
    },
    MaterialTapTargetSize: function MaterialTapTargetSize(t0) {
      this._theme_data$_name = t0;
    },
    ThemeData: function ThemeData(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51) {
      var _ = this;
      _.brightness = t0;
      _.primaryColor = t1;
      _.primaryColorBrightness = t2;
      _.primaryColorLight = t3;
      _.primaryColorDark = t4;
      _.canvasColor = t5;
      _.accentColor = t6;
      _.accentColorBrightness = t7;
      _.scaffoldBackgroundColor = t8;
      _.bottomAppBarColor = t9;
      _.cardColor = t10;
      _.dividerColor = t11;
      _.highlightColor = t12;
      _.splashColor = t13;
      _.splashFactory = t14;
      _.selectedRowColor = t15;
      _.unselectedWidgetColor = t16;
      _.disabledColor = t17;
      _.buttonTheme = t18;
      _.buttonColor = t19;
      _.secondaryHeaderColor = t20;
      _.textSelectionColor = t21;
      _.cursorColor = t22;
      _.textSelectionHandleColor = t23;
      _.backgroundColor = t24;
      _.dialogBackgroundColor = t25;
      _.indicatorColor = t26;
      _.hintColor = t27;
      _.errorColor = t28;
      _.toggleableActiveColor = t29;
      _.textTheme = t30;
      _.primaryTextTheme = t31;
      _.accentTextTheme = t32;
      _.inputDecorationTheme = t33;
      _.iconTheme = t34;
      _.primaryIconTheme = t35;
      _.accentIconTheme = t36;
      _.sliderTheme = t37;
      _.tabBarTheme = t38;
      _.cardTheme = t39;
      _.chipTheme = t40;
      _.platform = t41;
      _.materialTapTargetSize = t42;
      _.pageTransitionsTheme = t43;
      _.appBarTheme = t44;
      _.bottomAppBarTheme = t45;
      _.colorScheme = t46;
      _.snackBarTheme = t47;
      _.dialogTheme = t48;
      _.floatingActionButtonTheme = t49;
      _.typography = t50;
      _.cupertinoOverrideTheme = t51;
    },
    ThemeData_localize_closure: function ThemeData_localize_closure(t0, t1) {
      this.baseTheme = t0;
      this.localTextGeometry = t1;
    },
    MaterialBasedCupertinoThemeData: function MaterialBasedCupertinoThemeData(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._materialTheme = t0;
      _._brightness = t1;
      _._primaryColor = t2;
      _._primaryContrastingColor = t3;
      _._textTheme = t4;
      _._barBackgroundColor = t5;
      _._scaffoldBackgroundColor = t6;
    },
    _IdentityThemeDataCacheKey: function _IdentityThemeDataCacheKey(t0, t1) {
      this.baseTheme = t0;
      this.localTextGeometry = t1;
    },
    _FifoCache: function _FifoCache(t0, t1, t2) {
      this._cache = t0;
      this._maximumSize = t1;
      this.$ti = t2;
    },
    CircleBorder: function CircleBorder(t0) {
      this.side = t0;
    },
    DecorationImage: function DecorationImage() {
    },
    RoundedRectangleBorder$: function(borderRadius, side) {
      return new X.RoundedRectangleBorder(side, borderRadius);
    },
    _RoundedRectangleToCircleBorder$: function(borderRadius, circleness, side) {
      return new X._RoundedRectangleToCircleBorder(side, borderRadius, circleness);
    },
    RoundedRectangleBorder: function RoundedRectangleBorder(t0, t1) {
      this.side = t0;
      this.borderRadius = t1;
    },
    _RoundedRectangleToCircleBorder: function _RoundedRectangleToCircleBorder(t0, t1, t2) {
      this.side = t0;
      this.borderRadius = t1;
      this.circleness = t2;
    },
    SystemChrome_setApplicationSwitcherDescription: function(description) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1);
      var $async$SystemChrome_setApplicationSwitcherDescription = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait(C.OptionalMethodChannel_cWd.invokeMethod$1$2("SystemChrome.setApplicationSwitcherDescription", P.LinkedHashMap_LinkedHashMap$_literal(["label", description.label, "primaryColor", description.primaryColor], P.String, null), -1), $async$SystemChrome_setApplicationSwitcherDescription);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$SystemChrome_setApplicationSwitcherDescription, $async$completer);
    },
    ApplicationSwitcherDescription: function ApplicationSwitcherDescription(t0, t1) {
      this.label = t0;
      this.primaryColor = t1;
    },
    SystemUiOverlayStyle: function SystemUiOverlayStyle(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.systemNavigationBarColor = t0;
      _.systemNavigationBarDividerColor = t1;
      _.systemNavigationBarIconBrightness = t2;
      _.statusBarColor = t3;
      _.statusBarBrightness = t4;
      _.statusBarIconBrightness = t5;
    },
    TextSelection$: function(baseOffset, extentOffset) {
      var t1, t2;
      if (typeof baseOffset !== "number")
        return baseOffset.$lt();
      if (typeof extentOffset !== "number")
        return H.iae(extentOffset);
      t1 = baseOffset < extentOffset;
      if (t1)
        t2 = extentOffset;
      else
        t2 = baseOffset;
      if (t1)
        t1 = baseOffset;
      else
        t1 = extentOffset;
      return new X.TextSelection(baseOffset, extentOffset, t1, t2);
    },
    TextRange: function TextRange() {
    },
    TextSelection: function TextSelection(t0, t1, t2, t3) {
      var _ = this;
      _.baseOffset = t0;
      _.extentOffset = t1;
      _.start = t2;
      _.end = t3;
    },
    AnnotatedRegion: function AnnotatedRegion(t0, t1, t2, t3) {
      var _ = this;
      _.value = t0;
      _.child = t1;
      _.key = t2;
      _.$ti = t3;
    },
    IconData: function IconData(t0, t1, t2) {
      this.codePoint = t0;
      this.fontFamily = t1;
      this.matchTextDirection = t2;
    },
    ModalBarrier$: function(barrierSemanticsDismissible, color, dismissible, semanticsLabel) {
      return new X.ModalBarrier(color, false, true, semanticsLabel, null);
    },
    ModalBarrier: function ModalBarrier(t0, t1, t2, t3, t4) {
      var _ = this;
      _.color = t0;
      _.dismissible = t1;
      _.barrierSemanticsDismissible = t2;
      _.semanticsLabel = t3;
      _.key = t4;
    },
    ModalBarrier_build_closure: function ModalBarrier_build_closure(t0, t1) {
      this.$this = t0;
      this.context = t1;
    },
    OverlayEntry$: function(builder, maintainState) {
      return new X.OverlayEntry(builder, maintainState, new N.LabeledGlobalKey(null, [X._OverlayEntryState]));
    },
    Overlay_of: function(context, debugRequiredFor) {
      var result = H.interceptedTypeCheck(context.ancestorStateOfType$1(C.C_TypeMatcher), "$isOverlayState");
      H.assertHelper(new X.Overlay_of_closure(debugRequiredFor, result, context).call$0());
      return result;
    },
    _Theatre$: function(offstage, onstage) {
      return new X._Theatre(onstage, offstage, null);
    },
    OverlayEntry: function OverlayEntry(t0, t1, t2) {
      var _ = this;
      _.builder = t0;
      _._opaque = false;
      _._maintainState = t1;
      _._overlay = null;
      _._key = t2;
    },
    OverlayEntry_remove_closure: function OverlayEntry_remove_closure(t0, t1) {
      this.$this = t0;
      this.overlay = t1;
    },
    _OverlayEntry: function _OverlayEntry(t0, t1) {
      this.entry = t0;
      this.key = t1;
    },
    _OverlayEntryState: function _OverlayEntryState(t0) {
      this._widget = null;
      this._debugLifecycleState = t0;
      this._element = null;
    },
    _OverlayEntryState__markNeedsBuild_closure: function _OverlayEntryState__markNeedsBuild_closure() {
    },
    Overlay: function Overlay(t0, t1) {
      this.initialEntries = t0;
      this.key = t1;
    },
    Overlay_of_closure: function Overlay_of_closure(t0, t1, t2) {
      this.debugRequiredFor = t0;
      this.result = t1;
      this.context = t2;
    },
    OverlayState: function OverlayState(t0, t1, t2) {
      var _ = this;
      _._entries = t0;
      _.TickerProviderStateMixin__tickers = t1;
      _._widget = null;
      _._debugLifecycleState = t2;
      _._element = null;
    },
    OverlayState_insert_closure: function OverlayState_insert_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.below = t1;
      _.above = t2;
      _.entry = t3;
    },
    OverlayState_insertAll_closure: function OverlayState_insertAll_closure(t0) {
      this.$this = t0;
    },
    OverlayState_insertAll_closure0: function OverlayState_insertAll_closure0() {
    },
    OverlayState_insertAll_closure1: function OverlayState_insertAll_closure1(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.below = t1;
      _.above = t2;
      _.entries = t3;
    },
    OverlayState__remove_closure: function OverlayState__remove_closure(t0, t1) {
      this.$this = t0;
      this.entry = t1;
    },
    OverlayState__didChangeEntryOpacity_closure: function OverlayState__didChangeEntryOpacity_closure() {
    },
    _Theatre: function _Theatre(t0, t1, t2) {
      this.onstage = t0;
      this.offstage = t1;
      this.key = t2;
    },
    _TheatreElement: function _TheatreElement(t0, t1, t2, t3) {
      var _ = this;
      _._offstage = _._onstage = null;
      _._forgottenOffstageChildren = t0;
      _._framework$_parent = _._ancestorRenderObjectElement = _._renderObject = null;
      _._cachedHash = t1;
      _._depth = _._slot = null;
      _._widget = t2;
      _._owner = null;
      _._active = false;
      _._debugLifecycleState = t3;
      _._dependencies = _._inheritedWidgets = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._debugAllowIgnoredCallsToMarkNeedsBuild = _._debugBuiltOnce = _._inDirtyList = false;
    },
    _RenderTheatre: function _RenderTheatre(t0, t1, t2, t3) {
      var _ = this;
      _.ContainerRenderObjectMixin__childCount = t0;
      _.ContainerRenderObjectMixin__firstChild = t1;
      _.ContainerRenderObjectMixin__lastChild = t2;
      _.RenderObjectWithChildMixin__child = t3;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    _OverlayState_State_TickerProviderStateMixin_dispose_closure: function _OverlayState_State_TickerProviderStateMixin_dispose_closure(t0) {
      this.$this = t0;
    },
    _OverlayState_State_TickerProviderStateMixin: function _OverlayState_State_TickerProviderStateMixin() {
    },
    __RenderTheatre_RenderBox_RenderObjectWithChildMixin: function __RenderTheatre_RenderBox_RenderObjectWithChildMixin() {
    },
    __RenderTheatre_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin: function __RenderTheatre_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin() {
    },
    __RenderTheatre_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin_ContainerRenderObjectMixin: function __RenderTheatre_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin_ContainerRenderObjectMixin() {
    },
    HapticFeedback_vibrate: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1);
      var $async$HapticFeedback_vibrate = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait(C.OptionalMethodChannel_cWd.invokeMethod$1$1("HapticFeedback.vibrate", -1), $async$HapticFeedback_vibrate);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$HapticFeedback_vibrate, $async$completer);
    }
  },
  G = {
    AnimationController$: function(debugLabel, duration, lowerBound, upperBound, value, vsync) {
      var t1 = {func: 1, ret: -1, args: [X.AnimationStatus]},
        t2 = {func: 1, ret: -1};
      t2 = new G.AnimationController(lowerBound, upperBound, debugLabel, duration, C._AnimationDirection_0, C.AnimationStatus_0, new R.ObserverList(H.setRuntimeTypeInfo([], [t1]), [t1]), new R.ObserverList(H.setRuntimeTypeInfo([], [t2]), [t2]));
      t2._ticker = vsync.createTicker$1(t2.get$_tick());
      t2._internalSetValue$1(value == null ? lowerBound : value);
      return t2;
    },
    _AnimationDirection: function _AnimationDirection(t0) {
      this._animation_controller$_name = t0;
    },
    AnimationBehavior: function AnimationBehavior(t0) {
      this._animation_controller$_name = t0;
    },
    AnimationController: function AnimationController(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.lowerBound = t0;
      _.upperBound = t1;
      _.debugLabel = t2;
      _.duration = t3;
      _._animation_controller$_value = _._simulation = _._ticker = null;
      _._direction = t4;
      _._status = null;
      _._lastReportedStatus = t5;
      _.AnimationLocalStatusListenersMixin__statusListeners = t6;
      _.AnimationLocalListenersMixin__listeners = t7;
    },
    AnimationController_forward_closure: function AnimationController_forward_closure(t0) {
      this.$this = t0;
    },
    AnimationController_reverse_closure: function AnimationController_reverse_closure(t0) {
      this.$this = t0;
    },
    AnimationController__animateToInternal_closure: function AnimationController__animateToInternal_closure(t0) {
      this.$this = t0;
    },
    AnimationController_dispose_closure: function AnimationController_dispose_closure(t0) {
      this.$this = t0;
    },
    _InterpolationSimulation: function _InterpolationSimulation(t0, t1, t2, t3, t4) {
      var _ = this;
      _._durationInSeconds = t0;
      _._begin = t1;
      _._animation_controller$_end = t2;
      _._curve = t3;
      _.tolerance = t4;
    },
    _AnimationController_Animation_AnimationEagerListenerMixin: function _AnimationController_Animation_AnimationEagerListenerMixin() {
    },
    _AnimationController_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin: function _AnimationController_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin() {
    },
    _AnimationController_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin: function _AnimationController_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin() {
    },
    WriteBuffer$: function() {
      var t1 = new G.WriteBuffer(),
        t2 = new Uint8Array(0);
      t1._serialization$_buffer = new N.Uint8Buffer(t2, t2.length);
      t2 = new DataView(new ArrayBuffer(8));
      t1._eightBytes = t2;
      t2 = t2.buffer;
      t2.toString;
      t1._eightBytesAsList = H.NativeUint8List_NativeUint8List$view(t2, 0, null);
      return t1;
    },
    WriteBuffer: function WriteBuffer() {
      this._eightBytesAsList = this._eightBytes = this._serialization$_buffer = null;
    },
    ReadBuffer: function ReadBuffer(t0) {
      this.data = t0;
      this._serialization$_position = 0;
    },
    _synthesiseDownButtons: function(buttons, kind) {
      switch (kind) {
        case C.PointerDeviceKind_0:
        case C.PointerDeviceKind_2:
        case C.PointerDeviceKind_3:
          return buttons.$or(0, 1);
        default:
          return buttons;
      }
    },
    PointerEventConverter__ensureStateForPointer: function(datum, position) {
      return $.PointerEventConverter__pointers.putIfAbsent$2(datum.get$device(), new G.PointerEventConverter__ensureStateForPointer_closure(position));
    },
    PointerEventConverter_expand: function(data, devicePixelRatio) {
      return G.PointerEventConverter_expand$body(H.assertSubtype(data, "$isIterable", [P.PointerData], "$asIterable"), devicePixelRatio);
    },
    PointerEventConverter_expand$body: function($async$data, $async$devicePixelRatio) {
      return P._makeSyncStarIterable(function() {
        var data = $async$data,
          devicePixelRatio = $async$devicePixelRatio;
        var $async$goto = 0, $async$handler = 2, $async$currentError, t1, datum, t2, t3, position, radiusMinor, radiusMajor, radiusMin, radiusMax, timeStamp, kind, state, t4, t5, t6;
        return function $async$PointerEventConverter_expand($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = data.get$iterator(data);
              case 3:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 4;
                  break;
                }
                datum = t1.get$current();
                t2 = datum.get$physicalX() / devicePixelRatio;
                t3 = datum.get$physicalY() / devicePixelRatio;
                position = new P.Offset(t2, t3);
                radiusMinor = datum.get$radiusMinor().$div(0, devicePixelRatio);
                radiusMajor = datum.get$radiusMajor().$div(0, devicePixelRatio);
                radiusMin = datum.get$radiusMin().$div(0, devicePixelRatio);
                radiusMax = datum.get$radiusMax().$div(0, devicePixelRatio);
                timeStamp = datum.get$timeStamp(datum);
                kind = datum.get$kind();
                datum.get$change();
                datum.get$signalKind();
                datum.get$signalKind();
              case 5:
                // switch
                switch (datum.get$signalKind()) {
                  case C.PointerSignalKind_1:
                    // goto case
                    $async$goto = 7;
                    break;
                  case C.PointerSignalKind_0:
                    // goto case
                    $async$goto = 8;
                    break;
                  case C.PointerSignalKind_2:
                    // goto case
                    $async$goto = 9;
                    break;
                  default:
                    // goto after switch
                    $async$goto = 6;
                    break;
                }
                break;
              case 7:
                // case
                H.assertHelper($.PointerEventConverter__pointers.containsKey$1(datum.get$device()));
                state = G.PointerEventConverter__ensureStateForPointer(datum, position);
                $async$goto = !state.lastPosition.$eq(0, position) ? 10 : 11;
                break;
              case 10:
                // then
                $async$goto = state._down ? 12 : 14;
                break;
              case 12:
                // then
                state._converter$_pointer;
                datum.get$device();
                t2 = state.lastPosition;
                t3 = t2._dx;
                if (typeof t3 !== "number") {
                  H.iae(t3);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t2 = t2._dy;
                if (typeof t2 !== "number") {
                  H.iae(t2);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                G._synthesiseDownButtons(datum.get$buttons(), kind);
                datum.get$obscured();
                datum.get$pressure();
                datum.get$pressureMin();
                datum.get$pressureMax();
                datum.get$distanceMax();
                datum.get$size();
                datum.get$orientation();
                datum.get$tilt();
                $async$goto = 15;
                return null;
              case 15:
                // after yield
                // goto join
                $async$goto = 13;
                break;
              case 14:
                // else
                t4 = datum.get$device();
                t5 = state.lastPosition;
                t6 = t5._dx;
                if (typeof t6 !== "number") {
                  H.iae(t6);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t5 = t5._dy;
                if (typeof t5 !== "number") {
                  H.iae(t5);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 16;
                return new F.PointerHoverEvent(timeStamp, 0, kind, t4, position, new P.Offset(t2 - t6, t3 - t5), datum.get$buttons(), false, datum.get$obscured(), 0, datum.get$pressureMin(), datum.get$pressureMax(), datum.get$distance(), datum.get$distanceMax(), datum.get$size(), radiusMajor, radiusMinor, radiusMin, radiusMax, datum.get$orientation(), datum.get$tilt(), 0, true);
              case 16:
                // after yield
              case 13:
                // join
                state.lastPosition = position;
              case 11:
                // join
                $async$goto = 17;
                return new F.PointerScrollEvent(new P.Offset(datum.get$scrollDeltaX() / devicePixelRatio, datum.get$scrollDeltaY() / devicePixelRatio), timeStamp, 0, kind, datum.get$device(), position, C.Offset_0_0, 0, false, false, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, false);
              case 17:
                // after yield
                // goto after switch
                $async$goto = 6;
                break;
              case 8:
                // case
                H.assertHelper(false);
                // goto after switch
                $async$goto = 6;
                break;
              case 9:
                // case
                // goto after switch
                $async$goto = 6;
                break;
              case 6:
                // after switch
                // goto for condition
                $async$goto = 3;
                break;
              case 4:
                // after for
              case 1:
                // return
                return P._IterationMarker_endOfIteration();
              case 2:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, F.PointerEvent);
    },
    _PointerState: function _PointerState(t0) {
      this._converter$_pointer = null;
      this._down = false;
      this.lastPosition = t0;
    },
    PointerEventConverter__ensureStateForPointer_closure: function PointerEventConverter__ensureStateForPointer_closure(t0) {
      this.position = t0;
    },
    PointerSignalResolver: function PointerSignalResolver() {
      this._currentEvent = this._firstRegisteredCallback = null;
    },
    flipAxis: function(direction) {
      switch (direction) {
        case C.Axis_0:
          return C.Axis_1;
        case C.Axis_1:
          return C.Axis_0;
      }
      return;
    },
    RenderComparison: function RenderComparison(t0, t1) {
      this.index = t0;
      this._basic_types$_name = t1;
    },
    Axis: function Axis(t0) {
      this._basic_types$_name = t0;
    },
    VerticalDirection: function VerticalDirection(t0) {
      this._basic_types$_name = t0;
    },
    LogicalKeyboardKey_isControlCharacter: function(label) {
      var codeUnit, t1;
      if (label.length > 1)
        return false;
      codeUnit = J._codeUnitAt$1$s(label, 0);
      if (!(codeUnit <= 31 && true))
        t1 = codeUnit >= 127 && codeUnit <= 159;
      else
        t1 = true;
      return t1;
    },
    LogicalKeyboardKey: function LogicalKeyboardKey(t0, t1, t2) {
      this.keyId = t0;
      this.debugName = t1;
      this.keyLabel = t2;
    },
    PhysicalKeyboardKey: function PhysicalKeyboardKey(t0, t1) {
      this.usbHidUsage = t0;
      this.debugName = t1;
    },
    DecorationTween: function DecorationTween(t0, t1) {
      this.begin = t0;
      this.end = t1;
    },
    BorderRadiusTween: function BorderRadiusTween(t0, t1) {
      this.begin = t0;
      this.end = t1;
    },
    TextStyleTween: function TextStyleTween(t0, t1) {
      this.begin = t0;
      this.end = t1;
    },
    ImplicitlyAnimatedWidget: function ImplicitlyAnimatedWidget() {
    },
    ImplicitlyAnimatedWidgetState: function ImplicitlyAnimatedWidgetState() {
    },
    ImplicitlyAnimatedWidgetState_didUpdateWidget_closure: function ImplicitlyAnimatedWidgetState_didUpdateWidget_closure(t0) {
      this.$this = t0;
    },
    ImplicitlyAnimatedWidgetState__constructTweens_closure: function ImplicitlyAnimatedWidgetState__constructTweens_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    AnimatedWidgetBaseState: function AnimatedWidgetBaseState() {
    },
    AnimatedWidgetBaseState__handleAnimationChanged_closure: function AnimatedWidgetBaseState__handleAnimationChanged_closure() {
    },
    AnimatedDefaultTextStyle: function AnimatedDefaultTextStyle(t0, t1, t2, t3, t4) {
      var _ = this;
      _.child = t0;
      _.style = t1;
      _.curve = t2;
      _.duration = t3;
      _.key = t4;
    },
    _AnimatedDefaultTextStyleState: function _AnimatedDefaultTextStyleState(t0, t1) {
      var _ = this;
      _._animation = _._implicit_animations$_controller = _._implicit_animations$_style = null;
      _.SingleTickerProviderStateMixin__ticker = t0;
      _._widget = null;
      _._debugLifecycleState = t1;
      _._element = null;
    },
    _AnimatedDefaultTextStyleState_forEachTween_closure: function _AnimatedDefaultTextStyleState_forEachTween_closure() {
    },
    AnimatedPhysicalModel: function AnimatedPhysicalModel(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) {
      var _ = this;
      _.child = t0;
      _.shape = t1;
      _.clipBehavior = t2;
      _.borderRadius = t3;
      _.elevation = t4;
      _.color = t5;
      _.animateColor = t6;
      _.shadowColor = t7;
      _.curve = t8;
      _.duration = t9;
      _.key = t10;
    },
    _AnimatedPhysicalModelState: function _AnimatedPhysicalModelState(t0, t1) {
      var _ = this;
      _._animation = _._implicit_animations$_controller = _._implicit_animations$_shadowColor = _._implicit_animations$_color = _._implicit_animations$_elevation = _._implicit_animations$_borderRadius = null;
      _.SingleTickerProviderStateMixin__ticker = t0;
      _._widget = null;
      _._debugLifecycleState = t1;
      _._element = null;
    },
    _AnimatedPhysicalModelState_forEachTween_closure: function _AnimatedPhysicalModelState_forEachTween_closure() {
    },
    _AnimatedPhysicalModelState_forEachTween_closure0: function _AnimatedPhysicalModelState_forEachTween_closure0() {
    },
    _AnimatedPhysicalModelState_forEachTween_closure1: function _AnimatedPhysicalModelState_forEachTween_closure1() {
    },
    _AnimatedPhysicalModelState_forEachTween_closure2: function _AnimatedPhysicalModelState_forEachTween_closure2() {
    },
    _ImplicitlyAnimatedWidgetState_State_SingleTickerProviderStateMixin_dispose_closure: function _ImplicitlyAnimatedWidgetState_State_SingleTickerProviderStateMixin_dispose_closure(t0) {
      this.$this = t0;
    },
    _ImplicitlyAnimatedWidgetState_State_SingleTickerProviderStateMixin: function _ImplicitlyAnimatedWidgetState_State_SingleTickerProviderStateMixin() {
    }
  },
  S = {
    ProxyAnimation$: function(animation) {
      var t1 = {func: 1, ret: -1, args: [X.AnimationStatus]},
        t2 = {func: 1, ret: -1};
      t2 = new S.ProxyAnimation(new R.ObserverList(H.setRuntimeTypeInfo([], [t1]), [t1]), new R.ObserverList(H.setRuntimeTypeInfo([], [t2]), [t2]), 0);
      t2.set$_animations$_parent(animation);
      if (t2._animations$_parent == null) {
        t2._animations$_status = C.AnimationStatus_0;
        t2._animations$_value = 0;
      }
      return t2;
    },
    CurvedAnimation$: function(curve, $parent, reverseCurve) {
      var t1 = new S.CurvedAnimation($parent, curve, reverseCurve);
      t1._updateCurveDirection$1($parent.get$status($parent));
      $parent.addStatusListener$1(t1.get$_updateCurveDirection());
      return t1;
    },
    TrainHoppingAnimation$: function(_currentTrain, _nextTrain, onSwitchedTrain) {
      var t3, t4,
        t1 = {func: 1, ret: -1, args: [X.AnimationStatus]},
        t2 = {func: 1, ret: -1};
      t1 = new S.TrainHoppingAnimation(_currentTrain, _nextTrain, onSwitchedTrain, new R.ObserverList(H.setRuntimeTypeInfo([], [t1]), [t1]), new R.ObserverList(H.setRuntimeTypeInfo([], [t2]), [t2]));
      if (_nextTrain != null)
        if (J.$eq$(_currentTrain.get$value(), _nextTrain.get$value())) {
          t1.set$_currentTrain(_nextTrain);
          t1.set$_nextTrain(null);
        } else if (J.$gt$n(_currentTrain.get$value(), _nextTrain.get$value()))
          t1._mode = C._TrainHoppingMode_1;
        else {
          H.assertHelper(J.$lt$n(_currentTrain.get$value(), _nextTrain.get$value()));
          t1._mode = C._TrainHoppingMode_0;
        }
      t1._currentTrain.addStatusListener$1(t1.get$_statusChangeHandler());
      t3 = t1.get$_valueChangeHandler();
      t1._currentTrain.addListener$1(t3);
      t4 = t1._nextTrain;
      if (t4 != null) {
        H.functionTypeCheck(t3, t2);
        t4.didRegisterListener$0();
        t2 = t4.AnimationLocalListenersMixin__listeners;
        H.assertSubtypeOfRuntimeType(t3, H.getTypeArgumentByIndex(t2, 0));
        t2._isDirty = true;
        C.JSArray_methods.add$1(t2._list, t3);
      }
      H.assertHelper(t1._mode != null || t1._nextTrain == null);
      return t1;
    },
    _AlwaysCompleteAnimation: function _AlwaysCompleteAnimation() {
    },
    _AlwaysDismissedAnimation: function _AlwaysDismissedAnimation() {
    },
    AnimationWithParentMixin: function AnimationWithParentMixin() {
    },
    ProxyAnimation: function ProxyAnimation(t0, t1, t2) {
      var _ = this;
      _._animations$_parent = _._animations$_value = _._animations$_status = null;
      _.AnimationLocalStatusListenersMixin__statusListeners = t0;
      _.AnimationLocalListenersMixin__listeners = t1;
      _.AnimationLazyListenerMixin__listenerCounter = t2;
    },
    ReverseAnimation: function ReverseAnimation(t0, t1, t2) {
      this.parent = t0;
      this.AnimationLocalStatusListenersMixin__statusListeners = t1;
      this.AnimationLazyListenerMixin__listenerCounter = t2;
    },
    CurvedAnimation: function CurvedAnimation(t0, t1, t2) {
      var _ = this;
      _.parent = t0;
      _.curve = t1;
      _.reverseCurve = t2;
      _._curveDirection = null;
    },
    CurvedAnimation_value_closure: function CurvedAnimation_value_closure(t0, t1) {
      this.activeCurve = t0;
      this.t = t1;
    },
    _TrainHoppingMode: function _TrainHoppingMode(t0) {
      this._animations$_name = t0;
    },
    TrainHoppingAnimation: function TrainHoppingAnimation(t0, t1, t2, t3, t4) {
      var _ = this;
      _._currentTrain = t0;
      _._nextTrain = t1;
      _._mode = null;
      _.onSwitchedTrain = t2;
      _._lastValue = _._lastStatus = null;
      _.AnimationLocalStatusListenersMixin__statusListeners = t3;
      _.AnimationLocalListenersMixin__listeners = t4;
    },
    CompoundAnimation: function CompoundAnimation() {
    },
    AnimationMin: function AnimationMin(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.first = t0;
      _.next = t1;
      _._lastValue = _._lastStatus = null;
      _.AnimationLocalStatusListenersMixin__statusListeners = t2;
      _.AnimationLocalListenersMixin__listeners = t3;
      _.AnimationLazyListenerMixin__listenerCounter = t4;
      _.$ti = t5;
    },
    _CompoundAnimation_Animation_AnimationLazyListenerMixin: function _CompoundAnimation_Animation_AnimationLazyListenerMixin() {
    },
    _CompoundAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin: function _CompoundAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin() {
    },
    _CompoundAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin: function _CompoundAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin() {
    },
    _CurvedAnimation_Animation_AnimationWithParentMixin: function _CurvedAnimation_Animation_AnimationWithParentMixin() {
    },
    _ProxyAnimation_Animation_AnimationLazyListenerMixin: function _ProxyAnimation_Animation_AnimationLazyListenerMixin() {
    },
    _ProxyAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin: function _ProxyAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin() {
    },
    _ProxyAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin: function _ProxyAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin() {
    },
    _ReverseAnimation_Animation_AnimationLazyListenerMixin: function _ReverseAnimation_Animation_AnimationLazyListenerMixin() {
    },
    _ReverseAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalStatusListenersMixin: function _ReverseAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalStatusListenersMixin() {
    },
    _TrainHoppingAnimation_Animation_AnimationEagerListenerMixin: function _TrainHoppingAnimation_Animation_AnimationEagerListenerMixin() {
    },
    _TrainHoppingAnimation_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin: function _TrainHoppingAnimation_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin() {
    },
    _TrainHoppingAnimation_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin: function _TrainHoppingAnimation_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin() {
    },
    AnimationLazyListenerMixin: function AnimationLazyListenerMixin() {
    },
    AnimationEagerListenerMixin: function AnimationEagerListenerMixin() {
    },
    AnimationLocalListenersMixin: function AnimationLocalListenersMixin() {
    },
    AnimationLocalListenersMixin_notifyListeners_closure: function AnimationLocalListenersMixin_notifyListeners_closure(t0) {
      this.$this = t0;
    },
    AnimationLocalStatusListenersMixin: function AnimationLocalStatusListenersMixin() {
    },
    AnimationLocalStatusListenersMixin_notifyStatusListeners_closure: function AnimationLocalStatusListenersMixin_notifyStatusListeners_closure(t0) {
      this.$this = t0;
    },
    DragStartBehavior: function DragStartBehavior(t0) {
      this._recognizer$_name = t0;
    },
    GestureRecognizer: function GestureRecognizer() {
    },
    GestureRecognizer_invokeCallback_closure: function GestureRecognizer_invokeCallback_closure(t0, t1, t2) {
      this.$this = t0;
      this.debugReport = t1;
      this.name = t2;
    },
    GestureRecognizer_invokeCallback_closure0: function GestureRecognizer_invokeCallback_closure0(t0, t1) {
      this.$this = t0;
      this.name = t1;
    },
    OneSequenceGestureRecognizer: function OneSequenceGestureRecognizer() {
    },
    GestureRecognizerState: function GestureRecognizerState(t0) {
      this._recognizer$_name = t0;
    },
    PrimaryPointerGestureRecognizer: function PrimaryPointerGestureRecognizer() {
    },
    _GestureRecognizer_GestureArenaMember_DiagnosticableTreeMixin: function _GestureRecognizer_GestureArenaMember_DiagnosticableTreeMixin() {
    },
    MaterialApp: function MaterialApp(t0, t1, t2, t3) {
      var _ = this;
      _.home = t0;
      _.title = t1;
      _.theme = t2;
      _.key = t3;
    },
    _MaterialScrollBehavior: function _MaterialScrollBehavior() {
    },
    _MaterialAppState: function _MaterialAppState(t0) {
      var _ = this;
      _._widget = _._navigatorObservers = _._heroController = null;
      _._debugLifecycleState = t0;
      _._element = null;
    },
    _MaterialAppState_build_closure: function _MaterialAppState_build_closure() {
    },
    _MaterialAppState_build_closure0: function _MaterialAppState_build_closure0(t0) {
      this.$this = t0;
    },
    _MaterialAppState_build_closure1: function _MaterialAppState_build_closure1() {
    },
    _MaterialAppState_build_closure2: function _MaterialAppState_build_closure2(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    FloatingActionButtonThemeData_lerp: function(a, b, t) {
      var t2, t3, t4, t5, t6, t7, _null = null,
        t1 = a == null;
      if (t1 && b == null)
        return;
      t2 = t1 ? _null : a.backgroundColor;
      t3 = b == null;
      t2 = P.Color_lerp(t2, t3 ? _null : b.backgroundColor, t);
      t4 = t1 ? _null : a.foregroundColor;
      t4 = P.Color_lerp(t4, t3 ? _null : b.foregroundColor, t);
      t5 = t1 ? _null : a.elevation;
      t5 = P.lerpDouble(t5, t3 ? _null : b.elevation, t);
      t6 = t1 ? _null : a.disabledElevation;
      t6 = P.lerpDouble(t6, t3 ? _null : b.disabledElevation, t);
      t7 = t1 ? _null : a.highlightElevation;
      t7 = P.lerpDouble(t7, t3 ? _null : b.highlightElevation, t);
      t1 = t1 ? _null : a.shape;
      return new S.FloatingActionButtonThemeData(t2, t4, t5, t6, t7, Y.ShapeBorder_lerp(t1, t3 ? _null : b.shape, t));
    },
    FloatingActionButtonThemeData: function FloatingActionButtonThemeData(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.backgroundColor = t0;
      _.foregroundColor = t1;
      _.elevation = t2;
      _.disabledElevation = t3;
      _.highlightElevation = t4;
      _.shape = t5;
    },
    Tooltip$: function(child, message) {
      return new S.Tooltip(message, child, null);
    },
    Tooltip: function Tooltip(t0, t1, t2) {
      this.message = t0;
      this.child = t1;
      this.key = t2;
    },
    _TooltipState: function _TooltipState(t0, t1) {
      var _ = this;
      _._tooltip$_timer = _._entry = _._controller = null;
      _.SingleTickerProviderStateMixin__ticker = t0;
      _._widget = null;
      _._debugLifecycleState = t1;
      _._element = null;
    },
    _TooltipState_ensureTooltipVisible_closure: function _TooltipState_ensureTooltipVisible_closure(t0) {
      this.overlay = t0;
    },
    _TooltipPositionDelegate: function _TooltipPositionDelegate(t0, t1, t2) {
      this.target = t0;
      this.verticalOffset = t1;
      this.preferBelow = t2;
    },
    _TooltipOverlay: function _TooltipOverlay(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.message = t0;
      _.height = t1;
      _.padding = t2;
      _.animation = t3;
      _.target = t4;
      _.verticalOffset = t5;
      _.preferBelow = t6;
      _.key = t7;
    },
    __TooltipState_State_SingleTickerProviderStateMixin_dispose_closure: function __TooltipState_State_SingleTickerProviderStateMixin_dispose_closure(t0) {
      this.$this = t0;
    },
    __TooltipState_State_SingleTickerProviderStateMixin: function __TooltipState_State_SingleTickerProviderStateMixin() {
    },
    BoxDecoration$: function(border, borderRadius, boxShadow, color, gradient, image, shape) {
      return new S.BoxDecoration(color, image, border, borderRadius, boxShadow, gradient, shape);
    },
    BoxDecoration_lerp: function(a, b, t) {
      var t1, t2, t3, t4, t5, t6, t7;
      if (t === 0)
        return a;
      if (t === 1)
        return b;
      t1 = P.Color_lerp(a.color, b.color, t);
      t2 = t < 0.5;
      t3 = t2 ? a.image : b.image;
      t4 = F.BoxBorder_lerp(a.border, b.border, t);
      t5 = K.BorderRadiusGeometry_lerp(a.borderRadius, b.borderRadius, t);
      t6 = O.BoxShadow_lerpList(a.boxShadow, b.boxShadow, t);
      t7 = T.Gradient_lerp(a.gradient, b.gradient, t);
      return S.BoxDecoration$(t4, t5, t6, t1, t7, t3, t2 ? a.shape : b.shape);
    },
    BoxDecoration: function BoxDecoration(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.color = t0;
      _.image = t1;
      _.border = t2;
      _.borderRadius = t3;
      _.boxShadow = t4;
      _.gradient = t5;
      _.shape = t6;
    },
    _BoxDecorationPainter: function _BoxDecorationPainter(t0, t1) {
      var _ = this;
      _._box_decoration$_decoration = t0;
      _._imagePainter = _._rectForCachedBackgroundPaint = _._cachedBackgroundPaint = null;
      _.onChanged = t1;
    },
    _StadiumToCircleBorder$: function(circleness, side) {
      return new S._StadiumToCircleBorder(side, circleness);
    },
    _StadiumToRoundedRectangleBorder$: function(borderRadius, rectness, side) {
      return new S._StadiumToRoundedRectangleBorder(side, borderRadius, rectness);
    },
    StadiumBorder: function StadiumBorder(t0) {
      this.side = t0;
    },
    _StadiumToCircleBorder: function _StadiumToCircleBorder(t0, t1) {
      this.side = t0;
      this.circleness = t1;
    },
    _StadiumToRoundedRectangleBorder: function _StadiumToRoundedRectangleBorder(t0, t1, t2) {
      this.side = t0;
      this.borderRadius = t1;
      this.rectness = t2;
    },
    BoxConstraints$tight: function(size) {
      var t1 = size._dx,
        t2 = size._dy;
      return new S.BoxConstraints(t1, t1, t2, t2);
    },
    BoxConstraints$tightFor: function(height, width) {
      var t3, t4,
        t1 = width != null,
        t2 = t1 ? width : 0;
      t1 = t1 ? width : 1 / 0;
      t3 = height != null;
      t4 = t3 ? height : 0;
      return new S.BoxConstraints(t2, t1, t4, t3 ? height : 1 / 0);
    },
    _DebugSize: function _DebugSize(t0, t1, t2, t3) {
      var _ = this;
      _._box$_owner = t0;
      _._canBeUsedByParent = t1;
      _._dx = t2;
      _._dy = t3;
    },
    BoxConstraints: function BoxConstraints(t0, t1, t2, t3) {
      var _ = this;
      _.minWidth = t0;
      _.maxWidth = t1;
      _.minHeight = t2;
      _.maxHeight = t3;
    },
    BoxConstraints__debugPropagateDebugSize_closure: function BoxConstraints__debugPropagateDebugSize_closure(t0, t1) {
      this._box_0 = t0;
      this.size = t1;
    },
    BoxConstraints_constrain_closure: function BoxConstraints_constrain_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.size = t2;
    },
    BoxConstraints_debugAssertIsValid_closure: function BoxConstraints_debugAssertIsValid_closure(t0, t1, t2) {
      this.$this = t0;
      this.informationCollector = t1;
      this.isAppliedConstraint = t2;
    },
    BoxConstraints_debugAssertIsValid_closure_throwError: function BoxConstraints_debugAssertIsValid_closure_throwError(t0, t1) {
      this.$this = t0;
      this.informationCollector = t1;
    },
    BoxConstraints_toString_describe: function BoxConstraints_toString_describe() {
    },
    BoxHitTestEntry: function BoxHitTestEntry(t0, t1) {
      this.localPosition = t0;
      this.target = t1;
    },
    BoxParentData: function BoxParentData(t0) {
      this.offset = t0;
    },
    ContainerBoxParentData: function ContainerBoxParentData() {
    },
    _IntrinsicDimensionsCacheEntry: function _IntrinsicDimensionsCacheEntry() {
    },
    RenderBox: function RenderBox() {
    },
    RenderBox_size_closure: function RenderBox_size_closure(t0) {
      this.$this = t0;
    },
    RenderBox_size_closure0: function RenderBox_size_closure0(t0) {
      this.$this = t0;
    },
    RenderBox_size_closure1: function RenderBox_size_closure1(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    RenderBox_size_closure2: function RenderBox_size_closure2(t0) {
      this.$this = t0;
    },
    RenderBox_debugAdoptSize_closure: function RenderBox_debugAdoptSize_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.value = t2;
    },
    RenderBox_getDistanceToBaseline_closure: function RenderBox_getDistanceToBaseline_closure(t0) {
      this.$this = t0;
    },
    RenderBox_getDistanceToActualBaseline_closure: function RenderBox_getDistanceToActualBaseline_closure(t0, t1) {
      this.$this = t0;
      this.baseline = t1;
    },
    RenderBox_debugAssertDoesMeetConstraints_closure: function RenderBox_debugAssertDoesMeetConstraints_closure(t0) {
      this.$this = t0;
    },
    RenderBox_performLayout_closure: function RenderBox_performLayout_closure(t0) {
      this.$this = t0;
    },
    RenderBox_hitTest_closure: function RenderBox_hitTest_closure(t0) {
      this.$this = t0;
    },
    RenderBox_applyPaintTransform_closure: function RenderBox_applyPaintTransform_closure(t0, t1) {
      this.$this = t0;
      this.child = t1;
    },
    RenderBox_debugHandleEvent_closure: function RenderBox_debugHandleEvent_closure(t0, t1) {
      this.$this = t0;
      this.event = t1;
    },
    RenderBox_debugPaint_closure: function RenderBox_debugPaint_closure(t0, t1, t2) {
      this.$this = t0;
      this.context = t1;
      this.offset = t2;
    },
    RenderBox_debugPaintSize_closure: function RenderBox_debugPaintSize_closure(t0, t1, t2) {
      this.$this = t0;
      this.context = t1;
      this.offset = t2;
    },
    RenderBox_debugPaintBaselines_closure: function RenderBox_debugPaintBaselines_closure(t0, t1, t2) {
      this.$this = t0;
      this.offset = t1;
      this.context = t2;
    },
    RenderBoxContainerDefaultsMixin: function RenderBoxContainerDefaultsMixin() {
    },
    _ContainerBoxParentData_BoxParentData_ContainerParentDataMixin: function _ContainerBoxParentData_BoxParentData_ContainerParentDataMixin() {
    },
    _WidgetsAppState_basicLocaleListResolution: function(preferredLocales, supportedLocales) {
      var t2, allSupportedLocales, languageAndCountryLocales, languageAndScriptLocales, languageLocales, countryLocales, _i, locale, t3, matchesLanguageCode, matchesCountryCode, localeIndex, userLocale, match, resolvedLocale,
        t1 = P.Locale;
      H.assertSubtype(preferredLocales, "$isList", [t1], "$asList");
      H.assertSubtype(supportedLocales, "$isIterable", [t1], "$asIterable");
      if (preferredLocales == null || preferredLocales.length === 0)
        return C.JSArray_methods.get$first(supportedLocales);
      t2 = P.String;
      allSupportedLocales = P.HashMap_HashMap(t2, t1);
      languageAndCountryLocales = P.HashMap_HashMap(t2, t1);
      languageAndScriptLocales = P.HashMap_HashMap(t2, t1);
      languageLocales = P.HashMap_HashMap(t2, t1);
      countryLocales = P.HashMap_HashMap(t2, t1);
      for (_i = 0; _i < 1; ++_i) {
        locale = supportedLocales[_i];
        t1 = locale._languageCode;
        t2 = locale._countryCode;
        t3 = P.Locale__replaceDeprecatedLanguageSubtag(t1) + "_null_" + P.Locale__replaceDeprecatedRegionSubtag(t2);
        if (allSupportedLocales.$index(0, t3) == null)
          allSupportedLocales.$indexSet(0, t3, locale);
        t3 = P.Locale__replaceDeprecatedLanguageSubtag(t1) + "_null";
        if (languageAndScriptLocales.$index(0, t3) == null)
          languageAndScriptLocales.$indexSet(0, t3, locale);
        t3 = P.Locale__replaceDeprecatedLanguageSubtag(t1) + "_" + P.Locale__replaceDeprecatedRegionSubtag(t2);
        if (languageAndCountryLocales.$index(0, t3) == null)
          languageAndCountryLocales.$indexSet(0, t3, locale);
        t1 = P.Locale__replaceDeprecatedLanguageSubtag(t1);
        if (languageLocales.$index(0, t1) == null)
          languageLocales.$indexSet(0, t1, locale);
        t1 = P.Locale__replaceDeprecatedRegionSubtag(t2);
        if (countryLocales.$index(0, t1) == null)
          countryLocales.$indexSet(0, t1, locale);
      }
      for (matchesLanguageCode = null, matchesCountryCode = null, localeIndex = 0; localeIndex < preferredLocales.length; ++localeIndex) {
        userLocale = preferredLocales[localeIndex];
        t1 = userLocale._languageCode;
        t2 = P.Locale__replaceDeprecatedLanguageSubtag(t1) + "_null_";
        t3 = userLocale._countryCode;
        if (allSupportedLocales.containsKey$1(t2 + P.Locale__replaceDeprecatedRegionSubtag(t3)))
          return userLocale;
        P.Locale__replaceDeprecatedRegionSubtag(t3);
        match = languageAndCountryLocales.$index(0, P.Locale__replaceDeprecatedLanguageSubtag(t1) + "_" + P.Locale__replaceDeprecatedRegionSubtag(t3));
        if (match != null)
          return match;
        if (matchesLanguageCode != null)
          return matchesLanguageCode;
        match = languageLocales.$index(0, P.Locale__replaceDeprecatedLanguageSubtag(t1));
        if (match != null) {
          if (localeIndex === 0) {
            t2 = localeIndex + 1;
            t1 = !(t2 < preferredLocales.length && P.Locale__replaceDeprecatedLanguageSubtag(preferredLocales[t2]._languageCode) === P.Locale__replaceDeprecatedLanguageSubtag(t1));
          } else
            t1 = false;
          if (t1)
            return match;
          matchesLanguageCode = match;
        }
        if (matchesCountryCode == null) {
          P.Locale__replaceDeprecatedRegionSubtag(t3);
          t1 = true;
        } else
          t1 = false;
        if (t1) {
          match = countryLocales.$index(0, P.Locale__replaceDeprecatedRegionSubtag(t3));
          if (match != null)
            matchesCountryCode = match;
        }
      }
      resolvedLocale = matchesLanguageCode == null ? matchesCountryCode : matchesLanguageCode;
      return resolvedLocale == null ? C.JSArray_methods.get$first(supportedLocales) : resolvedLocale;
    },
    WidgetsApp: function WidgetsApp(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24) {
      var _ = this;
      _.navigatorKey = t0;
      _.onGenerateRoute = t1;
      _.pageRouteBuilder = t2;
      _.home = t3;
      _.routes = t4;
      _.onUnknownRoute = t5;
      _.initialRoute = t6;
      _.navigatorObservers = t7;
      _.builder = t8;
      _.title = t9;
      _.onGenerateTitle = t10;
      _.textStyle = t11;
      _.color = t12;
      _.locale = t13;
      _.localizationsDelegates = t14;
      _.localeListResolutionCallback = t15;
      _.localeResolutionCallback = t16;
      _.supportedLocales = t17;
      _.showPerformanceOverlay = t18;
      _.checkerboardRasterCacheImages = t19;
      _.checkerboardOffscreenLayers = t20;
      _.showSemanticsDebugger = t21;
      _.inspectorSelectButtonBuilder = t22;
      _.debugShowCheckedModeBanner = t23;
      _.key = t24;
    },
    _WidgetsAppState: function _WidgetsAppState(t0) {
      var _ = this;
      _._widget = _._app$_locale = _._navigator = null;
      _._debugLifecycleState = t0;
      _._element = null;
    },
    _WidgetsAppState__onGenerateRoute_closure: function _WidgetsAppState__onGenerateRoute_closure(t0) {
      this.$this = t0;
    },
    _WidgetsAppState__onUnknownRoute_closure: function _WidgetsAppState__onUnknownRoute_closure(t0, t1) {
      this.$this = t0;
      this.settings = t1;
    },
    _WidgetsAppState__onUnknownRoute_closure0: function _WidgetsAppState__onUnknownRoute_closure0(t0, t1, t2) {
      this.$this = t0;
      this.result = t1;
      this.settings = t2;
    },
    _WidgetsAppState_didChangeLocales_closure: function _WidgetsAppState_didChangeLocales_closure(t0, t1) {
      this.$this = t0;
      this.newLocale = t1;
    },
    _WidgetsAppState_didChangeAccessibilityFeatures_closure: function _WidgetsAppState_didChangeAccessibilityFeatures_closure() {
    },
    _WidgetsAppState_didChangeMetrics_closure: function _WidgetsAppState_didChangeMetrics_closure() {
    },
    _WidgetsAppState_didChangeTextScaleFactor_closure: function _WidgetsAppState_didChangeTextScaleFactor_closure() {
    },
    _WidgetsAppState_didChangePlatformBrightness_closure: function _WidgetsAppState_didChangePlatformBrightness_closure() {
    },
    _WidgetsAppState__debugCheckLocalizations_closure: function _WidgetsAppState__debugCheckLocalizations_closure(t0, t1) {
      this.$this = t0;
      this.appLocale = t1;
    },
    _WidgetsAppState__debugCheckLocalizations__closure: function _WidgetsAppState__debugCheckLocalizations__closure() {
    },
    _WidgetsAppState__debugCheckLocalizations__closure0: function _WidgetsAppState__debugCheckLocalizations__closure0() {
    },
    _WidgetsAppState_build_closure: function _WidgetsAppState_build_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    _WidgetsAppState_build_closure0: function _WidgetsAppState_build_closure0(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    InheritedNotifier: function InheritedNotifier() {
    },
    _InheritedNotifierElement: function _InheritedNotifierElement(t0, t1, t2, t3, t4) {
      var _ = this;
      _._inherited_notifier$_dirty = false;
      _._dependents = t0;
      _._framework$_parent = _._framework$_child = null;
      _._cachedHash = t1;
      _._depth = _._slot = null;
      _._widget = t2;
      _._owner = null;
      _._active = false;
      _._debugLifecycleState = t3;
      _._dependencies = _._inheritedWidgets = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._debugAllowIgnoredCallsToMarkNeedsBuild = _._debugBuiltOnce = _._inDirtyList = false;
      _.$ti = t4;
    },
    PageStorageBucket: function PageStorageBucket() {
    },
    PageStorage: function PageStorage(t0, t1) {
      this.child = t0;
      this.key = t1;
    },
    setEquals: function(a, b, $T) {
      var t1 = [$T];
      H.assertSubtype(a, "$isSet", t1, "$asSet");
      H.assertSubtype(b, "$isSet", t1, "$asSet");
      if (a == null)
        return b == null;
      if (b == null || a._collection$_length !== b._collection$_length)
        return false;
      for (t1 = P._LinkedHashSetIterator$(a, a._collection$_modifications, H.getTypeArgumentByIndex(a, 0)); t1.moveNext$0();)
        if (!b.contains$1(0, t1._collection$_current))
          return false;
      return true;
    },
    listEquals: function(a, b, $T) {
      var index,
        t1 = [$T];
      H.assertSubtype(a, "$isList", t1, "$asList");
      H.assertSubtype(b, "$isList", t1, "$asList");
      if (a == null)
        return b == null;
      if (b == null || a.length !== b.length)
        return false;
      for (index = 0; index < a.length; ++index) {
        t1 = a[index];
        if (index >= b.length)
          return H.ioore(b, index);
        if (!J.$eq$(t1, b[index]))
          return false;
      }
      return true;
    },
    SemanticsService_tooltip: function(message) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1);
      var $async$SemanticsService_tooltip = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait(C.BasicMessageChannel_8hp.send$1(new E.TooltipSemanticsEvent(message, "tooltip").toMap$0()), $async$SemanticsService_tooltip);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$SemanticsService_tooltip, $async$completer);
    }
  },
  Z = {
    Interval$: function(begin, end, curve) {
      return new Z.Interval(begin, end, curve);
    },
    Curve: function Curve() {
    },
    _Linear: function _Linear() {
    },
    Interval: function Interval(t0, t1, t2) {
      this.begin = t0;
      this.end = t1;
      this.curve = t2;
    },
    Threshold: function Threshold(t0) {
      this.threshold = t0;
    },
    Cubic: function Cubic(t0, t1, t2, t3) {
      var _ = this;
      _.a = t0;
      _.b = t1;
      _.c = t2;
      _.d = t3;
    },
    FlippedCurve: function FlippedCurve(t0) {
      this.curve = t0;
    },
    RawMaterialButton: function RawMaterialButton(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _.onPressed = t0;
      _.textStyle = t1;
      _.fillColor = t2;
      _.elevation = t3;
      _.highlightElevation = t4;
      _.disabledElevation = t5;
      _.constraints = t6;
      _.shape = t7;
      _.child = t8;
      _.materialTapTargetSize = t9;
      _.clipBehavior = t10;
      _.key = t11;
    },
    _RawMaterialButtonState: function _RawMaterialButtonState(t0) {
      var _ = this;
      _._highlight = false;
      _._widget = null;
      _._debugLifecycleState = t0;
      _._element = null;
    },
    _RawMaterialButtonState__handleHighlightChanged_closure: function _RawMaterialButtonState__handleHighlightChanged_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _InputPadding: function _InputPadding(t0, t1, t2) {
      this.minSize = t0;
      this.child = t1;
      this.key = t2;
    },
    _RenderInputPadding: function _RenderInputPadding(t0, t1) {
      var _ = this;
      _._minSize = t0;
      _.RenderObjectWithChildMixin__child = t1;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    DrawerController: function DrawerController() {
    },
    DrawerControllerState: function DrawerControllerState() {
    },
    _DrawerControllerState_State_SingleTickerProviderStateMixin: function _DrawerControllerState_State_SingleTickerProviderStateMixin() {
    },
    FlexibleSpaceBarSettings: function FlexibleSpaceBarSettings(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.toolbarOpacity = t0;
      _.minExtent = t1;
      _.maxExtent = t2;
      _.currentExtent = t3;
      _.child = t4;
      _.key = t5;
    },
    ClipContext: function ClipContext() {
    },
    ClipContext_clipRectAndPaint_closure: function ClipContext_clipRectAndPaint_closure(t0, t1) {
      this.$this = t0;
      this.rect = t1;
    },
    Decoration_lerp: function(a, b, t) {
      var t1, _null = null;
      H.assertHelper(t != null);
      t1 = a == null;
      if (t1 && b == null)
        return;
      if (t1) {
        t1 = b.lerpFrom$2(_null, t);
        return t1 == null ? b : t1;
      }
      if (b == null) {
        t1 = a.lerpTo$2(_null, t);
        return t1 == null ? a : t1;
      }
      if (t === 0)
        return a;
      if (t === 1)
        return b;
      t1 = b.lerpFrom$2(a, t);
      if (t1 == null)
        t1 = a.lerpTo$2(b, t);
      if (t1 == null) {
        if (typeof t !== "number")
          return t.$lt();
        if (t < 0.5) {
          t1 = a.lerpTo$2(_null, t * 2);
          if (t1 == null)
            t1 = a;
        } else {
          t1 = b.lerpFrom$2(_null, (t - 0.5) * 2);
          if (t1 == null)
            t1 = b;
        }
      }
      return t1;
    },
    Decoration: function Decoration() {
    },
    BoxPainter: function BoxPainter() {
    }
  },
  R = {
    Tween$: function(begin, end, $T) {
      return new R.Tween(begin, end, [$T]);
    },
    CurveTween$: function(curve) {
      return new R.CurveTween(curve);
    },
    Animatable: function Animatable() {
    },
    _AnimatedEvaluation: function _AnimatedEvaluation(t0, t1, t2) {
      this.parent = t0;
      this._evaluatable = t1;
      this.$ti = t2;
    },
    _ChainedEvaluation: function _ChainedEvaluation(t0, t1, t2) {
      this._tween$_parent = t0;
      this._evaluatable = t1;
      this.$ti = t2;
    },
    Tween: function Tween(t0, t1, t2) {
      this.begin = t0;
      this.end = t1;
      this.$ti = t2;
    },
    ReverseTween: function ReverseTween(t0, t1, t2, t3) {
      var _ = this;
      _.parent = t0;
      _.begin = t1;
      _.end = t2;
      _.$ti = t3;
    },
    ColorTween: function ColorTween(t0, t1) {
      this.begin = t0;
      this.end = t1;
    },
    RectTween: function RectTween() {
    },
    IntTween: function IntTween(t0, t1) {
      this.begin = t0;
      this.end = t1;
    },
    CurveTween: function CurveTween(t0) {
      this.curve = t0;
    },
    __AnimatedEvaluation_Animation_AnimationWithParentMixin: function __AnimatedEvaluation_Animation_AnimationWithParentMixin() {
    },
    CupertinoTextThemeData: function CupertinoTextThemeData() {
    },
    ObserverList: function ObserverList(t0, t1) {
      var _ = this;
      _._list = t0;
      _._isDirty = false;
      _._set = null;
      _.$ti = t1;
    },
    VelocityEstimate$: function(confidence, duration, offset, pixelsPerSecond) {
      return new R.VelocityEstimate(pixelsPerSecond, confidence, duration, offset);
    },
    Velocity: function Velocity(t0) {
      this.pixelsPerSecond = t0;
    },
    VelocityEstimate: function VelocityEstimate(t0, t1, t2, t3) {
      var _ = this;
      _.pixelsPerSecond = t0;
      _.confidence = t1;
      _.duration = t2;
      _.offset = t3;
    },
    _PointAtTime: function _PointAtTime(t0, t1) {
      this.time = t0;
      this.point = t1;
    },
    VelocityTracker: function VelocityTracker(t0) {
      this._samples = t0;
      this._velocity_tracker$_index = 0;
    },
    BackButtonIcon__getIconData: function(platform) {
      switch (platform) {
        case C.TargetPlatform_0:
        case C.TargetPlatform_1:
          return C.IconData_58820_MaterialIcons_true;
        case C.TargetPlatform_2:
          return C.IconData_58848_MaterialIcons_true;
      }
      H.assertHelper(false);
      return;
    },
    BackButtonIcon: function BackButtonIcon(t0) {
      this.key = t0;
    },
    BackButton: function BackButton(t0) {
      this.key = t0;
    },
    BackButton_build_closure: function BackButton_build_closure(t0) {
      this.context = t0;
    },
    InkResponse$: function(borderRadius, child, containedInkWell, customBorder, enableFeedback, excludeFromSemantics, highlightColor, highlightShape, key, onDoubleTap, onHighlightChanged, onLongPress, onTap, onTapCancel, onTapDown, radius, splashColor, splashFactory) {
      return new R.InkResponse(child, onTap, onTapDown, onTapCancel, onDoubleTap, onLongPress, onHighlightChanged, containedInkWell, highlightShape, radius, borderRadius, customBorder, highlightColor, splashColor, splashFactory, true, false, key);
    },
    InteractiveInkFeature: function InteractiveInkFeature() {
    },
    InteractiveInkFeatureFactory: function InteractiveInkFeatureFactory() {
    },
    InkResponse: function InkResponse(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17) {
      var _ = this;
      _.child = t0;
      _.onTap = t1;
      _.onTapDown = t2;
      _.onTapCancel = t3;
      _.onDoubleTap = t4;
      _.onLongPress = t5;
      _.onHighlightChanged = t6;
      _.containedInkWell = t7;
      _.highlightShape = t8;
      _.radius = t9;
      _.borderRadius = t10;
      _.customBorder = t11;
      _.highlightColor = t12;
      _.splashColor = t13;
      _.splashFactory = t14;
      _.enableFeedback = t15;
      _.excludeFromSemantics = t16;
      _.key = t17;
    },
    _InkResponseState: function _InkResponseState(t0, t1, t2) {
      var _ = this;
      _._lastHighlight = _._currentSplash = _._splashes = null;
      _.AutomaticKeepAliveClientMixin__keepAliveHandle = t0;
      _._widget = null;
      _._debugLifecycleState = t1;
      _._element = null;
      _.$ti = t2;
    },
    _InkResponseState__createInkFeature_onRemoved: function _InkResponseState__createInkFeature_onRemoved(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    _InkResponseState_build_closure: function _InkResponseState_build_closure(t0, t1) {
      this.$this = t0;
      this.context = t1;
    },
    InkWell: function InkWell(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17) {
      var _ = this;
      _.child = t0;
      _.onTap = t1;
      _.onTapDown = t2;
      _.onTapCancel = t3;
      _.onDoubleTap = t4;
      _.onLongPress = t5;
      _.onHighlightChanged = t6;
      _.containedInkWell = t7;
      _.highlightShape = t8;
      _.radius = t9;
      _.borderRadius = t10;
      _.customBorder = t11;
      _.highlightColor = t12;
      _.splashColor = t13;
      _.splashFactory = t14;
      _.enableFeedback = t15;
      _.excludeFromSemantics = t16;
      _.key = t17;
    },
    __InkResponseState_State_AutomaticKeepAliveClientMixin: function __InkResponseState_State_AutomaticKeepAliveClientMixin() {
    },
    TextTheme$: function(body1, body2, button, caption, display1, display2, display3, display4, headline, overline, subhead, subtitle, title) {
      return new R.TextTheme(display4, display3, display2, display1, headline, title, subhead, body2, body1, caption, button, subtitle, overline);
    },
    TextTheme_lerp: function(a, b, t) {
      var t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, _null = null,
        t1 = a == null,
        t2 = t1 ? _null : a.display4,
        t3 = b == null;
      t2 = A.TextStyle_lerp(t2, t3 ? _null : b.display4, t);
      t4 = t1 ? _null : a.display3;
      t4 = A.TextStyle_lerp(t4, t3 ? _null : b.display3, t);
      t5 = t1 ? _null : a.display2;
      t5 = A.TextStyle_lerp(t5, t3 ? _null : b.display2, t);
      t6 = t1 ? _null : a.display1;
      t6 = A.TextStyle_lerp(t6, t3 ? _null : b.display1, t);
      t7 = t1 ? _null : a.headline;
      t7 = A.TextStyle_lerp(t7, t3 ? _null : b.headline, t);
      t8 = t1 ? _null : a.title;
      t8 = A.TextStyle_lerp(t8, t3 ? _null : b.title, t);
      t9 = t1 ? _null : a.subhead;
      t9 = A.TextStyle_lerp(t9, t3 ? _null : b.subhead, t);
      t10 = t1 ? _null : a.body2;
      t10 = A.TextStyle_lerp(t10, t3 ? _null : b.body2, t);
      t11 = t1 ? _null : a.body1;
      t11 = A.TextStyle_lerp(t11, t3 ? _null : b.body1, t);
      t12 = t1 ? _null : a.caption;
      t12 = A.TextStyle_lerp(t12, t3 ? _null : b.caption, t);
      t13 = t1 ? _null : a.button;
      t13 = A.TextStyle_lerp(t13, t3 ? _null : b.button, t);
      t14 = t1 ? _null : a.subtitle;
      t14 = A.TextStyle_lerp(t14, t3 ? _null : b.subtitle, t);
      t1 = t1 ? _null : a.overline;
      return R.TextTheme$(t11, t10, t13, t12, t6, t5, t4, t2, t7, A.TextStyle_lerp(t1, t3 ? _null : b.overline, t), t9, t14, t8);
    },
    TextTheme: function TextTheme(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _.display4 = t0;
      _.display3 = t1;
      _.display2 = t2;
      _.display1 = t3;
      _.headline = t4;
      _.title = t5;
      _.subhead = t6;
      _.body2 = t7;
      _.body1 = t8;
      _.caption = t9;
      _.button = t10;
      _.subtitle = t11;
      _.overline = t12;
    }
  },
  L = {CupertinoLocalizations: function CupertinoLocalizations() {
    }, _CupertinoLocalizationsDelegate: function _CupertinoLocalizationsDelegate() {
    }, DefaultCupertinoLocalizations: function DefaultCupertinoLocalizations() {
    }, InputDecorationTheme: function InputDecorationTheme() {
    }, RenderPerformanceOverlay: function RenderPerformanceOverlay(t0, t1, t2, t3) {
      var _ = this;
      _._optionsMask = t0;
      _._rasterizerThreshold = t1;
      _._checkerboardRasterCacheImages = t2;
      _._checkerboardOffscreenLayers = t3;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    }, KeepAliveNotification: function KeepAliveNotification() {
    }, KeepAliveHandle: function KeepAliveHandle(t0) {
      this.ChangeNotifier__listeners = t0;
    }, AutomaticKeepAliveClientMixin: function AutomaticKeepAliveClientMixin() {
    },
    FocusScope$: function(autofocus, child, key, node) {
      return new L.FocusScope(null, child, null, null, autofocus, node, key);
    },
    FocusScope_of: function(context) {
      var marker, t1;
      H.assertHelper(context != null);
      marker = H.interceptedTypeCheck(context.inheritFromWidgetOfExactType$1(C.Type__FocusMarker_fgL), "$is_FocusMarker");
      t1 = marker == null ? null : marker.notifier;
      t1 = t1 == null ? null : t1.get$nearestScope();
      return t1 == null ? context._owner.focusManager.rootScope : t1;
    },
    _FocusMarker$: function(child, node) {
      return new L._FocusMarker(node, child, null);
    },
    Focus: function Focus() {
    },
    _FocusState: function _FocusState(t0) {
      var _ = this;
      _._hasFocus = _._internalNode = null;
      _._didAutofocus = false;
      _._widget = _._focusAttachment = null;
      _._debugLifecycleState = t0;
      _._element = null;
    },
    _FocusState__handleFocusChanged_closure: function _FocusState__handleFocusChanged_closure(t0) {
      this.$this = t0;
    },
    FocusScope: function FocusScope(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.debugLabel = t0;
      _.child = t1;
      _.onKey = t2;
      _.onFocusChange = t3;
      _.autofocus = t4;
      _.focusNode = t5;
      _.key = t6;
    },
    _FocusScopeState: function _FocusScopeState(t0) {
      var _ = this;
      _._hasFocus = _._internalNode = null;
      _._didAutofocus = false;
      _._widget = _._focusAttachment = null;
      _._debugLifecycleState = t0;
      _._element = null;
    },
    _FocusMarker: function _FocusMarker(t0, t1, t2) {
      this.notifier = t0;
      this.child = t1;
      this.key = t2;
    },
    Icon$: function(icon) {
      return new L.Icon(icon, null);
    },
    Icon: function Icon(t0, t1) {
      this.icon = t0;
      this.key = t1;
    },
    _loadAll: function(locale, allDelegates) {
      var t2, output, types, delegates, _i, delegate, t3, inputValue, futureValue, type, _box_1 = {},
        t1 = [L.LocalizationsDelegate,,];
      H.assertSubtype(allDelegates, "$isIterable", [t1], "$asIterable");
      t2 = P.Type;
      output = P.LinkedHashMap_LinkedHashMap$_empty(t2, null);
      _box_1.pendingList = null;
      types = P.LinkedHashSet_LinkedHashSet$_empty(t2);
      delegates = H.setRuntimeTypeInfo([], [t1]);
      for (t1 = allDelegates.length, _i = 0; _i < allDelegates.length; allDelegates.length === t1 || (0, H.throwConcurrentModificationError)(allDelegates), ++_i) {
        delegate = allDelegates[_i];
        delegate.toString;
        t2 = H.getRuntimeTypeArgumentIntercepted(J.getInterceptor$(delegate), delegate, "LocalizationsDelegate", 0);
        if (!types.contains$1(0, new H.TypeImpl(t2)) && delegate.isSupported$1(locale)) {
          types.add$1(0, new H.TypeImpl(t2));
          C.JSArray_methods.add$1(delegates, delegate);
        }
      }
      for (t1 = delegates.length, t2 = [L._Pending], _i = 0; _i < delegates.length; delegates.length === t1 || (0, H.throwConcurrentModificationError)(delegates), ++_i) {
        t3 = {};
        delegate = delegates[_i];
        inputValue = delegate.load$1(locale);
        t3.completedValue = null;
        futureValue = inputValue.then$1$1(new L._loadAll_closure(t3), null);
        if (t3.completedValue != null) {
          type = new H.TypeImpl(H.getRuntimeTypeArgument(delegate, "LocalizationsDelegate", 0));
          H.assertHelper(!output.containsKey$1(type));
          output.$indexSet(0, type, t3.completedValue);
        } else {
          t3 = _box_1.pendingList;
          if (t3 == null)
            t3 = _box_1.pendingList = H.setRuntimeTypeInfo([], t2);
          C.JSArray_methods.add$1(t3, new L._Pending(delegate, futureValue));
        }
      }
      t1 = _box_1.pendingList;
      if (t1 == null)
        return new O.SynchronousFuture(output, [[P.Map, P.Type,,]]);
      t2 = [P.Future,,];
      t3 = H.getTypeArgumentByIndex(t1, 0);
      return P.Future_wait(new H.MappedListIterable(t1, H.functionTypeCheck(new L._loadAll_closure0(), {func: 1, ret: t2, args: [t3]}), [t3, t2]), null).then$1$1(new L._loadAll_closure1(_box_1, output), [P.Map, P.Type,,]);
    },
    Localizations$: function(child, delegates, locale) {
      return new L.Localizations(locale, delegates, child, null);
    },
    Localizations_localeOf: function(context, nullOk) {
      var scope = H.interceptedTypeCheck(context.inheritFromWidgetOfExactType$1(C.Type__LocalizationsScope_Lpb), "$is_LocalizationsScope");
      if (scope == null)
        return;
      return scope.localizationsState._localizations$_locale;
    },
    Localizations_of: function(context, type, $T) {
      var scope = H.interceptedTypeCheck(context.inheritFromWidgetOfExactType$1(C.Type__LocalizationsScope_Lpb), "$is_LocalizationsScope"),
        t1 = scope == null ? null : scope.localizationsState;
      return t1 == null ? null : H.assertSubtypeOfRuntimeType(t1._typeToResources.$index(0, type), $T);
    },
    _Pending: function _Pending(t0, t1) {
      this.delegate = t0;
      this.futureValue = t1;
    },
    _loadAll_closure: function _loadAll_closure(t0) {
      this._box_0 = t0;
    },
    _loadAll_closure0: function _loadAll_closure0() {
    },
    _loadAll_closure1: function _loadAll_closure1(t0, t1) {
      this._box_1 = t0;
      this.output = t1;
    },
    LocalizationsDelegate: function LocalizationsDelegate() {
    },
    WidgetsLocalizations: function WidgetsLocalizations() {
    },
    _WidgetsLocalizationsDelegate: function _WidgetsLocalizationsDelegate() {
    },
    DefaultWidgetsLocalizations: function DefaultWidgetsLocalizations() {
    },
    _LocalizationsScope: function _LocalizationsScope(t0, t1, t2, t3) {
      var _ = this;
      _.localizationsState = t0;
      _.typeToResources = t1;
      _.child = t2;
      _.key = t3;
    },
    Localizations: function Localizations(t0, t1, t2, t3) {
      var _ = this;
      _.locale = t0;
      _.delegates = t1;
      _.child = t2;
      _.key = t3;
    },
    _LocalizationsState: function _LocalizationsState(t0, t1, t2) {
      var _ = this;
      _._localizedResourcesScopeKey = t0;
      _._typeToResources = t1;
      _._widget = _._localizations$_locale = null;
      _._debugLifecycleState = t2;
      _._element = null;
    },
    _LocalizationsState_load_closure: function _LocalizationsState_load_closure(t0) {
      this._box_0 = t0;
    },
    _LocalizationsState_load_closure0: function _LocalizationsState_load_closure0(t0, t1) {
      this.$this = t0;
      this.locale = t1;
    },
    _LocalizationsState_load__closure: function _LocalizationsState_load__closure(t0, t1, t2) {
      this.$this = t0;
      this.value = t1;
      this.locale = t2;
    },
    PerformanceOverlay: function PerformanceOverlay(t0, t1, t2, t3) {
      var _ = this;
      _.optionsMask = t0;
      _.checkerboardRasterCacheImages = t1;
      _.checkerboardOffscreenLayers = t2;
      _.key = t3;
    },
    DefaultTextStyle$: function(child, maxLines, overflow, softWrap, style, textAlign) {
      return new L.DefaultTextStyle(style, textAlign, softWrap, overflow, maxLines, child, null);
    },
    Text$: function(data, style) {
      return new L.Text(data, style, null);
    },
    DefaultTextStyle: function DefaultTextStyle(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.style = t0;
      _.textAlign = t1;
      _.softWrap = t2;
      _.overflow = t3;
      _.maxLines = t4;
      _.child = t5;
      _.key = t6;
    },
    Text: function Text(t0, t1, t2) {
      this.data = t0;
      this.style = t1;
      this.key = t2;
    }
  },
  D = {
    CupertinoPageRoute__isPopGestureEnabled: function(route, $T) {
      var t1;
      H.assertSubtype(route, "$isPageRoute", [$T], "$asPageRoute");
      if (route.get$isFirst())
        return false;
      if (route.get$willHandlePopInternally())
        return false;
      t1 = route._animationProxy;
      if (t1.get$status(t1) !== C.AnimationStatus_3)
        return false;
      t1 = route._secondaryAnimationProxy;
      if (t1.get$status(t1) !== C.AnimationStatus_0)
        return false;
      if (route._navigator$_navigator._userGesturesInProgress > 0)
        return false;
      return true;
    },
    CupertinoPageRoute_buildPageTransitions: function(route, context, animation, secondaryAnimation, child, $T) {
      var t1, t2, t3, t4;
      H.assertSubtype(route, "$isPageRoute", [$T], "$asPageRoute");
      t1 = [P.double];
      H.assertSubtype(animation, "$isAnimation", t1, "$asAnimation");
      H.assertSubtype(secondaryAnimation, "$isAnimation", t1, "$asAnimation");
      t1 = route._navigator$_navigator._userGesturesInProgress > 0;
      t2 = t1 ? animation : S.CurvedAnimation$(C.Cubic_izR, animation, C.Cubic_OcD);
      t3 = P.Offset;
      t2 = t2.drive$1$1($.$get$_kRightMiddleTween(), t3);
      t4 = t1 ? secondaryAnimation : S.CurvedAnimation$(C.Cubic_izR, secondaryAnimation, C.Cubic_OcD);
      t3 = t4.drive$1$1($.$get$_kMiddleLeftTween(), t3);
      t1 = t1 ? animation : S.CurvedAnimation$(C.Cubic_izR, animation, null);
      return new D.CupertinoPageTransition(t2, t3, t1.drive$1$1($.$get$_kGradientShadowTween(), Z.Decoration), new D._CupertinoBackGestureDetector(child, new D.CupertinoPageRoute_buildPageTransitions_closure(route, $T), new D.CupertinoPageRoute_buildPageTransitions_closure0(route, $T), null, [$T]), null);
    },
    _CupertinoEdgeShadowDecoration_lerp: function(a, b, t) {
      var t1 = a == null;
      if (t1 && b == null)
        return;
      t1 = t1 ? null : a.edgeGradient;
      return new D._CupertinoEdgeShadowDecoration(T.LinearGradient_lerp(t1, b == null ? null : b.edgeGradient, t));
    },
    CupertinoPageRoute_buildPageTransitions_closure: function CupertinoPageRoute_buildPageTransitions_closure(t0, t1) {
      this.route = t0;
      this.T = t1;
    },
    CupertinoPageRoute_buildPageTransitions_closure0: function CupertinoPageRoute_buildPageTransitions_closure0(t0, t1) {
      this.route = t0;
      this.T = t1;
    },
    CupertinoPageTransition: function CupertinoPageTransition(t0, t1, t2, t3, t4) {
      var _ = this;
      _._primaryPositionAnimation = t0;
      _._secondaryPositionAnimation = t1;
      _._primaryShadowAnimation = t2;
      _.child = t3;
      _.key = t4;
    },
    _CupertinoBackGestureDetector: function _CupertinoBackGestureDetector(t0, t1, t2, t3, t4) {
      var _ = this;
      _.child = t0;
      _.enabledCallback = t1;
      _.onStartPopGesture = t2;
      _.key = t3;
      _.$ti = t4;
    },
    _CupertinoBackGestureDetectorState: function _CupertinoBackGestureDetectorState(t0, t1) {
      var _ = this;
      _._widget = _._recognizer = _._backGestureController = null;
      _._debugLifecycleState = t0;
      _._element = null;
      _.$ti = t1;
    },
    _CupertinoBackGestureController: function _CupertinoBackGestureController(t0, t1, t2) {
      this.controller = t0;
      this.navigator = t1;
      this.$ti = t2;
    },
    _CupertinoBackGestureController_dragEnd_closure: function _CupertinoBackGestureController_dragEnd_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    _CupertinoEdgeShadowDecoration: function _CupertinoEdgeShadowDecoration(t0) {
      this.edgeGradient = t0;
    },
    _CupertinoEdgeShadowPainter: function _CupertinoEdgeShadowPainter(t0, t1) {
      this._route$_decoration = t0;
      this.onChanged = t1;
    },
    Key: function Key() {
    },
    LocalKey: function LocalKey() {
    },
    ValueKey: function ValueKey(t0, t1) {
      this.value = t0;
      this.$ti = t1;
    },
    _TypeLiteral: function _TypeLiteral(t0) {
      this.$ti = t0;
    },
    debugPrintThrottled: function(message, wrapWidth) {
      var messageLines, t1, t2;
      H.stringTypeCheck(message);
      H.intTypeCheck(wrapWidth);
      messageLines = message == null ? null : H.setRuntimeTypeInfo(message.split("\n"), [P.String]);
      if (messageLines == null)
        messageLines = H.setRuntimeTypeInfo(["null"], [P.String]);
      if (wrapWidth != null) {
        t1 = P.String;
        t2 = H.getTypeArgumentByIndex(messageLines, 0);
        $.$get$_debugPrintBuffer().addAll$1(0, new H.ExpandIterable(messageLines, H.functionTypeCheck(new D.debugPrintThrottled_closure(wrapWidth), {func: 1, ret: [P.Iterable, t1], args: [t2]}), [t2, t1]));
      } else
        $.$get$_debugPrintBuffer().addAll$1(0, messageLines);
      if (!$._debugPrintScheduled)
        D._debugPrintTask();
    },
    _debugPrintTask: function() {
      var line,
        t1 = $._debugPrintScheduled = false,
        t2 = $.$get$_debugPrintStopwatch();
      if (P.Duration$(t2.get$elapsedMicroseconds(), 0, 0)._duration > 1000000) {
        t2.stop$0();
        t2.reset$0();
        $._debugPrintedCharacters = 0;
      }
      while (true) {
        if ($._debugPrintedCharacters < 12288) {
          t2 = $.$get$_debugPrintBuffer();
          t2 = !t2.get$isEmpty(t2);
        } else
          t2 = t1;
        if (!t2)
          break;
        line = $.$get$_debugPrintBuffer().removeFirst$0();
        $._debugPrintedCharacters = $._debugPrintedCharacters + line.length;
        H.printString(H.S(line));
      }
      t1 = $.$get$_debugPrintBuffer();
      if (!t1.get$isEmpty(t1)) {
        $._debugPrintScheduled = true;
        $._debugPrintedCharacters = 0;
        P.Timer_Timer(C.Duration_1000000, D.print___debugPrintTask$closure());
        if ($._debugPrintCompleter == null) {
          t1 = -1;
          $._debugPrintCompleter = new P._AsyncCompleter(new P._Future($.Zone__current, [t1]), [t1]);
        }
      } else {
        $.$get$_debugPrintStopwatch().start$0();
        t1 = $._debugPrintCompleter;
        if (t1 != null)
          t1.complete$0();
        $._debugPrintCompleter = null;
      }
    },
    debugPrintDone: function() {
      var t1 = $._debugPrintCompleter;
      t1 = t1 == null ? null : t1.future;
      if (t1 == null) {
        t1 = new P._Future($.Zone__current, [-1]);
        t1._asyncComplete$1(null);
      }
      return t1;
    },
    debugWordWrap: function($async$message, $async$width, $async$wrapIndent) {
      return P._makeSyncStarIterable(function() {
        var message = $async$message,
          width = $async$width,
          wrapIndent = $async$wrapIndent;
        var $async$goto = 0, $async$handler = 2, $async$currentError, t2, prefix, index, index0, start, startForLengthCalculations, addPrefix, mode, lastWordStart, lastWordEnd, t3, t1;
        return function $async$debugWordWrap($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            $async$outer:
              switch ($async$goto) {
                case 0:
                  // Function start
                  t1 = message.length;
                  if (t1 >= width) {
                    t2 = J.trimLeft$0$s(message);
                    if (0 >= t2.length) {
                      H.ioore(t2, 0);
                      // goto return
                      $async$goto = 1;
                      break;
                    }
                    t2 = t2[0] === "#";
                  } else
                    t2 = true;
                  $async$goto = t2 ? 3 : 4;
                  break;
                case 3:
                  // then
                  $async$goto = 5;
                  return message;
                case 5:
                  // after yield
                  // goto return
                  $async$goto = 1;
                  break;
                case 4:
                  // join
                  t2 = $.$get$_indentPattern().matchAsPrefix$1(0, message)._match;
                  if (0 >= t2.length) {
                    H.ioore(t2, 0);
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  prefix = wrapIndent + C.JSString_methods.$mul(" ", t2[0].length);
                  index = prefix.length;
                  t2 = J.getInterceptor$s(message), index0 = index, start = 0, startForLengthCalculations = 0, addPrefix = false, mode = C._WordWrapParseMode_0, lastWordStart = null, lastWordEnd = null;
                case 6:
                  // for condition
                  // trivial condition
                case 8:
                  // switch
                  switch (mode) {
                    case C._WordWrapParseMode_0:
                      // goto case
                      $async$goto = 10;
                      break;
                    case C._WordWrapParseMode_1:
                      // goto case
                      $async$goto = 11;
                      break;
                    case C._WordWrapParseMode_2:
                      // goto case
                      $async$goto = 12;
                      break;
                    default:
                      // goto after switch
                      $async$goto = 9;
                      break;
                  }
                  break;
                case 10:
                  // case
                  while (true) {
                    if (index0 < t1) {
                      if (index0 < 0) {
                        H.ioore(message, index0);
                        // goto return
                        $async$goto = 1;
                        break $async$outer;
                      }
                      t3 = message[index0] === " ";
                    } else
                      t3 = false;
                    if (!t3)
                      break;
                    ++index0;
                  }
                  lastWordStart = index0;
                  mode = C._WordWrapParseMode_1;
                  // goto after switch
                  $async$goto = 9;
                  break;
                case 11:
                  // case
                  while (true) {
                    if (index0 < t1) {
                      if (index0 < 0) {
                        H.ioore(message, index0);
                        // goto return
                        $async$goto = 1;
                        break $async$outer;
                      }
                      t3 = message[index0] !== " ";
                    } else
                      t3 = false;
                    if (!t3)
                      break;
                    ++index0;
                  }
                  mode = C._WordWrapParseMode_2;
                  // goto after switch
                  $async$goto = 9;
                  break;
                case 12:
                  // case
                  t3 = index0 - startForLengthCalculations;
                  $async$goto = t3 > width || index0 === t1 ? 13 : 15;
                  break;
                case 13:
                  // then
                  if (t3 <= width || lastWordEnd == null)
                    lastWordEnd = index0;
                  $async$goto = addPrefix ? 16 : 18;
                  break;
                case 16:
                  // then
                  $async$goto = 19;
                  return prefix + t2.substring$2(message, start, lastWordEnd);
                case 19:
                  // after yield
                  // goto join
                  $async$goto = 17;
                  break;
                case 18:
                  // else
                  $async$goto = 20;
                  return t2.substring$2(message, start, lastWordEnd);
                case 20:
                  // after yield
                  addPrefix = true;
                case 17:
                  // join
                  if (lastWordEnd >= t1) {
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  if (lastWordEnd === index0) {
                    while (true) {
                      if (index0 < t1) {
                        if (index0 < 0) {
                          H.ioore(message, index0);
                          // goto return
                          $async$goto = 1;
                          break $async$outer;
                        }
                        t3 = message[index0] === " ";
                      } else
                        t3 = false;
                      if (!t3)
                        break;
                      ++index0;
                    }
                    start = index0;
                    mode = C._WordWrapParseMode_1;
                  } else {
                    if (typeof lastWordStart !== "number") {
                      lastWordStart.$gt();
                      // goto return
                      $async$goto = 1;
                      break;
                    }
                    H.assertHelper(lastWordStart > lastWordEnd);
                    start = lastWordStart;
                    mode = C._WordWrapParseMode_2;
                  }
                  startForLengthCalculations = start - index;
                  H.assertHelper(addPrefix);
                  lastWordEnd = null;
                  // goto join
                  $async$goto = 14;
                  break;
                case 15:
                  // else
                  lastWordEnd = index0;
                  mode = C._WordWrapParseMode_0;
                case 14:
                  // join
                  // goto after switch
                  $async$goto = 9;
                  break;
                case 9:
                  // after switch
                  // goto for condition
                  $async$goto = 6;
                  break;
                case 7:
                  // after for
                case 1:
                  // return
                  return P._IterationMarker_endOfIteration();
                case 2:
                  // rethrow
                  return P._IterationMarker_uncaughtError($async$currentError);
              }
        };
      }, P.String);
    },
    debugPrintThrottled_closure: function debugPrintThrottled_closure(t0) {
      this.wrapWidth = t0;
    },
    _WordWrapParseMode: function _WordWrapParseMode(t0) {
      this._print$_name = t0;
    },
    GestureDisposition: function GestureDisposition(t0) {
      this._arena$_name = t0;
    },
    GestureArenaMember: function GestureArenaMember() {
    },
    GestureArenaEntry: function GestureArenaEntry(t0, t1, t2) {
      this._arena = t0;
      this._pointer = t1;
      this._member = t2;
    },
    _GestureArena: function _GestureArena(t0) {
      var _ = this;
      _.members = t0;
      _.isOpen = true;
      _.hasPendingSweep = _.isHeld = false;
      _.eagerWinner = null;
    },
    _GestureArena_toString_closure: function _GestureArena_toString_closure(t0) {
      this.$this = t0;
    },
    GestureArenaManager: function GestureArenaManager(t0) {
      this._arenas = t0;
    },
    GestureArenaManager_add_closure: function GestureArenaManager_add_closure(t0, t1) {
      this.$this = t0;
      this.pointer = t1;
    },
    GestureArenaManager__tryToResolveArena_closure: function GestureArenaManager__tryToResolveArena_closure(t0, t1, t2) {
      this.$this = t0;
      this.pointer = t1;
      this.state = t2;
    },
    GestureArenaManager__debugLogDiagnostic_closure: function GestureArenaManager__debugLogDiagnostic_closure(t0, t1, t2) {
      this.state = t0;
      this.pointer = t1;
      this.message = t2;
    },
    _maxBy: function(input, keyFunc, $T) {
      var maxValue, maxKey, _i, value, key;
      H.assertSubtype(input, "$isIterable", [$T], "$asIterable");
      H.functionTypeCheck(keyFunc, {func: 1, args: [$T]});
      for (maxValue = null, maxKey = null, _i = 0; _i < 4; ++_i) {
        value = input[_i];
        key = keyFunc.call$1(value);
        if (maxKey == null || J.$gt$n(key, maxKey)) {
          maxKey = key;
          maxValue = value;
        }
      }
      return maxValue;
    },
    MaterialPointArcTween: function MaterialPointArcTween(t0, t1) {
      var _ = this;
      _._arc$_dirty = true;
      _._endAngle = _._beginAngle = _._arc$_radius = _._center = null;
      _.begin = t0;
      _.end = t1;
    },
    MaterialPointArcTween__initialize_sweepAngle: function MaterialPointArcTween__initialize_sweepAngle(t0, t1) {
      this.$this = t0;
      this.distanceFromAtoB = t1;
    },
    _CornerId: function _CornerId(t0) {
      this._arc$_name = t0;
    },
    _Diagonal: function _Diagonal(t0, t1) {
      this.beginId = t0;
      this.endId = t1;
    },
    MaterialRectArcTween: function MaterialRectArcTween(t0, t1) {
      var _ = this;
      _._arc$_dirty = true;
      _._endArc = _._beginArc = null;
      _.begin = t0;
      _.end = t1;
    },
    MaterialRectArcTween__initialize_closure: function MaterialRectArcTween__initialize_closure(t0, t1) {
      this.$this = t0;
      this.centersVector = t1;
    },
    BottomAppBarTheme: function BottomAppBarTheme(t0, t1, t2) {
      this.color = t0;
      this.elevation = t1;
      this.shape = t2;
    },
    ShaderWarmUp: function ShaderWarmUp() {
    },
    DefaultShaderWarmUp: function DefaultShaderWarmUp() {
    },
    GestureRecognizerFactoryWithHandlers$: function(_constructor, _initializer, $T) {
      return new D.GestureRecognizerFactoryWithHandlers(_constructor, _initializer, [$T]);
    },
    GestureDetector$: function(behavior, child, dragStartBehavior, excludeFromSemantics, key, onDoubleTap, onHorizontalDragCancel, onHorizontalDragDown, onHorizontalDragEnd, onHorizontalDragUpdate, onLongPress, onPanDown, onPanEnd, onPanUpdate, onTap, onTapCancel, onTapDown, onVerticalDragEnd, onVerticalDragUpdate) {
      return new D.GestureDetector(child, onTapDown, onTap, onTapCancel, onDoubleTap, onLongPress, onVerticalDragUpdate, onVerticalDragEnd, onHorizontalDragDown, onHorizontalDragUpdate, onHorizontalDragEnd, onHorizontalDragCancel, onPanDown, onPanUpdate, onPanEnd, behavior, excludeFromSemantics, dragStartBehavior, key);
    },
    GestureRecognizerFactory: function GestureRecognizerFactory() {
    },
    GestureRecognizerFactoryWithHandlers: function GestureRecognizerFactoryWithHandlers(t0, t1, t2) {
      this._constructor = t0;
      this._initializer = t1;
      this.$ti = t2;
    },
    GestureDetector: function GestureDetector(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18) {
      var _ = this;
      _.child = t0;
      _.onTapDown = t1;
      _.onTap = t2;
      _.onTapCancel = t3;
      _.onDoubleTap = t4;
      _.onLongPress = t5;
      _.onVerticalDragUpdate = t6;
      _.onVerticalDragEnd = t7;
      _.onHorizontalDragDown = t8;
      _.onHorizontalDragUpdate = t9;
      _.onHorizontalDragEnd = t10;
      _.onHorizontalDragCancel = t11;
      _.onPanDown = t12;
      _.onPanUpdate = t13;
      _.onPanEnd = t14;
      _.behavior = t15;
      _.excludeFromSemantics = t16;
      _.dragStartBehavior = t17;
      _.key = t18;
    },
    GestureDetector_build_closure: function GestureDetector_build_closure(t0) {
      this.$this = t0;
    },
    GestureDetector_build_closure0: function GestureDetector_build_closure0(t0) {
      this.$this = t0;
    },
    GestureDetector_build_closure1: function GestureDetector_build_closure1(t0) {
      this.$this = t0;
    },
    GestureDetector_build_closure2: function GestureDetector_build_closure2(t0) {
      this.$this = t0;
    },
    GestureDetector_build_closure3: function GestureDetector_build_closure3(t0) {
      this.$this = t0;
    },
    GestureDetector_build_closure4: function GestureDetector_build_closure4(t0) {
      this.$this = t0;
    },
    GestureDetector_build_closure5: function GestureDetector_build_closure5(t0) {
      this.$this = t0;
    },
    GestureDetector_build_closure6: function GestureDetector_build_closure6(t0) {
      this.$this = t0;
    },
    GestureDetector_build_closure7: function GestureDetector_build_closure7(t0) {
      this.$this = t0;
    },
    GestureDetector_build_closure8: function GestureDetector_build_closure8(t0) {
      this.$this = t0;
    },
    GestureDetector_build_closure9: function GestureDetector_build_closure9(t0) {
      this.$this = t0;
    },
    GestureDetector_build_closure10: function GestureDetector_build_closure10(t0) {
      this.$this = t0;
    },
    RawGestureDetector: function RawGestureDetector(t0, t1, t2, t3, t4) {
      var _ = this;
      _.child = t0;
      _.gestures = t1;
      _.behavior = t2;
      _.excludeFromSemantics = t3;
      _.key = t4;
    },
    RawGestureDetectorState: function RawGestureDetectorState(t0, t1) {
      var _ = this;
      _._recognizers = t0;
      _._widget = null;
      _._debugLifecycleState = t1;
      _._element = null;
    },
    RawGestureDetectorState_debugFillProperties_closure: function RawGestureDetectorState_debugFillProperties_closure() {
    },
    _GestureSemantics: function _GestureSemantics(t0, t1, t2) {
      this.owner = t0;
      this.child = t1;
      this.key = t2;
    }
  },
  K = {CupertinoTheme: function CupertinoTheme(t0, t1, t2) {
      this.data = t0;
      this.child = t1;
      this.key = t2;
    }, _InheritedCupertinoTheme: function _InheritedCupertinoTheme(t0, t1, t2) {
      this.theme = t0;
      this.child = t1;
      this.key = t2;
    }, CupertinoThemeData: function CupertinoThemeData(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._brightness = t0;
      _._primaryColor = t1;
      _._primaryContrastingColor = t2;
      _._textTheme = t3;
      _._barBackgroundColor = t4;
      _._scaffoldBackgroundColor = t5;
    },
    ChipThemeData$: function(backgroundColor, brightness, deleteIconColor, disabledColor, elevation, labelPadding, labelStyle, padding, pressElevation, secondaryLabelStyle, secondarySelectedColor, selectedColor, selectedShadowColor, shadowColor, shape) {
      return new K.ChipThemeData(backgroundColor, deleteIconColor, disabledColor, selectedColor, secondarySelectedColor, shadowColor, selectedShadowColor, labelPadding, padding, shape, labelStyle, secondaryLabelStyle, brightness, elevation, pressElevation);
    },
    ChipThemeData_ChipThemeData$fromDefaults: function(brightness, labelStyle, secondaryColor) {
      var primaryColor, t1, t2, t3, backgroundColor, deleteIconColor, disabledColor, selectedColor, t4, t5, t6, secondarySelectedColor, secondaryLabelStyle, _null = null;
      H.assertHelper(secondaryColor != null);
      H.assertHelper(labelStyle != null);
      primaryColor = brightness === C.Brightness_1 ? C.Color_4278190080 : C.Color_4294967295;
      t1 = primaryColor.value;
      t2 = (16711680 & t1) >>> 16;
      t3 = (65280 & t1) >>> 8;
      t1 = (255 & t1) >>> 0;
      backgroundColor = P.Color$fromARGB(31, t2, t3, t1);
      deleteIconColor = P.Color$fromARGB(222, t2, t3, t1);
      disabledColor = P.Color$fromARGB(12, t2, t3, t1);
      selectedColor = P.Color$fromARGB(61, t2, t3, t1);
      t4 = secondaryColor.value;
      t5 = (16711680 & t4) >>> 16;
      t6 = (65280 & t4) >>> 8;
      t4 = (255 & t4) >>> 0;
      secondarySelectedColor = P.Color$fromARGB(61, t5, t6, t4);
      secondaryLabelStyle = labelStyle.copyWith$1$color(P.Color$fromARGB(222, t5, t6, t4));
      return K.ChipThemeData$(backgroundColor, brightness, deleteIconColor, disabledColor, _null, C.EdgeInsets_8_0_8_0, labelStyle.copyWith$1$color(P.Color$fromARGB(222, t2, t3, t1)), C.EdgeInsets_4_4_4_4, _null, secondaryLabelStyle, secondarySelectedColor, selectedColor, _null, _null, C.StadiumBorder_wjC);
    },
    ChipThemeData_lerp: function(a, b, t) {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, _null = null,
        t1 = a == null;
      if (t1 && b == null)
        return;
      t2 = t1 ? _null : a.backgroundColor;
      t3 = b == null;
      t2 = P.Color_lerp(t2, t3 ? _null : b.backgroundColor, t);
      t4 = t1 ? _null : a.deleteIconColor;
      t4 = P.Color_lerp(t4, t3 ? _null : b.deleteIconColor, t);
      t5 = t1 ? _null : a.disabledColor;
      t5 = P.Color_lerp(t5, t3 ? _null : b.disabledColor, t);
      t6 = t1 ? _null : a.selectedColor;
      t6 = P.Color_lerp(t6, t3 ? _null : b.selectedColor, t);
      t7 = t1 ? _null : a.secondarySelectedColor;
      t7 = P.Color_lerp(t7, t3 ? _null : b.secondarySelectedColor, t);
      t8 = t1 ? _null : a.shadowColor;
      t8 = P.Color_lerp(t8, t3 ? _null : b.shadowColor, t);
      t9 = t1 ? _null : a.selectedShadowColor;
      t9 = P.Color_lerp(t9, t3 ? _null : b.selectedShadowColor, t);
      t10 = t1 ? _null : a.labelPadding;
      t10 = V.EdgeInsetsGeometry_lerp(t10, t3 ? _null : b.labelPadding, t);
      t11 = t1 ? _null : a.padding;
      t11 = V.EdgeInsetsGeometry_lerp(t11, t3 ? _null : b.padding, t);
      t12 = t1 ? _null : a.shape;
      t12 = Y.ShapeBorder_lerp(t12, t3 ? _null : b.shape, t);
      t13 = t1 ? _null : a.labelStyle;
      t13 = A.TextStyle_lerp(t13, t3 ? _null : b.labelStyle, t);
      t14 = t1 ? _null : a.secondaryLabelStyle;
      t14 = A.TextStyle_lerp(t14, t3 ? _null : b.secondaryLabelStyle, t);
      if (t < 0.5) {
        t15 = t1 ? _null : a.brightness;
        if (t15 == null)
          t15 = C.Brightness_1;
      } else {
        t15 = t3 ? _null : b.brightness;
        if (t15 == null)
          t15 = C.Brightness_1;
      }
      t16 = t1 ? _null : a.elevation;
      t16 = P.lerpDouble(t16, t3 ? _null : b.elevation, t);
      t1 = t1 ? _null : a.pressElevation;
      return K.ChipThemeData$(t2, t15, t4, t5, t16, t10, t13, t11, P.lerpDouble(t1, t3 ? _null : b.pressElevation, t), t14, t7, t6, t9, t8, t12);
    },
    ChipThemeData: function ChipThemeData(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14) {
      var _ = this;
      _.backgroundColor = t0;
      _.deleteIconColor = t1;
      _.disabledColor = t2;
      _.selectedColor = t3;
      _.secondarySelectedColor = t4;
      _.shadowColor = t5;
      _.selectedShadowColor = t6;
      _.labelPadding = t7;
      _.padding = t8;
      _.shape = t9;
      _.labelStyle = t10;
      _.secondaryLabelStyle = t11;
      _.brightness = t12;
      _.elevation = t13;
      _.pressElevation = t14;
    },
    _FadeUpwardsPageTransition: function _FadeUpwardsPageTransition(t0, t1, t2, t3) {
      var _ = this;
      _._positionAnimation = t0;
      _._opacityAnimation = t1;
      _.child = t2;
      _.key = t3;
    },
    PageTransitionsBuilder: function PageTransitionsBuilder() {
    },
    FadeUpwardsPageTransitionsBuilder: function FadeUpwardsPageTransitionsBuilder() {
    },
    CupertinoPageTransitionsBuilder: function CupertinoPageTransitionsBuilder() {
    },
    PageTransitionsTheme: function PageTransitionsTheme() {
    },
    PageTransitionsTheme__all_closure: function PageTransitionsTheme__all_closure(t0) {
      this.builders = t0;
    },
    SnackBarThemeData$: function(actionTextColor, backgroundColor, behavior, disabledActionTextColor, elevation, shape) {
      return new K.SnackBarThemeData(backgroundColor, actionTextColor, disabledActionTextColor, elevation, shape, behavior);
    },
    SnackBarBehavior: function SnackBarBehavior() {
    },
    SnackBarThemeData: function SnackBarThemeData(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.backgroundColor = t0;
      _.actionTextColor = t1;
      _.disabledActionTextColor = t2;
      _.elevation = t3;
      _.shape = t4;
      _.behavior = t5;
    },
    Theme_of: function(context) {
      var t1, theme,
        inheritedTheme = H.interceptedTypeCheck(context.inheritFromWidgetOfExactType$1(C.Type__InheritedTheme_pIu), "$is_InheritedTheme"),
        category = L.Localizations_of(context, C.Type_MaterialLocalizations_flR, U.MaterialLocalizations) == null ? null : C.ScriptCategory_0;
      if (category == null)
        category = C.ScriptCategory_0;
      t1 = inheritedTheme == null ? null : inheritedTheme.theme;
      theme = t1 == null ? null : t1.data;
      if (theme == null)
        theme = $.$get$Theme__kFallbackTheme();
      return X.ThemeData_localize(theme, theme.typography.geometryThemeFor$1(category));
    },
    Theme: function Theme(t0, t1, t2, t3) {
      var _ = this;
      _.data = t0;
      _.isMaterialAppTheme = t1;
      _.child = t2;
      _.key = t3;
    },
    _InheritedTheme: function _InheritedTheme(t0, t1, t2) {
      this.theme = t0;
      this.child = t1;
      this.key = t2;
    },
    ThemeDataTween: function ThemeDataTween(t0, t1) {
      this.begin = t0;
      this.end = t1;
    },
    AnimatedTheme: function AnimatedTheme(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.data = t0;
      _.isMaterialAppTheme = t1;
      _.child = t2;
      _.curve = t3;
      _.duration = t4;
      _.key = t5;
    },
    _AnimatedThemeState: function _AnimatedThemeState(t0, t1) {
      var _ = this;
      _._animation = _._implicit_animations$_controller = _._theme$_data = null;
      _.SingleTickerProviderStateMixin__ticker = t0;
      _._widget = null;
      _._debugLifecycleState = t1;
      _._element = null;
    },
    _AnimatedThemeState_forEachTween_closure: function _AnimatedThemeState_forEachTween_closure() {
    },
    AlignmentGeometry_lerp: function(a, b, t) {
      var t1 = a == null;
      if (t1 && b == null)
        return;
      if (t1)
        return b.$mul(0, t);
      if (b == null)
        return a.$mul(0, 1 - t);
      if (!!a.$isAlignment && !!b.$isAlignment)
        return K.Alignment_lerp(a, b, t);
      if (!!a.$isAlignmentDirectional && !!b.$isAlignmentDirectional)
        return K.AlignmentDirectional_lerp(a, b, t);
      return new K._MixedAlignment(P.lerpDouble(a.get$_x(), b.get$_x(), t), P.lerpDouble(a.get$_alignment$_start(), b.get$_alignment$_start(), t), P.lerpDouble(a.get$_y(), b.get$_y(), t));
    },
    Alignment$: function(x, y) {
      return new K.Alignment(x, y);
    },
    Alignment_lerp: function(a, b, t) {
      return K.Alignment$(P.lerpDouble(a.x, b.x, t), P.lerpDouble(a.y, b.y, t));
    },
    Alignment__stringify: function(x, y) {
      var t2, t3,
        t1 = x === -1;
      if (t1 && y === -1)
        return "topLeft";
      t2 = x === 0;
      if (t2 && y === -1)
        return "topCenter";
      t3 = x === 1;
      if (t3 && y === -1)
        return "topRight";
      if (t1 && y === 0)
        return "centerLeft";
      if (t2 && y === 0)
        return "center";
      if (t3 && y === 0)
        return "centerRight";
      if (t1 && y === 1)
        return "bottomLeft";
      if (t2 && y === 1)
        return "bottomCenter";
      if (t3 && y === 1)
        return "bottomRight";
      return "Alignment(" + J.toStringAsFixed$1$n(x, 1) + ", " + J.toStringAsFixed$1$n(y, 1) + ")";
    },
    AlignmentDirectional$: function(start, y) {
      return new K.AlignmentDirectional(start, y);
    },
    AlignmentDirectional_lerp: function(a, b, t) {
      return K.AlignmentDirectional$(P.lerpDouble(a.start, b.start, t), P.lerpDouble(a.y, b.y, t));
    },
    AlignmentDirectional__stringify: function(start, y) {
      var t2, t3,
        t1 = start === -1;
      if (t1 && y === -1)
        return "AlignmentDirectional.topStart";
      t2 = start === 0;
      if (t2 && y === -1)
        return "AlignmentDirectional.topCenter";
      t3 = start === 1;
      if (t3 && y === -1)
        return "AlignmentDirectional.topEnd";
      if (t1 && y === 0)
        return "AlignmentDirectional.centerStart";
      if (t2 && y === 0)
        return "AlignmentDirectional.center";
      if (t3 && y === 0)
        return "AlignmentDirectional.centerEnd";
      if (t1 && y === 1)
        return "AlignmentDirectional.bottomStart";
      if (t2 && y === 1)
        return "AlignmentDirectional.bottomCenter";
      if (t3 && y === 1)
        return "AlignmentDirectional.bottomEnd";
      return "AlignmentDirectional(" + J.toStringAsFixed$1$n(start, 1) + ", " + J.toStringAsFixed$1$n(y, 1) + ")";
    },
    AlignmentGeometry: function AlignmentGeometry() {
    },
    Alignment: function Alignment(t0, t1) {
      this.x = t0;
      this.y = t1;
    },
    AlignmentDirectional: function AlignmentDirectional(t0, t1) {
      this.start = t0;
      this.y = t1;
    },
    _MixedAlignment: function _MixedAlignment(t0, t1, t2) {
      this._x = t0;
      this._alignment$_start = t1;
      this._y = t2;
    },
    BorderRadiusGeometry_lerp: function(a, b, t) {
      var t1 = a == null;
      if (t1 && b == null)
        return;
      if (t1)
        a = C.BorderRadius_tLn;
      return a.add$1(0, (b == null ? C.BorderRadius_tLn : b).subtract$1(a).$mul(0, t));
    },
    BorderRadius$circular: function(radius) {
      var t1 = new P.Radius(radius, radius);
      return new K.BorderRadius(t1, t1, t1, t1);
    },
    BorderRadius_lerp: function(a, b, t) {
      var t1;
      H.assertHelper(t != null);
      t1 = a == null;
      if (t1 && b == null)
        return;
      if (t1)
        return b.$mul(0, t);
      if (b == null) {
        if (typeof t !== "number")
          return H.iae(t);
        return a.$mul(0, 1 - t);
      }
      return new K.BorderRadius(P.Radius_lerp(a.topLeft, b.topLeft, t), P.Radius_lerp(a.topRight, b.topRight, t), P.Radius_lerp(a.bottomLeft, b.bottomLeft, t), P.Radius_lerp(a.bottomRight, b.bottomRight, t));
    },
    BorderRadiusGeometry: function BorderRadiusGeometry() {
    },
    BorderRadius: function BorderRadius(t0, t1, t2, t3) {
      var _ = this;
      _.topLeft = t0;
      _.topRight = t1;
      _.bottomLeft = t2;
      _.bottomRight = t3;
    },
    _MixedBorderRadius: function _MixedBorderRadius(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _._topLeft = t0;
      _._topRight = t1;
      _._bottomLeft = t2;
      _._bottomRight = t3;
      _._topStart = t4;
      _._topEnd = t5;
      _._bottomStart = t6;
      _._bottomEnd = t7;
    },
    PaintingContext$: function(_containerLayer, estimatedBounds) {
      return new K.PaintingContext(_containerLayer, estimatedBounds);
    },
    PaintingContext__repaintCompositedChild: function(child, childContext, debugAlsoPaintedParent) {
      var t1;
      H.assertHelper(child.get$isRepaintBoundary());
      H.assertHelper(new K.PaintingContext__repaintCompositedChild_closure(child, debugAlsoPaintedParent).call$0());
      t1 = child._layer;
      if (t1 == null) {
        H.assertHelper(debugAlsoPaintedParent);
        child._layer = new T.OffsetLayer(C.Offset_0_0);
      } else {
        H.assertHelper(debugAlsoPaintedParent || t1._node$_owner != null);
        child._layer.removeAllChildren$0();
      }
      H.assertHelper(new K.PaintingContext__repaintCompositedChild_closure0(child).call$0());
      if (childContext == null)
        childContext = K.PaintingContext$(child._layer, child.get$paintBounds());
      child._paintWithContext$2(childContext, C.Offset_0_0);
      childContext.stopRecordingIfNeeded$0();
    },
    PaintingContext_debugInstrumentRepaintCompositedChild: function(child, customContext) {
      H.assertHelper(new K.PaintingContext_debugInstrumentRepaintCompositedChild_closure(child, false, customContext).call$0());
    },
    FlutterErrorDetailsForRendering$: function(context, exception, informationCollector, library, renderObject, stack) {
      return new K.FlutterErrorDetailsForRendering(renderObject, exception, stack, library, context, informationCollector, false);
    },
    _SemanticsGeometry__transformRect: function(rect, $parent, child) {
      var transform;
      if (rect == null)
        return;
      if (rect.get$isEmpty(rect))
        return C.Rect_0_0_0_0;
      transform = new E.Matrix4(new Float64Array(16));
      transform.setIdentity$0();
      $parent.applyPaintTransform$2(child, transform);
      return T.MatrixUtils_inverseTransformRect(transform, rect);
    },
    _SemanticsGeometry__intersectRects: function(a, b) {
      if (a == null)
        return b;
      if (b == null)
        return a;
      return a.intersect$1(b);
    },
    ParentData: function ParentData() {
    },
    PaintingContext: function PaintingContext(t0, t1) {
      var _ = this;
      _._containerLayer = t0;
      _.estimatedBounds = t1;
      _._canvas = _._recorder = _._currentLayer = null;
    },
    PaintingContext__repaintCompositedChild_closure: function PaintingContext__repaintCompositedChild_closure(t0, t1) {
      this.child = t0;
      this.debugAlsoPaintedParent = t1;
    },
    PaintingContext__repaintCompositedChild_closure0: function PaintingContext__repaintCompositedChild_closure0(t0) {
      this.child = t0;
    },
    PaintingContext_debugInstrumentRepaintCompositedChild_closure: function PaintingContext_debugInstrumentRepaintCompositedChild_closure(t0, t1, t2) {
      this.child = t0;
      this.debugAlsoPaintedParent = t1;
      this.customContext = t2;
    },
    PaintingContext_paintChild_closure: function PaintingContext_paintChild_closure(t0) {
      this.child = t0;
    },
    PaintingContext_paintChild_closure0: function PaintingContext_paintChild_closure0() {
    },
    PaintingContext__compositeChild_closure: function PaintingContext__compositeChild_closure(t0) {
      this.child = t0;
    },
    PaintingContext__isRecording_closure: function PaintingContext__isRecording_closure(t0, t1) {
      this.$this = t0;
      this.hasCanvas = t1;
    },
    PaintingContext_stopRecordingIfNeeded_closure: function PaintingContext_stopRecordingIfNeeded_closure(t0) {
      this.$this = t0;
    },
    PaintingContext_pushClipRect_closure: function PaintingContext_pushClipRect_closure(t0, t1, t2) {
      this.$this = t0;
      this.painter = t1;
      this.offset = t2;
    },
    Constraints: function Constraints() {
    },
    SemanticsHandle_dispose_closure: function SemanticsHandle_dispose_closure(t0) {
      this.$this = t0;
    },
    PipelineOwner: function PipelineOwner(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.onNeedVisualUpdate = t0;
      _.onSemanticsOwnerCreated = t1;
      _.onSemanticsOwnerDisposed = t2;
      _._rootNode = null;
      _._nodesNeedingLayout = t3;
      _._debugAllowMutationsToDirtySubtrees = _._debugDoingLayout = false;
      _._nodesNeedingCompositingBitsUpdate = t4;
      _._nodesNeedingPaint = t5;
      _._debugDoingPaint = false;
      _._semanticsOwner = null;
      _._outstandingSemanticsHandles = 0;
      _._debugDoingSemantics = false;
      _._nodesNeedingSemantics = t6;
    },
    PipelineOwner_flushLayout_closure: function PipelineOwner_flushLayout_closure(t0) {
      this.$this = t0;
    },
    PipelineOwner_flushLayout_closure0: function PipelineOwner_flushLayout_closure0() {
    },
    PipelineOwner_flushLayout_closure1: function PipelineOwner_flushLayout_closure1(t0) {
      this.$this = t0;
    },
    PipelineOwner_flushCompositingBits_closure: function PipelineOwner_flushCompositingBits_closure() {
    },
    PipelineOwner_flushPaint_closure: function PipelineOwner_flushPaint_closure(t0) {
      this.$this = t0;
    },
    PipelineOwner_flushPaint_closure0: function PipelineOwner_flushPaint_closure0() {
    },
    PipelineOwner_flushPaint_closure1: function PipelineOwner_flushPaint_closure1(t0) {
      this.$this = t0;
    },
    PipelineOwner_flushSemantics_closure: function PipelineOwner_flushSemantics_closure(t0) {
      this.$this = t0;
    },
    PipelineOwner_flushSemantics_closure0: function PipelineOwner_flushSemantics_closure0() {
    },
    PipelineOwner_flushSemantics_closure1: function PipelineOwner_flushSemantics_closure1(t0) {
      this.$this = t0;
    },
    RenderObject: function RenderObject() {
    },
    RenderObject_reassemble_closure: function RenderObject_reassemble_closure() {
    },
    RenderObject__debugReportException_closure: function RenderObject__debugReportException_closure(t0) {
      this.$this = t0;
    },
    RenderObject__debugReportException_closure_visitor: function RenderObject__debugReportException_closure_visitor(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.maxLines = t1;
      _.descendants = t2;
      _.maxDepth = t3;
    },
    RenderObject__debugCanPerformMutations_closure: function RenderObject__debugCanPerformMutations_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    RenderObject_debugNeedsLayout_closure: function RenderObject_debugNeedsLayout_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    RenderObject_markNeedsLayout_closure: function RenderObject_markNeedsLayout_closure(t0) {
      this.$this = t0;
    },
    RenderObject__cleanRelayoutBoundary_closure: function RenderObject__cleanRelayoutBoundary_closure() {
    },
    RenderObject_scheduleInitialLayout_closure: function RenderObject_scheduleInitialLayout_closure(t0) {
      this.$this = t0;
    },
    RenderObject__layoutWithoutResize_closure: function RenderObject__layoutWithoutResize_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    RenderObject__layoutWithoutResize_closure0: function RenderObject__layoutWithoutResize_closure0(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    RenderObject_layout_closure: function RenderObject_layout_closure(t0) {
      this.$this = t0;
    },
    RenderObject_layout_closure0: function RenderObject_layout_closure0(t0, t1) {
      this.$this = t0;
      this.parentUsesSize = t1;
    },
    RenderObject_layout_closure1: function RenderObject_layout_closure1(t0) {
      this.$this = t0;
    },
    RenderObject_layout_closure2: function RenderObject_layout_closure2(t0) {
      this.$this = t0;
    },
    RenderObject_layout_closure3: function RenderObject_layout_closure3(t0) {
      this.$this = t0;
    },
    RenderObject_layout_closure4: function RenderObject_layout_closure4(t0) {
      this.$this = t0;
    },
    RenderObject_layout_closure5: function RenderObject_layout_closure5(t0) {
      this.$this = t0;
    },
    RenderObject_layout_closure6: function RenderObject_layout_closure6(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    RenderObject_layout_closure7: function RenderObject_layout_closure7(t0) {
      this.$this = t0;
    },
    RenderObject_layout_closure8: function RenderObject_layout_closure8(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    RenderObject_debugLayer_closure: function RenderObject_debugLayer_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    RenderObject_markNeedsCompositingBitsUpdate_closure: function RenderObject_markNeedsCompositingBitsUpdate_closure(t0) {
      this.$this = t0;
    },
    RenderObject__updateCompositingBits_closure: function RenderObject__updateCompositingBits_closure(t0) {
      this.$this = t0;
    },
    RenderObject_markNeedsPaint_closure: function RenderObject_markNeedsPaint_closure(t0) {
      this.$this = t0;
    },
    RenderObject_markNeedsPaint_closure0: function RenderObject_markNeedsPaint_closure0(t0) {
      this.$this = t0;
    },
    RenderObject__paintWithContext_closure: function RenderObject__paintWithContext_closure(t0) {
      this.$this = t0;
    },
    RenderObject__paintWithContext_closure0: function RenderObject__paintWithContext_closure0(t0) {
      this.$this = t0;
    },
    RenderObject__paintWithContext_closure1: function RenderObject__paintWithContext_closure1(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    RenderObject__paintWithContext_closure2: function RenderObject__paintWithContext_closure2(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.context = t2;
      _.offset = t3;
    },
    RenderObject_debugSemantics_closure: function RenderObject_debugSemantics_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    RenderObject_clearSemantics_closure: function RenderObject_clearSemantics_closure() {
    },
    RenderObject__getSemanticsForParent_closure: function RenderObject__getSemanticsForParent_closure(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.childrenMergeIntoParent = t2;
      _.fragments = t3;
      _.toBeMarkedExplicit = t4;
      _.config = t5;
      _.producesForkingFragment = t6;
    },
    RenderObject_toStringDeep_closure: function RenderObject_toStringDeep_closure(t0) {
      this._box_0 = t0;
    },
    RenderObject_toStringDeep_closure0: function RenderObject_toStringDeep_closure0(t0) {
      this._box_0 = t0;
    },
    RenderObject_toStringShallow_closure: function RenderObject_toStringShallow_closure(t0) {
      this._box_0 = t0;
    },
    RenderObject_toStringShallow_closure0: function RenderObject_toStringShallow_closure0(t0) {
      this._box_0 = t0;
    },
    RenderObjectWithChildMixin: function RenderObjectWithChildMixin() {
    },
    RenderObjectWithChildMixin_debugValidateChild_closure: function RenderObjectWithChildMixin_debugValidateChild_closure(t0, t1) {
      this.$this = t0;
      this.child = t1;
    },
    ContainerParentDataMixin: function ContainerParentDataMixin() {
    },
    ContainerRenderObjectMixin: function ContainerRenderObjectMixin() {
    },
    ContainerRenderObjectMixin_debugValidateChild_closure: function ContainerRenderObjectMixin_debugValidateChild_closure(t0, t1) {
      this.$this = t0;
      this.child = t1;
    },
    FlutterErrorDetailsForRendering: function FlutterErrorDetailsForRendering(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.renderObject = t0;
      _.exception = t1;
      _.stack = t2;
      _.library = t3;
      _.context = t4;
      _.informationCollector = t5;
      _.silent = t6;
    },
    _SemanticsFragment: function _SemanticsFragment() {
    },
    _ContainerSemanticsFragment: function _ContainerSemanticsFragment(t0, t1) {
      this.interestingFragments = t0;
      this.dropsSemanticsOfPreviousSiblings = t1;
    },
    _InterestingSemanticsFragment: function _InterestingSemanticsFragment() {
    },
    _RootSemanticsFragment: function _RootSemanticsFragment(t0, t1, t2) {
      var _ = this;
      _._object$_children = t0;
      _._ancestorChain = t1;
      _._object$_tagsForChildren = null;
      _.dropsSemanticsOfPreviousSiblings = t2;
    },
    _SwitchableSemanticsFragment: function _SwitchableSemanticsFragment(t0, t1, t2, t3, t4) {
      var _ = this;
      _._mergeIntoParent = t0;
      _._config = t1;
      _._isConfigWritable = false;
      _._object$_children = t2;
      _._isExplicit = false;
      _._ancestorChain = t3;
      _._object$_tagsForChildren = null;
      _.dropsSemanticsOfPreviousSiblings = t4;
    },
    _AbortingSemanticsFragment: function _AbortingSemanticsFragment(t0, t1) {
      this._ancestorChain = t0;
      this._object$_tagsForChildren = null;
      this.dropsSemanticsOfPreviousSiblings = t1;
    },
    _SemanticsGeometry: function _SemanticsGeometry() {
      var _ = this;
      _._rect = _._object$_transform = _._semanticsClipRect = _._paintClipRect = null;
      _._markAsHidden = false;
    },
    _RenderObject_AbstractNode_DiagnosticableTreeMixin: function _RenderObject_AbstractNode_DiagnosticableTreeMixin() {
    },
    RelativeRect$fromLTRB: function(left, $top, right, bottom) {
      return new K.RelativeRect(left, $top, right, bottom);
    },
    RelativeRect: function RelativeRect(t0, t1, t2, t3) {
      var _ = this;
      _.left = t0;
      _.top = t1;
      _.right = t2;
      _.bottom = t3;
    },
    StackParentData: function StackParentData(t0, t1, t2) {
      var _ = this;
      _.height = _.width = _.left = _.bottom = _.right = _.top = null;
      _.ContainerParentDataMixin_previousSibling = t0;
      _.ContainerParentDataMixin_nextSibling = t1;
      _.offset = t2;
    },
    StackFit: function StackFit(t0) {
      this._stack$_name = t0;
    },
    Overflow: function Overflow(t0) {
      this._stack$_name = t0;
    },
    RenderStack: function RenderStack(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._hasVisualOverflow = false;
      _._stack$_resolvedAlignment = null;
      _._stack$_alignment = t0;
      _._stack$_textDirection = t1;
      _._fit = t2;
      _._overflow = t3;
      _.ContainerRenderObjectMixin__childCount = t4;
      _.ContainerRenderObjectMixin__firstChild = t5;
      _.ContainerRenderObjectMixin__lastChild = t6;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    _RenderStack_RenderBox_ContainerRenderObjectMixin: function _RenderStack_RenderBox_ContainerRenderObjectMixin() {
    },
    _RenderStack_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin: function _RenderStack_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin() {
    },
    Navigator_maybePop: function(context, $T) {
      H.assertSubtypeOfRuntimeType(null, $T);
      return K.Navigator_of(context).maybePop$1$1(null, $T);
    },
    Navigator_of: function(context) {
      var t1 = context.ancestorStateOfType$1(C.C_TypeMatcher2);
      H.interceptedTypeCheck(t1, "$isNavigatorState");
      H.assertHelper(new K.Navigator_of_closure(t1, false).call$0());
      return t1;
    },
    RoutePopDisposition: function RoutePopDisposition(t0) {
      this._navigator$_name = t0;
    },
    Route: function Route() {
    },
    RouteSettings: function RouteSettings(t0, t1, t2) {
      this.name = t0;
      this.isInitialRoute = t1;
      this.$arguments = t2;
    },
    NavigatorObserver: function NavigatorObserver() {
    },
    Navigator: function Navigator(t0, t1, t2, t3, t4) {
      var _ = this;
      _.initialRoute = t0;
      _.onGenerateRoute = t1;
      _.onUnknownRoute = t2;
      _.observers = t3;
      _.key = t4;
    },
    Navigator_of_closure: function Navigator_of_closure(t0, t1) {
      this.navigator = t0;
      this.nullOk = t1;
    },
    NavigatorState: function NavigatorState(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _._overlayKey = t0;
      _._history = t1;
      _._poppedRoutes = t2;
      _.focusScopeNode = t3;
      _._initialOverlayEntries = t4;
      _._debugLocked = false;
      _._userGesturesInProgress = 0;
      _._activePointers = t5;
      _.TickerProviderStateMixin__tickers = t6;
      _._widget = null;
      _._debugLifecycleState = t7;
      _._element = null;
    },
    NavigatorState_initState_closure: function NavigatorState_initState_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.plannedInitialRouteNames = t1;
      this.plannedInitialRoutes = t2;
    },
    NavigatorState_dispose_closure: function NavigatorState_dispose_closure(t0) {
      this.$this = t0;
    },
    NavigatorState_dispose_closure0: function NavigatorState_dispose_closure0(t0) {
      this.$this = t0;
    },
    NavigatorState__routeNamed_closure: function NavigatorState__routeNamed_closure(t0, t1) {
      this.$this = t0;
      this.name = t1;
    },
    NavigatorState__routeNamed_closure0: function NavigatorState__routeNamed_closure0(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.name = t2;
    },
    NavigatorState_push_closure: function NavigatorState_push_closure(t0) {
      this.$this = t0;
    },
    NavigatorState_push_closure0: function NavigatorState_push_closure0(t0) {
      this.$this = t0;
    },
    NavigatorState_pop_closure: function NavigatorState_pop_closure(t0) {
      this.$this = t0;
    },
    NavigatorState_pop_closure0: function NavigatorState_pop_closure0(t0, t1) {
      this._box_0 = t0;
      this.route = t1;
    },
    NavigatorState_pop_closure1: function NavigatorState_pop_closure1(t0) {
      this.$this = t0;
    },
    NavigatorState_pop_closure2: function NavigatorState_pop_closure2(t0) {
      this.$this = t0;
    },
    NavigatorState__cancelActivePointers_closure: function NavigatorState__cancelActivePointers_closure(t0) {
      this.absorber = t0;
    },
    _NavigatorState_State_TickerProviderStateMixin_dispose_closure: function _NavigatorState_State_TickerProviderStateMixin_dispose_closure(t0) {
      this.$this = t0;
    },
    _NavigatorState_State_TickerProviderStateMixin: function _NavigatorState_State_TickerProviderStateMixin() {
    },
    ScrollBehavior: function ScrollBehavior() {
    },
    ScrollConfiguration: function ScrollConfiguration(t0, t1, t2) {
      this.behavior = t0;
      this.child = t1;
      this.key = t2;
    },
    SlideTransition$: function(child, position, textDirection, transformHitTests) {
      return new K.SlideTransition(textDirection, transformHitTests, child, position, null);
    },
    ScaleTransition$: function(child, scale) {
      return new K.ScaleTransition(child, scale, null);
    },
    RotationTransition$: function(child, turns) {
      return new K.RotationTransition(child, turns, null);
    },
    FadeTransition$: function(child, opacity) {
      return new K.FadeTransition(opacity, child, null);
    },
    AnimatedBuilder$: function(animation, builder, child) {
      return new K.AnimatedBuilder(builder, child, animation, null);
    },
    AnimatedWidget: function AnimatedWidget() {
    },
    _AnimatedState: function _AnimatedState(t0) {
      this._widget = null;
      this._debugLifecycleState = t0;
      this._element = null;
    },
    _AnimatedState__handleChange_closure: function _AnimatedState__handleChange_closure() {
    },
    SlideTransition: function SlideTransition(t0, t1, t2, t3, t4) {
      var _ = this;
      _.textDirection = t0;
      _.transformHitTests = t1;
      _.child = t2;
      _.listenable = t3;
      _.key = t4;
    },
    ScaleTransition: function ScaleTransition(t0, t1, t2) {
      this.child = t0;
      this.listenable = t1;
      this.key = t2;
    },
    RotationTransition: function RotationTransition(t0, t1, t2) {
      this.child = t0;
      this.listenable = t1;
      this.key = t2;
    },
    FadeTransition: function FadeTransition(t0, t1, t2) {
      this.opacity = t0;
      this.child = t1;
      this.key = t2;
    },
    DecoratedBoxTransition: function DecoratedBoxTransition(t0, t1, t2, t3) {
      var _ = this;
      _.decoration = t0;
      _.child = t1;
      _.listenable = t2;
      _.key = t3;
    },
    AnimatedBuilder: function AnimatedBuilder(t0, t1, t2, t3) {
      var _ = this;
      _.builder = t0;
      _.child = t1;
      _.listenable = t2;
      _.key = t3;
    }
  },
  U = {
    FlutterErrorDetails$: function(context, exception, informationCollector, library, silent, stack) {
      return new U.FlutterErrorDetails(exception, stack, library, context, informationCollector, false);
    },
    FlutterError$: function(message) {
      return new U.FlutterError(message);
    },
    FlutterError_dumpErrorToConsole: function(details, forceReport) {
      var header, footer, t1, verb, t2, errorName, prefix, message, t3, t4, stackLines, stackList, throwPattern, assertPattern, assertMatch, ourLibraryPattern, ourFault, information, _box_0 = {};
      _box_0.reportError = true;
      H.assertHelper(new U.FlutterError_dumpErrorToConsole_closure(_box_0).call$0());
      if (!_box_0.reportError && true)
        return;
      if ($.FlutterError__errorCount === 0 || false) {
        header = ("\u2550\u2550\u2561 EXCEPTION CAUGHT BY " + details.library + " \u255e").toUpperCase();
        footer = C.JSString_methods.$mul("\u2550", 100);
        D.print__debugPrintThrottled$closure().call$1(header + C.JSString_methods.$mul("\u2550", footer.length - header.length));
        t1 = details.context;
        verb = "thrown" + (t1 != null ? " " + t1 : "");
        t1 = details.exception;
        t2 = J.getInterceptor$(t1);
        if (!!t2.$isNullThrownError)
          D.debugPrintThrottled("The null value was " + verb + ".", 100);
        else if (typeof t1 === "number")
          D.debugPrintThrottled("The number " + H.S(t1) + " was " + verb + ".", 100);
        else {
          if (!!t2.$isAssertionError)
            errorName = "assertion";
          else if (typeof t1 === "string")
            errorName = "message";
          else
            errorName = !!t2.$isError || !!t2.$isException ? t2.get$runtimeType(t1).toString$0(0) : t2.get$runtimeType(t1).toString$0(0) + " object";
          prefix = t2.get$runtimeType(t1).toString$0(0) + ": ";
          message = details.exceptionAsString$0();
          if (C.JSString_methods.startsWith$1(message, prefix))
            message = C.JSString_methods.substring$1(message, prefix.length);
          D.debugPrintThrottled("The following " + errorName + " was " + verb + ":\n" + message, 100);
        }
        t3 = details.stack;
        t4 = t3 != null;
        stackLines = t4 ? H.setRuntimeTypeInfo(C.JSString_methods.trimRight$0(t3.toString$0(0)).split("\n"), [P.String]) : null;
        if (!!t2.$isAssertionError && !t1.$isFlutterError) {
          if (stackLines != null) {
            stackList = H.SubListIterable$(stackLines, 0, 2, H.getTypeArgumentByIndex(stackLines, 0)).toList$0(0);
            if (stackList.length >= 2) {
              throwPattern = P.RegExp_RegExp("^#0 +_AssertionError._throwNew \\(dart:.+\\)$");
              assertPattern = P.RegExp_RegExp("^#1 +[^(]+ \\((.+?):([0-9]+)(?::[0-9]+)?\\)$");
              if (0 >= stackList.length)
                return H.ioore(stackList, 0);
              t1 = H.stringTypeCheck(stackList[0]);
              if (typeof t1 !== "string")
                H.throwExpression(H.argumentErrorValue(t1));
              if (throwPattern._nativeRegExp.test(t1)) {
                if (1 >= stackList.length)
                  return H.ioore(stackList, 1);
                assertMatch = assertPattern.firstMatch$1(stackList[1]);
                if (assertMatch != null) {
                  t1 = assertMatch._match;
                  H.assertHelper(t1.length - 1 === 2);
                  ourLibraryPattern = P.RegExp_RegExp("^package:flutter/");
                  if (1 >= t1.length)
                    return H.ioore(t1, 1);
                  t1 = t1[1];
                  if (typeof t1 !== "string")
                    H.throwExpression(H.argumentErrorValue(t1));
                  ourFault = ourLibraryPattern._nativeRegExp.test(t1);
                } else
                  ourFault = true;
              } else
                ourFault = true;
            } else
              ourFault = true;
          } else
            ourFault = true;
          if (ourFault) {
            D.debugPrintThrottled("\nEither the assertion indicates an error in the framework itself, or we should provide substantially more information in this error message to help you determine and fix the underlying cause.", 100);
            D.debugPrintThrottled("In either case, please report this assertion by filing a bug on GitHub:", 100);
            D.print__debugPrintThrottled$closure().call$1("  https://github.com/flutter/flutter/issues/new?template=BUG.md");
          }
        }
        if (t4) {
          D.debugPrintThrottled("\nWhen the exception was thrown, this was the stack:", 100);
          stackLines = U.FlutterError_defaultStackFilter(stackLines);
          for (t1 = C.JSArray_methods.get$iterator(stackLines); t1.moveNext$0();)
            D.debugPrintThrottled(t1.get$current(), 100);
        }
        t1 = details.informationCollector;
        if (t1 != null) {
          information = new P.StringBuffer("");
          t1.call$1(information);
          t1 = information._contents;
          D.debugPrintThrottled("\n" + C.JSString_methods.trimRight$0(t1.charCodeAt(0) == 0 ? t1 : t1), 100);
        }
        D.print__debugPrintThrottled$closure().call$1(footer);
      } else {
        t1 = details.exceptionAsString$0().split("\n");
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        D.print__debugPrintThrottled$closure().call$1("Another exception was thrown: " + J.trimLeft$0$s(t1[0]));
      }
      $.FlutterError__errorCount = $.FlutterError__errorCount + 1;
    },
    FlutterError_defaultStackFilter: function($frames) {
      var stackParser, packageParser, t2, result, skipped, t3, match, t4, packageMatch, where,
        t1 = P.String;
      H.assertSubtype($frames, "$isIterable", [t1], "$asIterable");
      stackParser = P.RegExp_RegExp("^#[0-9]+ +([^.]+).* \\(([^/\\\\]*)[/\\\\].+:[0-9]+(?::[0-9]+)?\\)$");
      packageParser = P.RegExp_RegExp("^([^:]+):(.+)$");
      t2 = [t1];
      result = H.setRuntimeTypeInfo([], t2);
      skipped = H.setRuntimeTypeInfo([], t2);
      for (t2 = J.get$iterator$ax($frames); t2.moveNext$0();) {
        t3 = t2.get$current();
        match = stackParser.firstMatch$1(t3);
        if (match != null) {
          t4 = match._match;
          H.assertHelper(t4.length - 1 === 2);
          if (2 >= t4.length)
            return H.ioore(t4, 2);
          if (C.JSArray_methods.contains$1(C.List_cg9, t4[2])) {
            if (2 >= t4.length)
              return H.ioore(t4, 2);
            packageMatch = packageParser.firstMatch$1(t4[2]);
            if (packageMatch != null) {
              t3 = packageMatch._match;
              if (1 >= t3.length)
                return H.ioore(t3, 1);
              t3 = t3[1] === "package";
            } else
              t3 = false;
            if (t3) {
              t3 = packageMatch._match;
              if (2 >= t3.length)
                return H.ioore(t3, 2);
              C.JSArray_methods.add$1(skipped, "package " + H.S(t3[2]));
            } else {
              if (2 >= t4.length)
                return H.ioore(t4, 2);
              C.JSArray_methods.add$1(skipped, "package " + H.S(t4[2]));
            }
            continue;
          }
          if (1 >= t4.length)
            return H.ioore(t4, 1);
          if (C.JSArray_methods.contains$1(C.List_ifn, t4[1])) {
            if (1 >= t4.length)
              return H.ioore(t4, 1);
            C.JSArray_methods.add$1(skipped, "class " + H.S(t4[1]));
            continue;
          }
        }
        C.JSArray_methods.add$1(result, t3);
      }
      t2 = skipped.length;
      if (t2 === 1)
        C.JSArray_methods.add$1(result, "(elided one frame from " + C.JSArray_methods.get$single(skipped) + ")");
      else if (t2 > 1) {
        where = P.LinkedHashSet_LinkedHashSet$from(skipped, t1).toList$0(0);
        C.JSArray_methods.sort$0(where);
        t1 = where.length;
        if (t1 > 1)
          C.JSArray_methods.$indexSet(where, t1 - 1, "and " + H.S(C.JSArray_methods.get$last(where)));
        t1 = where.length;
        t2 = skipped.length;
        if (t1 > 2)
          C.JSArray_methods.add$1(result, "(elided " + t2 + " frames from " + C.JSArray_methods.join$1(where, ", ") + ")");
        else
          C.JSArray_methods.add$1(result, "(elided " + t2 + " frames from " + C.JSArray_methods.join$1(where, " ") + ")");
      }
      return result;
    },
    FlutterError_reportError: function(details) {
      U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(details);
    },
    FlutterErrorDetails: function FlutterErrorDetails(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.exception = t0;
      _.stack = t1;
      _.library = t2;
      _.context = t3;
      _.informationCollector = t4;
      _.silent = t5;
    },
    FlutterError: function FlutterError(t0) {
      this.message = t0;
    },
    FlutterError_dumpErrorToConsole_closure: function FlutterError_dumpErrorToConsole_closure(t0) {
      this._box_0 = t0;
    },
    _getClipCallback: function(referenceBox, containedInkWell, rectCallback) {
      if (containedInkWell)
        return new U._getClipCallback_closure(referenceBox);
      return;
    },
    _getTargetRadius: function(referenceBox, containedInkWell, rectCallback, position) {
      var size, d1, t1, d2, t2, d3, d4;
      if (containedInkWell) {
        size = referenceBox.get$size();
        size.toString;
        d1 = position.$sub(0, C.Offset_0_0).get$distance();
        t1 = size._dx;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = 0 + t1;
        d2 = position.$sub(0, new P.Offset(t1, 0)).get$distance();
        t2 = size._dy;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = 0 + t2;
        d3 = position.$sub(0, new P.Offset(0, t2)).get$distance();
        d4 = position.$sub(0, new P.Offset(t1, t2)).get$distance();
        return Math.ceil(Math.max(Math.max(d1, d2), Math.max(d3, d4)));
      }
      return 35;
    },
    _getClipCallback_closure: function _getClipCallback_closure(t0) {
      this.referenceBox = t0;
    },
    _InkSplashFactory: function _InkSplashFactory() {
    },
    InkSplash: function InkSplash(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) {
      var _ = this;
      _._ink_splash$_position = t0;
      _._ink_splash$_borderRadius = t1;
      _._ink_splash$_customBorder = t2;
      _._targetRadius = t3;
      _._clipCallback = t4;
      _._repositionToReferenceBox = t5;
      _._ink_splash$_textDirection = t6;
      _._alphaController = _._ink_splash$_alpha = _._radiusController = _._radius = null;
      _._ink_well$_color = t7;
      _._material$_controller = t8;
      _.referenceBox = t9;
      _.onRemoved = t10;
      _._debugDisposed = false;
    },
    MaterialLocalizations: function MaterialLocalizations() {
    },
    _MaterialLocalizationsDelegate: function _MaterialLocalizationsDelegate() {
    },
    DefaultMaterialLocalizations: function DefaultMaterialLocalizations() {
    },
    TabBarTheme$: function(indicator, indicatorSize, labelColor, labelPadding, labelStyle, unselectedLabelColor, unselectedLabelStyle) {
      return new U.TabBarTheme(indicator, indicatorSize, labelColor, labelPadding, labelStyle, unselectedLabelColor, unselectedLabelStyle);
    },
    TabBarTheme: function TabBarTheme(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.indicator = t0;
      _.indicatorSize = t1;
      _.labelColor = t2;
      _.labelPadding = t3;
      _.labelStyle = t4;
      _.unselectedLabelColor = t5;
      _.unselectedLabelStyle = t6;
    },
    Typography_Typography: function(black, dense, englishLike, platform, tall, white) {
      var t1;
      if (platform == null)
        t1 = black != null && white != null;
      else
        t1 = true;
      H.assertHelper(t1);
      switch (platform) {
        case C.TargetPlatform_2:
          if (black == null)
            black = C.TextTheme_Ab5;
          if (white == null)
            white = C.TextTheme_nCA;
          break;
        case C.TargetPlatform_0:
        case C.TargetPlatform_1:
          if (black == null)
            black = C.TextTheme_9YE;
          if (white == null)
            white = C.TextTheme_ssJ;
          break;
      }
      if (englishLike == null)
        englishLike = C.TextTheme_OHV;
      if (dense == null)
        dense = C.TextTheme_Srw;
      return new U.Typography(black, white, englishLike, dense, tall == null ? C.TextTheme_Cl7 : tall);
    },
    ScriptCategory: function ScriptCategory(t0) {
      this._typography$_name = t0;
    },
    Typography: function Typography(t0, t1, t2, t3, t4) {
      var _ = this;
      _.black = t0;
      _.white = t1;
      _.englishLike = t2;
      _.dense = t3;
      _.tall = t4;
    },
    TextPainter$: function(ellipsis, locale, maxLines, strutStyle, text, textAlign, textDirection, textScaleFactor) {
      return new U.TextPainter(text, textAlign, textDirection, textScaleFactor, ellipsis, locale, maxLines, strutStyle);
    },
    TextPainter: function TextPainter(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _._text_painter$_paragraph = null;
      _._text_painter$_needsLayout = true;
      _._text = t0;
      _._textAlign = t1;
      _._text_painter$_textDirection = t2;
      _._textScaleFactor = t3;
      _._text_painter$_ellipsis = t4;
      _._text_painter$_locale = t5;
      _._maxLines = t6;
      _._text_painter$_strutStyle = t7;
      _._lastMaxWidth = _._lastMinWidth = null;
    },
    TextPainter_paint_closure: function TextPainter_paint_closure(t0) {
      this.$this = t0;
    },
    StringCodec: function StringCodec() {
    },
    JSONMessageCodec: function JSONMessageCodec() {
    },
    JSONMethodCodec: function JSONMethodCodec() {
    },
    StandardMessageCodec: function StandardMessageCodec() {
    },
    StandardMessageCodec_writeValue_closure: function StandardMessageCodec_writeValue_closure(t0, t1) {
      this.$this = t0;
      this.buffer = t1;
    },
    NotificationListener$: function(child, onNotification, $T) {
      return new U.NotificationListener(child, onNotification, null, [$T]);
    },
    Notification: function Notification() {
    },
    NotificationListener: function NotificationListener(t0, t1, t2, t3) {
      var _ = this;
      _.child = t0;
      _.onNotification = t1;
      _.key = t2;
      _.$ti = t3;
    },
    LayoutChangedNotification: function LayoutChangedNotification() {
    },
    TickerMode_of: function(context) {
      var t1 = H.interceptedTypeCheck(context.inheritFromWidgetOfExactType$1(C.Type_TickerMode_zTp), "$isTickerMode") == null && null;
      return t1 !== false;
    },
    TickerMode: function TickerMode(t0, t1, t2) {
      this.enabled = t0;
      this.child = t1;
      this.key = t2;
    },
    SingleTickerProviderStateMixin: function SingleTickerProviderStateMixin() {
    },
    SingleTickerProviderStateMixin_createTicker_closure: function SingleTickerProviderStateMixin_createTicker_closure(t0) {
      this.$this = t0;
    },
    TickerProviderStateMixin: function TickerProviderStateMixin() {
    },
    _WidgetTicker: function _WidgetTicker(t0, t1, t2) {
      var _ = this;
      _._creator = t0;
      _._future = null;
      _._muted = false;
      _._startTime = null;
      _._onTick = t1;
      _._animationId = null;
      _.debugLabel = t2;
      _._debugCreationStack = null;
    },
    Title$: function(child, color, title) {
      return new U.Title(title, color, child, null);
    },
    Title: function Title(t0, t1, t2, t3) {
      var _ = this;
      _.title = t0;
      _.color = t1;
      _.child = t2;
      _.key = t3;
    },
    createLocalImageConfiguration: function(context) {
      var t1, t2;
      H.interceptedTypeCheck(context.inheritFromWidgetOfExactType$1(C.Type_DefaultAssetBundle_8cA), "$isDefaultAssetBundle");
      t1 = $.$get$rootBundle();
      t2 = F.MediaQuery_of(context, true);
      t2 = t2 == null ? null : t2.devicePixelRatio;
      if (t2 == null)
        t2 = 1;
      return new M.ImageConfiguration(t1, t2, L.Localizations_localeOf(context, true), T.Directionality_of(context), null, T.defaultTargetPlatform());
    }
  },
  N = {
    _exitApplication: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1);
      var $async$_exitApplication = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              P._ProcessUtils__exit(0);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_exitApplication, $async$completer);
    },
    BindingBase: function BindingBase() {
    },
    BindingBase_initInstances_closure: function BindingBase_initInstances_closure() {
    },
    BindingBase_initServiceExtensions_closure: function BindingBase_initServiceExtensions_closure(t0) {
      this.$this = t0;
    },
    BindingBase_initServiceExtensions_closure0: function BindingBase_initServiceExtensions_closure0() {
    },
    BindingBase_initServiceExtensions_closure1: function BindingBase_initServiceExtensions_closure1(t0) {
      this.$this = t0;
    },
    BindingBase_initServiceExtensions__closure: function BindingBase_initServiceExtensions__closure(t0, t1) {
      this.$this = t0;
      this.platformOverrideExtensionName = t1;
    },
    BindingBase_initServiceExtensions_closure2: function BindingBase_initServiceExtensions_closure2() {
    },
    BindingBase_lockEvents_closure: function BindingBase_lockEvents_closure(t0) {
      this.$this = t0;
    },
    BindingBase_registerSignalServiceExtension_closure: function BindingBase_registerSignalServiceExtension_closure(t0) {
      this.callback = t0;
    },
    BindingBase_registerBoolServiceExtension_closure: function BindingBase_registerBoolServiceExtension_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.setter = t1;
      _.name = t2;
      _.getter = t3;
    },
    BindingBase_registerNumericServiceExtension_closure: function BindingBase_registerNumericServiceExtension_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.name = t1;
      _.setter = t2;
      _.getter = t3;
    },
    BindingBase_registerStringServiceExtension_closure: function BindingBase_registerStringServiceExtension_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.setter = t1;
      _.name = t2;
      _.getter = t3;
    },
    BindingBase_registerServiceExtension_closure: function BindingBase_registerServiceExtension_closure(t0, t1) {
      this.methodName = t0;
      this.callback = t1;
    },
    BindingBase_registerServiceExtension__closure: function BindingBase_registerServiceExtension__closure(t0, t1) {
      this.method = t0;
      this.parameters = t1;
    },
    BindingBase_registerServiceExtension__closure0: function BindingBase_registerServiceExtension__closure0() {
    },
    FlutterErrorDetailsForPointerEventDispatcher$: function(context, $event, exception, hitTestEntry, informationCollector, library, stack) {
      return new N.FlutterErrorDetailsForPointerEventDispatcher(exception, stack, library, context, informationCollector, false);
    },
    GestureBinding: function GestureBinding() {
    },
    GestureBinding__handlePointerEvent_closure: function GestureBinding__handlePointerEvent_closure(t0, t1) {
      this._box_0 = t0;
      this.event = t1;
    },
    GestureBinding__handlePointerEvent_closure0: function GestureBinding__handlePointerEvent_closure0(t0) {
      this.event = t0;
    },
    GestureBinding_dispatchEvent_closure: function GestureBinding_dispatchEvent_closure(t0) {
      this.event = t0;
    },
    GestureBinding_dispatchEvent_closure0: function GestureBinding_dispatchEvent_closure0(t0, t1) {
      this.event = t0;
      this.entry = t1;
    },
    FlutterErrorDetailsForPointerEventDispatcher: function FlutterErrorDetailsForPointerEventDispatcher(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.exception = t0;
      _.stack = t1;
      _.library = t2;
      _.context = t3;
      _.informationCollector = t4;
      _.silent = t5;
    },
    TapDownDetails: function TapDownDetails(t0) {
      this.globalPosition = t0;
    },
    TapUpDetails: function TapUpDetails() {
    },
    TapGestureRecognizer: function TapGestureRecognizer(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.onTapCancel = _.onTap = _.onTapUp = _.onTapDown = null;
      _._wonArenaForPrimaryPointer = _._sentTapDown = false;
      _._finalPosition = null;
      _.deadline = t0;
      _.postAcceptSlopTolerance = t1;
      _.state = t2;
      _.initialPosition = _.primaryPointer = null;
      _._gestureAccepted = false;
      _._timer = null;
      _._recognizer$_entries = t3;
      _._trackedPointers = t4;
      _.debugOwner = t5;
      _._kind = t6;
    },
    TapGestureRecognizer__checkDown_closure: function TapGestureRecognizer__checkDown_closure(t0) {
      this.$this = t0;
    },
    SnackBarClosedReason: function SnackBarClosedReason() {
    },
    SnackBar: function SnackBar() {
    },
    PaintingBinding: function PaintingBinding() {
    },
    Tolerance: function Tolerance(t0, t1) {
      this.distance = t0;
      this.velocity = t1;
    },
    debugDumpSemanticsTree: function(childOrder) {
      var _null = null,
        t1 = $.RendererBinding__instance;
      t1 = t1 == null ? _null : t1.RendererBinding__pipelineOwner._rootNode;
      t1 = t1 == null ? _null : t1.get$debugSemantics();
      t1 = t1 == null ? _null : new A._SemanticsDiagnosticableNode(childOrder, t1, _null, true, true, C.DiagnosticsTreeStyle_0).toStringDeep$3$minLevel$prefixLineOne$prefixOtherLines(C.DiagnosticLevel_2, "", _null);
      D.print__debugPrintThrottled$closure().call$1(t1 == null ? "Semantics not collected." : t1);
    },
    RendererBinding: function RendererBinding() {
    },
    RendererBinding__createMouseTracker_closure: function RendererBinding__createMouseTracker_closure(t0) {
      this.$this = t0;
    },
    RendererBinding__forceRepaint_closure: function RendererBinding__forceRepaint_closure(t0) {
      this._box_0 = t0;
    },
    ViewportOffset: function ViewportOffset() {
    },
    timeDilation: function(value) {
      var t1;
      if (typeof value !== "number")
        return value.$gt();
      H.assertHelper(value > 0);
      if ($._timeDilation === value)
        return;
      t1 = $.SchedulerBinding__instance;
      if (t1 != null)
        t1.resetEpoch$0();
      $._timeDilation = value;
    },
    _TaskEntry$: function(task, priority, debugLabel, flow, $T) {
      var t1 = new N._TaskEntry(task, priority, debugLabel, flow, [$T]);
      t1._TaskEntry$4(task, priority, debugLabel, flow, $T);
      return t1;
    },
    _FrameCallbackEntry$: function(callback, rescheduling) {
      var t1 = new N._FrameCallbackEntry(callback);
      t1._FrameCallbackEntry$2$rescheduling(callback, rescheduling);
      return t1;
    },
    SchedulerBinding__parseAppLifecycleMessage: function(message) {
      switch (message) {
        case "AppLifecycleState.paused":
          return C.AppLifecycleState_2;
        case "AppLifecycleState.resumed":
          return C.AppLifecycleState_0;
        case "AppLifecycleState.inactive":
          return C.AppLifecycleState_1;
        case "AppLifecycleState.suspending":
          return C.AppLifecycleState_3;
      }
      return;
    },
    SchedulerBinding__taskSorter: function(e1, e2) {
      H.interceptedTypeCheck(e1, "$is_TaskEntry");
      H.interceptedTypeCheck(e2, "$is_TaskEntry");
      return -C.JSInt_methods.compareTo$1(e1.priority, e2.priority);
    },
    defaultSchedulingStrategy: function(priority, scheduler) {
      var t1 = scheduler.SchedulerBinding__transientCallbacks;
      if (t1.get$length(t1) > 0)
        return priority >= 100000;
      return true;
    },
    _TaskEntry: function _TaskEntry(t0, t1, t2, t3, t4) {
      var _ = this;
      _.task = t0;
      _.priority = t1;
      _.debugLabel = t2;
      _.flow = t3;
      _.completer = _.debugStack = null;
      _.$ti = t4;
    },
    _TaskEntry_closure: function _TaskEntry_closure(t0) {
      this.$this = t0;
    },
    _TaskEntry_run_closure: function _TaskEntry_run_closure(t0) {
      this.$this = t0;
    },
    _FrameCallbackEntry: function _FrameCallbackEntry(t0) {
      this.callback = t0;
      this.debugStack = null;
    },
    _FrameCallbackEntry_closure: function _FrameCallbackEntry_closure(t0, t1) {
      this.$this = t0;
      this.rescheduling = t1;
    },
    _FrameCallbackEntry__closure: function _FrameCallbackEntry__closure() {
    },
    SchedulerPhase: function SchedulerPhase(t0, t1) {
      this.index = t0;
      this._name = t1;
    },
    SchedulerBinding: function SchedulerBinding() {
    },
    SchedulerBinding_handleEventLoopCallback_closure: function SchedulerBinding_handleEventLoopCallback_closure(t0, t1) {
      this._box_0 = t0;
      this.entry = t1;
    },
    SchedulerBinding_handleEventLoopCallback_closure0: function SchedulerBinding_handleEventLoopCallback_closure0(t0) {
      this._box_0 = t0;
    },
    SchedulerBinding_endOfFrame_closure: function SchedulerBinding_endOfFrame_closure(t0) {
      this.$this = t0;
    },
    SchedulerBinding_scheduleFrame_closure: function SchedulerBinding_scheduleFrame_closure(t0) {
      this.$this = t0;
    },
    SchedulerBinding_scheduleForcedFrame_closure: function SchedulerBinding_scheduleForcedFrame_closure(t0) {
      this.$this = t0;
    },
    SchedulerBinding_scheduleWarmUpFrame_closure: function SchedulerBinding_scheduleWarmUpFrame_closure(t0) {
      this.$this = t0;
    },
    SchedulerBinding_scheduleWarmUpFrame_closure0: function SchedulerBinding_scheduleWarmUpFrame_closure0(t0, t1) {
      this.$this = t0;
      this.hadScheduledFrame = t1;
    },
    SchedulerBinding_scheduleWarmUpFrame_closure1: function SchedulerBinding_scheduleWarmUpFrame_closure1(t0) {
      this.$this = t0;
    },
    SchedulerBinding_handleBeginFrame_closure: function SchedulerBinding_handleBeginFrame_closure(t0, t1) {
      this.$this = t0;
      this.rawTimeStamp = t1;
    },
    SchedulerBinding_handleBeginFrame_closure0: function SchedulerBinding_handleBeginFrame_closure0(t0) {
      this.$this = t0;
    },
    SchedulerBinding_handleDrawFrame_closure: function SchedulerBinding_handleDrawFrame_closure(t0) {
      this.$this = t0;
    },
    SchedulerBinding__invokeFrameCallback_closure: function SchedulerBinding__invokeFrameCallback_closure(t0) {
      this.callbackStack = t0;
    },
    SchedulerBinding__invokeFrameCallback_closure0: function SchedulerBinding__invokeFrameCallback_closure0(t0) {
      this.callbackStack = t0;
    },
    SchedulerBinding__invokeFrameCallback_closure1: function SchedulerBinding__invokeFrameCallback_closure1() {
    },
    SemanticsBinding: function SemanticsBinding() {
    },
    SemanticsBinding_disableAnimations_closure: function SemanticsBinding_disableAnimations_closure(t0) {
      this._box_0 = t0;
    },
    ServicesBinding__parseLicenses: function(rawLicenses) {
      var _licenseSeparator, result, licenses, t1, _i, license, t2, split;
      H.stringTypeCheck(rawLicenses);
      _licenseSeparator = "\n" + C.JSString_methods.$mul("-", 80) + "\n";
      result = H.setRuntimeTypeInfo([], [F.LicenseEntry]);
      licenses = rawLicenses.split(_licenseSeparator);
      for (t1 = licenses.length, _i = 0; _i < t1; ++_i) {
        license = licenses[_i];
        t2 = J.getInterceptor$asx(license);
        split = t2.indexOf$1(license, "\n\n");
        if (split >= 0) {
          t2.substring$2(license, 0, split).split("\n");
          t2.substring$1(license, split + 2);
          C.JSArray_methods.add$1(result, new F.LicenseEntryWithLineBreaks());
        } else
          C.JSArray_methods.add$1(result, new F.LicenseEntryWithLineBreaks());
      }
      return result;
    },
    ServicesBinding: function ServicesBinding() {
    },
    ServicesBinding__addLicenses_closure: function ServicesBinding__addLicenses_closure(t0) {
      this.rawLicenses = t0;
    },
    ServicesBinding__addLicenses_closure0: function ServicesBinding__addLicenses_closure0(t0, t1) {
      this.parsedLicenses = t0;
      this.rawLicenses = t1;
    },
    debugDumpApp: function() {
      var t1 = {};
      H.assertHelper($.WidgetsBinding__instance != null);
      t1.mode = "RELEASE MODE";
      H.assertHelper(new N.debugDumpApp_closure(t1).call$0());
      D.print__debugPrintThrottled$closure().call$1(J.get$runtimeType$($.WidgetsBinding__instance).toString$0(0) + " - " + t1.mode);
      t1 = $.WidgetsBinding__instance.WidgetsBinding__renderViewElement;
      if (t1 != null)
        D.print__debugPrintThrottled$closure().call$1(t1.toStringDeep$0());
      else
        D.print__debugPrintThrottled$closure().call$1("<no tree currently mounted>");
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure(t0) {
      this.$this = t0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure0: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure0(t0) {
      this.$this = t0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure1: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure1() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure2: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure2(t0) {
      this.$this = t0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure3: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure3() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure4: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure4(t0) {
      this.$this = t0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure5: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure5() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure6: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure6(t0) {
      this.$this = t0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure7: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure7() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure0: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure0() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure1: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure1() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure2: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure2() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure0: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure0() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_initServiceExtensions_closure: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_initServiceExtensions_closure(t0) {
      this.$this = t0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_initServiceExtensions__closure: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_initServiceExtensions__closure() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_initServiceExtensions__closure0: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_initServiceExtensions__closure0(t0) {
      this.$this = t0;
    },
    WidgetsBindingObserver: function WidgetsBindingObserver() {
    },
    WidgetsBinding: function WidgetsBinding() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure0: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure0() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure1: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure1(t0) {
      this.$this = t0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure2: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure2(t0) {
      this.$this = t0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure3: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure3() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure4: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure4() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure5: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure5(t0) {
      this.$this = t0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure0: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure0(t0) {
      this.$this = t0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure1: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure1() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure2: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure2(t0) {
      this.$this = t0;
    },
    WidgetsBinding__handleBuildScheduled_closure: function WidgetsBinding__handleBuildScheduled_closure(t0) {
      this.$this = t0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_drawFrame_closure: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_drawFrame_closure(t0) {
      this.$this = t0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_drawFrame_closure0: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_drawFrame_closure0(t0) {
      this.$this = t0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_performReassemble_closure: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_performReassemble_closure() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_performReassemble_closure0: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_performReassemble_closure0(t0) {
      this.$this = t0;
    },
    debugDumpApp_closure: function debugDumpApp_closure(t0) {
      this._box_0 = t0;
    },
    RenderObjectToWidgetAdapter: function RenderObjectToWidgetAdapter(t0, t1, t2, t3, t4) {
      var _ = this;
      _.child = t0;
      _.container = t1;
      _.debugShortDescription = t2;
      _.key = t3;
      _.$ti = t4;
    },
    RenderObjectToWidgetAdapter_attachToRenderTree_closure: function RenderObjectToWidgetAdapter_attachToRenderTree_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.owner = t2;
    },
    RenderObjectToWidgetAdapter_attachToRenderTree_closure0: function RenderObjectToWidgetAdapter_attachToRenderTree_closure0(t0) {
      this._box_0 = t0;
    },
    RenderObjectToWidgetElement: function RenderObjectToWidgetElement(t0, t1, t2, t3) {
      var _ = this;
      _._framework$_parent = _._ancestorRenderObjectElement = _._renderObject = _._newWidget = _._child = null;
      _._cachedHash = t0;
      _._depth = _._slot = null;
      _._widget = t1;
      _._owner = null;
      _._active = false;
      _._debugLifecycleState = t2;
      _._dependencies = _._inheritedWidgets = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._debugAllowIgnoredCallsToMarkNeedsBuild = _._debugBuiltOnce = _._inDirtyList = false;
      _.$ti = t3;
    },
    WidgetsFlutterBinding: function WidgetsFlutterBinding(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38) {
      var _ = this;
      _.WidgetsBinding__buildOwner = t0;
      _.WidgetsBinding__observers = t1;
      _.WidgetsBinding__needToReportFirstFrame = t2;
      _.WidgetsBinding__deferFirstFrameReportCount = t3;
      _.WidgetsBinding_debugBuildingDirtyElements = t4;
      _.WidgetsBinding__renderViewElement = t5;
      _.RendererBinding__mouseTracker = t6;
      _.RendererBinding__pipelineOwner = t7;
      _.RendererBinding__semanticsHandle = t8;
      _.SemanticsBinding__accessibilityFeatures = t9;
      _.PaintingBinding__imageCache = t10;
      _.PaintingBinding__kDecodedCacheRatioCap = t11;
      _.SchedulerBinding__lifecycleState = t12;
      _.SchedulerBinding_schedulingStrategy = t13;
      _.SchedulerBinding__taskQueue = t14;
      _.SchedulerBinding__hasRequestedAnEventLoopCallback = t15;
      _.SchedulerBinding__nextFrameCallbackId = t16;
      _.SchedulerBinding__transientCallbacks = t17;
      _.SchedulerBinding__removedIds = t18;
      _.SchedulerBinding__persistentCallbacks = t19;
      _.SchedulerBinding__postFrameCallbacks = t20;
      _.SchedulerBinding__nextFrameCompleter = t21;
      _.SchedulerBinding__hasScheduledFrame = t22;
      _.SchedulerBinding__schedulerPhase = t23;
      _.SchedulerBinding__framesEnabled = t24;
      _.SchedulerBinding__warmUpFrame = t25;
      _.SchedulerBinding__firstRawTimeStampInEpoch = t26;
      _.SchedulerBinding__epochStart = t27;
      _.SchedulerBinding__lastRawTimeStamp = t28;
      _.SchedulerBinding__currentFrameTimeStamp = t29;
      _.SchedulerBinding__profileFrameNumber = t30;
      _.SchedulerBinding__profileFrameStopwatch = t31;
      _.SchedulerBinding__debugBanner = t32;
      _.SchedulerBinding__ignoreNextEngineDrawFrame = t33;
      _.GestureBinding__pendingPointerEvents = t34;
      _.GestureBinding_pointerRouter = t35;
      _.GestureBinding_gestureArena = t36;
      _.GestureBinding_pointerSignalResolver = t37;
      _.GestureBinding__hitTests = t38;
      _._lockCount = 0;
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding: function _WidgetsFlutterBinding_BindingBase_GestureBinding() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding() {
    },
    _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding: function _WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding() {
    },
    GlobalKey__debugVerifyIllFatedPopulation: function() {
      H.assertHelper(new N.GlobalKey__debugVerifyIllFatedPopulation_closure().call$0());
    },
    Widget_canUpdate: function(oldWidget, newWidget) {
      return new H.TypeImpl(H.getRti(oldWidget)).$eq(0, J.get$runtimeType$(newWidget)) && J.$eq$(oldWidget.key, newWidget.key);
    },
    Element__sort: function(a, b) {
      var t1, t2;
      H.interceptedTypeCheck(a, "$isElement");
      H.interceptedTypeCheck(b, "$isElement");
      t1 = a._depth;
      t2 = b._depth;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 < t2)
        return -1;
      if (t2 < t1)
        return 1;
      t1 = b._dirty;
      if (t1 && !a._dirty)
        return -1;
      if (a._dirty && !t1)
        return 1;
      return 0;
    },
    Element__activateRecursively: function(element) {
      H.assertHelper(element._debugLifecycleState === C._ElementLifecycle_2);
      element.activate$0();
      H.assertHelper(element._debugLifecycleState === C._ElementLifecycle_1);
      element.visitChildren$1(N.framework_Element__activateRecursively$closure());
    },
    ErrorWidget__stringify: function(exception) {
      var t1, exception;
      try {
        t1 = J.toString$0$(exception);
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
      }
      return "Error";
    },
    StatefulElement$: function(widget) {
      var t1 = widget.createState$0(),
        t2 = ($.Element__nextHashCode + 1) % 16777215;
      $.Element__nextHashCode = t2;
      t2 = new N.StatefulElement(t1, t2, widget, C._ElementLifecycle_0);
      t2.StatefulElement$1(widget);
      return t2;
    },
    _debugReportException: function(context, exception, stack, informationCollector) {
      var details;
      H.interceptedTypeCheck(stack, "$isStackTrace");
      details = U.FlutterErrorDetails$(context, exception, H.functionTypeCheck(informationCollector, {func: 1, ret: -1, args: [P.StringBuffer]}), "widgets library", false, stack);
      U.FlutterError_reportError(details);
      return details;
    },
    UniqueKey: function UniqueKey() {
    },
    GlobalKey: function GlobalKey() {
    },
    GlobalKey__register_closure: function GlobalKey__register_closure(t0, t1) {
      this.$this = t0;
      this.element = t1;
    },
    GlobalKey__unregister_closure: function GlobalKey__unregister_closure(t0, t1) {
      this.$this = t0;
      this.element = t1;
    },
    GlobalKey__debugReserveFor_closure: function GlobalKey__debugReserveFor_closure(t0, t1) {
      this.$this = t0;
      this.parent = t1;
    },
    GlobalKey__debugVerifyIllFatedPopulation_closure: function GlobalKey__debugVerifyIllFatedPopulation_closure() {
    },
    GlobalKey__debugVerifyIllFatedPopulation__closure: function GlobalKey__debugVerifyIllFatedPopulation__closure() {
    },
    LabeledGlobalKey: function LabeledGlobalKey(t0, t1) {
      this._framework$_debugLabel = t0;
      this.$ti = t1;
    },
    GlobalObjectKey: function GlobalObjectKey(t0, t1) {
      this.value = t0;
      this.$ti = t1;
    },
    TypeMatcher: function TypeMatcher(t0) {
      this.$ti = t0;
    },
    Widget: function Widget() {
    },
    StatelessWidget: function StatelessWidget() {
    },
    StatefulWidget: function StatefulWidget() {
    },
    _StateLifecycle: function _StateLifecycle(t0) {
      this._framework$_name = t0;
    },
    State: function State() {
    },
    State_setState_closure: function State_setState_closure(t0) {
      this.$this = t0;
    },
    State_setState_closure0: function State_setState_closure0(t0, t1) {
      this.$this = t0;
      this.result = t1;
    },
    State_dispose_closure: function State_dispose_closure(t0) {
      this.$this = t0;
    },
    State_debugFillProperties_closure: function State_debugFillProperties_closure(t0, t1) {
      this.$this = t0;
      this.properties = t1;
    },
    ProxyWidget: function ProxyWidget() {
    },
    ParentDataWidget: function ParentDataWidget() {
    },
    InheritedWidget: function InheritedWidget() {
    },
    RenderObjectWidget: function RenderObjectWidget() {
    },
    LeafRenderObjectWidget: function LeafRenderObjectWidget() {
    },
    SingleChildRenderObjectWidget: function SingleChildRenderObjectWidget() {
    },
    MultiChildRenderObjectWidget: function MultiChildRenderObjectWidget() {
    },
    _ElementLifecycle: function _ElementLifecycle(t0) {
      this._framework$_name = t0;
    },
    _InactiveElements: function _InactiveElements(t0) {
      this._locked = false;
      this._elements = t0;
    },
    _InactiveElements__unmount_closure: function _InactiveElements__unmount_closure(t0) {
      this.element = t0;
    },
    _InactiveElements__unmount_closure0: function _InactiveElements__unmount_closure0(t0, t1) {
      this.$this = t0;
      this.element = t1;
    },
    _InactiveElements__deactivateRecursively_closure: function _InactiveElements__deactivateRecursively_closure(t0) {
      this.element = t0;
    },
    BuildContext: function BuildContext() {
    },
    BuildOwner: function BuildOwner(t0, t1, t2) {
      var _ = this;
      _.onBuildScheduled = null;
      _._inactiveElements = t0;
      _._dirtyElements = t1;
      _._scheduledFlushDirtyElements = false;
      _._dirtyElementsNeedsResorting = null;
      _.focusManager = t2;
      _._debugStateLockLevel = 0;
      _._debugBuilding = false;
      _._debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans = _._debugCurrentBuildTarget = null;
    },
    BuildOwner_scheduleBuildFor_closure: function BuildOwner_scheduleBuildFor_closure(t0, t1) {
      this.$this = t0;
      this.element = t1;
    },
    BuildOwner_scheduleBuildFor_closure0: function BuildOwner_scheduleBuildFor_closure0(t0) {
      this.$this = t0;
    },
    BuildOwner_scheduleBuildFor_closure1: function BuildOwner_scheduleBuildFor_closure1(t0) {
      this.$this = t0;
    },
    BuildOwner_lockState_closure: function BuildOwner_lockState_closure(t0) {
      this.$this = t0;
    },
    BuildOwner_lockState_closure0: function BuildOwner_lockState_closure0(t0) {
      this.$this = t0;
    },
    BuildOwner_buildScope_closure: function BuildOwner_buildScope_closure(t0, t1) {
      this.$this = t0;
      this.context = t1;
    },
    BuildOwner_buildScope_closure0: function BuildOwner_buildScope_closure0(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.context = t2;
    },
    BuildOwner_buildScope_closure1: function BuildOwner_buildScope_closure1(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.context = t2;
    },
    BuildOwner_buildScope_closure2: function BuildOwner_buildScope_closure2(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    BuildOwner_buildScope_closure3: function BuildOwner_buildScope_closure3(t0) {
      this.$this = t0;
    },
    BuildOwner_buildScope__closure: function BuildOwner_buildScope__closure() {
    },
    BuildOwner_buildScope_closure4: function BuildOwner_buildScope_closure4(t0) {
      this.$this = t0;
    },
    BuildOwner__debugTrackElementThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans_closure: function BuildOwner__debugTrackElementThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans_closure() {
    },
    BuildOwner_finalizeTree_closure: function BuildOwner_finalizeTree_closure(t0) {
      this.$this = t0;
    },
    BuildOwner_finalizeTree_closure0: function BuildOwner_finalizeTree_closure0(t0) {
      this.$this = t0;
    },
    BuildOwner_finalizeTree__closure: function BuildOwner_finalizeTree__closure() {
    },
    BuildOwner_finalizeTree__closure0: function BuildOwner_finalizeTree__closure0(t0) {
      this.keyLabels = t0;
    },
    BuildOwner_finalizeTree__closure1: function BuildOwner_finalizeTree__closure1() {
    },
    BuildOwner_finalizeTree__closure2: function BuildOwner_finalizeTree__closure2(t0) {
      this.elementLabels = t0;
    },
    Element: function Element() {
    },
    Element_reassemble_closure: function Element_reassemble_closure() {
    },
    Element_renderObject_visit: function Element_renderObject_visit(t0) {
      this._box_0 = t0;
    },
    Element_visitChildElements_closure: function Element_visitChildElements_closure(t0) {
      this.$this = t0;
    },
    Element_updateChild_closure: function Element_updateChild_closure(t0, t1) {
      this.$this = t0;
      this.newWidget = t1;
    },
    Element_updateChild_closure0: function Element_updateChild_closure0(t0) {
      this.child = t0;
    },
    Element_mount_closure: function Element_mount_closure(t0) {
      this.$this = t0;
    },
    Element_updateSlotForChild_visit: function Element_updateSlotForChild_visit(t0) {
      this.newSlot = t0;
    },
    Element__updateDepth_closure: function Element__updateDepth_closure(t0) {
      this.expectedDepth = t0;
    },
    Element_detachRenderObject_closure: function Element_detachRenderObject_closure() {
    },
    Element_attachRenderObject_closure: function Element_attachRenderObject_closure(t0) {
      this.newSlot = t0;
    },
    Element__retakeInactiveElement_closure: function Element__retakeInactiveElement_closure(t0, t1) {
      this.$this = t0;
      this.element = t1;
    },
    Element__retakeInactiveElement_closure0: function Element__retakeInactiveElement_closure0(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.parent = t1;
      _.key = t2;
      _.element = t3;
    },
    Element_inflateWidget_closure: function Element_inflateWidget_closure(t0, t1) {
      this.$this = t0;
      this.newChild = t1;
    },
    Element_inflateWidget_closure0: function Element_inflateWidget_closure0(t0, t1) {
      this.$this = t0;
      this.newChild = t1;
    },
    Element__debugCheckForCycles_closure: function Element__debugCheckForCycles_closure(t0, t1) {
      this.$this = t0;
      this.newChild = t1;
    },
    Element_deactivateChild_closure: function Element_deactivateChild_closure(t0, t1) {
      this.$this = t0;
      this.child = t1;
    },
    Element__activateWithParent_closure: function Element__activateWithParent_closure(t0) {
      this.$this = t0;
    },
    Element_activate_closure: function Element_activate_closure(t0) {
      this.$this = t0;
    },
    Element_deactivate_closure: function Element_deactivate_closure(t0) {
      this.$this = t0;
    },
    Element_unmount_closure: function Element_unmount_closure(t0) {
      this.$this = t0;
    },
    Element_size_closure: function Element_size_closure(t0) {
      this.$this = t0;
    },
    Element_size_closure0: function Element_size_closure0(t0, t1) {
      this.$this = t0;
      this.renderObject = t1;
    },
    Element__debugCheckStateIsActiveForAncestorLookup_closure: function Element__debugCheckStateIsActiveForAncestorLookup_closure(t0) {
      this.$this = t0;
    },
    Element__debugCheckOwnerBuildTargetExists_closure: function Element__debugCheckOwnerBuildTargetExists_closure(t0, t1) {
      this.$this = t0;
      this.methodName = t1;
    },
    Element_debugFillProperties_closure: function Element_debugFillProperties_closure() {
    },
    Element_debugDescribeChildren_closure: function Element_debugDescribeChildren_closure(t0) {
      this.children = t0;
    },
    Element_markNeedsBuild_closure: function Element_markNeedsBuild_closure(t0) {
      this.$this = t0;
    },
    Element_rebuild_closure: function Element_rebuild_closure(t0) {
      this.$this = t0;
    },
    Element_rebuild_closure0: function Element_rebuild_closure0(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    Element_rebuild_closure1: function Element_rebuild_closure1(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    ErrorWidget: function ErrorWidget(t0, t1) {
      this.message = t0;
      this.key = t1;
    },
    ErrorWidget_closure: function ErrorWidget_closure() {
    },
    ComponentElement: function ComponentElement() {
    },
    StatelessElement: function StatelessElement(t0, t1, t2) {
      var _ = this;
      _._framework$_parent = _._framework$_child = null;
      _._cachedHash = t0;
      _._depth = _._slot = null;
      _._widget = t1;
      _._owner = null;
      _._active = false;
      _._debugLifecycleState = t2;
      _._dependencies = _._inheritedWidgets = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._debugAllowIgnoredCallsToMarkNeedsBuild = _._debugBuiltOnce = _._inDirtyList = false;
    },
    StatefulElement: function StatefulElement(t0, t1, t2, t3) {
      var _ = this;
      _._framework$_state = t0;
      _._framework$_parent = _._framework$_child = null;
      _._cachedHash = t1;
      _._depth = _._slot = null;
      _._widget = t2;
      _._owner = null;
      _._active = false;
      _._debugLifecycleState = t3;
      _._dependencies = _._inheritedWidgets = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._debugAllowIgnoredCallsToMarkNeedsBuild = _._debugBuiltOnce = _._inDirtyList = false;
    },
    StatefulElement_closure: function StatefulElement_closure(t0, t1) {
      this.$this = t0;
      this.widget = t1;
    },
    StatefulElement__firstBuild_closure: function StatefulElement__firstBuild_closure(t0, t1) {
      this.$this = t0;
      this.debugCheckForReturnedFuture = t1;
    },
    StatefulElement__firstBuild_closure0: function StatefulElement__firstBuild_closure0(t0) {
      this.$this = t0;
    },
    StatefulElement__firstBuild_closure1: function StatefulElement__firstBuild_closure1(t0) {
      this.$this = t0;
    },
    StatefulElement_update_closure: function StatefulElement_update_closure(t0, t1) {
      this.$this = t0;
      this.debugCheckForReturnedFuture = t1;
    },
    StatefulElement_unmount_closure: function StatefulElement_unmount_closure(t0) {
      this.$this = t0;
    },
    StatefulElement_inheritFromElement_closure: function StatefulElement_inheritFromElement_closure(t0, t1) {
      this.$this = t0;
      this.ancestor = t1;
    },
    ProxyElement: function ProxyElement() {
    },
    ParentDataElement: function ParentDataElement(t0, t1, t2, t3) {
      var _ = this;
      _._framework$_parent = _._framework$_child = null;
      _._cachedHash = t0;
      _._depth = _._slot = null;
      _._widget = t1;
      _._owner = null;
      _._active = false;
      _._debugLifecycleState = t2;
      _._dependencies = _._inheritedWidgets = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._debugAllowIgnoredCallsToMarkNeedsBuild = _._debugBuiltOnce = _._inDirtyList = false;
      _.$ti = t3;
    },
    ParentDataElement_mount_closure: function ParentDataElement_mount_closure(t0, t1) {
      this.$this = t0;
      this.parent = t1;
    },
    ParentDataElement__applyParentData_applyParentDataToChild: function ParentDataElement__applyParentData_applyParentDataToChild(t0) {
      this.widget = t0;
    },
    InheritedElement: function InheritedElement(t0, t1, t2, t3) {
      var _ = this;
      _._dependents = t0;
      _._framework$_parent = _._framework$_child = null;
      _._cachedHash = t1;
      _._depth = _._slot = null;
      _._widget = t2;
      _._owner = null;
      _._active = false;
      _._debugLifecycleState = t3;
      _._dependencies = _._inheritedWidgets = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._debugAllowIgnoredCallsToMarkNeedsBuild = _._debugBuiltOnce = _._inDirtyList = false;
    },
    InheritedElement_debugDeactivated_closure: function InheritedElement_debugDeactivated_closure(t0) {
      this.$this = t0;
    },
    InheritedElement_notifyClients_closure: function InheritedElement_notifyClients_closure(t0, t1) {
      this.$this = t0;
      this.dependent = t1;
    },
    RenderObjectElement: function RenderObjectElement() {
    },
    RenderObjectElement_mount_closure: function RenderObjectElement_mount_closure(t0) {
      this.$this = t0;
    },
    RenderObjectElement_update_closure: function RenderObjectElement_update_closure(t0) {
      this.$this = t0;
    },
    RenderObjectElement__debugUpdateRenderObjectOwner_closure: function RenderObjectElement__debugUpdateRenderObjectOwner_closure(t0) {
      this.$this = t0;
    },
    RenderObjectElement_updateChildren_replaceWithNullIfForgotten: function RenderObjectElement_updateChildren_replaceWithNullIfForgotten(t0) {
      this.forgottenChildren = t0;
    },
    RootRenderObjectElement: function RootRenderObjectElement() {
    },
    LeafRenderObjectElement: function LeafRenderObjectElement(t0, t1, t2) {
      var _ = this;
      _._framework$_parent = _._ancestorRenderObjectElement = _._renderObject = null;
      _._cachedHash = t0;
      _._depth = _._slot = null;
      _._widget = t1;
      _._owner = null;
      _._active = false;
      _._debugLifecycleState = t2;
      _._dependencies = _._inheritedWidgets = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._debugAllowIgnoredCallsToMarkNeedsBuild = _._debugBuiltOnce = _._inDirtyList = false;
    },
    SingleChildRenderObjectElement: function SingleChildRenderObjectElement(t0, t1, t2) {
      var _ = this;
      _._framework$_parent = _._ancestorRenderObjectElement = _._renderObject = _._framework$_child = null;
      _._cachedHash = t0;
      _._depth = _._slot = null;
      _._widget = t1;
      _._owner = null;
      _._active = false;
      _._debugLifecycleState = t2;
      _._dependencies = _._inheritedWidgets = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._debugAllowIgnoredCallsToMarkNeedsBuild = _._debugBuiltOnce = _._inDirtyList = false;
    },
    MultiChildRenderObjectElement: function MultiChildRenderObjectElement(t0, t1, t2, t3) {
      var _ = this;
      _._framework$_children = null;
      _._forgottenChildren = t0;
      _._framework$_parent = _._ancestorRenderObjectElement = _._renderObject = null;
      _._cachedHash = t1;
      _._depth = _._slot = null;
      _._widget = t2;
      _._owner = null;
      _._active = false;
      _._debugLifecycleState = t3;
      _._dependencies = _._inheritedWidgets = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._debugAllowIgnoredCallsToMarkNeedsBuild = _._debugBuiltOnce = _._inDirtyList = false;
    },
    _DebugCreator: function _DebugCreator(t0) {
      this.element = t0;
    },
    _calculateSubtreeBoundsHelper: function(object, transform) {
      var t1 = {};
      t1.bounds = T.MatrixUtils_transformRect(transform, object.get$semanticBounds());
      object.visitChildren$1(new N._calculateSubtreeBoundsHelper_closure(t1, transform, object));
      return t1.bounds;
    },
    _ScreenshotPaintingContext_toImage: function(renderObject, renderBounds, debugPaint, pixelRatio) {
      var data, context, t1,
        _s86_ = "You can only access RenderObject.layer for render objects that are repaint boundaries.",
        repaintBoundary = renderObject;
      while (true) {
        t1 = repaintBoundary != null;
        if (!(t1 && !repaintBoundary.get$isRepaintBoundary()))
          break;
        repaintBoundary = H.interceptedTypeCheck(repaintBoundary._node$_parent, "$isRenderObject");
      }
      H.assertHelper(t1);
      data = new N._ScreenshotData(renderObject, new N._ScreenshotContainerLayer(C.Offset_0_0));
      context = new N._ScreenshotPaintingContext(data, repaintBoundary.get$debugLayer(), repaintBoundary.get$paintBounds());
      if (renderObject === repaintBoundary) {
        t1 = data.containerLayer;
        if (H.assertTest(repaintBoundary.get$isRepaintBoundary()))
          H.assertThrow(_s86_);
        H.assertHelper(!repaintBoundary._needsPaint);
        t1.append$1(new N._ProxyLayer(repaintBoundary._layer));
        data.foundTarget = true;
        if (H.assertTest(repaintBoundary.get$isRepaintBoundary()))
          H.assertThrow(_s86_);
        H.assertHelper(!repaintBoundary._needsPaint);
        t1 = repaintBoundary._layer._layer$_offset;
        data.containerLayer.set$offset(t1);
      } else
        K.PaintingContext_debugInstrumentRepaintCompositedChild(repaintBoundary, context);
      if (debugPaint && !$.debugPaintSizeEnabled) {
        data.includeInRegularContext = false;
        t1 = context;
        t1.super$PaintingContext$stopRecordingIfNeeded();
        t1._stopRecordingScreenshotIfNeeded$0();
        H.assertHelper(data.foundTarget);
        $.debugPaintSizeEnabled = data.includeInScreenshot = true;
        try {
          t1 = data;
          H.assertHelper(t1.foundTarget);
          renderObject.debugPaint$2(context, t1.containerLayer._layer$_offset);
        } finally {
          $.debugPaintSizeEnabled = false;
          t1 = context;
          t1.super$PaintingContext$stopRecordingIfNeeded();
          t1._stopRecordingScreenshotIfNeeded$0();
        }
      }
      if (H.assertTest(repaintBoundary.get$isRepaintBoundary()))
        H.assertThrow(_s86_);
      H.assertHelper(!repaintBoundary._needsPaint);
      repaintBoundary._layer.buildScene$1(new P.SceneBuilder());
    },
    _DiagnosticsPathNode$: function(childIndex, children, node) {
      return new N._DiagnosticsPathNode(node, children, childIndex);
    },
    _followDiagnosticableChain: function(chain) {
      var path, diagnostic, i, target, children, foundMatch, j, child;
      H.assertSubtype(chain, "$isList", [Y.Diagnosticable], "$asList");
      path = H.setRuntimeTypeInfo([], [N._DiagnosticsPathNode]);
      if (chain.length === 0)
        return path;
      diagnostic = C.JSArray_methods.get$first(chain).toDiagnosticsNode$2$name$style(null, null);
      for (i = 1; i < chain.length; ++i) {
        target = chain[i];
        children = diagnostic.getChildren$0();
        j = 0;
        while (true) {
          if (!(j < children.length)) {
            foundMatch = false;
            break;
          }
          child = children[j];
          if (J.$eq$(child.get$value(), target)) {
            C.JSArray_methods.add$1(path, new N._DiagnosticsPathNode(diagnostic, children, j));
            diagnostic = child;
            foundMatch = true;
            break;
          }
          ++j;
        }
        H.assertHelper(foundMatch);
      }
      C.JSArray_methods.add$1(path, N._DiagnosticsPathNode$(null, diagnostic.getChildren$0(), diagnostic));
      return path;
    },
    _SerializeConfig$: function(expandPropertyValues, groupName, includeProperties, subtreeDepth, summaryTree) {
      return new N._SerializeConfig(groupName, summaryTree, subtreeDepth, null, includeProperties, expandPropertyValues);
    },
    _SerializeConfig$merge: function(base, pathToInclude, subtreeDepth) {
      var t1 = subtreeDepth == null ? base.subtreeDepth : subtreeDepth;
      return new N._SerializeConfig(base.groupName, base.summaryTree, t1, base.pathToInclude, base.includeProperties, base.expandPropertyValues);
    },
    _ElementLocationStatsTracker$: function() {
      var t1 = [N._LocationCount];
      return new N._ElementLocationStatsTracker(H.setRuntimeTypeInfo([], t1), H.setRuntimeTypeInfo([], t1), H.setRuntimeTypeInfo([], t1));
    },
    _InspectorOverlayLayer$: function(overlayRect, selection) {
      var t1 = new N._InspectorOverlayLayer(selection, overlayRect);
      t1._InspectorOverlayLayer$2$overlayRect$selection(overlayRect, selection, {});
      return t1;
    },
    _getCreationLocation: function(object) {
      if (object instanceof N.Element)
        object.get$widget();
      return;
    },
    _ProxyLayer: function _ProxyLayer(t0) {
      var _ = this;
      _._widget_inspector$_layer = t0;
      _._needsAddToScene = true;
      _.debugCreator = _._previousSibling = _._nextSibling = _._engineLayer = _._subtreeNeedsAddToScene = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    _MulticastCanvas: function _MulticastCanvas(t0, t1) {
      this._main = t0;
      this._screenshot = t1;
    },
    _calculateSubtreeBoundsHelper_closure: function _calculateSubtreeBoundsHelper_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.transform = t1;
      this.object = t2;
    },
    _ScreenshotContainerLayer: function _ScreenshotContainerLayer(t0) {
      var _ = this;
      _._layer$_offset = t0;
      _._layer$_lastChild = _._layer$_firstChild = null;
      _._needsAddToScene = true;
      _.debugCreator = _._previousSibling = _._nextSibling = _._engineLayer = _._subtreeNeedsAddToScene = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    _ScreenshotData: function _ScreenshotData(t0, t1) {
      var _ = this;
      _.target = t0;
      _.containerLayer = t1;
      _.includeInScreenshot = _.foundTarget = false;
      _.includeInRegularContext = true;
    },
    _ScreenshotPaintingContext: function _ScreenshotPaintingContext(t0, t1, t2) {
      var _ = this;
      _._widget_inspector$_data = t0;
      _._multicastCanvas = _._screenshotCanvas = _._screenshotRecorder = _._screenshotCurrentLayer = null;
      _._containerLayer = t1;
      _.estimatedBounds = t2;
      _._canvas = _._recorder = _._currentLayer = null;
    },
    _ScreenshotPaintingContext__isScreenshotRecording_closure: function _ScreenshotPaintingContext__isScreenshotRecording_closure(t0, t1) {
      this.$this = t0;
      this.hasScreenshotCanvas = t1;
    },
    _DiagnosticsPathNode: function _DiagnosticsPathNode(t0, t1, t2) {
      this.node = t0;
      this.children = t1;
      this.childIndex = t2;
    },
    _InspectorReferenceData: function _InspectorReferenceData(t0) {
      this.object = t0;
      this.count = 1;
    },
    _SerializeConfig: function _SerializeConfig(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.groupName = t0;
      _.summaryTree = t1;
      _.subtreeDepth = t2;
      _.pathToInclude = t3;
      _.includeProperties = t4;
      _.expandPropertyValues = t5;
    },
    _WidgetInspectorService: function _WidgetInspectorService(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) {
      var _ = this;
      _.WidgetInspectorService__serializeRing = t0;
      _.WidgetInspectorService__serializeRingIndex = t1;
      _.WidgetInspectorService_selection = t2;
      _.WidgetInspectorService_selectionChangedCallback = t3;
      _.WidgetInspectorService__groups = t4;
      _.WidgetInspectorService__idToReferenceData = t5;
      _.WidgetInspectorService__objectToId = t6;
      _.WidgetInspectorService__nextId = t7;
      _.WidgetInspectorService__pubRootDirectories = t8;
      _.WidgetInspectorService__trackRebuildDirtyWidgets = t9;
      _.WidgetInspectorService__trackRepaintWidgets = t10;
      _.WidgetInspectorService__registerServiceExtensionCallback = t11;
      _.WidgetInspectorService__widgetCreationTracked = t12;
      _.WidgetInspectorService__frameStart = t13;
      _.WidgetInspectorService__rebuildStats = t14;
      _.WidgetInspectorService__repaintStats = t15;
    },
    WidgetInspectorService: function WidgetInspectorService() {
    },
    WidgetInspectorService__registerSignalServiceExtension_closure: function WidgetInspectorService__registerSignalServiceExtension_closure(t0) {
      this.callback = t0;
    },
    WidgetInspectorService__registerObjectGroupServiceExtension_closure: function WidgetInspectorService__registerObjectGroupServiceExtension_closure(t0) {
      this.callback = t0;
    },
    WidgetInspectorService__registerBoolServiceExtension_closure: function WidgetInspectorService__registerBoolServiceExtension_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.setter = t1;
      _.name = t2;
      _.getter = t3;
    },
    WidgetInspectorService__registerServiceExtensionWithArg_closure: function WidgetInspectorService__registerServiceExtensionWithArg_closure(t0) {
      this.callback = t0;
    },
    WidgetInspectorService__registerServiceExtensionVarArgs_closure: function WidgetInspectorService__registerServiceExtensionVarArgs_closure(t0) {
      this.callback = t0;
    },
    WidgetInspectorService__registerServiceExtensionVarArgs__closure: function WidgetInspectorService__registerServiceExtensionVarArgs__closure(t0, t1) {
      this.argPrefix = t0;
      this.args = t1;
    },
    WidgetInspectorService_initServiceExtensions_closure: function WidgetInspectorService_initServiceExtensions_closure() {
    },
    WidgetInspectorService_initServiceExtensions_closure0: function WidgetInspectorService_initServiceExtensions_closure0() {
    },
    WidgetInspectorService_initServiceExtensions_closure1: function WidgetInspectorService_initServiceExtensions_closure1(t0) {
      this.$this = t0;
    },
    WidgetInspectorService_initServiceExtensions_closure2: function WidgetInspectorService_initServiceExtensions_closure2(t0) {
      this.$this = t0;
    },
    WidgetInspectorService_initServiceExtensions_closure3: function WidgetInspectorService_initServiceExtensions_closure3(t0) {
      this.$this = t0;
    },
    WidgetInspectorService_initServiceExtensions_closure4: function WidgetInspectorService_initServiceExtensions_closure4(t0) {
      this.$this = t0;
    },
    WidgetInspectorService_initServiceExtensions_closure5: function WidgetInspectorService_initServiceExtensions_closure5(t0) {
      this.$this = t0;
    },
    WidgetInspectorService_initServiceExtensions_closure_markTreeNeedsPaint: function WidgetInspectorService_initServiceExtensions_closure_markTreeNeedsPaint() {
    },
    WidgetInspectorService_initServiceExtensions_closure6: function WidgetInspectorService_initServiceExtensions_closure6(t0) {
      this.$this = t0;
    },
    WidgetInspectorService_toId_closure: function WidgetInspectorService_toId_closure() {
    },
    WidgetInspectorService_setPubRootDirectories_closure: function WidgetInspectorService_setPubRootDirectories_closure() {
    },
    WidgetInspectorService__getParentChain_closure: function WidgetInspectorService__getParentChain_closure(t0, t1) {
      this.$this = t0;
      this.groupName = t1;
    },
    WidgetInspectorService__nodeToJson_closure: function WidgetInspectorService__nodeToJson_closure(t0) {
      this._box_0 = t0;
    },
    WidgetInspectorService__nodeToJson_closure0: function WidgetInspectorService__nodeToJson_closure0() {
    },
    WidgetInspectorService__nodesToJson_closure: function WidgetInspectorService__nodesToJson_closure(t0, t1) {
      this.$this = t0;
      this.config = t1;
    },
    WidgetInspectorService__onPaint_closure: function WidgetInspectorService__onPaint_closure(t0) {
      this.$this = t0;
    },
    _LocationCount: function _LocationCount() {
    },
    _ElementLocationStatsTracker: function _ElementLocationStatsTracker(t0, t1, t2) {
      this._stats = t0;
      this.active = t1;
      this.newLocations = t2;
    },
    _ElementLocationStatsTracker_exportToJson_closure: function _ElementLocationStatsTracker_exportToJson_closure() {
    },
    WidgetInspector: function WidgetInspector(t0, t1, t2) {
      this.child = t0;
      this.selectButtonBuilder = t1;
      this.key = t2;
    },
    _WidgetInspectorState: function _WidgetInspectorState(t0, t1, t2) {
      var _ = this;
      _._lastPointerLocation = null;
      _.selection = t0;
      _.isSelectMode = true;
      _._ignorePointerKey = t1;
      _._widget = _._selectionChangedCallback = null;
      _._debugLifecycleState = t2;
      _._element = null;
    },
    _WidgetInspectorState_initState_closure: function _WidgetInspectorState_initState_closure(t0) {
      this.$this = t0;
    },
    _WidgetInspectorState_initState__closure: function _WidgetInspectorState_initState__closure() {
    },
    _WidgetInspectorState_hitTest__area: function _WidgetInspectorState_hitTest__area() {
    },
    _WidgetInspectorState_hitTest_closure: function _WidgetInspectorState_hitTest_closure(t0) {
      this._area = t0;
    },
    _WidgetInspectorState__inspectAt_closure: function _WidgetInspectorState__inspectAt_closure(t0, t1) {
      this.$this = t0;
      this.selected = t1;
    },
    _WidgetInspectorState__handlePanEnd_closure: function _WidgetInspectorState__handlePanEnd_closure(t0) {
      this.$this = t0;
    },
    _WidgetInspectorState__handleTap_closure: function _WidgetInspectorState__handleTap_closure(t0) {
      this.$this = t0;
    },
    _WidgetInspectorState__handleEnableSelect_closure: function _WidgetInspectorState__handleEnableSelect_closure(t0) {
      this.$this = t0;
    },
    InspectorSelection: function InspectorSelection(t0) {
      var _ = this;
      _._candidates = t0;
      _._widget_inspector$_index = 0;
      _._currentElement = _._widget_inspector$_current = null;
    },
    _InspectorOverlay: function _InspectorOverlay(t0, t1) {
      this.selection = t0;
      this.key = t1;
    },
    _RenderInspectorOverlay: function _RenderInspectorOverlay(t0) {
      var _ = this;
      _._selection = t0;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    _TransformedRect: function _TransformedRect(t0, t1) {
      this.rect = t0;
      this.transform = t1;
    },
    _InspectorOverlayRenderState: function _InspectorOverlayRenderState(t0, t1, t2, t3, t4) {
      var _ = this;
      _.overlayRect = t0;
      _.selected = t1;
      _.candidates = t2;
      _.tooltip = t3;
      _.textDirection = t4;
    },
    _InspectorOverlayLayer: function _InspectorOverlayLayer(t0, t1) {
      var _ = this;
      _.selection = t0;
      _.overlayRect = t1;
      _._textPainterMaxWidth = _._widget_inspector$_textPainter = _._widget_inspector$_picture = _._lastState = null;
      _._needsAddToScene = true;
      _.debugCreator = _._previousSibling = _._nextSibling = _._engineLayer = _._subtreeNeedsAddToScene = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    _InspectorOverlayLayer_closure: function _InspectorOverlayLayer_closure(t0) {
      this._box_0 = t0;
    },
    __WidgetInspectorState_State_WidgetsBindingObserver: function __WidgetInspectorState_State_WidgetsBindingObserver() {
    },
    _TypedDataBuffer: function _TypedDataBuffer() {
    },
    _IntBuffer: function _IntBuffer() {
    },
    Uint8Buffer: function Uint8Buffer(t0, t1) {
      this._typed_buffers$_buffer = t0;
      this._typed_buffers$_length = t1;
    },
    positionDependentBox: function(childSize, preferBelow, size, target, verticalOffset) {
      var t1, t2, t3, t4, fitsBelow, fitsAbove, tooltipBelow, y, x, normalizedTargetX, edge;
      H.assertHelper(size != null);
      H.assertHelper(childSize != null);
      t1 = target._dy;
      if (typeof t1 !== "number")
        return t1.$add();
      t2 = t1 + verticalOffset;
      t3 = childSize._dy;
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = size._dy;
      if (typeof t4 !== "number")
        return t4.$sub();
      t4 -= 10;
      fitsBelow = t2 + t3 <= t4;
      t3 = t1 - verticalOffset - t3;
      fitsAbove = t3 >= 10;
      if (preferBelow)
        tooltipBelow = fitsBelow || !fitsAbove;
      else
        tooltipBelow = !(fitsAbove || !fitsBelow);
      y = tooltipBelow ? Math.min(t2, t4) : Math.max(t3, 10);
      t1 = size._dx;
      if (typeof t1 !== "number")
        return t1.$sub();
      t2 = childSize._dx;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 - 20 < t2)
        x = (t1 - t2) / 2;
      else {
        t3 = t1 - 10;
        normalizedTargetX = J.clamp$2$n(target._dx, 10, t3);
        t4 = t2 / 2;
        edge = 10 + t4;
        if (normalizedTargetX < edge)
          x = 10;
        else
          x = normalizedTargetX > t1 - edge ? t3 - t2 : normalizedTargetX - t4;
      }
      return new P.Offset(x, y);
    }
  },
  B = {Listenable: function Listenable() {
    }, ChangeNotifier: function ChangeNotifier() {
    }, ChangeNotifier__debugAssertNotDisposed_closure: function ChangeNotifier__debugAssertNotDisposed_closure(t0) {
      this.$this = t0;
    }, ChangeNotifier_notifyListeners_closure: function ChangeNotifier_notifyListeners_closure(t0) {
      this.$this = t0;
    }, _MergingListenable: function _MergingListenable(t0) {
      this._change_notifier$_children = t0;
    }, AbstractNode: function AbstractNode() {
    }, AbstractNode_adoptChild_closure: function AbstractNode_adoptChild_closure(t0, t1) {
      this.$this = t0;
      this.child = t1;
    },
    LeastSquaresSolver$: function(x, y, w) {
      return new B.LeastSquaresSolver(x, y, w);
    },
    _Vector: function _Vector(t0, t1, t2) {
      this._lsq_solver$_offset = t0;
      this._lsq_solver$_length = t1;
      this._lsq_solver$_elements = t2;
    },
    _Matrix: function _Matrix(t0, t1) {
      this._columns = t0;
      this._lsq_solver$_elements = t1;
    },
    PolynomialFit: function PolynomialFit(t0) {
      this.coefficients = t0;
      this.confidence = null;
    },
    LeastSquaresSolver: function LeastSquaresSolver(t0, t1, t2) {
      this.x = t0;
      this.y = t1;
      this.w = t2;
    },
    IconButton$: function(color, icon, onPressed, tooltip) {
      return new B.IconButton(icon, color, onPressed, tooltip, null);
    },
    IconButton: function IconButton(t0, t1, t2, t3, t4) {
      var _ = this;
      _.icon = t0;
      _.color = t1;
      _.onPressed = t2;
      _.tooltip = t3;
      _.key = t4;
    },
    MultiChildLayoutParentData: function MultiChildLayoutParentData(t0, t1, t2) {
      var _ = this;
      _.id = null;
      _.ContainerParentDataMixin_previousSibling = t0;
      _.ContainerParentDataMixin_nextSibling = t1;
      _.offset = t2;
    },
    MultiChildLayoutDelegate: function MultiChildLayoutDelegate() {
    },
    MultiChildLayoutDelegate_layoutChild_closure: function MultiChildLayoutDelegate_layoutChild_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.child = t1;
      _.childId = t2;
      _.constraints = t3;
    },
    MultiChildLayoutDelegate_positionChild_closure: function MultiChildLayoutDelegate_positionChild_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.child = t1;
      _.childId = t2;
      _.offset = t3;
    },
    MultiChildLayoutDelegate__callPerformLayout_closure: function MultiChildLayoutDelegate__callPerformLayout_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    MultiChildLayoutDelegate__callPerformLayout_closure0: function MultiChildLayoutDelegate__callPerformLayout_closure0(t0, t1) {
      this._box_0 = t0;
      this.childParentData = t1;
    },
    MultiChildLayoutDelegate__callPerformLayout_closure1: function MultiChildLayoutDelegate__callPerformLayout_closure1(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    MultiChildLayoutDelegate__callPerformLayout_closure2: function MultiChildLayoutDelegate__callPerformLayout_closure2(t0) {
      this.$this = t0;
    },
    MultiChildLayoutDelegate__callPerformLayout_closure3: function MultiChildLayoutDelegate__callPerformLayout_closure3(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    RenderCustomMultiChildLayoutBox: function RenderCustomMultiChildLayoutBox(t0, t1, t2, t3) {
      var _ = this;
      _._custom_layout$_delegate = t0;
      _.ContainerRenderObjectMixin__childCount = t1;
      _.ContainerRenderObjectMixin__firstChild = t2;
      _.ContainerRenderObjectMixin__lastChild = t3;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    _RenderCustomMultiChildLayoutBox_RenderBox_ContainerRenderObjectMixin: function _RenderCustomMultiChildLayoutBox_RenderBox_ContainerRenderObjectMixin() {
    },
    _RenderCustomMultiChildLayoutBox_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin: function _RenderCustomMultiChildLayoutBox_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin() {
    },
    BinaryMessages__sendPlatformMessage: function(channel, message) {
      var t1 = P.ByteData,
        t2 = $.Zone__current;
      $.$get$window().sendPlatformMessage$3(channel, message, new B.BinaryMessages__sendPlatformMessage_closure(new P._AsyncCompleter(new P._Future(t2, [t1]), [t1])));
    },
    BinaryMessages_handlePlatformMessage: function(channel, data, callback) {
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.ByteData]});
      return B.BinaryMessages_handlePlatformMessage$body(channel, data, callback);
    },
    BinaryMessages_handlePlatformMessage$body: function(channel, data, callback) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$handler = 1, $async$currentError, $async$next = [], handler, exception, stack, exception0, response, $async$exception0;
      var $async$BinaryMessages_handlePlatformMessage = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              response = null;
              $async$handler = 3;
              handler = $.BinaryMessages__handlers.$index(0, channel);
              $async$goto = handler != null ? 6 : 7;
              break;
            case 6:
              // then
              $async$goto = 8;
              return P._asyncAwait(handler.call$1(data), $async$BinaryMessages_handlePlatformMessage);
            case 8:
              // returning from await.
              response = $async$result;
            case 7:
              // join
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // catch
              $async$handler = 2;
              $async$exception0 = $async$currentError;
              exception = H.unwrapException($async$exception0);
              stack = H.getTraceFromException($async$exception0);
              U.FlutterError_reportError(U.FlutterErrorDetails$("during a platform message callback", exception, null, "services library", false, stack));
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 2:
              // uncaught
              $async$next = [1];
            case 4:
              // finally
              $async$handler = 1;
              callback.call$1(response);
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
              // implicit return
              return P._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$BinaryMessages_handlePlatformMessage, $async$completer);
    },
    BinaryMessages_send: function(channel, message) {
      $.BinaryMessages__mockHandlers.$index(0, channel);
      return B.BinaryMessages__sendPlatformMessage(channel, message);
    },
    BinaryMessages_setMessageHandler: function(channel, handler) {
      H.functionTypeCheck(handler, {func: 1, ret: [P.Future, P.ByteData], args: [P.ByteData]});
      if (handler == null)
        $.BinaryMessages__handlers.remove$1(0, channel);
      else
        $.BinaryMessages__handlers.$indexSet(0, channel, handler);
    },
    BinaryMessages__sendPlatformMessage_closure: function BinaryMessages__sendPlatformMessage_closure(t0) {
      this.completer = t0;
    },
    RawKeyEvent_RawKeyEvent$fromMessage: function(message) {
      var keymap, t1, t2, t3, t4, t5, t6, data, type,
        _s9_ = "codePoint",
        _s7_ = "keyCode",
        _s8_ = "scanCode",
        _s9_0 = "modifiers";
      H.assertSubtype(message, "$isMap", [P.String, null], "$asMap");
      keymap = H.stringTypeCheck(message.$index(0, "keymap"));
      switch (keymap) {
        case "android":
          t1 = message.$index(0, "flags");
          t1 = H.intTypeCheck(t1 == null ? 0 : t1);
          t2 = message.$index(0, _s9_);
          t2 = H.intTypeCheck(t2 == null ? 0 : t2);
          t3 = message.$index(0, _s7_);
          t3 = H.intTypeCheck(t3 == null ? 0 : t3);
          t4 = message.$index(0, "plainCodePoint");
          t4 = H.intTypeCheck(t4 == null ? 0 : t4);
          t5 = message.$index(0, _s8_);
          t5 = H.intTypeCheck(t5 == null ? 0 : t5);
          t6 = message.$index(0, "metaState");
          data = new Q.RawKeyEventDataAndroid(t1, t2, t4, t3, t5, H.intTypeCheck(t6 == null ? 0 : t6));
          break;
        case "fuchsia":
          t1 = message.$index(0, "hidUsage");
          t1 = H.intTypeCheck(t1 == null ? 0 : t1);
          t2 = message.$index(0, _s9_);
          t2 = H.intTypeCheck(t2 == null ? 0 : t2);
          t3 = message.$index(0, _s9_0);
          data = new Q.RawKeyEventDataFuchsia(t1, t2, H.intTypeCheck(t3 == null ? 0 : t3));
          break;
        case "macos":
          t1 = message.$index(0, "characters");
          t1 = H.stringTypeCheck(t1 == null ? "" : t1);
          t2 = message.$index(0, "charactersIgnoringModifiers");
          t2 = H.stringTypeCheck(t2 == null ? "" : t2);
          t3 = message.$index(0, _s7_);
          t3 = H.intTypeCheck(t3 == null ? 0 : t3);
          t4 = message.$index(0, _s9_0);
          data = new B.RawKeyEventDataMacOs(t1, t2, t3, H.intTypeCheck(t4 == null ? 0 : t4));
          break;
        case "linux":
          t1 = message.$index(0, "toolkit");
          t1 = O.KeyHelper_KeyHelper(H.stringTypeCheck(t1 == null ? "" : t1));
          t2 = message.$index(0, _s9_);
          t2 = H.intTypeCheck(t2 == null ? 0 : t2);
          t3 = message.$index(0, _s7_);
          t3 = H.intTypeCheck(t3 == null ? 0 : t3);
          t4 = message.$index(0, _s8_);
          t4 = H.intTypeCheck(t4 == null ? 0 : t4);
          t5 = message.$index(0, _s9_0);
          data = new O.RawKeyEventDataLinux(t1, t4, t2, t3, H.intTypeCheck(t5 == null ? 0 : t5));
          break;
        default:
          throw H.wrapException(U.FlutterError$("Unknown keymap for key events: " + H.S(keymap)));
      }
      type = H.stringTypeCheck(message.$index(0, "type"));
      switch (type) {
        case "keydown":
          H.stringTypeCheck(message.$index(0, "character"));
          return new B.RawKeyDownEvent(data);
        case "keyup":
          return new B.RawKeyUpEvent(data);
        default:
          throw H.wrapException(U.FlutterError$("Unknown key event type: " + H.S(type)));
      }
    },
    KeyboardSide: function KeyboardSide(t0) {
      this._raw_keyboard$_name = t0;
    },
    ModifierKey: function ModifierKey(t0) {
      this._raw_keyboard$_name = t0;
    },
    RawKeyEventData: function RawKeyEventData() {
    },
    RawKeyEvent: function RawKeyEvent() {
    },
    RawKeyDownEvent: function RawKeyDownEvent(t0) {
      this.data = t0;
    },
    RawKeyUpEvent: function RawKeyUpEvent(t0) {
      this.data = t0;
    },
    RawKeyboard: function RawKeyboard(t0, t1) {
      this._listeners = t0;
      this._keysPressed = t1;
    },
    RawKeyEventDataMacOs: function RawKeyEventDataMacOs(t0, t1, t2, t3) {
      var _ = this;
      _.characters = t0;
      _.charactersIgnoringModifiers = t1;
      _.keyCode = t2;
      _.modifiers = t3;
    },
    RawKeyEventDataMacOs_getModifierSide_findSide: function RawKeyEventDataMacOs_getModifierSide_findSide(t0) {
      this.$this = t0;
    }
  },
  E = {
    debugInstrumentAction: function(description, action, $T) {
      var stopwatch, t1 = {};
      H.functionTypeCheck(action, {func: 1, ret: [P.Future, $T]});
      t1.instrument = false;
      H.assertHelper(new E.debugInstrumentAction_closure(t1).call$0());
      if (t1.instrument) {
        stopwatch = new P.Stopwatch();
        if ($.Stopwatch__frequency == null) {
          H.Primitives_initTicker();
          $.Stopwatch__frequency = $.Primitives_timerFrequency;
        }
        stopwatch.start$0();
        return action.call$0().whenComplete$1(new E.debugInstrumentAction_closure0(stopwatch, description));
      } else
        return action.call$0();
    },
    debugInstrumentAction_closure: function debugInstrumentAction_closure(t0) {
      this._box_0 = t0;
    },
    debugInstrumentAction_closure0: function debugInstrumentAction_closure0(t0, t1) {
      this.stopwatch = t0;
      this.description = t1;
    },
    _ToolbarContainerLayout: function _ToolbarContainerLayout() {
    },
    AppBar: function AppBar(t0, t1, t2) {
      this.title = t0;
      this.preferredSize = t1;
      this.key = t2;
    },
    _AppBarState: function _AppBarState(t0) {
      this._widget = null;
      this._debugLifecycleState = t0;
      this._element = null;
    },
    MaterialColor: function MaterialColor(t0, t1) {
      this._swatch = t0;
      this.value = t1;
    },
    debugCheckHasMaterial: function(context) {
      H.assertHelper(new E.debugCheckHasMaterial_closure(context).call$0());
      return true;
    },
    debugCheckHasMaterialLocalizations: function(context) {
      H.assertHelper(new E.debugCheckHasMaterialLocalizations_closure(context).call$0());
      return true;
    },
    debugCheckHasMaterial_closure: function debugCheckHasMaterial_closure(t0) {
      this.context = t0;
    },
    debugCheckHasMaterial__closure: function debugCheckHasMaterial__closure(t0) {
      this.ancestors = t0;
    },
    debugCheckHasMaterialLocalizations_closure: function debugCheckHasMaterialLocalizations_closure(t0) {
      this.context = t0;
    },
    debugCheckHasMaterialLocalizations__closure: function debugCheckHasMaterialLocalizations__closure(t0) {
      this.ancestors = t0;
    },
    FloatingActionButton$: function(child, mini, onPressed, tooltip) {
      return new E.FloatingActionButton(child, tooltip, onPressed, mini ? C.BoxConstraints_40_40_40_40 : C.BoxConstraints_56_56_56_56, null);
    },
    _DefaultHeroTag: function _DefaultHeroTag() {
    },
    FloatingActionButton: function FloatingActionButton(t0, t1, t2, t3, t4) {
      var _ = this;
      _.child = t0;
      _.tooltip = t1;
      _.onPressed = t2;
      _._sizeConstraints = t3;
      _.key = t4;
    },
    HSVColor: function HSVColor(t0, t1, t2, t3) {
      var _ = this;
      _.alpha = t0;
      _.hue = t1;
      _.saturation = t2;
      _.value = t3;
    },
    ColorSwatch: function ColorSwatch() {
    },
    ImageCache: function ImageCache(t0, t1) {
      this._pendingImages = t0;
      this._image_cache$_cache = t1;
    },
    _CachedImage: function _CachedImage() {
    },
    _PendingImage: function _PendingImage() {
    },
    _debugDrawDoubleRect: function(canvas, outerRect, innerRect, color) {
      var path = new P.Path();
      H.throwExpression(P.UnimplementedError$(null));
      path.set$fillType(C.PathFillType_1);
      path.addRect$1(outerRect);
      path.addRect$1(innerRect);
    },
    debugPaintPadding: function(canvas, outerRect, innerRect) {
      H.assertHelper(new E.debugPaintPadding_closure(innerRect, canvas, outerRect, 2).call$0());
    },
    debugPaintPadding_closure: function debugPaintPadding_closure(t0, t1, t2, t3) {
      var _ = this;
      _.innerRect = t0;
      _.canvas = t1;
      _.outerRect = t2;
      _.outlineWidth = t3;
    },
    RenderConstrainedBox$: function(additionalConstraints) {
      var t1 = new E.RenderConstrainedBox(additionalConstraints, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    RenderProxyBox: function RenderProxyBox() {
    },
    RenderProxyBoxMixin: function RenderProxyBoxMixin() {
    },
    HitTestBehavior: function HitTestBehavior(t0) {
      this._proxy_box$_name = t0;
    },
    RenderProxyBoxWithHitTestBehavior: function RenderProxyBoxWithHitTestBehavior() {
    },
    RenderConstrainedBox: function RenderConstrainedBox(t0, t1) {
      var _ = this;
      _._additionalConstraints = t0;
      _.RenderObjectWithChildMixin__child = t1;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderConstrainedBox_debugPaintSize_closure: function RenderConstrainedBox_debugPaintSize_closure(t0, t1, t2) {
      this.$this = t0;
      this.context = t1;
      this.offset = t2;
    },
    RenderLimitedBox: function RenderLimitedBox(t0, t1, t2) {
      var _ = this;
      _._maxWidth = t0;
      _._maxHeight = t1;
      _.RenderObjectWithChildMixin__child = t2;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderOpacity: function RenderOpacity(t0, t1, t2, t3) {
      var _ = this;
      _._alpha = t0;
      _._proxy_box$_opacity = t1;
      _._alwaysIncludeSemantics = t2;
      _.RenderObjectWithChildMixin__child = t3;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderAnimatedOpacity: function RenderAnimatedOpacity(t0, t1) {
      var _ = this;
      _._proxy_box$_opacity = _._currentlyNeedsCompositing = _._alpha = null;
      _._alwaysIncludeSemantics = t0;
      _.RenderObjectWithChildMixin__child = t1;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    CustomClipper: function CustomClipper() {
    },
    ShapeBorderClipper: function ShapeBorderClipper(t0, t1) {
      this.shape = t0;
      this.textDirection = t1;
    },
    _RenderCustomClip: function _RenderCustomClip() {
    },
    _RenderCustomClip_debugPaintSize_closure: function _RenderCustomClip_debugPaintSize_closure(t0) {
      this.$this = t0;
    },
    RenderClipRect: function RenderClipRect(t0, t1, t2) {
      var _ = this;
      _._clipper = t0;
      _._clip = null;
      _.clipBehavior = t1;
      _._debugText = _._debugPaint = null;
      _.RenderObjectWithChildMixin__child = t2;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderClipRect_debugPaintSize_closure: function RenderClipRect_debugPaintSize_closure(t0, t1, t2) {
      this.$this = t0;
      this.context = t1;
      this.offset = t2;
    },
    RenderClipPath: function RenderClipPath(t0, t1, t2) {
      var _ = this;
      _._clipper = t0;
      _._clip = null;
      _.clipBehavior = t1;
      _._debugText = _._debugPaint = null;
      _.RenderObjectWithChildMixin__child = t2;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderClipPath_debugPaintSize_closure: function RenderClipPath_debugPaintSize_closure(t0, t1, t2) {
      this.$this = t0;
      this.context = t1;
      this.offset = t2;
    },
    _RenderPhysicalModelBase: function _RenderPhysicalModelBase() {
    },
    RenderPhysicalModel: function RenderPhysicalModel(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _._proxy_box$_shape = t0;
      _._proxy_box$_borderRadius = t1;
      _._proxy_box$_elevation = t2;
      _._proxy_box$_shadowColor = t3;
      _._proxy_box$_color = t4;
      _._clipper = t5;
      _._clip = null;
      _.clipBehavior = t6;
      _._debugText = _._debugPaint = null;
      _.RenderObjectWithChildMixin__child = t7;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderPhysicalShape: function RenderPhysicalShape(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._proxy_box$_elevation = t0;
      _._proxy_box$_shadowColor = t1;
      _._proxy_box$_color = t2;
      _._clipper = t3;
      _._clip = null;
      _.clipBehavior = t4;
      _._debugText = _._debugPaint = null;
      _.RenderObjectWithChildMixin__child = t5;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    DecorationPosition: function DecorationPosition(t0) {
      this._proxy_box$_name = t0;
    },
    RenderDecoratedBox: function RenderDecoratedBox(t0, t1, t2, t3) {
      var _ = this;
      _._painter = null;
      _._decoration = t0;
      _._proxy_box$_position = t1;
      _._configuration = t2;
      _.RenderObjectWithChildMixin__child = t3;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderDecoratedBox_paint_closure: function RenderDecoratedBox_paint_closure(t0, t1) {
      this._box_0 = t0;
      this.context = t1;
    },
    RenderDecoratedBox_paint_closure0: function RenderDecoratedBox_paint_closure0(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.context = t2;
    },
    RenderTransform: function RenderTransform(t0, t1) {
      var _ = this;
      _._proxy_box$_textDirection = _._proxy_box$_alignment = _._origin = null;
      _.transformHitTests = t0;
      _._transform = null;
      _.RenderObjectWithChildMixin__child = t1;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderFractionalTranslation: function RenderFractionalTranslation(t0, t1, t2) {
      var _ = this;
      _._translation = t0;
      _.transformHitTests = t1;
      _.RenderObjectWithChildMixin__child = t2;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderPointerListener: function RenderPointerListener(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _.onPointerDown = t0;
      _.onPointerMove = t1;
      _._onPointerEnter = t2;
      _._onPointerHover = t3;
      _._onPointerExit = t4;
      _.onPointerUp = t5;
      _.onPointerCancel = t6;
      _.onPointerSignal = t7;
      _._hoverAnnotation = null;
      _.behavior = t8;
      _.RenderObjectWithChildMixin__child = t9;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderRepaintBoundary: function RenderRepaintBoundary(t0) {
      var _ = this;
      _._debugAsymmetricPaintCount = _._debugSymmetricPaintCount = 0;
      _.RenderObjectWithChildMixin__child = t0;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderRepaintBoundary_debugRegisterRepaintBoundaryPaint_closure: function RenderRepaintBoundary_debugRegisterRepaintBoundaryPaint_closure(t0, t1, t2) {
      this.$this = t0;
      this.includedParent = t1;
      this.includedChild = t2;
    },
    RenderRepaintBoundary_debugFillProperties_closure: function RenderRepaintBoundary_debugFillProperties_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.properties = t2;
    },
    RenderIgnorePointer: function RenderIgnorePointer(t0, t1, t2) {
      var _ = this;
      _._ignoring = t0;
      _._ignoringSemantics = t1;
      _.RenderObjectWithChildMixin__child = t2;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderOffstage: function RenderOffstage(t0, t1) {
      var _ = this;
      _._proxy_box$_offstage = t0;
      _.RenderObjectWithChildMixin__child = t1;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderAbsorbPointer: function RenderAbsorbPointer(t0, t1, t2) {
      var _ = this;
      _._absorbing = t0;
      _._ignoringSemantics = t1;
      _.RenderObjectWithChildMixin__child = t2;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderSemanticsGestureHandler: function RenderSemanticsGestureHandler(t0, t1, t2, t3, t4) {
      var _ = this;
      _._proxy_box$_onTap = t0;
      _._proxy_box$_onLongPress = t1;
      _._onHorizontalDragUpdate = t2;
      _._onVerticalDragUpdate = t3;
      _.RenderObjectWithChildMixin__child = t4;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderSemanticsAnnotations: function RenderSemanticsAnnotations(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46) {
      var _ = this;
      _._container = t0;
      _._explicitChildNodes = t1;
      _._excludeSemantics = t2;
      _._checked = t3;
      _._enabled = t4;
      _._selected = t5;
      _._button = t6;
      _._header = t7;
      _._textField = t8;
      _._focused = t9;
      _._inMutuallyExclusiveGroup = t10;
      _._obscured = t11;
      _._scopesRoute = t12;
      _._namesRoute = t13;
      _._hidden = t14;
      _._image = t15;
      _._liveRegion = t16;
      _._toggled = t17;
      _._proxy_box$_label = t18;
      _._proxy_box$_value = t19;
      _._proxy_box$_increasedValue = t20;
      _._proxy_box$_decreasedValue = t21;
      _._proxy_box$_hint = t22;
      _._proxy_box$_hintOverrides = t23;
      _._proxy_box$_textDirection = t24;
      _._proxy_box$_sortKey = t25;
      _._proxy_box$_onTap = t26;
      _._onDismiss = t27;
      _._proxy_box$_onLongPress = t28;
      _._onScrollLeft = t29;
      _._onScrollRight = t30;
      _._onScrollUp = t31;
      _._onScrollDown = t32;
      _._onIncrease = t33;
      _._onDecrease = t34;
      _._onCopy = t35;
      _._onCut = t36;
      _._onPaste = t37;
      _._onMoveCursorForwardByCharacter = t38;
      _._onMoveCursorBackwardByCharacter = t39;
      _._onMoveCursorForwardByWord = t40;
      _._onMoveCursorBackwardByWord = t41;
      _._onSetSelection = t42;
      _._onDidGainAccessibilityFocus = t43;
      _._onDidLoseAccessibilityFocus = t44;
      _._proxy_box$_customSemanticsActions = t45;
      _.RenderObjectWithChildMixin__child = t46;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderBlockSemantics: function RenderBlockSemantics(t0, t1) {
      var _ = this;
      _._blocking = t0;
      _.RenderObjectWithChildMixin__child = t1;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderMergeSemantics: function RenderMergeSemantics(t0) {
      var _ = this;
      _.RenderObjectWithChildMixin__child = t0;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderExcludeSemantics: function RenderExcludeSemantics(t0, t1) {
      var _ = this;
      _._excluding = t0;
      _.RenderObjectWithChildMixin__child = t1;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderAnnotatedRegion: function RenderAnnotatedRegion(t0, t1, t2, t3) {
      var _ = this;
      _._proxy_box$_value = t0;
      _._sized = t1;
      _.RenderObjectWithChildMixin__child = t2;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
      _.$ti = t3;
    },
    _RenderProxyBox_RenderBox_RenderObjectWithChildMixin: function _RenderProxyBox_RenderBox_RenderObjectWithChildMixin() {
    },
    _RenderProxyBox_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin: function _RenderProxyBox_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin() {
    },
    SemanticsEvent: function SemanticsEvent() {
    },
    TooltipSemanticsEvent: function TooltipSemanticsEvent(t0, t1) {
      this.message = t0;
      this.type = t1;
    },
    LongPressSemanticsEvent: function LongPressSemanticsEvent(t0) {
      this.type = t0;
    },
    TapSemanticEvent: function TapSemanticEvent(t0) {
      this.type = t0;
    },
    debugCheckHasMediaQuery: function(context) {
      H.assertHelper(new E.debugCheckHasMediaQuery_closure(context).call$0());
      return true;
    },
    debugCheckHasDirectionality: function(context) {
      H.assertHelper(new E.debugCheckHasDirectionality_closure(context).call$0());
      return true;
    },
    debugWidgetBuilderValue: function(widget, built) {
      H.assertHelper(new E.debugWidgetBuilderValue_closure(built, widget).call$0());
    },
    debugCheckHasMediaQuery_closure: function debugCheckHasMediaQuery_closure(t0) {
      this.context = t0;
    },
    debugCheckHasDirectionality_closure: function debugCheckHasDirectionality_closure(t0) {
      this.context = t0;
    },
    debugWidgetBuilderValue_closure: function debugWidgetBuilderValue_closure(t0, t1) {
      this.built = t0;
      this.widget = t1;
    },
    NavigationToolbar: function NavigationToolbar(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.leading = t0;
      _.middle = t1;
      _.trailing = t2;
      _.centerMiddle = t3;
      _.middleSpacing = t4;
      _.key = t5;
    },
    _ToolbarSlot: function _ToolbarSlot(t0) {
      this._navigation_toolbar$_name = t0;
    },
    _ToolbarLayout: function _ToolbarLayout(t0, t1, t2) {
      var _ = this;
      _.centerMiddle = t0;
      _.middleSpacing = t1;
      _.textDirection = t2;
      _._debugChildrenNeedingLayout = _._idToChild = null;
    },
    PrimaryScrollController: function PrimaryScrollController(t0, t1, t2) {
      this.controller = t0;
      this.child = t1;
      this.key = t2;
    },
    Matrix4_tryInvert: function(other) {
      var r = new E.Matrix4(new Float64Array(16));
      if (r.copyInverse$1(other) === 0)
        return;
      return r;
    },
    Matrix4_Matrix4$identity: function() {
      var t1 = new E.Matrix4(new Float64Array(16));
      t1.setIdentity$0();
      return t1;
    },
    Matrix4_Matrix4$translationValues: function(x, y, z) {
      var t1 = new Float64Array(16),
        t2 = new E.Matrix4(t1);
      t2.setIdentity$0();
      t1[14] = z;
      C.NativeFloat64List_methods.$indexSet(t1, 13, y);
      C.NativeFloat64List_methods.$indexSet(t1, 12, x);
      return t2;
    },
    Matrix4: function Matrix4(t0) {
      this._m4storage = t0;
    },
    Vector3: function Vector3(t0) {
      this._v3storage = t0;
    },
    Vector4: function Vector4(t0) {
      this._v4storage = t0;
    }
  },
  F = {
    compute: function(callback, message, debugLabel, $Q, $R) {
      return F.compute$body(H.functionTypeCheck(callback, {func: 1, ret: {futureOr: 1, type: $R}, args: [$Q]}), H.assertSubtypeOfRuntimeType(message, $Q), debugLabel, $Q, $R, $R);
    },
    compute$body: function(callback, message, debugLabel, $Q, $R, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        resultPort, t1;
      var $async$compute = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              P.Timeline_startSync(debugLabel + ": start", null, new P.Flow(9, 0));
              resultPort = new P._ReceivePortImpl();
              P.Timeline_finishSync();
              resultPort.get$sendPort();
              t1 = resultPort.get$sendPort();
              $async$goto = 2;
              return P._asyncAwait(P.Isolate_spawn(H.instantiate2(F.isolates___spawn$closure(), $Q, $R), null, true, new P._ReceivePortImpl().get$sendPort(), t1, [F._IsolateConfiguration, $Q, {futureOr: 1, type: $R}]), $async$compute);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$compute, $async$completer);
    },
    _spawn: function(configuration, $Q, $R) {
      return F._spawn$body(H.assertSubtype(configuration, "$is_IsolateConfiguration", [$Q, {futureOr: 1, type: $R}], "$as_IsolateConfiguration"), $Q, $R);
    },
    _spawn$body: function(configuration, $Q, $R) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        t1;
      var $async$_spawn = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = {};
              t1.result = null;
              $async$goto = 2;
              return P._asyncAwait(P.Timeline_timeSync(H.S(configuration.get$debugLabel()), new F._spawn_closure(t1, configuration), new P.Flow(10, configuration.get$flowId()), [P.Future, P.Null]), $async$_spawn);
            case 2:
              // returning from await.
              P.Timeline_timeSync(H.S(configuration.get$debugLabel()) + ": returning result", new F._spawn_closure0(t1, configuration), new P.Flow(10, configuration.get$flowId()), P.Null);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_spawn, $async$completer);
    },
    _IsolateConfiguration: function _IsolateConfiguration() {
    },
    _spawn_closure: function _spawn_closure(t0, t1) {
      this._box_0 = t0;
      this.configuration = t1;
    },
    _spawn_closure0: function _spawn_closure0(t0, t1) {
      this._box_0 = t0;
      this.configuration = t1;
    },
    LicenseEntry: function LicenseEntry() {
    },
    LicenseEntryWithLineBreaks: function LicenseEntryWithLineBreaks() {
    },
    PointerCancelEvent$: function(buttons, device, distance, distanceMax, kind, obscured, orientation, pointer, position, pressure, pressureMax, pressureMin, radiusMajor, radiusMax, radiusMin, radiusMinor, size, tilt, timeStamp) {
      return new F.PointerCancelEvent(timeStamp, pointer, kind, device, position, C.Offset_0_0, buttons, false, false, pressure, pressureMin, pressureMax, distance, distanceMax, size, radiusMajor, radiusMinor, radiusMin, radiusMax, orientation, tilt, 0, false);
    },
    PointerEvent: function PointerEvent() {
    },
    PointerHoverEvent: function PointerHoverEvent(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22) {
      var _ = this;
      _.timeStamp = t0;
      _.pointer = t1;
      _.kind = t2;
      _.device = t3;
      _.position = t4;
      _.delta = t5;
      _.buttons = t6;
      _.down = t7;
      _.obscured = t8;
      _.pressure = t9;
      _.pressureMin = t10;
      _.pressureMax = t11;
      _.distance = t12;
      _.distanceMax = t13;
      _.size = t14;
      _.radiusMajor = t15;
      _.radiusMinor = t16;
      _.radiusMin = t17;
      _.radiusMax = t18;
      _.orientation = t19;
      _.tilt = t20;
      _.platformData = t21;
      _.synthesized = t22;
    },
    PointerEnterEvent: function PointerEnterEvent() {
    },
    PointerExitEvent: function PointerExitEvent() {
    },
    PointerDownEvent: function PointerDownEvent() {
    },
    PointerMoveEvent: function PointerMoveEvent() {
    },
    PointerUpEvent: function PointerUpEvent() {
    },
    PointerSignalEvent: function PointerSignalEvent() {
    },
    PointerScrollEvent: function PointerScrollEvent(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23) {
      var _ = this;
      _.scrollDelta = t0;
      _.timeStamp = t1;
      _.pointer = t2;
      _.kind = t3;
      _.device = t4;
      _.position = t5;
      _.delta = t6;
      _.buttons = t7;
      _.down = t8;
      _.obscured = t9;
      _.pressure = t10;
      _.pressureMin = t11;
      _.pressureMax = t12;
      _.distance = t13;
      _.distanceMax = t14;
      _.size = t15;
      _.radiusMajor = t16;
      _.radiusMinor = t17;
      _.radiusMin = t18;
      _.radiusMax = t19;
      _.orientation = t20;
      _.tilt = t21;
      _.platformData = t22;
      _.synthesized = t23;
    },
    PointerCancelEvent: function PointerCancelEvent(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22) {
      var _ = this;
      _.timeStamp = t0;
      _.pointer = t1;
      _.kind = t2;
      _.device = t3;
      _.position = t4;
      _.delta = t5;
      _.buttons = t6;
      _.down = t7;
      _.obscured = t8;
      _.pressure = t9;
      _.pressureMin = t10;
      _.pressureMax = t11;
      _.distance = t12;
      _.distanceMax = t13;
      _.size = t14;
      _.radiusMajor = t15;
      _.radiusMinor = t16;
      _.radiusMin = t17;
      _.radiusMax = t18;
      _.orientation = t19;
      _.tilt = t20;
      _.platformData = t21;
      _.synthesized = t22;
    },
    _CountdownZoned: function _CountdownZoned() {
      this._timeout = false;
    },
    _TapTracker: function _TapTracker(t0, t1, t2, t3) {
      var _ = this;
      _.pointer = t0;
      _.entry = t1;
      _._multitap$_initialPosition = t2;
      _._doubleTapMinTimeCountdown = t3;
      _._isTrackingPointer = false;
    },
    DoubleTapGestureRecognizer: function DoubleTapGestureRecognizer(t0, t1, t2) {
      var _ = this;
      _._firstTap = _._doubleTapTimer = _.onDoubleTap = null;
      _._trackers = t0;
      _.debugOwner = t1;
      _._kind = t2;
    },
    InputBorder: function InputBorder() {
    },
    BoxBorder_lerp: function(a, b, t) {
      var t2, t0, t3, t4,
        t1 = J.getInterceptor$(a);
      if (!!t1.$isBorder || a == null)
        t2 = b instanceof F.Border || b == null;
      else
        t2 = false;
      if (t2)
        return F.Border_lerp(H.interceptedTypeCheck(a, "$isBorder"), H.interceptedTypeCheck(b, "$isBorder"), t);
      t1 = !!t1.$isBorderDirectional;
      if (t1 || a == null)
        t2 = b instanceof F.BorderDirectional || b == null;
      else
        t2 = false;
      if (t2)
        return F.BorderDirectional_lerp(H.interceptedTypeCheck(a, "$isBorderDirectional"), H.interceptedTypeCheck(b, "$isBorderDirectional"), t);
      if (b instanceof F.Border && t1) {
        t = 1 - t;
        t0 = b;
        b = a;
        a = t0;
      }
      t1 = J.getInterceptor$(a);
      if (!!t1.$isBorder && b instanceof F.BorderDirectional) {
        t1 = b.start;
        if (t1.$eq(0, C.BorderSide_m7u) && b.end.$eq(0, C.BorderSide_m7u)) {
          t1 = Y.BorderSide_lerp(a.top, b.top, t);
          t2 = Y.BorderSide_lerp(a.right, C.BorderSide_m7u, t);
          return F.Border$(Y.BorderSide_lerp(a.bottom, b.bottom, t), Y.BorderSide_lerp(a.left, C.BorderSide_m7u, t), t2, t1);
        }
        t2 = a.left;
        if (t2.$eq(0, C.BorderSide_m7u) && a.right.$eq(0, C.BorderSide_m7u)) {
          t2 = Y.BorderSide_lerp(a.top, b.top, t);
          t1 = Y.BorderSide_lerp(C.BorderSide_m7u, t1, t);
          t3 = Y.BorderSide_lerp(C.BorderSide_m7u, b.end, t);
          return F.BorderDirectional$(Y.BorderSide_lerp(a.bottom, b.bottom, t), t3, t1, t2);
        }
        if (t < 0.5) {
          t1 = Y.BorderSide_lerp(a.top, b.top, t);
          t3 = t * 2;
          t4 = Y.BorderSide_lerp(a.right, C.BorderSide_m7u, t3);
          return F.Border$(Y.BorderSide_lerp(a.bottom, b.bottom, t), Y.BorderSide_lerp(t2, C.BorderSide_m7u, t3), t4, t1);
        }
        t2 = Y.BorderSide_lerp(a.top, b.top, t);
        t3 = (t - 0.5) * 2;
        t1 = Y.BorderSide_lerp(C.BorderSide_m7u, t1, t3);
        t3 = Y.BorderSide_lerp(C.BorderSide_m7u, b.end, t3);
        return F.BorderDirectional$(Y.BorderSide_lerp(a.bottom, b.bottom, t), t3, t1, t2);
      }
      throw H.wrapException(U.FlutterError$("BoxBorder.lerp can only interpolate Border and BorderDirectional classes.\nBoxBorder.lerp() was called with two objects of type " + t1.get$runtimeType(a).toString$0(0) + " and " + J.get$runtimeType$(b).toString$0(0) + ":\n  " + H.S(a) + "\n  " + H.S(b) + "\nHowever, only Border and BorderDirectional classes are supported by this method. For a more general interpolation method, consider using ShapeBorder.lerp instead."));
    },
    BoxBorder__paintUniformBorderWithRadius: function(canvas, rect, side, borderRadius) {
      var paint, outer, width;
      H.assertHelper(side.style !== C.BorderStyle_0);
      paint = new P.Paint(new DataView(new ArrayBuffer(75)));
      paint.set$color(side.color);
      outer = borderRadius.toRRect$1(rect);
      width = side.width;
      if (width === 0) {
        paint.set$style(C.PaintingStyle_1);
        paint.set$strokeWidth(0);
        canvas.drawRRect$2(outer, paint);
      } else
        canvas.drawDRRect$3(outer, outer.inflate$1(-width), paint);
    },
    BoxBorder__paintUniformBorderWithCircle: function(canvas, rect, side) {
      var paint, t1;
      H.assertHelper(side.style !== C.BorderStyle_0);
      paint = side.toPaint$0();
      t1 = rect.get$shortestSide();
      canvas.drawCircle$3(rect.get$center(), (t1 - side.width) / 2, paint);
    },
    BoxBorder__paintUniformBorderWithRectangle: function(canvas, rect, side) {
      var paint;
      H.assertHelper(side.style !== C.BorderStyle_0);
      paint = side.toPaint$0();
      canvas.drawRect$2(rect.inflate$1(-(side.width / 2)), paint);
    },
    Border$: function(bottom, left, right, $top) {
      return new F.Border($top, right, bottom, left);
    },
    Border_lerp: function(a, b, t) {
      var t2,
        t1 = a == null;
      if (t1 && b == null)
        return;
      if (t1)
        return b.scale$1(t);
      if (b == null)
        return a.scale$1(1 - t);
      t1 = Y.BorderSide_lerp(a.top, b.top, t);
      t2 = Y.BorderSide_lerp(a.right, b.right, t);
      return F.Border$(Y.BorderSide_lerp(a.bottom, b.bottom, t), Y.BorderSide_lerp(a.left, b.left, t), t2, t1);
    },
    BorderDirectional$: function(bottom, end, start, $top) {
      return new F.BorderDirectional($top, start, end, bottom);
    },
    BorderDirectional_lerp: function(a, b, t) {
      var t2,
        t1 = a == null;
      if (t1 && b == null)
        return;
      if (t1)
        return b.scale$1(t);
      if (b == null)
        return a.scale$1(1 - t);
      t1 = Y.BorderSide_lerp(a.top, b.top, t);
      t2 = Y.BorderSide_lerp(a.end, b.end, t);
      return F.BorderDirectional$(Y.BorderSide_lerp(a.bottom, b.bottom, t), t2, Y.BorderSide_lerp(a.start, b.start, t), t1);
    },
    BoxShape: function BoxShape(t0) {
      this._box_border$_name = t0;
    },
    BoxBorder: function BoxBorder() {
    },
    Border: function Border(t0, t1, t2, t3) {
      var _ = this;
      _.top = t0;
      _.right = t1;
      _.bottom = t2;
      _.left = t3;
    },
    BorderDirectional: function BorderDirectional(t0, t1, t2, t3) {
      var _ = this;
      _.top = t0;
      _.start = t1;
      _.end = t2;
      _.bottom = t3;
    },
    _startIsTopLeft: function(direction, textDirection, verticalDirection) {
      H.assertHelper(direction != null);
      switch (direction) {
        case C.Axis_0:
          switch (textDirection) {
            case C.TextDirection_1:
              return true;
            case C.TextDirection_0:
              return false;
          }
          break;
        case C.Axis_1:
          switch (verticalDirection) {
            case C.VerticalDirection_1:
              return true;
            case C.VerticalDirection_0:
              return false;
          }
          break;
      }
      return;
    },
    _RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin_DebugOverflowIndicatorMixin_reassemble_closure: function _RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin_DebugOverflowIndicatorMixin_reassemble_closure(t0) {
      this.$this = t0;
    },
    FlexFit: function FlexFit(t0) {
      this._flex$_name = t0;
    },
    FlexParentData: function FlexParentData(t0, t1, t2) {
      var _ = this;
      _.fit = _.flex = null;
      _.ContainerParentDataMixin_previousSibling = t0;
      _.ContainerParentDataMixin_nextSibling = t1;
      _.offset = t2;
    },
    MainAxisSize: function MainAxisSize(t0) {
      this._flex$_name = t0;
    },
    MainAxisAlignment: function MainAxisAlignment(t0) {
      this._flex$_name = t0;
    },
    CrossAxisAlignment: function CrossAxisAlignment(t0) {
      this._flex$_name = t0;
    },
    RenderFlex: function RenderFlex(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _._flex$_direction = t0;
      _._mainAxisAlignment = t1;
      _._mainAxisSize = t2;
      _._crossAxisAlignment = t3;
      _._flex$_textDirection = t4;
      _._verticalDirection = t5;
      _._textBaseline = t6;
      _._flex$_overflow = null;
      _.DebugOverflowIndicatorMixin__indicatorLabel = t7;
      _.DebugOverflowIndicatorMixin__overflowReportNeeded = t8;
      _.ContainerRenderObjectMixin__childCount = t9;
      _.ContainerRenderObjectMixin__firstChild = t10;
      _.ContainerRenderObjectMixin__lastChild = t11;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderFlex_performLayout_closure: function RenderFlex_performLayout_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.canFlex = t2;
    },
    RenderFlex_performLayout_closure0: function RenderFlex_performLayout_closure0(t0) {
      this.$this = t0;
    },
    RenderFlex_paint_closure: function RenderFlex_paint_closure(t0, t1, t2) {
      this.$this = t0;
      this.context = t1;
      this.offset = t2;
    },
    _RenderFlex_RenderBox_ContainerRenderObjectMixin: function _RenderFlex_RenderBox_ContainerRenderObjectMixin() {
    },
    _RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin: function _RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin() {
    },
    _RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin_DebugOverflowIndicatorMixin: function _RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin_DebugOverflowIndicatorMixin() {
    },
    PlatformException$: function(code, details, message) {
      return new F.PlatformException(code, message, details);
    },
    MethodCall: function MethodCall(t0, t1) {
      this.method = t0;
      this.$arguments = t1;
    },
    PlatformException: function PlatformException(t0, t1, t2) {
      this.code = t0;
      this.message = t1;
      this.details = t2;
    },
    MissingPluginException: function MissingPluginException(t0) {
      this.message = t0;
    },
    MediaQueryData$: function(accessibleNavigation, alwaysUse24HourFormat, boldText, devicePixelRatio, disableAnimations, invertColors, padding, platformBrightness, size, textScaleFactor, viewInsets) {
      return new F.MediaQueryData(size, devicePixelRatio, textScaleFactor, platformBrightness, viewInsets, padding, false, accessibleNavigation, invertColors, disableAnimations, boldText);
    },
    MediaQuery$: function(child, data, key) {
      return new F.MediaQuery(data, child, key);
    },
    MediaQuery_of: function(context, nullOk) {
      var query;
      H.assertHelper(context != null);
      query = H.interceptedTypeCheck(context.inheritFromWidgetOfExactType$1(C.Type_MediaQuery_nDB), "$isMediaQuery");
      if (query != null)
        return query.data;
      if (nullOk)
        return;
      throw H.wrapException(U.FlutterError$("MediaQuery.of() called with a context that does not contain a MediaQuery.\nNo MediaQuery ancestor could be found starting from the context that was passed to MediaQuery.of(). This can happen because you do not have a WidgetsApp or MaterialApp widget (those widgets introduce a MediaQuery), or it can happen if the context you use comes from a widget above those widgets.\nThe context used was:\n  " + context.toString$0(0)));
    },
    MediaQueryData: function MediaQueryData(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) {
      var _ = this;
      _.size = t0;
      _.devicePixelRatio = t1;
      _.textScaleFactor = t2;
      _.platformBrightness = t3;
      _.viewInsets = t4;
      _.padding = t5;
      _.alwaysUse24HourFormat = t6;
      _.accessibleNavigation = t7;
      _.invertColors = t8;
      _.disableAnimations = t9;
      _.boldText = t10;
    },
    MediaQuery: function MediaQuery(t0, t1, t2) {
      this.data = t0;
      this.child = t1;
      this.key = t2;
    },
    ScrollController: function ScrollController(t0, t1) {
      this._positions = t0;
      this.ChangeNotifier__listeners = t1;
    },
    main: function() {
      var targetPlatform, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, _null = null;
      if (H.boolConversionCheck($.$get$Platform_isMacOS()))
        targetPlatform = C.TargetPlatform_2;
      else
        targetPlatform = H.boolConversionCheck($.$get$Platform_isLinux()) || H.boolConversionCheck($.$get$Platform_isWindows()) ? C.TargetPlatform_0 : _null;
      if (targetPlatform != null)
        $.debugDefaultTargetPlatformOverride = targetPlatform;
      if ($.WidgetsBinding__instance == null) {
        t1 = N.Element;
        t2 = P.HashSet_HashSet(t1);
        t1 = H.setRuntimeTypeInfo([], [t1]);
        t3 = O.FocusNode;
        t4 = [t3];
        t5 = {func: 1, ret: -1};
        t5 = new O.FocusScopeNode(H.setRuntimeTypeInfo([], t4), _null, H.setRuntimeTypeInfo([], t4), new R.ObserverList(H.setRuntimeTypeInfo([], [t5]), [t5]));
        t5.set$debugLabel("Root Focus Scope");
        t3 = t5._manager = new O.FocusManager(t5, P.LinkedHashSet_LinkedHashSet$_empty(t3));
        t5 = $.$get$RawKeyboard_instance();
        t5.toString;
        t4 = H.functionTypeCheck(t3.get$_handleRawKeyEvent(), {func: 1, ret: -1, args: [B.RawKeyEvent]});
        C.JSArray_methods.add$1(t5._listeners, t4);
        t4 = H.setRuntimeTypeInfo([], [N.WidgetsBindingObserver]);
        t5 = [N._TaskEntry,,];
        t6 = new Array(7);
        t6.fixed$length = Array;
        t6 = H.setRuntimeTypeInfo(t6, [t5]);
        t7 = P.int;
        t8 = P.HashSet_HashSet(t7);
        t9 = [{func: 1, ret: -1, args: [P.Duration]}];
        t10 = H.setRuntimeTypeInfo([], t9);
        t9 = H.setRuntimeTypeInfo([], t9);
        if ($.Stopwatch__frequency == null) {
          H.Primitives_initTicker();
          $.Stopwatch__frequency = $.Primitives_timerFrequency;
        }
        new N.WidgetsFlutterBinding(new N.BuildOwner(new N._InactiveElements(t2), t1, t3), t4, true, 0, false, _null, _null, _null, _null, _null, _null, 0, _null, N.binding__defaultSchedulingStrategy$closure(), new Y.HeapPriorityQueue(N.binding_SchedulerBinding__taskSorter$closure(), t6, [t5]), false, 0, P.LinkedHashMap_LinkedHashMap$_empty(t7, N._FrameCallbackEntry), t8, t10, t9, _null, false, C.SchedulerPhase_0, true, false, _null, C.Duration_0, C.Duration_0, _null, 0, new P.Stopwatch(), _null, false, P.ListQueue$(F.PointerEvent), new O.PointerRouter(P.LinkedHashMap_LinkedHashMap$_empty(t7, [P.LinkedHashSet, {func: 1, ret: -1, args: [F.PointerEvent]}]), P.LinkedHashSet_LinkedHashSet({func: 1, ret: -1, args: [F.PointerEvent]})), new D.GestureArenaManager(P.LinkedHashMap_LinkedHashMap$_empty(t7, D._GestureArena)), new G.PointerSignalResolver(), P.LinkedHashMap_LinkedHashMap$_empty(t7, O.HitTestResult)).BindingBase$0();
      }
      t1 = $.WidgetsBinding__instance;
      t2 = t1.RendererBinding__pipelineOwner._rootNode;
      t3 = S.RenderBox;
      t1.WidgetsBinding__renderViewElement = new N.RenderObjectToWidgetAdapter(new F.MyApp(_null), t2, "[root]", new N.GlobalObjectKey(t2, [[N.State, N.StatefulWidget]]), [t3]).attachToRenderTree$2(t1.WidgetsBinding__buildOwner, H.assertSubtype(t1.WidgetsBinding__renderViewElement, "$isRenderObjectToWidgetElement", [t3], "$asRenderObjectToWidgetElement"));
      t1.scheduleWarmUpFrame$0();
    },
    MyApp: function MyApp(t0) {
      this.key = t0;
    },
    MyHomePage: function MyHomePage(t0, t1) {
      this.title = t0;
      this.key = t1;
    },
    _MyHomePageState: function _MyHomePageState(t0) {
      var _ = this;
      _._counter = 0;
      _._widget = null;
      _._debugLifecycleState = t0;
      _._element = null;
    },
    _MyHomePageState__incrementCounter_closure: function _MyHomePageState__incrementCounter_closure(t0) {
      this.$this = t0;
    }
  },
  T = {
    defaultTargetPlatform: function() {
      var t2, t1 = {};
      t1.result = null;
      if (H.boolConversionCheck($.$get$Platform_isIOS()))
        t1.result = C.TargetPlatform_2;
      else if (H.boolConversionCheck($.$get$Platform_isAndroid()))
        t1.result = C.TargetPlatform_0;
      else if (H.boolConversionCheck($.$get$Platform_isFuchsia()))
        t1.result = C.TargetPlatform_1;
      H.assertHelper(new T.defaultTargetPlatform_closure(t1).call$0());
      t2 = $.debugDefaultTargetPlatformOverride;
      if (t2 != null)
        t1.result = t2;
      t1 = t1.result;
      if (t1 == null)
        throw H.wrapException(U.FlutterError$("Unknown platform.\n" + H.S($.$get$Platform__operatingSystem()) + " was not recognized as a target platform. Consider updating the list of TargetPlatforms to include this platform."));
      return t1;
    },
    TargetPlatform: function TargetPlatform(t0) {
      this._platform$_name = t0;
    },
    defaultTargetPlatform_closure: function defaultTargetPlatform_closure(t0) {
      this._box_0 = t0;
    },
    LongPressStartDetails: function LongPressStartDetails() {
    },
    LongPressMoveUpdateDetails: function LongPressMoveUpdateDetails() {
    },
    LongPressEndDetails: function LongPressEndDetails() {
    },
    LongPressGestureRecognizer: function LongPressGestureRecognizer(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._longPressAccepted = false;
      _.onLongPressEnd = _.onLongPressUp = _.onLongPressMoveUpdate = _.onLongPressStart = _.onLongPress = _._longPressOrigin = null;
      _.deadline = t0;
      _.postAcceptSlopTolerance = t1;
      _.state = t2;
      _.initialPosition = _.primaryPointer = null;
      _._gestureAccepted = false;
      _._timer = null;
      _._recognizer$_entries = t3;
      _._trackedPointers = t4;
      _.debugOwner = t5;
      _._kind = t6;
    },
    _sample: function(colors, stops, t) {
      var t1, index, t2, t3, t4, t5;
      H.assertSubtype(colors, "$isList", [P.Color], "$asList");
      H.assertSubtype(stops, "$isList", [P.double], "$asList");
      H.assertHelper(colors.length !== 0);
      H.assertHelper(stops.length !== 0);
      H.assertHelper(t != null);
      t1 = C.JSArray_methods.get$first(stops);
      if (typeof t !== "number")
        return t.$le();
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (t <= t1)
        return C.JSArray_methods.get$first(colors);
      t1 = C.JSArray_methods.get$last(stops);
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (t >= t1)
        return C.JSArray_methods.get$last(colors);
      index = C.JSArray_methods.lastIndexWhere$1(stops, new T._sample_closure(t));
      H.assertHelper(index !== -1);
      t1 = colors.length;
      if (index < 0 || index >= t1)
        return H.ioore(colors, index);
      t2 = colors[index];
      t3 = index + 1;
      if (t3 >= t1)
        return H.ioore(colors, t3);
      t1 = colors[t3];
      t4 = stops.length;
      if (index >= t4)
        return H.ioore(stops, index);
      t5 = stops[index];
      if (typeof t5 !== "number")
        return H.iae(t5);
      if (t3 >= t4)
        return H.ioore(stops, t3);
      return P.Color_lerp(t2, t1, (t - t5) / J.$sub$n(stops[t3], t5));
    },
    _interpolateColorsAndStops: function(aColors, aStops, bColors, bStops, t) {
      var t3, t4, stops, interpolatedStops,
        t1 = P.Color,
        t2 = [t1];
      H.assertSubtype(aColors, "$isList", t2, "$asList");
      t3 = P.double;
      t4 = [t3];
      H.assertSubtype(aStops, "$isList", t4, "$asList");
      H.assertSubtype(bColors, "$isList", t2, "$asList");
      H.assertSubtype(bStops, "$isList", t4, "$asList");
      H.assertHelper(aColors.length >= 2);
      H.assertHelper(bColors.length >= 2);
      H.assertHelper(aStops.length === aColors.length);
      H.assertHelper(bStops.length === bColors.length);
      stops = P.SplayTreeSet$(null, null, t3);
      stops.addAll$1(0, aStops);
      stops.addAll$1(0, bStops);
      interpolatedStops = stops.toList$1$growable(0, false);
      t3 = H.getTypeArgumentByIndex(interpolatedStops, 0);
      return new T._ColorsAndStops(new H.MappedListIterable(interpolatedStops, H.functionTypeCheck(new T._interpolateColorsAndStops_closure(aColors, aStops, bColors, bStops, t), {func: 1, ret: t1, args: [t3]}), [t3, t1]).toList$1$growable(0, false), interpolatedStops);
    },
    Gradient_lerp: function(a, b, t) {
      return;
    },
    LinearGradient$: function(begin, colors, end, stops, tileMode) {
      return new T.LinearGradient(begin, end, tileMode, colors, stops);
    },
    LinearGradient_lerp: function(a, b, t) {
      var interpolated, t2, t3,
        t1 = a == null;
      if (t1 && b == null)
        return;
      if (t1)
        return b.scale$1(t);
      if (b == null)
        return a.scale$1(1 - t);
      interpolated = T._interpolateColorsAndStops(a.colors, a._impliedStops$0(), b.colors, b._impliedStops$0(), t);
      t1 = K.AlignmentGeometry_lerp(a.begin, b.begin, t);
      t2 = K.AlignmentGeometry_lerp(a.end, b.end, t);
      t3 = t < 0.5 ? a.tileMode : b.tileMode;
      return T.LinearGradient$(t1, interpolated.colors, t2, interpolated.stops, t3);
    },
    _ColorsAndStops: function _ColorsAndStops(t0, t1) {
      this.colors = t0;
      this.stops = t1;
    },
    _sample_closure: function _sample_closure(t0) {
      this.t = t0;
    },
    _interpolateColorsAndStops_closure: function _interpolateColorsAndStops_closure(t0, t1, t2, t3, t4) {
      var _ = this;
      _.aColors = t0;
      _.aStops = t1;
      _.bColors = t2;
      _.bStops = t3;
      _.t = t4;
    },
    Gradient: function Gradient() {
    },
    LinearGradient: function LinearGradient(t0, t1, t2, t3, t4) {
      var _ = this;
      _.begin = t0;
      _.end = t1;
      _.tileMode = t2;
      _.colors = t3;
      _.stops = t4;
    },
    LinearGradient_scale_closure: function LinearGradient_scale_closure(t0) {
      this.factor = t0;
    },
    MatrixUtils_getAsTranslation: function(transform) {
      var values;
      H.assertHelper(transform != null);
      values = transform._m4storage;
      if (values[0] === 1 && values[1] === 0 && values[2] === 0 && values[3] === 0 && values[4] === 0 && values[5] === 1 && values[6] === 0 && values[7] === 0 && values[8] === 0 && values[9] === 0 && values[10] === 1 && values[11] === 0 && values[14] === 0 && values[15] === 1)
        return new P.Offset(values[12], values[13]);
      return;
    },
    MatrixUtils_getAsScale: function(transform) {
      var values;
      H.assertHelper(transform != null);
      values = transform._m4storage;
      if (values[1] === 0 && values[2] === 0 && values[3] === 0 && values[4] === 0 && values[6] === 0 && values[7] === 0 && values[8] === 0 && values[9] === 0 && values[10] === 1 && values[11] === 0 && values[12] === 0 && values[13] === 0 && values[14] === 0 && values[15] === 1 && values[0] === values[5])
        return values[0];
      return;
    },
    MatrixUtils_matrixEquals: function(a, b) {
      var t1, t2, t3;
      if (a == b)
        return true;
      t1 = a == null;
      H.assertHelper(!t1 || b != null);
      if (t1)
        return T.MatrixUtils_isIdentity(b);
      if (b == null)
        return T.MatrixUtils_isIdentity(a);
      t1 = a._m4storage;
      t2 = t1[0];
      t3 = b._m4storage;
      return t2 === t3[0] && t1[1] === t3[1] && t1[2] === t3[2] && t1[3] === t3[3] && t1[4] === t3[4] && t1[5] === t3[5] && t1[6] === t3[6] && t1[7] === t3[7] && t1[8] === t3[8] && t1[9] === t3[9] && t1[10] === t3[10] && t1[11] === t3[11] && t1[12] === t3[12] && t1[13] === t3[13] && t1[14] === t3[14] && t1[15] === t3[15];
    },
    MatrixUtils_isIdentity: function(a) {
      var t1;
      H.assertHelper(a != null);
      t1 = a._m4storage;
      return t1[0] === 1 && t1[1] === 0 && t1[2] === 0 && t1[3] === 0 && t1[4] === 0 && t1[5] === 1 && t1[6] === 0 && t1[7] === 0 && t1[8] === 0 && t1[9] === 0 && t1[10] === 1 && t1[11] === 0 && t1[12] === 0 && t1[13] === 0 && t1[14] === 0 && t1[15] === 1;
    },
    MatrixUtils_transformPoint: function(transform, point) {
      var t1 = point._dx,
        t2 = point._dy,
        position3 = new E.Vector3(new Float64Array(3));
      position3.setValues$3(t1, t2, 0);
      t1 = transform.perspectiveTransform$1(position3)._v3storage;
      return new P.Offset(t1[0], t1[1]);
    },
    MatrixUtils_transformRect: function(transform, rect) {
      var point3, point4, t4, t5, t6,
        t1 = rect.left,
        t2 = rect.top,
        point1 = T.MatrixUtils_transformPoint(transform, new P.Offset(t1, t2)),
        t3 = rect.right,
        point2 = T.MatrixUtils_transformPoint(transform, new P.Offset(t3, t2));
      t2 = rect.bottom;
      point3 = T.MatrixUtils_transformPoint(transform, new P.Offset(t1, t2));
      point4 = T.MatrixUtils_transformPoint(transform, new P.Offset(t3, t2));
      t2 = point1._dx;
      t3 = point2._dx;
      t1 = point3._dx;
      t4 = point4._dx;
      t5 = Math.min(H.checkNum(t1), H.checkNum(t4));
      t5 = Math.min(H.checkNum(t3), t5);
      t5 = Math.min(H.checkNum(t2), t5);
      point1 = point1._dy;
      point2 = point2._dy;
      point3 = point3._dy;
      point4 = point4._dy;
      t6 = Math.min(H.checkNum(point3), H.checkNum(point4));
      t6 = Math.min(H.checkNum(point2), t6);
      t6 = Math.min(H.checkNum(point1), t6);
      t4 = Math.max(H.checkNum(t1), H.checkNum(t4));
      t4 = Math.max(H.checkNum(t3), t4);
      t4 = Math.max(H.checkNum(t2), t4);
      point4 = Math.max(H.checkNum(point3), H.checkNum(point4));
      point4 = Math.max(H.checkNum(point2), point4);
      return P.Rect$fromLTRB(t5, t6, t4, Math.max(H.checkNum(point1), point4));
    },
    MatrixUtils_inverseTransformRect: function(transform, rect) {
      var transform0;
      if (T.MatrixUtils_isIdentity(transform))
        return rect;
      transform0 = new E.Matrix4(new Float64Array(16));
      transform0.setFrom$1(transform);
      transform0.copyInverse$1(transform0);
      return T.MatrixUtils_transformRect(transform0, rect);
    },
    debugDescribeTransform: function(transform) {
      var t1, matrix;
      if (transform == null)
        return C.List_null;
      t1 = H.setRuntimeTypeInfo(transform.toString$0(0).split("\n"), [P.String]);
      matrix = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
      if (0 < 0 || 0 >= matrix.length)
        return H.ioore(matrix, -1);
      matrix.pop();
      return matrix;
    },
    TransformProperty$: function($name, value, defaultValue, showName) {
      var _null = null;
      return new T.TransformProperty(_null, _null, _null, _null, false, value, defaultValue, C.DiagnosticLevel_3, $name, true, showName, C.DiagnosticsTreeStyle_5);
    },
    TransformProperty: function TransformProperty(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _._description = t0;
      _.ifNull = t1;
      _.ifEmpty = t2;
      _.tooltip = t3;
      _.missingIfNull = t4;
      _._value = t5;
      _._valueComputed = true;
      _._exception = null;
      _.defaultValue = t6;
      _._defaultLevel = t7;
      _.name = t8;
      _.showSeparator = t9;
      _.showName = t10;
      _.style = t11;
    },
    Simulation: function Simulation() {
    },
    _OverflowSide: function _OverflowSide(t0, t1) {
      this.index = t0;
      this._debug_overflow_indicator$_name = t1;
    },
    _OverflowRegionData: function _OverflowRegionData(t0, t1, t2, t3, t4) {
      var _ = this;
      _.rect = t0;
      _.label = t1;
      _.labelOffset = t2;
      _.rotation = t3;
      _.side = t4;
    },
    DebugOverflowIndicatorMixin: function DebugOverflowIndicatorMixin() {
    },
    DebugOverflowIndicatorMixin__reportOverflow_closure: function DebugOverflowIndicatorMixin__reportOverflow_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    AnnotatedRegionLayer$: function(value, offset, size, $T) {
      var t1 = offset == null ? C.Offset_0_0 : offset;
      return new T.AnnotatedRegionLayer(value, size, t1, [$T]);
    },
    Layer: function Layer() {
    },
    PictureLayer: function PictureLayer(t0) {
      var _ = this;
      _.canvasBounds = t0;
      _._picture = null;
      _._willChangeHint = _._isComplexHint = false;
      _._needsAddToScene = true;
      _.debugCreator = _._previousSibling = _._nextSibling = _._engineLayer = _._subtreeNeedsAddToScene = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    PerformanceOverlayLayer: function PerformanceOverlayLayer(t0, t1, t2, t3, t4) {
      var _ = this;
      _._overlayRect = t0;
      _.optionsMask = t1;
      _.rasterizerThreshold = t2;
      _.checkerboardRasterCacheImages = t3;
      _.checkerboardOffscreenLayers = t4;
      _._needsAddToScene = true;
      _.debugCreator = _._previousSibling = _._nextSibling = _._engineLayer = _._subtreeNeedsAddToScene = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    ContainerLayer: function ContainerLayer() {
    },
    ContainerLayer_append_closure: function ContainerLayer_append_closure(t0, t1) {
      this.$this = t0;
      this.child = t1;
    },
    OffsetLayer: function OffsetLayer(t0) {
      var _ = this;
      _._layer$_offset = t0;
      _._layer$_lastChild = _._layer$_firstChild = null;
      _._needsAddToScene = true;
      _.debugCreator = _._previousSibling = _._nextSibling = _._engineLayer = _._subtreeNeedsAddToScene = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    OffsetLayer_buildScene_closure: function OffsetLayer_buildScene_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    ClipRectLayer: function ClipRectLayer(t0, t1) {
      var _ = this;
      _._clipRect = t0;
      _._clipBehavior = t1;
      _._layer$_lastChild = _._layer$_firstChild = null;
      _._needsAddToScene = true;
      _.debugCreator = _._previousSibling = _._nextSibling = _._engineLayer = _._subtreeNeedsAddToScene = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    ClipRectLayer_addToScene_closure: function ClipRectLayer_addToScene_closure(t0) {
      this._box_0 = t0;
    },
    TransformLayer: function TransformLayer(t0, t1) {
      var _ = this;
      _._layer$_transform = t0;
      _._invertedTransform = _._lastEffectiveTransform = null;
      _._inverseDirty = true;
      _._layer$_offset = t1;
      _._layer$_lastChild = _._layer$_firstChild = null;
      _._needsAddToScene = true;
      _.debugCreator = _._previousSibling = _._nextSibling = _._engineLayer = _._subtreeNeedsAddToScene = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    OpacityLayer: function OpacityLayer(t0, t1) {
      var _ = this;
      _._layer$_alpha = t0;
      _._layer$_offset = t1;
      _._layer$_lastChild = _._layer$_firstChild = null;
      _._needsAddToScene = true;
      _.debugCreator = _._previousSibling = _._nextSibling = _._engineLayer = _._subtreeNeedsAddToScene = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    OpacityLayer_addToScene_closure: function OpacityLayer_addToScene_closure(t0) {
      this._box_0 = t0;
    },
    PhysicalModelLayer: function PhysicalModelLayer() {
    },
    AnnotatedRegionLayer: function AnnotatedRegionLayer(t0, t1, t2, t3) {
      var _ = this;
      _.value = t0;
      _.size = t1;
      _.offset = t2;
      _._layer$_lastChild = _._layer$_firstChild = null;
      _._needsAddToScene = true;
      _.debugCreator = _._previousSibling = _._nextSibling = _._engineLayer = _._subtreeNeedsAddToScene = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
      _.$ti = t3;
    },
    _Layer_AbstractNode_DiagnosticableTreeMixin: function _Layer_AbstractNode_DiagnosticableTreeMixin() {
    },
    RenderShiftedBox: function RenderShiftedBox() {
    },
    RenderPadding: function RenderPadding(t0, t1, t2) {
      var _ = this;
      _._resolvedPadding = null;
      _._padding = t0;
      _._shifted_box$_textDirection = t1;
      _.RenderObjectWithChildMixin__child = t2;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderPadding_debugPaintSize_closure: function RenderPadding_debugPaintSize_closure(t0, t1, t2) {
      this.$this = t0;
      this.offset = t1;
      this.context = t2;
    },
    RenderAligningShiftedBox: function RenderAligningShiftedBox() {
    },
    RenderPositionedBox: function RenderPositionedBox(t0, t1, t2, t3, t4) {
      var _ = this;
      _._widthFactor = t0;
      _._heightFactor = t1;
      _._resolvedAlignment = null;
      _._alignment = t2;
      _._shifted_box$_textDirection = t3;
      _.RenderObjectWithChildMixin__child = t4;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderPositionedBox_debugPaintSize_closure: function RenderPositionedBox_debugPaintSize_closure(t0, t1, t2) {
      this.$this = t0;
      this.offset = t1;
      this.context = t2;
    },
    SingleChildLayoutDelegate: function SingleChildLayoutDelegate() {
    },
    RenderCustomSingleChildLayoutBox: function RenderCustomSingleChildLayoutBox(t0, t1) {
      var _ = this;
      _._delegate = t0;
      _.RenderObjectWithChildMixin__child = t1;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    _RenderShiftedBox_RenderBox_RenderObjectWithChildMixin: function _RenderShiftedBox_RenderBox_RenderObjectWithChildMixin() {
    },
    Directionality_of: function(context) {
      var widget = H.interceptedTypeCheck(context.inheritFromWidgetOfExactType$1(C.Type_Directionality_8Om), "$isDirectionality");
      return widget == null ? null : widget.textDirection;
    },
    Opacity$: function(child, opacity) {
      return new T.Opacity(opacity, child, null);
    },
    CustomPaint$: function(child, foregroundPainter, painter) {
      return new T.CustomPaint(painter, foregroundPainter, child, null);
    },
    Transform$: function(alignment, child, transform, transformHitTests) {
      return new T.Transform(transform, alignment, transformHitTests, child, null);
    },
    Padding$: function(child, padding) {
      return new T.Padding(padding, child, null);
    },
    Align$: function(alignment, child, heightFactor, key, widthFactor) {
      return new T.Align(alignment, widthFactor, heightFactor, child, key);
    },
    CustomSingleChildLayout$: function(child, delegate) {
      return new T.CustomSingleChildLayout(delegate, child, null);
    },
    LayoutId$: function(child, id) {
      return new T.LayoutId(id, child, new D.ValueKey(id, [P.Object]));
    },
    CustomMultiChildLayout$: function(children, delegate) {
      return new T.CustomMultiChildLayout(delegate, children, null);
    },
    ConstrainedBox$: function(child, constraints) {
      return new T.ConstrainedBox(constraints, child, null);
    },
    Stack$: function(alignment, children, fit) {
      return new T.Stack(alignment, fit, children, null);
    },
    Positioned$: function(bottom, child, height, key, left, right, $top, width) {
      return new T.Positioned(left, $top, right, bottom, width, height, child, key);
    },
    Column$: function(children, mainAxisAlignment) {
      return new T.Column(C.Axis_1, mainAxisAlignment, C.MainAxisSize_1, C.CrossAxisAlignment_2, null, C.VerticalDirection_1, null, children, null);
    },
    RichText$: function(locale, maxLines, overflow, softWrap, strutStyle, text, textAlign, textDirection, textScaleFactor) {
      return new T.RichText(text, textAlign, textDirection, softWrap, overflow, textScaleFactor, maxLines, locale, strutStyle, null);
    },
    Listener$: function(behavior, child, onPointerCancel, onPointerDown, onPointerUp) {
      return new T.Listener(onPointerDown, onPointerUp, onPointerCancel, behavior, child, null);
    },
    IgnorePointer$: function(child, ignoring, ignoringSemantics, key) {
      return new T.IgnorePointer(ignoring, ignoringSemantics, child, key);
    },
    Semantics$: function(button, child, container, enabled, explicitChildNodes, header, label, namesRoute, onDismiss, scopesRoute, textDirection) {
      var _null = null;
      return new T.Semantics(new A.SemanticsProperties(enabled, _null, _null, _null, button, header, _null, _null, _null, _null, _null, scopesRoute, namesRoute, _null, _null, label, _null, _null, _null, _null, _null, textDirection, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, onDismiss, _null), container, explicitChildNodes, false, child, _null);
    },
    ExcludeSemantics$: function(child, excluding) {
      return new T.ExcludeSemantics(excluding, child, null);
    },
    Builder$: function(builder) {
      return new T.Builder(builder, null);
    },
    Directionality: function Directionality(t0, t1, t2) {
      this.textDirection = t0;
      this.child = t1;
      this.key = t2;
    },
    Opacity: function Opacity(t0, t1, t2) {
      this.opacity = t0;
      this.child = t1;
      this.key = t2;
    },
    CustomPaint: function CustomPaint(t0, t1, t2, t3) {
      var _ = this;
      _.painter = t0;
      _.foregroundPainter = t1;
      _.child = t2;
      _.key = t3;
    },
    ClipRect: function ClipRect(t0, t1) {
      this.child = t0;
      this.key = t1;
    },
    ClipPath: function ClipPath(t0, t1, t2, t3) {
      var _ = this;
      _.clipper = t0;
      _.clipBehavior = t1;
      _.child = t2;
      _.key = t3;
    },
    PhysicalModel: function PhysicalModel(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.shape = t0;
      _.clipBehavior = t1;
      _.borderRadius = t2;
      _.elevation = t3;
      _.color = t4;
      _.shadowColor = t5;
      _.child = t6;
      _.key = t7;
    },
    PhysicalShape: function PhysicalShape(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.clipper = t0;
      _.clipBehavior = t1;
      _.elevation = t2;
      _.color = t3;
      _.shadowColor = t4;
      _.child = t5;
      _.key = t6;
    },
    Transform: function Transform(t0, t1, t2, t3, t4) {
      var _ = this;
      _.transform = t0;
      _.alignment = t1;
      _.transformHitTests = t2;
      _.child = t3;
      _.key = t4;
    },
    FractionalTranslation: function FractionalTranslation(t0, t1, t2, t3) {
      var _ = this;
      _.translation = t0;
      _.transformHitTests = t1;
      _.child = t2;
      _.key = t3;
    },
    Padding: function Padding(t0, t1, t2) {
      this.padding = t0;
      this.child = t1;
      this.key = t2;
    },
    Align: function Align(t0, t1, t2, t3, t4) {
      var _ = this;
      _.alignment = t0;
      _.widthFactor = t1;
      _.heightFactor = t2;
      _.child = t3;
      _.key = t4;
    },
    Center: function Center(t0, t1, t2, t3, t4) {
      var _ = this;
      _.alignment = t0;
      _.widthFactor = t1;
      _.heightFactor = t2;
      _.child = t3;
      _.key = t4;
    },
    CustomSingleChildLayout: function CustomSingleChildLayout(t0, t1, t2) {
      this.delegate = t0;
      this.child = t1;
      this.key = t2;
    },
    LayoutId: function LayoutId(t0, t1, t2) {
      this.id = t0;
      this.child = t1;
      this.key = t2;
    },
    CustomMultiChildLayout: function CustomMultiChildLayout(t0, t1, t2) {
      this.delegate = t0;
      this.children = t1;
      this.key = t2;
    },
    SizedBox: function SizedBox(t0, t1, t2, t3) {
      var _ = this;
      _.width = t0;
      _.height = t1;
      _.child = t2;
      _.key = t3;
    },
    ConstrainedBox: function ConstrainedBox(t0, t1, t2) {
      this.constraints = t0;
      this.child = t1;
      this.key = t2;
    },
    LimitedBox: function LimitedBox(t0, t1, t2, t3) {
      var _ = this;
      _.maxWidth = t0;
      _.maxHeight = t1;
      _.child = t2;
      _.key = t3;
    },
    Offstage: function Offstage(t0, t1, t2) {
      this.offstage = t0;
      this.child = t1;
      this.key = t2;
    },
    _OffstageElement: function _OffstageElement(t0, t1, t2) {
      var _ = this;
      _._framework$_parent = _._ancestorRenderObjectElement = _._renderObject = _._framework$_child = null;
      _._cachedHash = t0;
      _._depth = _._slot = null;
      _._widget = t1;
      _._owner = null;
      _._active = false;
      _._debugLifecycleState = t2;
      _._dependencies = _._inheritedWidgets = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._debugAllowIgnoredCallsToMarkNeedsBuild = _._debugBuiltOnce = _._inDirtyList = false;
    },
    Stack: function Stack(t0, t1, t2, t3) {
      var _ = this;
      _.alignment = t0;
      _.fit = t1;
      _.children = t2;
      _.key = t3;
    },
    Positioned: function Positioned(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.left = t0;
      _.top = t1;
      _.right = t2;
      _.bottom = t3;
      _.width = t4;
      _.height = t5;
      _.child = t6;
      _.key = t7;
    },
    PositionedDirectional: function PositionedDirectional(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.start = t0;
      _.top = t1;
      _.bottom = t2;
      _.width = t3;
      _.child = t4;
      _.key = t5;
    },
    Flex: function Flex() {
    },
    Column: function Column(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.direction = t0;
      _.mainAxisAlignment = t1;
      _.mainAxisSize = t2;
      _.crossAxisAlignment = t3;
      _.textDirection = t4;
      _.verticalDirection = t5;
      _.textBaseline = t6;
      _.children = t7;
      _.key = t8;
    },
    RichText: function RichText(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _.text = t0;
      _.textAlign = t1;
      _.textDirection = t2;
      _.softWrap = t3;
      _.overflow = t4;
      _.textScaleFactor = t5;
      _.maxLines = t6;
      _.locale = t7;
      _.strutStyle = t8;
      _.key = t9;
    },
    DefaultAssetBundle: function DefaultAssetBundle() {
    },
    Listener: function Listener(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.onPointerDown = t0;
      _.onPointerUp = t1;
      _.onPointerCancel = t2;
      _.behavior = t3;
      _.child = t4;
      _.key = t5;
    },
    RepaintBoundary: function RepaintBoundary(t0, t1) {
      this.child = t0;
      this.key = t1;
    },
    IgnorePointer: function IgnorePointer(t0, t1, t2, t3) {
      var _ = this;
      _.ignoring = t0;
      _.ignoringSemantics = t1;
      _.child = t2;
      _.key = t3;
    },
    AbsorbPointer: function AbsorbPointer(t0, t1, t2) {
      this.absorbing = t0;
      this.child = t1;
      this.key = t2;
    },
    Semantics: function Semantics(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.properties = t0;
      _.container = t1;
      _.explicitChildNodes = t2;
      _.excludeSemantics = t3;
      _.child = t4;
      _.key = t5;
    },
    MergeSemantics: function MergeSemantics(t0, t1) {
      this.child = t0;
      this.key = t1;
    },
    BlockSemantics: function BlockSemantics(t0, t1) {
      this.child = t0;
      this.key = t1;
    },
    ExcludeSemantics: function ExcludeSemantics(t0, t1, t2) {
      this.excluding = t0;
      this.child = t1;
      this.key = t2;
    },
    KeyedSubtree: function KeyedSubtree(t0, t1) {
      this.child = t0;
      this.key = t1;
    },
    Builder: function Builder(t0, t1) {
      this.builder = t0;
      this.key = t1;
    },
    _globalBoundingBoxFor: function(context) {
      var t1, t2, t3,
        box = H.interceptedTypeCheck(context.get$renderObject(), "$isRenderBox");
      H.assertHelper(box != null && box._size != null);
      t1 = box.getTransformTo$1(null);
      t2 = box.get$size();
      t3 = t2._dx;
      t2 = t2._dy;
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return T.MatrixUtils_transformRect(t1, new P.Rect(0, 0, 0 + t3, 0 + t2));
    },
    Hero__allHeroesFor: function(context, isUserGestureTransition, $navigator) {
      var result;
      H.assertHelper(context != null);
      H.assertHelper($navigator != null);
      result = P.LinkedHashMap_LinkedHashMap$_empty(P.Object, T._HeroState);
      context.visitChildElements$1(new T.Hero__allHeroesFor_visitor(isUserGestureTransition, $navigator, new T.Hero__allHeroesFor_addHero(result)));
      return result;
    },
    HeroFlightDirection: function HeroFlightDirection(t0) {
      this._heroes$_name = t0;
    },
    Hero: function Hero(t0, t1, t2) {
      this.tag = t0;
      this.child = t1;
      this.key = t2;
    },
    Hero__allHeroesFor_addHero: function Hero__allHeroesFor_addHero(t0) {
      this.result = t0;
    },
    Hero__allHeroesFor_addHero_closure: function Hero__allHeroesFor_addHero_closure(t0, t1, t2) {
      this.result = t0;
      this.tag = t1;
      this.hero = t2;
    },
    Hero__allHeroesFor_visitor: function Hero__allHeroesFor_visitor(t0, t1, t2) {
      this.isUserGestureTransition = t0;
      this.navigator = t1;
      this.addHero = t2;
    },
    _HeroState: function _HeroState(t0, t1) {
      var _ = this;
      _._heroes$_key = t0;
      _._widget = _._placeholderSize = null;
      _._debugLifecycleState = t1;
      _._element = null;
    },
    _HeroState_startFlight_closure: function _HeroState_startFlight_closure(t0, t1) {
      this.$this = t0;
      this.box = t1;
    },
    _HeroState_endFlight_closure: function _HeroState_endFlight_closure(t0) {
      this.$this = t0;
    },
    _HeroFlightManifest: function _HeroFlightManifest(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _.type = t0;
      _.overlay = t1;
      _.navigatorRect = t2;
      _.fromRoute = t3;
      _.toRoute = t4;
      _.fromHero = t5;
      _.toHero = t6;
      _.createRectTween = t7;
      _.shuttleBuilder = t8;
      _.isUserGestureTransition = t9;
    },
    _HeroFlight: function _HeroFlight(t0, t1) {
      var _ = this;
      _.onFlightEnded = t0;
      _.shuttle = _.heroRectTween = null;
      _._heroOpacity = t1;
      _.overlayEntry = _.manifest = _._proxyAnimation = null;
      _._aborted = false;
    },
    _HeroFlight__buildOverlay_closure: function _HeroFlight__buildOverlay_closure(t0) {
      this.$this = t0;
    },
    _HeroFlight_start_closure: function _HeroFlight_start_closure(t0) {
      this.initialManifest = t0;
    },
    HeroController: function HeroController(t0, t1) {
      this.createRectTween = t0;
      this._flights = t1;
      this._navigator$_navigator = null;
    },
    HeroController__maybeStartHeroTransition_closure: function HeroController__maybeStartHeroTransition_closure(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.$this = t0;
      _.from = t1;
      _.to = t2;
      _.animation = t3;
      _.flightType = t4;
      _.isUserGestureTransition = t5;
    },
    HeroController_closure: function HeroController_closure() {
    },
    IconThemeData_lerp: function(a, b, t) {
      var t4, _null = null,
        t1 = a == null,
        t2 = t1 ? _null : a.color,
        t3 = b == null;
      t2 = P.Color_lerp(t2, t3 ? _null : b.color, t);
      t4 = t1 ? _null : a.get$opacity();
      t4 = P.lerpDouble(t4, t3 ? _null : b.get$opacity(), t);
      t1 = t1 ? _null : a.size;
      return new T.IconThemeData(t2, t4, P.lerpDouble(t1, t3 ? _null : b.size, t));
    },
    IconThemeData: function IconThemeData(t0, t1, t2) {
      this.color = t0;
      this._opacity = t1;
      this.size = t2;
    },
    ModalRoute_of: function(context, $T) {
      var widget = H.interceptedTypeCheck(context.inheritFromWidgetOfExactType$1(C.Type__ModalScopeStatus_sUr), "$is_ModalScopeStatus"),
        t1 = widget == null ? null : widget.route;
      return H.assertSubtype(t1, "$isModalRoute", [$T], "$asModalRoute");
    },
    OverlayRoute: function OverlayRoute() {
    },
    TransitionRoute: function TransitionRoute() {
    },
    TransitionRoute__updateSecondaryAnimation_closure: function TransitionRoute__updateSecondaryAnimation_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.nextRoute = t2;
    },
    LocalHistoryEntry: function LocalHistoryEntry() {
    },
    LocalHistoryRoute: function LocalHistoryRoute() {
    },
    _ModalScopeStatus: function _ModalScopeStatus(t0, t1, t2, t3, t4) {
      var _ = this;
      _.isCurrent = t0;
      _.canPop = t1;
      _.route = t2;
      _.child = t3;
      _.key = t4;
    },
    _ModalScope: function _ModalScope(t0, t1, t2) {
      this.route = t0;
      this.key = t1;
      this.$ti = t2;
    },
    _ModalScopeState: function _ModalScopeState(t0, t1, t2) {
      var _ = this;
      _._listenable = _._page = null;
      _.focusScopeNode = t0;
      _._widget = null;
      _._debugLifecycleState = t1;
      _._element = null;
      _.$ti = t2;
    },
    _ModalScopeState__forceRebuildPage_closure: function _ModalScopeState__forceRebuildPage_closure(t0) {
      this.$this = t0;
    },
    _ModalScopeState_build_closure0: function _ModalScopeState_build_closure0(t0) {
      this.$this = t0;
    },
    _ModalScopeState_build_closure: function _ModalScopeState_build_closure(t0) {
      this.$this = t0;
    },
    ModalRoute: function ModalRoute() {
    },
    ModalRoute_offstage_closure: function ModalRoute_offstage_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    ModalRoute_changedInternalState_closure: function ModalRoute_changedInternalState_closure() {
    },
    _ModalRoute_TransitionRoute_LocalHistoryRoute: function _ModalRoute_TransitionRoute_LocalHistoryRoute() {
    }
  },
  O = {SynchronousFuture: function SynchronousFuture(t0, t1) {
      this._synchronous_future$_value = t0;
      this.$ti = t1;
    }, SynchronousFuture_whenComplete_closure: function SynchronousFuture_whenComplete_closure(t0) {
      this.$this = t0;
    },
    DragUpdateDetails$: function(delta, globalPosition, primaryDelta, sourceTimeStamp) {
      return new O.DragUpdateDetails(delta, primaryDelta, globalPosition);
    },
    DragEndDetails$: function(primaryVelocity, velocity) {
      return new O.DragEndDetails(velocity);
    },
    DragDownDetails: function DragDownDetails(t0) {
      this.globalPosition = t0;
    },
    DragStartDetails: function DragStartDetails(t0) {
      this.globalPosition = t0;
    },
    DragUpdateDetails: function DragUpdateDetails(t0, t1, t2) {
      this.delta = t0;
      this.primaryDelta = t1;
      this.globalPosition = t2;
    },
    DragEndDetails: function DragEndDetails(t0) {
      this.velocity = t0;
    },
    HitTestEntry: function HitTestEntry(t0) {
      this.target = t0;
    },
    HitTestResult: function HitTestResult(t0) {
      this._path = t0;
    },
    _DragState: function _DragState(t0) {
      this._monodrag$_name = t0;
    },
    DragGestureRecognizer: function DragGestureRecognizer() {
    },
    DragGestureRecognizer_addAllowedPointer_closure: function DragGestureRecognizer_addAllowedPointer_closure(t0) {
      this.$this = t0;
    },
    DragGestureRecognizer_handleEvent_closure: function DragGestureRecognizer_handleEvent_closure(t0, t1, t2) {
      this.$this = t0;
      this.event = t1;
      this.delta = t2;
    },
    DragGestureRecognizer_acceptGesture_closure: function DragGestureRecognizer_acceptGesture_closure(t0, t1) {
      this.$this = t0;
      this.timestamp = t1;
    },
    DragGestureRecognizer_acceptGesture_closure0: function DragGestureRecognizer_acceptGesture_closure0(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.timestamp = t2;
    },
    DragGestureRecognizer_didStopTrackingLastPointer_closure: function DragGestureRecognizer_didStopTrackingLastPointer_closure(t0, t1) {
      this.$this = t0;
      this.velocity = t1;
    },
    DragGestureRecognizer_didStopTrackingLastPointer_closure0: function DragGestureRecognizer_didStopTrackingLastPointer_closure0(t0, t1) {
      this.estimate = t0;
      this.velocity = t1;
    },
    DragGestureRecognizer_didStopTrackingLastPointer_closure1: function DragGestureRecognizer_didStopTrackingLastPointer_closure1(t0) {
      this.$this = t0;
    },
    DragGestureRecognizer_didStopTrackingLastPointer_closure2: function DragGestureRecognizer_didStopTrackingLastPointer_closure2(t0) {
      this.estimate = t0;
    },
    VerticalDragGestureRecognizer: function VerticalDragGestureRecognizer(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.dragStartBehavior = t0;
      _.onCancel = _.onEnd = _.onUpdate = _.onStart = _.onDown = null;
      _._monodrag$_state = t1;
      _._lastPendingEventTimestamp = _._pendingDragOffset = _._initialPosition = null;
      _._velocityTrackers = t2;
      _._recognizer$_entries = t3;
      _._trackedPointers = t4;
      _.debugOwner = t5;
      _._kind = t6;
    },
    HorizontalDragGestureRecognizer: function HorizontalDragGestureRecognizer(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.dragStartBehavior = t0;
      _.onCancel = _.onEnd = _.onUpdate = _.onStart = _.onDown = null;
      _._monodrag$_state = t1;
      _._lastPendingEventTimestamp = _._pendingDragOffset = _._initialPosition = null;
      _._velocityTrackers = t2;
      _._recognizer$_entries = t3;
      _._trackedPointers = t4;
      _.debugOwner = t5;
      _._kind = t6;
    },
    PanGestureRecognizer: function PanGestureRecognizer(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.dragStartBehavior = t0;
      _.onCancel = _.onEnd = _.onUpdate = _.onStart = _.onDown = null;
      _._monodrag$_state = t1;
      _._lastPendingEventTimestamp = _._pendingDragOffset = _._initialPosition = null;
      _._velocityTrackers = t2;
      _._recognizer$_entries = t3;
      _._trackedPointers = t4;
      _.debugOwner = t5;
      _._kind = t6;
    },
    PointerRouter: function PointerRouter(t0, t1) {
      this._routeMap = t0;
      this._globalRoutes = t1;
    },
    PointerRouter_addRoute_closure: function PointerRouter_addRoute_closure() {
    },
    PointerRouter__dispatch_closure: function PointerRouter__dispatch_closure(t0) {
      this.event = t0;
    },
    FlutterErrorDetailsForPointerRouter: function FlutterErrorDetailsForPointerRouter(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.exception = t0;
      _.stack = t1;
      _.library = t2;
      _.context = t3;
      _.informationCollector = t4;
      _.silent = t5;
    },
    BoxShadow_lerp: function(a, b, t) {
      var t2, t3,
        t1 = a == null;
      if (t1 && b == null)
        return;
      if (t1)
        return b.scale$1(t);
      if (b == null)
        return a.scale$1(1 - t);
      t1 = P.Color_lerp(a.color, b.color, t);
      t2 = P.Offset_lerp(a.offset, b.offset, t);
      t3 = P.lerpDouble(a.blurRadius, b.blurRadius, t);
      return new O.BoxShadow(P.lerpDouble(a.spreadRadius, b.spreadRadius, t), t1, t2, t3);
    },
    BoxShadow_lerpList: function(a, b, t) {
      var t2, result, commonLength, i, t3, t4, t5, t6,
        t1 = [O.BoxShadow];
      H.assertSubtype(a, "$isList", t1, "$asList");
      H.assertSubtype(b, "$isList", t1, "$asList");
      t2 = a == null;
      if (t2 && b == null)
        return;
      if (t2)
        a = H.setRuntimeTypeInfo([], t1);
      if (b == null)
        b = H.setRuntimeTypeInfo([], t1);
      result = H.setRuntimeTypeInfo([], t1);
      commonLength = Math.min(a.length, b.length);
      for (i = 0; i < commonLength; ++i) {
        if (i >= a.length)
          return H.ioore(a, i);
        t1 = a[i];
        if (i >= b.length)
          return H.ioore(b, i);
        C.JSArray_methods.add$1(result, O.BoxShadow_lerp(t1, b[i], t));
      }
      for (t1 = 1 - t, i = commonLength; t2 = a.length, i < t2; ++i) {
        if (i < 0)
          return H.ioore(a, i);
        t2 = a[i];
        t3 = t2.color;
        t4 = t2.offset;
        t5 = t4._dx;
        if (typeof t5 !== "number")
          return t5.$mul();
        t4 = t4._dy;
        if (typeof t4 !== "number")
          return t4.$mul();
        t6 = t2.blurRadius;
        if (typeof t6 !== "number")
          return t6.$mul();
        t2 = t2.spreadRadius;
        if (typeof t2 !== "number")
          return t2.$mul();
        C.JSArray_methods.add$1(result, new O.BoxShadow(t2 * t1, t3, new P.Offset(t5 * t1, t4 * t1), t6 * t1));
      }
      for (i = commonLength; t1 = b.length, i < t1; ++i) {
        if (i < 0)
          return H.ioore(b, i);
        t1 = b[i];
        t2 = t1.color;
        t3 = t1.offset;
        t4 = t3._dx;
        if (typeof t4 !== "number")
          return t4.$mul();
        t3 = t3._dy;
        if (typeof t3 !== "number")
          return t3.$mul();
        t5 = t1.blurRadius;
        if (typeof t5 !== "number")
          return t5.$mul();
        t1 = t1.spreadRadius;
        if (typeof t1 !== "number")
          return t1.$mul();
        C.JSArray_methods.add$1(result, new O.BoxShadow(t1 * t, t2, new P.Offset(t4 * t, t3 * t), t5 * t));
      }
      return result;
    },
    BoxShadow: function BoxShadow(t0, t1, t2, t3) {
      var _ = this;
      _.spreadRadius = t0;
      _.color = t1;
      _.offset = t2;
      _.blurRadius = t3;
    },
    BoxShadow_toPaint_closure: function BoxShadow_toPaint_closure(t0) {
      this.result = t0;
    },
    KeyHelper_KeyHelper: function(toolkit) {
      if (toolkit === "glfw")
        return new O.GLFWKeyHelper();
      else
        throw H.wrapException(U.FlutterError$("Window toolkit not recognized: " + toolkit));
    },
    RawKeyEventDataLinux: function RawKeyEventDataLinux(t0, t1, t2, t3, t4) {
      var _ = this;
      _.keyHelper = t0;
      _.scanCode = t1;
      _.codePoint = t2;
      _.keyCode = t3;
      _.modifiers = t4;
    },
    KeyHelper: function KeyHelper() {
    },
    GLFWKeyHelper: function GLFWKeyHelper() {
    },
    _GLFWKeyHelper_Object_KeyHelper: function _GLFWKeyHelper_Object_KeyHelper() {
    },
    FocusAttachment: function FocusAttachment(t0) {
      this._node = t0;
    },
    FocusNode: function FocusNode() {
    },
    FocusNode_debugLabel_closure: function FocusNode_debugLabel_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    FocusNode_enclosingScope_closure: function FocusNode_enclosingScope_closure() {
    },
    FocusNode_enclosingScope_closure0: function FocusNode_enclosingScope_closure0() {
    },
    FocusNode_debugDescribeChildren_closure: function FocusNode_debugDescribeChildren_closure(t0) {
      this._box_0 = t0;
    },
    FocusScopeNode: function FocusScopeNode(t0, t1, t2, t3) {
      var _ = this;
      _._focusedChildren = t0;
      _._context = null;
      _._onKey = t1;
      _._parent = _._manager = null;
      _._children = t2;
      _._attachment = _._debugLabel = null;
      _.ChangeNotifier__listeners = t3;
    },
    FocusManager: function FocusManager(t0, t1) {
      var _ = this;
      _.rootScope = t0;
      _._nextFocus = _._currentFocus = null;
      _._dirtyNodes = t1;
      _._haveScheduledUpdate = false;
    },
    FocusManager__handleRawKeyEvent_allNodes: function FocusManager__handleRawKeyEvent_allNodes() {
    },
    _FocusManager_Object_DiagnosticableTreeMixin: function _FocusManager_Object_DiagnosticableTreeMixin() {
    },
    _FocusNode_Object_DiagnosticableTreeMixin: function _FocusNode_Object_DiagnosticableTreeMixin() {
    },
    _FocusNode_Object_DiagnosticableTreeMixin_ChangeNotifier: function _FocusNode_Object_DiagnosticableTreeMixin_ChangeNotifier() {
    }
  },
  V = {AppBarTheme: function AppBarTheme(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.brightness = t0;
      _.color = t1;
      _.elevation = t2;
      _.iconTheme = t3;
      _.actionsIconTheme = t4;
      _.textTheme = t5;
    }, MaterialPageRoute: function MaterialPageRoute(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _.builder = t0;
      _.fullscreenDialog = t1;
      _._routes$_offstage = false;
      _._secondaryAnimationProxy = _._animationProxy = null;
      _._willPopCallbacks = t2;
      _._scopeKey = t3;
      _._subtreeKey = t4;
      _._storageBucket = t5;
      _._modalScopeCache = _._modalBarrier = null;
      _.LocalHistoryRoute__localHistory = t6;
      _._transitionCompleter = t7;
      _._routes$_controller = _._routes$_animation = null;
      _._secondaryAnimation = t8;
      _._result = null;
      _._overlayEntries = t9;
      _._navigator$_navigator = null;
      _.settings = t10;
      _._popCompleter = t11;
      _.$ti = t12;
    }, MaterialPageRoute_buildPage_closure: function MaterialPageRoute_buildPage_closure(t0, t1) {
      this.$this = t0;
      this.result = t1;
    },
    EdgeInsetsGeometry_lerp: function(a, b, t) {
      var t1 = a == null;
      if (t1 && b == null)
        return;
      if (t1)
        return b.$mul(0, t);
      if (b == null)
        return a.$mul(0, 1 - t);
      if (!!a.$isEdgeInsets && !!b.$isEdgeInsets)
        return V.EdgeInsets_lerp(a, b, t);
      if (!!a.$isEdgeInsetsDirectional && !!b.$isEdgeInsetsDirectional)
        return V.EdgeInsetsDirectional_lerp(a, b, t);
      return new V._MixedEdgeInsets(P.lerpDouble(a.get$_left(), b.get$_left(), t), P.lerpDouble(a.get$_right(), b.get$_right(), t), P.lerpDouble(a.get$_edge_insets$_start(), b.get$_edge_insets$_start(), t), P.lerpDouble(a.get$_edge_insets$_end(), b.get$_edge_insets$_end(), t), P.lerpDouble(a.get$_top(), b.get$_top(), t), P.lerpDouble(a.get$_bottom(), b.get$_bottom(), t));
    },
    EdgeInsets$fromWindowPadding: function(padding, devicePixelRatio) {
      return new V.EdgeInsets(padding.left / devicePixelRatio, padding.top / devicePixelRatio, padding.right / devicePixelRatio, padding.bottom / devicePixelRatio);
    },
    EdgeInsets_lerp: function(a, b, t) {
      var t1 = a == null;
      if (t1 && b == null)
        return;
      if (t1)
        return b.$mul(0, t);
      if (b == null)
        return a.$mul(0, 1 - t);
      return new V.EdgeInsets(P.lerpDouble(a.left, b.left, t), P.lerpDouble(a.top, b.top, t), P.lerpDouble(a.right, b.right, t), P.lerpDouble(a.bottom, b.bottom, t));
    },
    EdgeInsetsDirectional_lerp: function(a, b, t) {
      return new V.EdgeInsetsDirectional(P.lerpDouble(a.start, b.start, t), P.lerpDouble(a.top, b.top, t), P.lerpDouble(a.end, b.end, t), P.lerpDouble(a.bottom, b.bottom, t));
    },
    EdgeInsetsGeometry: function EdgeInsetsGeometry() {
    },
    EdgeInsets: function EdgeInsets(t0, t1, t2, t3) {
      var _ = this;
      _.left = t0;
      _.top = t1;
      _.right = t2;
      _.bottom = t3;
    },
    EdgeInsetsDirectional: function EdgeInsetsDirectional(t0, t1, t2, t3) {
      var _ = this;
      _.start = t0;
      _.top = t1;
      _.end = t2;
      _.bottom = t3;
    },
    _MixedEdgeInsets: function _MixedEdgeInsets(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._left = t0;
      _._right = t1;
      _._edge_insets$_start = t2;
      _._edge_insets$_end = t3;
      _._top = t4;
      _._bottom = t5;
    },
    NotchedShape: function NotchedShape() {
    },
    RenderCustomPaint__updateSemanticsChildren: function(oldSemantics, newChildSemantics) {
      var t1, newChildrenBottom, oldChildrenBottom, t2, newChildren, haveOldChildren, oldChild, newSemantics, newChild, oldKeyedChildren, oldChildrenTop, newChildrenTop, _box_0 = {};
      _box_0.newChildSemantics = newChildSemantics;
      t1 = A.SemanticsNode;
      H.assertSubtype(oldSemantics, "$isList", [t1], "$asList");
      H.assertSubtype(newChildSemantics, "$isList", [V.CustomPainterSemantics], "$asList");
      if (oldSemantics == null)
        oldSemantics = C.List_empty2;
      _box_0.newChildSemantics = newChildSemantics == null ? C.List_empty3 : newChildSemantics;
      H.assertHelper(new V.RenderCustomPaint__updateSemanticsChildren_closure(_box_0).call$0());
      newChildrenBottom = J.get$length$asx(_box_0.newChildSemantics) - 1;
      oldChildrenBottom = oldSemantics.length - 1;
      t2 = new Array(J.get$length$asx(_box_0.newChildSemantics));
      t2.fixed$length = Array;
      newChildren = H.setRuntimeTypeInfo(t2, [t1]);
      haveOldChildren = 0 <= oldChildrenBottom;
      t2 = 0 <= newChildrenBottom;
      while (true) {
        if (!(haveOldChildren && t2))
          break;
        if (0 >= oldSemantics.length)
          return H.ioore(oldSemantics, 0);
        oldChild = oldSemantics[0];
        newSemantics = J.$index$asx(_box_0.newChildSemantics, 0);
        oldChild.key;
        newSemantics.get$key();
        break;
      }
      while (true) {
        if (!(haveOldChildren && t2))
          break;
        if (oldChildrenBottom < 0 || oldChildrenBottom >= oldSemantics.length)
          return H.ioore(oldSemantics, oldChildrenBottom);
        oldChild = oldSemantics[oldChildrenBottom];
        newChild = J.$index$asx(_box_0.newChildSemantics, newChildrenBottom);
        oldChild.key;
        newChild.get$key();
        break;
      }
      if (haveOldChildren) {
        oldKeyedChildren = P.LinkedHashMap_LinkedHashMap$_empty(D.Key, t1);
        for (t1 = oldSemantics.length, oldChildrenTop = 0; oldChildrenTop <= oldChildrenBottom;) {
          if (oldChildrenTop >= t1)
            return H.ioore(oldSemantics, oldChildrenTop);
          oldSemantics[oldChildrenTop].key;
          ++oldChildrenTop;
        }
        haveOldChildren = true;
      } else {
        oldChildrenTop = 0;
        oldKeyedChildren = null;
      }
      for (newChildrenTop = 0; newChildrenTop <= newChildrenBottom;) {
        newSemantics = J.$index$asx(_box_0.newChildSemantics, newChildrenTop);
        if (haveOldChildren) {
          oldChild = oldKeyedChildren.$index(0, newSemantics.get$key());
          if (oldChild != null) {
            newSemantics.get$key();
            oldChild = null;
          }
        } else
          oldChild = null;
        t1 = oldChild == null;
        if (!t1) {
          newSemantics.get$key();
          t2 = false;
        } else
          t2 = true;
        H.assertHelper(t2);
        newChild = V.RenderCustomPaint__updateSemanticsChild(oldChild, newSemantics);
        H.assertHelper(J.$eq$(oldChild, newChild) || t1);
        C.JSArray_methods.$indexSet(newChildren, newChildrenTop, newChild);
        ++newChildrenTop;
      }
      H.assertHelper(oldChildrenTop === oldChildrenBottom + 1);
      H.assertHelper(newChildrenTop === newChildrenBottom + 1);
      H.assertHelper(J.get$length$asx(_box_0.newChildSemantics) - newChildrenTop === oldSemantics.length - oldChildrenTop);
      newChildrenBottom = J.get$length$asx(_box_0.newChildSemantics) - 1;
      oldChildrenBottom = oldSemantics.length - 1;
      while (true) {
        if (!(oldChildrenTop <= oldChildrenBottom && newChildrenTop <= newChildrenBottom))
          break;
        if (oldChildrenTop >= oldSemantics.length)
          return H.ioore(oldSemantics, oldChildrenTop);
        oldChild = oldSemantics[oldChildrenTop];
        newSemantics = J.$index$asx(_box_0.newChildSemantics, newChildrenTop);
        oldChild.key;
        newSemantics.get$key();
        H.assertHelper(false);
        newChild = V.RenderCustomPaint__updateSemanticsChild(oldChild, newSemantics);
        H.assertHelper(oldChild === newChild);
        C.JSArray_methods.$indexSet(newChildren, newChildrenTop, newChild);
        ++newChildrenTop;
        ++oldChildrenTop;
      }
      H.assertHelper(new V.RenderCustomPaint__updateSemanticsChildren_closure0(newChildren).call$0());
      return newChildren;
    },
    RenderCustomPaint__updateSemanticsChild: function(oldChild, newSemantics) {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, newChild, properties, config,
        t1 = oldChild == null;
      if (!t1) {
        newSemantics.get$key();
        t2 = false;
      } else
        t2 = true;
      H.assertHelper(t2);
      if (t1) {
        t1 = newSemantics.get$key();
        t2 = $.$get$SemanticsNode__kEmptyConfig();
        t3 = t2._isMergingSemanticsOfDescendants;
        t4 = t2._actions;
        t5 = t2._customSemanticsActions;
        t6 = t2._actionsAsBits;
        t7 = t2._flags;
        t8 = t2._label;
        t9 = t2._semantics$_value;
        t10 = t2._decreasedValue;
        t11 = t2._increasedValue;
        t12 = t2._hint;
        t13 = t2._elevation;
        t14 = t2._thickness;
        t2 = t2._textDirection;
        t15 = ($.SemanticsNode__lastIdentifier + 1) % 65535;
        $.SemanticsNode__lastIdentifier = t15;
        newChild = new A.SemanticsNode(t1, t15, null, C.Rect_0_0_0_0, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t2);
      } else
        newChild = oldChild;
      properties = newSemantics.get$properties();
      t1 = {func: 1, ret: -1};
      config = new A.SemanticsConfiguration(P.LinkedHashMap_LinkedHashMap$_empty(P.SemanticsAction, {func: 1, ret: -1, args: [,]}), P.LinkedHashMap_LinkedHashMap$_empty(A.CustomSemanticsAction, t1));
      properties.get$sortKey();
      config.set$sortKey(properties.get$sortKey());
      properties.get$checked();
      t2 = properties.get$checked();
      config._setFlag$2(C.SemanticsFlag_1, true);
      config._setFlag$2(C.SemanticsFlag_2, t2);
      properties.get$selected();
      config._setFlag$2(C.SemanticsFlag_4, properties.get$selected());
      properties.get$button();
      config._setFlag$2(C.SemanticsFlag_8, properties.get$button());
      properties.get$textField();
      config._setFlag$2(C.SemanticsFlag_16, properties.get$textField());
      properties.get$focused();
      config._setFlag$2(C.SemanticsFlag_32, properties.get$focused());
      properties.get$enabled();
      t2 = properties.get$enabled();
      config._setFlag$2(C.SemanticsFlag_64, true);
      config._setFlag$2(C.SemanticsFlag_128, t2);
      properties.get$inMutuallyExclusiveGroup();
      config._setFlag$2(C.SemanticsFlag_256, properties.get$inMutuallyExclusiveGroup());
      properties.get$obscured();
      config._setFlag$2(C.SemanticsFlag_1024, properties.get$obscured());
      properties.get$hidden();
      config._setFlag$2(C.SemanticsFlag_8192, properties.get$hidden());
      properties.get$header();
      config._setFlag$2(C.SemanticsFlag_512, properties.get$header());
      properties.get$scopesRoute();
      config._setFlag$2(C.SemanticsFlag_2048, properties.get$scopesRoute());
      properties.get$namesRoute();
      config._setFlag$2(C.SemanticsFlag_4096, properties.get$namesRoute());
      properties.get$liveRegion();
      config._setFlag$2(C.SemanticsFlag_32768, properties.get$liveRegion());
      properties.get$toggled();
      t2 = properties.get$toggled();
      config._setFlag$2(C.SemanticsFlag_65536, true);
      config._setFlag$2(C.SemanticsFlag_131072, t2);
      properties.get$image();
      config._setFlag$2(C.SemanticsFlag_16384, properties.get$image());
      properties.get$label();
      config.set$label(properties.get$label());
      properties.get$value();
      config.set$value(properties.get$value());
      properties.get$increasedValue();
      config.set$increasedValue(properties.get$increasedValue());
      properties.get$decreasedValue();
      config.set$decreasedValue(properties.get$decreasedValue());
      properties.get$hint();
      config.set$hint(properties.get$hint());
      properties.get$textDirection();
      config._textDirection = properties.get$textDirection();
      config._hasBeenAnnotated = true;
      properties.get$onTap();
      t2 = H.functionTypeCheck(properties.get$onTap(), t1);
      config._addArgumentlessAction$2(C.SemanticsAction_1, t2);
      config.set$_onTap(t2);
      properties.get$onLongPress();
      t2 = H.functionTypeCheck(properties.get$onLongPress(), t1);
      config._addArgumentlessAction$2(C.SemanticsAction_2, t2);
      config.set$_onLongPress(t2);
      properties.get$onScrollLeft();
      t2 = H.functionTypeCheck(properties.get$onScrollLeft(), t1);
      config._addArgumentlessAction$2(C.SemanticsAction_4, t2);
      config.set$_semantics$_onScrollLeft(t2);
      properties.get$onScrollRight();
      t2 = H.functionTypeCheck(properties.get$onScrollRight(), t1);
      config._addArgumentlessAction$2(C.SemanticsAction_8, t2);
      config.set$_semantics$_onScrollRight(t2);
      properties.get$onScrollUp();
      t2 = H.functionTypeCheck(properties.get$onScrollUp(), t1);
      config._addArgumentlessAction$2(C.SemanticsAction_16, t2);
      config.set$_semantics$_onScrollUp(t2);
      properties.get$onScrollDown();
      t2 = H.functionTypeCheck(properties.get$onScrollDown(), t1);
      config._addArgumentlessAction$2(C.SemanticsAction_32, t2);
      config.set$_semantics$_onScrollDown(t2);
      properties.get$onIncrease();
      t2 = H.functionTypeCheck(properties.get$onIncrease(), t1);
      config._addArgumentlessAction$2(C.SemanticsAction_64, t2);
      config.set$_semantics$_onIncrease(t2);
      properties.get$onDecrease();
      t2 = H.functionTypeCheck(properties.get$onDecrease(), t1);
      config._addArgumentlessAction$2(C.SemanticsAction_128, t2);
      config.set$_semantics$_onDecrease(t2);
      properties.get$onCopy();
      t2 = H.functionTypeCheck(properties.get$onCopy(), t1);
      config._addArgumentlessAction$2(C.SemanticsAction_4096, t2);
      config.set$_semantics$_onCopy(t2);
      properties.get$onCut();
      t2 = H.functionTypeCheck(properties.get$onCut(), t1);
      config._addArgumentlessAction$2(C.SemanticsAction_8192, t2);
      config.set$_semantics$_onCut(t2);
      properties.get$onPaste();
      t2 = H.functionTypeCheck(properties.get$onPaste(), t1);
      config._addArgumentlessAction$2(C.SemanticsAction_16384, t2);
      config.set$_semantics$_onPaste(t2);
      properties.get$onMoveCursorForwardByCharacter();
      config.set$onMoveCursorForwardByCharacter(properties.get$onMoveCursorForwardByCharacter());
      properties.get$onMoveCursorBackwardByCharacter();
      config.set$onMoveCursorBackwardByCharacter(properties.get$onMoveCursorBackwardByCharacter());
      properties.get$onSetSelection();
      config.set$onSetSelection(properties.get$onSetSelection());
      properties.get$onDidGainAccessibilityFocus();
      t2 = H.functionTypeCheck(properties.get$onDidGainAccessibilityFocus(), t1);
      config._addArgumentlessAction$2(C.SemanticsAction_32768, t2);
      config.set$_semantics$_onDidGainAccessibilityFocus(t2);
      properties.get$onDidLoseAccessibilityFocus();
      t2 = H.functionTypeCheck(properties.get$onDidLoseAccessibilityFocus(), t1);
      config._addArgumentlessAction$2(C.SemanticsAction_65536, t2);
      config.set$_semantics$_onDidLoseAccessibilityFocus(t2);
      properties.get$onDismiss();
      t1 = H.functionTypeCheck(properties.get$onDismiss(), t1);
      config._addArgumentlessAction$2(C.SemanticsAction_262144, t1);
      config.set$_semantics$_onDismiss(t1);
      newChild.updateWith$2$childrenInInversePaintOrder$config(C.List_empty2, config);
      newChild.set$rect(newSemantics.get$rect());
      newChild.set$transform(newSemantics.get$transform());
      newChild.set$tags(newSemantics.get$tags());
      return newChild;
    },
    CustomPainter: function CustomPainter() {
    },
    CustomPainterSemantics: function CustomPainterSemantics() {
    },
    RenderCustomPaint: function RenderCustomPaint(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._custom_paint$_painter = t0;
      _._foregroundPainter = t1;
      _._preferredSize = t2;
      _.isComplex = t3;
      _.willChange = t4;
      _._foregroundSemanticsNodes = _._backgroundSemanticsNodes = _._foregroundSemanticsBuilder = _._backgroundSemanticsBuilder = null;
      _.RenderObjectWithChildMixin__child = t5;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderCustomPaint__paintWithPainter_closure: function RenderCustomPaint__paintWithPainter_closure(t0, t1) {
      this._box_0 = t0;
      this.canvas = t1;
    },
    RenderCustomPaint__paintWithPainter_closure0: function RenderCustomPaint__paintWithPainter_closure0(t0, t1, t2) {
      this._box_0 = t0;
      this.canvas = t1;
      this.painter = t2;
    },
    RenderCustomPaint_assembleSemanticsNode_closure: function RenderCustomPaint_assembleSemanticsNode_closure(t0, t1) {
      this.$this = t0;
      this.children = t1;
    },
    RenderCustomPaint__updateSemanticsChildren_closure: function RenderCustomPaint__updateSemanticsChildren_closure(t0) {
      this._box_0 = t0;
    },
    RenderCustomPaint__updateSemanticsChildren_closure0: function RenderCustomPaint__updateSemanticsChildren_closure0(t0) {
      this.newChildren = t0;
    },
    RenderErrorBox$: function(message) {
      var t1 = new V.RenderErrorBox(message);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.RenderErrorBox$1(message);
      return t1;
    },
    RenderErrorBox: function RenderErrorBox(t0) {
      var _ = this;
      _.message = t0;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = _._paragraph = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    SystemSound_play: function(type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1);
      var $async$SystemSound_play = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait(C.OptionalMethodChannel_cWd.invokeMethod$1$2("SystemSound.play", type._system_sound$_name, -1), $async$SystemSound_play);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$SystemSound_play, $async$completer);
    },
    SystemSoundType: function SystemSoundType(t0) {
      this._system_sound$_name = t0;
    },
    PageRoute: function PageRoute() {
    }
  },
  M = {
    ButtonThemeData$: function(alignedDropdown, buttonColor, colorScheme, disabledColor, height, highlightColor, layoutBehavior, materialTapTargetSize, minWidth, padding, shape, splashColor, textTheme) {
      return new M.ButtonThemeData(minWidth, height, textTheme, layoutBehavior, padding, shape, false, buttonColor, disabledColor, highlightColor, splashColor, colorScheme, materialTapTargetSize);
    },
    ButtonTextTheme: function ButtonTextTheme(t0) {
      this._button_theme$_name = t0;
    },
    ButtonBarLayoutBehavior: function ButtonBarLayoutBehavior(t0) {
      this._button_theme$_name = t0;
    },
    ButtonThemeData: function ButtonThemeData(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _.minWidth = t0;
      _.height = t1;
      _.textTheme = t2;
      _.layoutBehavior = t3;
      _._button_theme$_padding = t4;
      _._button_theme$_shape = t5;
      _.alignedDropdown = t6;
      _._buttonColor = t7;
      _._disabledColor = t8;
      _._highlightColor = t9;
      _._splashColor = t10;
      _.colorScheme = t11;
      _._materialTapTargetSize = t12;
    },
    Material$: function(animationDuration, child, clipBehavior, color, elevation, key, shape, textStyle, type) {
      return new M.Material(child, type, elevation, color, textStyle, shape, clipBehavior, animationDuration, key);
    },
    _MaterialState__transparentInterior: function(clipBehavior, contents, context, shape) {
      var child = new M._ShapeBorderPaint(contents, shape, true, null);
      if (clipBehavior === C.Clip_0)
        return child;
      return new T.ClipPath(new E.ShapeBorderClipper(shape, T.Directionality_of(context)), clipBehavior, child, null);
    },
    MaterialType: function MaterialType(t0) {
      this._material$_name = t0;
    },
    Material: function Material(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.child = t0;
      _.type = t1;
      _.elevation = t2;
      _.color = t3;
      _.textStyle = t4;
      _.shape = t5;
      _.clipBehavior = t6;
      _.animationDuration = t7;
      _.key = t8;
    },
    _MaterialState: function _MaterialState(t0, t1, t2) {
      var _ = this;
      _._inkFeatureRenderer = t0;
      _.TickerProviderStateMixin__tickers = t1;
      _._widget = null;
      _._debugLifecycleState = t2;
      _._element = null;
    },
    _MaterialState_build_closure: function _MaterialState_build_closure(t0) {
      this.$this = t0;
    },
    _RenderInkFeatures: function _RenderInkFeatures(t0, t1) {
      var _ = this;
      _.vsync = t0;
      _._inkFeatures = null;
      _.RenderObjectWithChildMixin__child = t1;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    _InkFeatures: function _InkFeatures(t0, t1, t2, t3) {
      var _ = this;
      _.color = t0;
      _.vsync = t1;
      _.child = t2;
      _.key = t3;
    },
    InkFeature: function InkFeature() {
    },
    InkFeature_dispose_closure: function InkFeature_dispose_closure(t0) {
      this.$this = t0;
    },
    ShapeBorderTween: function ShapeBorderTween(t0, t1) {
      this.begin = t0;
      this.end = t1;
    },
    _MaterialInterior: function _MaterialInterior(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _.child = t0;
      _.shape = t1;
      _.borderOnForeground = t2;
      _.clipBehavior = t3;
      _.elevation = t4;
      _.color = t5;
      _.shadowColor = t6;
      _.curve = t7;
      _.duration = t8;
      _.key = t9;
    },
    _MaterialInteriorState: function _MaterialInteriorState(t0, t1) {
      var _ = this;
      _._animation = _._implicit_animations$_controller = _._border = _._shadowColor = _._material$_elevation = null;
      _.SingleTickerProviderStateMixin__ticker = t0;
      _._widget = null;
      _._debugLifecycleState = t1;
      _._element = null;
    },
    _MaterialInteriorState_forEachTween_closure: function _MaterialInteriorState_forEachTween_closure() {
    },
    _MaterialInteriorState_forEachTween_closure0: function _MaterialInteriorState_forEachTween_closure0() {
    },
    _MaterialInteriorState_forEachTween_closure1: function _MaterialInteriorState_forEachTween_closure1() {
    },
    _ShapeBorderPaint: function _ShapeBorderPaint(t0, t1, t2, t3) {
      var _ = this;
      _.child = t0;
      _.shape = t1;
      _.borderOnForeground = t2;
      _.key = t3;
    },
    _ShapeBorderPainter: function _ShapeBorderPainter(t0, t1) {
      this.border = t0;
      this.textDirection = t1;
    },
    __MaterialState_State_TickerProviderStateMixin_dispose_closure: function __MaterialState_State_TickerProviderStateMixin_dispose_closure(t0) {
      this.$this = t0;
    },
    __MaterialState_State_TickerProviderStateMixin: function __MaterialState_State_TickerProviderStateMixin() {
    },
    Scaffold_of: function(context, nullOk) {
      var result;
      H.assertHelper(context != null);
      result = H.interceptedTypeCheck(context.ancestorStateOfType$1(C.C_TypeMatcher3), "$isScaffoldState");
      if (nullOk || result != null)
        return result;
      throw H.wrapException(U.FlutterError$('Scaffold.of() called with a context that does not contain a Scaffold.\nNo Scaffold ancestor could be found starting from the context that was passed to Scaffold.of(). This usually happens when the context provided is from the same StatefulWidget as that whose build function actually creates the Scaffold widget being sought.\nThere are several ways to avoid this problem. The simplest is to use a Builder to get a context that is "under" the Scaffold. For an example of this, please see the documentation for Scaffold.of():\n  https://docs.flutter.io/flutter/material/Scaffold/of.html\nA more efficient solution is to split your build function into several widgets. This introduces a new context from which you can obtain the Scaffold. In this solution, you would have an outer widget that creates the Scaffold populated by instances of your new inner widgets, and then in these inner widgets you would use Scaffold.of().\nA less elegant but more expedient solution is assign a GlobalKey to the Scaffold, then use the key.currentState property to obtain the ScaffoldState rather than using the Scaffold.of() function.\nThe context used was:\n  ' + context.toString$0(0)));
    },
    _ScaffoldSlot: function _ScaffoldSlot(t0) {
      this._scaffold$_name = t0;
    },
    ScaffoldPrelayoutGeometry: function ScaffoldPrelayoutGeometry(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.floatingActionButtonSize = t0;
      _.bottomSheetSize = t1;
      _.contentBottom = t2;
      _.minInsets = t3;
      _.scaffoldSize = t4;
      _.snackBarSize = t5;
      _.textDirection = t6;
    },
    ScaffoldGeometry: function ScaffoldGeometry(t0, t1) {
      this.bottomNavigationBarTop = t0;
      this.floatingActionButtonArea = t1;
    },
    _ScaffoldGeometryNotifier: function _ScaffoldGeometryNotifier(t0, t1) {
      this.floatingActionButtonScale = null;
      this.geometry = t0;
      this.ChangeNotifier__listeners = t1;
    },
    _BodyBoxConstraints: function _BodyBoxConstraints(t0, t1, t2, t3, t4) {
      var _ = this;
      _.bottomWidgetsHeight = t0;
      _.minWidth = t1;
      _.maxWidth = t2;
      _.minHeight = t3;
      _.maxHeight = t4;
    },
    _ScaffoldLayout: function _ScaffoldLayout(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.extendBody = t0;
      _.minInsets = t1;
      _.textDirection = t2;
      _.geometryNotifier = t3;
      _.previousFloatingActionButtonLocation = t4;
      _.currentFloatingActionButtonLocation = t5;
      _.floatingActionButtonMoveAnimationProgress = t6;
      _.floatingActionButtonMotionAnimator = t7;
      _.isSnackBarFloating = t8;
      _._debugChildrenNeedingLayout = _._idToChild = null;
    },
    _FloatingActionButtonTransition: function _FloatingActionButtonTransition(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.child = t0;
      _.fabMoveAnimation = t1;
      _.fabMotionAnimator = t2;
      _.geometryNotifier = t3;
      _.currentController = t4;
      _.key = t5;
    },
    _FloatingActionButtonTransitionState: function _FloatingActionButtonTransitionState(t0, t1) {
      var _ = this;
      _._previousChild = _._currentRotationAnimation = _._extendedCurrentScaleAnimation = _._currentScaleAnimation = _._previousRotationAnimation = _._previousScaleAnimation = _._previousController = null;
      _.TickerProviderStateMixin__tickers = t0;
      _._widget = null;
      _._debugLifecycleState = t1;
      _._element = null;
    },
    _FloatingActionButtonTransitionState__handlePreviousAnimationStatusChanged_closure: function _FloatingActionButtonTransitionState__handlePreviousAnimationStatusChanged_closure(t0, t1) {
      this.$this = t0;
      this.status = t1;
    },
    Scaffold: function Scaffold(t0, t1, t2, t3) {
      var _ = this;
      _.appBar = t0;
      _.body = t1;
      _.floatingActionButton = t2;
      _.key = t3;
    },
    ScaffoldState: function ScaffoldState(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _._drawerKey = t0;
      _._endDrawerKey = t1;
      _._appBarMaxHeight = null;
      _._endDrawerOpened = _._drawerOpened = false;
      _._snackBars = t2;
      _._accessibleNavigation = _._snackBarTimer = null;
      _._dismissedBottomSheets = t3;
      _._floatingActionButtonVisibilityController = _._floatingActionButtonLocation = _._previousFloatingActionButtonLocation = _._floatingActionButtonAnimator = _._floatingActionButtonMoveController = _._currentBottomSheet = null;
      _._primaryScrollController = t4;
      _._geometryNotifier = null;
      _._showBodyScrim = false;
      _._bodyScrimColor = t5;
      _.TickerProviderStateMixin__tickers = t6;
      _._widget = null;
      _._debugLifecycleState = t7;
      _._element = null;
    },
    ScaffoldState_build_closure: function ScaffoldState_build_closure(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.children = t2;
      _._extendBody = t3;
      _.minInsets = t4;
      _.textDirection = t5;
    },
    ScaffoldFeatureController: function ScaffoldFeatureController() {
    },
    _StandardBottomSheet: function _StandardBottomSheet() {
    },
    _ScaffoldScope: function _ScaffoldScope(t0, t1, t2) {
      this.hasDrawer = t0;
      this.child = t1;
      this.key = t2;
    },
    _ScaffoldState_State_TickerProviderStateMixin_dispose_closure: function _ScaffoldState_State_TickerProviderStateMixin_dispose_closure(t0) {
      this.$this = t0;
    },
    __FloatingActionButtonTransitionState_State_TickerProviderStateMixin_dispose_closure: function __FloatingActionButtonTransitionState_State_TickerProviderStateMixin_dispose_closure(t0) {
      this.$this = t0;
    },
    _ScaffoldState_State_TickerProviderStateMixin: function _ScaffoldState_State_TickerProviderStateMixin() {
    },
    __FloatingActionButtonTransitionState_State_TickerProviderStateMixin: function __FloatingActionButtonTransitionState_State_TickerProviderStateMixin() {
    },
    ImageConfiguration: function ImageConfiguration(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.bundle = t0;
      _.devicePixelRatio = t1;
      _.locale = t2;
      _.textDirection = t3;
      _.size = t4;
      _.platform = t5;
    },
    Ticker$: function(_onTick, debugLabel) {
      var t1 = new M.Ticker(_onTick, debugLabel);
      t1.Ticker$2$debugLabel(_onTick, debugLabel);
      return t1;
    },
    Ticker: function Ticker(t0, t1) {
      var _ = this;
      _._future = null;
      _._muted = false;
      _._startTime = null;
      _._onTick = t0;
      _._animationId = null;
      _.debugLabel = t1;
      _._debugCreationStack = null;
    },
    Ticker_closure: function Ticker_closure(t0) {
      this.$this = t0;
    },
    Ticker_start_closure: function Ticker_start_closure(t0) {
      this.$this = t0;
    },
    Ticker_dispose_closure: function Ticker_dispose_closure(t0) {
      this.$this = t0;
    },
    Ticker_toString_closure: function Ticker_toString_closure(t0, t1) {
      this.$this = t0;
      this.buffer = t1;
    },
    Ticker_toString_closure0: function Ticker_toString_closure0(t0, t1, t2) {
      this.$this = t0;
      this.debugIncludeStack = t1;
      this.buffer = t2;
    },
    TickerFuture: function TickerFuture(t0) {
      this._primaryCompleter = t0;
      this._completed = null;
    },
    DecoratedBox$: function(child, decoration, position) {
      return new M.DecoratedBox(decoration, position, child, null);
    },
    Container$: function(alignment, child, color, constraints, decoration, padding, width) {
      var t1, t2, _null = null;
      if (decoration == null)
        t1 = color != null ? S.BoxDecoration$(_null, _null, _null, color, _null, _null, C.BoxShape_0) : _null;
      else
        t1 = decoration;
      if (width != null || false) {
        t2 = constraints == null ? _null : constraints.tighten$2$height$width(_null, width);
        if (t2 == null)
          t2 = S.BoxConstraints$tightFor(_null, width);
      } else
        t2 = constraints;
      return new M.Container(child, alignment, padding, t1, t2, _null);
    },
    DecoratedBox: function DecoratedBox(t0, t1, t2, t3) {
      var _ = this;
      _.decoration = t0;
      _.position = t1;
      _.child = t2;
      _.key = t3;
    },
    Container: function Container(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.child = t0;
      _.alignment = t1;
      _.padding = t2;
      _.decoration = t3;
      _.constraints = t4;
      _.key = t5;
    },
    Feedback_forTap: function(context) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, t1;
      var $async$Feedback_forTap = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          $async$outer:
            switch ($async$goto) {
              case 0:
                // Function start
                context.get$renderObject().sendSemanticsEvent$1(C.TapSemanticEvent_tap);
                switch (K.Theme_of(context).platform) {
                  case C.TargetPlatform_0:
                  case C.TargetPlatform_1:
                    $async$returnValue = V.SystemSound_play(C.SystemSoundType_0);
                    // goto return
                    $async$goto = 1;
                    break $async$outer;
                  default:
                    t1 = new P._Future($.Zone__current, [-1]);
                    t1._asyncComplete$1(null);
                    $async$returnValue = t1;
                    // goto return
                    $async$goto = 1;
                    break $async$outer;
                }
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
      });
      return P._asyncStartSync($async$Feedback_forTap, $async$completer);
    },
    Feedback_forLongPress: function(context) {
      var t1;
      context.get$renderObject().sendSemanticsEvent$1(C.LongPressSemanticsEvent_longPress);
      switch (K.Theme_of(context).platform) {
        case C.TargetPlatform_0:
        case C.TargetPlatform_1:
          return X.HapticFeedback_vibrate();
        default:
          t1 = new P._Future($.Zone__current, [-1]);
          t1._asyncComplete$1(null);
          return t1;
      }
    },
    SystemNavigator_pop: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1);
      var $async$SystemNavigator_pop = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait(C.OptionalMethodChannel_cWd.invokeMethod$1$1("SystemNavigator.pop", -1), $async$SystemNavigator_pop);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$SystemNavigator_pop, $async$completer);
    }
  },
  A = {
    CardTheme$: function(clipBehavior, color, elevation, margin, shape) {
      return new A.CardTheme(clipBehavior, color, elevation, margin, shape);
    },
    CardTheme: function CardTheme(t0, t1, t2, t3, t4) {
      var _ = this;
      _.clipBehavior = t0;
      _.color = t1;
      _.elevation = t2;
      _.margin = t3;
      _.shape = t4;
    },
    ColorScheme$: function(background, brightness, error, onBackground, onError, onPrimary, onSecondary, onSurface, primary, primaryVariant, secondary, secondaryVariant, surface) {
      return new A.ColorScheme(primary, primaryVariant, secondary, secondaryVariant, surface, background, error, onPrimary, onSecondary, onSurface, onBackground, onError, brightness);
    },
    ColorScheme: function ColorScheme(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _.primary = t0;
      _.primaryVariant = t1;
      _.secondary = t2;
      _.secondaryVariant = t3;
      _.surface = t4;
      _.background = t5;
      _.error = t6;
      _.onPrimary = t7;
      _.onSecondary = t8;
      _.onSurface = t9;
      _.onBackground = t10;
      _.onError = t11;
      _.brightness = t12;
    },
    _endOffset: function(scaffoldGeometry) {
      var t2, t3,
        t1 = scaffoldGeometry.textDirection;
      H.assertHelper(t1 != null);
      switch (t1) {
        case C.TextDirection_0:
          t1 = scaffoldGeometry.minInsets.left;
          if (typeof t1 !== "number")
            return H.iae(t1);
          return 16 + t1 - 0;
        case C.TextDirection_1:
          t1 = scaffoldGeometry.scaffoldSize._dx;
          if (typeof t1 !== "number")
            return t1.$sub();
          t2 = scaffoldGeometry.minInsets.right;
          if (typeof t2 !== "number")
            return H.iae(t2);
          t3 = scaffoldGeometry.floatingActionButtonSize._dx;
          if (typeof t3 !== "number")
            return H.iae(t3);
          return t1 - 16 - t2 - t3 + 0;
      }
      return;
    },
    FloatingActionButtonLocation: function FloatingActionButtonLocation() {
    },
    _EndFloatFloatingActionButtonLocation: function _EndFloatFloatingActionButtonLocation() {
    },
    FloatingActionButtonAnimator: function FloatingActionButtonAnimator() {
    },
    _ScalingFabMotionAnimator: function _ScalingFabMotionAnimator() {
    },
    _AnimationSwap: function _AnimationSwap(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.parent = t0;
      _.swapThreshold = t1;
      _.first = t2;
      _.next = t3;
      _._lastValue = _._lastStatus = null;
      _.AnimationLocalStatusListenersMixin__statusListeners = t4;
      _.AnimationLocalListenersMixin__listeners = t5;
      _.AnimationLazyListenerMixin__listenerCounter = t6;
      _.$ti = t7;
    },
    TextStyle$0: function(background, backgroundColor, color, debugLabel, decoration, decorationColor, decorationStyle, decorationThickness, fontFamily, fontFamilyFallback, fontSize, fontStyle, fontWeight, foreground, height, inherit, letterSpacing, locale, $package, shadows, textBaseline, wordSpacing) {
      return new A.TextStyle0(inherit, color, backgroundColor, fontFamily, fontFamilyFallback, $package, fontSize, fontWeight, fontStyle, letterSpacing, wordSpacing, textBaseline, height, locale, foreground, background, decoration, decorationColor, decorationStyle, decorationThickness, debugLabel, shadows);
    },
    TextStyle_lerp: function(a, b, t) {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, _null = null, t1 = {};
      H.assertHelper(t != null);
      t2 = a == null;
      H.assertHelper(t2 || b == null || a.inherit === b.inherit);
      if (t2 && b == null)
        return;
      t1.lerpDebugLabel = null;
      H.assertHelper(new A.TextStyle_lerp_closure(t1, a, t, b).call$0());
      if (t2) {
        t2 = b.inherit;
        t3 = P.Color_lerp(_null, b.color, t);
        t4 = P.Color_lerp(_null, b.backgroundColor, t);
        if (typeof t !== "number")
          return t.$lt();
        t5 = t < 0.5;
        t6 = t5 ? _null : b.fontFamily;
        t7 = t5 ? _null : b.get$fontFamilyFallback();
        t8 = t5 ? _null : b.fontSize;
        t9 = P.FontWeight_lerp(_null, b.fontWeight, t);
        t10 = t5 ? _null : b.fontStyle;
        t11 = t5 ? _null : b.letterSpacing;
        t12 = t5 ? _null : b.wordSpacing;
        t13 = t5 ? _null : b.textBaseline;
        t14 = t5 ? _null : b.height;
        t15 = t5 ? _null : b.locale;
        t16 = t5 ? _null : b.foreground;
        t17 = t5 ? _null : b.background;
        t18 = t5 ? _null : b.decoration;
        t19 = t5 ? _null : b.shadows;
        t20 = P.Color_lerp(_null, b.decorationColor, t);
        t21 = t5 ? _null : b.decorationStyle;
        t5 = t5 ? _null : b.decorationThickness;
        return A.TextStyle$0(t17, t4, t3, t1.lerpDebugLabel, t18, t20, t21, t5, t6, t7, t8, t10, t9, t16, t14, t2, t11, t15, _null, t19, t13, t12);
      }
      if (b == null) {
        t2 = a.inherit;
        t3 = P.Color_lerp(a.color, _null, t);
        t4 = P.Color_lerp(_null, a.backgroundColor, t);
        if (typeof t !== "number")
          return t.$lt();
        t5 = t < 0.5;
        t6 = t5 ? a.fontFamily : _null;
        t7 = t5 ? a.get$fontFamilyFallback() : _null;
        t8 = t5 ? a.fontSize : _null;
        t9 = P.FontWeight_lerp(a.fontWeight, _null, t);
        t10 = t5 ? a.fontStyle : _null;
        t11 = t5 ? a.letterSpacing : _null;
        t12 = t5 ? a.wordSpacing : _null;
        t13 = t5 ? a.textBaseline : _null;
        t14 = t5 ? a.height : _null;
        t15 = t5 ? a.locale : _null;
        t16 = t5 ? a.foreground : _null;
        t17 = t5 ? a.background : _null;
        t18 = t5 ? a.shadows : _null;
        t19 = t5 ? a.decoration : _null;
        t20 = P.Color_lerp(a.decorationColor, _null, t);
        t21 = t5 ? a.decorationStyle : _null;
        t5 = t5 ? a.decorationThickness : _null;
        return A.TextStyle$0(t17, t4, t3, t1.lerpDebugLabel, t19, t20, t21, t5, t6, t7, t8, t10, t9, t16, t14, t2, t11, t15, _null, t18, t13, t12);
      }
      t2 = b.inherit;
      t3 = a.foreground;
      t4 = t3 == null;
      t5 = t4 && b.foreground == null ? P.Color_lerp(a.color, b.color, t) : _null;
      t6 = a.background;
      t7 = t6 == null;
      t8 = t7 && b.background == null ? P.Color_lerp(a.backgroundColor, b.backgroundColor, t) : _null;
      if (typeof t !== "number")
        return t.$lt();
      t9 = t < 0.5;
      t10 = t9 ? a.fontFamily : b.fontFamily;
      t11 = t9 ? a.get$fontFamilyFallback() : b.get$fontFamilyFallback();
      t12 = a.fontSize;
      t13 = t12 == null ? b.fontSize : t12;
      t14 = b.fontSize;
      t12 = P.lerpDouble(t13, t14 == null ? t12 : t14, t);
      t13 = P.FontWeight_lerp(a.fontWeight, b.fontWeight, t);
      t14 = t9 ? a.fontStyle : b.fontStyle;
      t15 = a.letterSpacing;
      t16 = t15 == null ? b.letterSpacing : t15;
      t17 = b.letterSpacing;
      t15 = P.lerpDouble(t16, t17 == null ? t15 : t17, t);
      t16 = a.wordSpacing;
      t17 = t16 == null ? b.wordSpacing : t16;
      t18 = b.wordSpacing;
      t16 = P.lerpDouble(t17, t18 == null ? t16 : t18, t);
      t17 = t9 ? a.textBaseline : b.textBaseline;
      t18 = a.height;
      t19 = t18 == null ? b.height : t18;
      t20 = b.height;
      t18 = P.lerpDouble(t19, t20 == null ? t18 : t20, t);
      t19 = t9 ? a.locale : b.locale;
      if (!t4 || b.foreground != null)
        if (t9) {
          if (t4) {
            t3 = new P.Paint(new DataView(new ArrayBuffer(75)));
            t3.set$color(a.color);
          }
        } else {
          t3 = b.foreground;
          if (t3 == null) {
            t3 = new P.Paint(new DataView(new ArrayBuffer(75)));
            t3.set$color(b.color);
          }
        }
      else
        t3 = _null;
      if (!t7 || b.background != null)
        if (t9)
          if (t7) {
            t4 = new P.Paint(new DataView(new ArrayBuffer(75)));
            t4.set$color(a.backgroundColor);
          } else
            t4 = t6;
        else {
          t4 = b.background;
          if (t4 == null) {
            t4 = new P.Paint(new DataView(new ArrayBuffer(75)));
            t4.set$color(b.backgroundColor);
          }
        }
      else
        t4 = _null;
      t6 = t9 ? a.shadows : b.shadows;
      t7 = t9 ? a.decoration : b.decoration;
      t20 = P.Color_lerp(a.decorationColor, b.decorationColor, t);
      t9 = t9 ? a.decorationStyle : b.decorationStyle;
      t21 = a.decorationThickness;
      t22 = t21 == null ? b.decorationThickness : t21;
      t23 = b.decorationThickness;
      t21 = P.lerpDouble(t22, t23 == null ? t21 : t23, t);
      return A.TextStyle$0(t4, t8, t5, t1.lerpDebugLabel, t7, t20, t9, t21, t10, t11, t12, t14, t13, t3, t18, t2, t15, t19, _null, t6, t17, t16);
    },
    TextStyle0: function TextStyle0(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21) {
      var _ = this;
      _.inherit = t0;
      _.color = t1;
      _.backgroundColor = t2;
      _.fontFamily = t3;
      _._text_style$_fontFamilyFallback = t4;
      _._package = t5;
      _.fontSize = t6;
      _.fontWeight = t7;
      _.fontStyle = t8;
      _.letterSpacing = t9;
      _.wordSpacing = t10;
      _.textBaseline = t11;
      _.height = t12;
      _.locale = t13;
      _.foreground = t14;
      _.background = t15;
      _.decoration = t16;
      _.decorationColor = t17;
      _.decorationStyle = t18;
      _.decorationThickness = t19;
      _.debugLabel = t20;
      _.shadows = t21;
    },
    TextStyle_copyWith_closure: function TextStyle_copyWith_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.debugLabel = t2;
    },
    TextStyle_apply_closure: function TextStyle_apply_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    TextStyle_merge_closure: function TextStyle_merge_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.other = t2;
    },
    TextStyle_lerp_closure: function TextStyle_lerp_closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.a = t1;
      _.t = t2;
      _.b = t3;
    },
    TextStyle_debugFillProperties_closure: function TextStyle_debugFillProperties_closure() {
    },
    ViewConfiguration: function ViewConfiguration(t0, t1) {
      this.size = t0;
      this.devicePixelRatio = t1;
    },
    RenderView: function RenderView(t0, t1, t2, t3) {
      var _ = this;
      _._view$_size = t0;
      _._view$_configuration = t1;
      _._window = t2;
      _._rootTransform = null;
      _.RenderObjectWithChildMixin__child = t3;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderView_debugFillProperties_closure: function RenderView_debugFillProperties_closure(t0) {
      this.properties = t0;
    },
    _RenderView_RenderObject_RenderObjectWithChildMixin: function _RenderView_RenderObject_RenderObjectWithChildMixin() {
    },
    CustomSemanticsAction_getIdentifier: function(action) {
      var result = $.CustomSemanticsAction__ids.$index(0, action);
      if (result == null) {
        result = $.CustomSemanticsAction__nextId;
        $.CustomSemanticsAction__nextId = result + 1;
        $.CustomSemanticsAction__ids.$indexSet(0, action, result);
        $.CustomSemanticsAction__actions.$indexSet(0, result, action);
      }
      return result;
    },
    SemanticsData__sortedListsEqual: function(left, right) {
      var i,
        t1 = [P.int];
      H.assertSubtype(left, "$isList", t1, "$asList");
      H.assertSubtype(right, "$isList", t1, "$asList");
      if (left.length !== right.length)
        return false;
      for (i = 0; i < left.length; ++i) {
        t1 = left[i];
        if (i >= right.length)
          return H.ioore(right, i);
        if (!J.$eq$(t1, right[i]))
          return false;
      }
      return true;
    },
    _pointInParentCoordinates: function(node, point) {
      var t1, vector;
      if (node._semantics$_transform == null)
        return point;
      t1 = new Float64Array(3);
      vector = new E.Vector3(t1);
      vector.setValues$3(point._dx, point._dy, 0);
      node._semantics$_transform.transform3$1(vector);
      return new P.Offset(t1[0], t1[1]);
    },
    _childrenInDefaultOrder: function(children, textDirection) {
      var edges, t2, _i, child, t3, t4, t5, t6, verticalGroups, group, depth, edge, result,
        t1 = [A.SemanticsNode];
      H.assertSubtype(children, "$isList", t1, "$asList");
      edges = H.setRuntimeTypeInfo([], [A._BoxEdge]);
      for (t2 = children.length, _i = 0; _i < children.length; children.length === t2 || (0, H.throwConcurrentModificationError)(children), ++_i) {
        child = children[_i];
        t3 = child._semantics$_rect;
        t4 = t3.left;
        if (typeof t4 !== "number")
          return t4.$sub();
        t5 = t3.top;
        if (typeof t5 !== "number")
          return t5.$sub();
        t6 = t3.right;
        if (typeof t6 !== "number")
          return t6.$add();
        t3 = t3.bottom;
        if (typeof t3 !== "number")
          return t3.$add();
        C.JSArray_methods.add$1(edges, new A._BoxEdge(true, A._pointInParentCoordinates(child, new P.Offset(t4 - -0.1, t5 - -0.1))._dy, child));
        C.JSArray_methods.add$1(edges, new A._BoxEdge(false, A._pointInParentCoordinates(child, new P.Offset(t6 + -0.1, t3 + -0.1))._dy, child));
      }
      C.JSArray_methods.sort$0(edges);
      verticalGroups = H.setRuntimeTypeInfo([], [A._SemanticsSortGroup]);
      for (t2 = edges.length, group = null, depth = 0, _i = 0; _i < edges.length; edges.length === t2 || (0, H.throwConcurrentModificationError)(edges), ++_i) {
        edge = edges[_i];
        if (edge.isLeadingEdge) {
          ++depth;
          if (group == null)
            group = new A._SemanticsSortGroup(edge.offset, textDirection, H.setRuntimeTypeInfo([], t1));
          C.JSArray_methods.add$1(group.nodes, edge.node);
        } else
          --depth;
        if (depth === 0) {
          C.JSArray_methods.add$1(verticalGroups, group);
          group = null;
        }
      }
      C.JSArray_methods.sort$0(verticalGroups);
      result = H.setRuntimeTypeInfo([], t1);
      for (t1 = verticalGroups.length, _i = 0; _i < verticalGroups.length; verticalGroups.length === t1 || (0, H.throwConcurrentModificationError)(verticalGroups), ++_i)
        C.JSArray_methods.addAll$1(result, verticalGroups[_i].sortedWithinVerticalGroup$0());
      return result;
    },
    SemanticsConfiguration$: function() {
      return new A.SemanticsConfiguration(P.LinkedHashMap_LinkedHashMap$_empty(P.SemanticsAction, {func: 1, ret: -1, args: [,]}), P.LinkedHashMap_LinkedHashMap$_empty(A.CustomSemanticsAction, {func: 1, ret: -1}));
    },
    _concatStrings: function(otherString, otherTextDirection, thisString, thisTextDirection) {
      var nestedLabel;
      if (otherString.length === 0)
        return thisString;
      if (thisTextDirection != otherTextDirection && otherTextDirection != null)
        switch (otherTextDirection) {
          case C.TextDirection_0:
            nestedLabel = "\u202b" + otherString + "\u202c";
            break;
          case C.TextDirection_1:
            nestedLabel = "\u202a" + otherString + "\u202c";
            break;
          default:
            nestedLabel = otherString;
        }
      else
        nestedLabel = otherString;
      if (thisString.length === 0)
        return nestedLabel;
      return thisString + "\n" + nestedLabel;
    },
    SemanticsTag: function SemanticsTag() {
    },
    CustomSemanticsAction: function CustomSemanticsAction() {
    },
    SemanticsData: function SemanticsData(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20) {
      var _ = this;
      _.flags = t0;
      _.actions = t1;
      _.label = t2;
      _.value = t3;
      _.increasedValue = t4;
      _.decreasedValue = t5;
      _.hint = t6;
      _.textDirection = t7;
      _.textSelection = t8;
      _.scrollChildCount = t9;
      _.scrollIndex = t10;
      _.scrollPosition = t11;
      _.scrollExtentMax = t12;
      _.scrollExtentMin = t13;
      _.platformViewId = t14;
      _.rect = t15;
      _.tags = t16;
      _.transform = t17;
      _.elevation = t18;
      _.thickness = t19;
      _.customSemanticsActionIds = t20;
    },
    SemanticsData_debugFillProperties_closure: function SemanticsData_debugFillProperties_closure() {
    },
    _SemanticsDiagnosticableNode: function _SemanticsDiagnosticableNode(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.childOrder = t0;
      _.value = t1;
      _._cachedBuilder = null;
      _.name = t2;
      _.showSeparator = t3;
      _.showName = t4;
      _.style = t5;
    },
    SemanticsHintOverrides: function SemanticsHintOverrides() {
    },
    SemanticsProperties: function SemanticsProperties(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40) {
      var _ = this;
      _.enabled = t0;
      _.checked = t1;
      _.toggled = t2;
      _.selected = t3;
      _.button = t4;
      _.header = t5;
      _.textField = t6;
      _.focused = t7;
      _.inMutuallyExclusiveGroup = t8;
      _.hidden = t9;
      _.obscured = t10;
      _.scopesRoute = t11;
      _.namesRoute = t12;
      _.image = t13;
      _.liveRegion = t14;
      _.label = t15;
      _.value = t16;
      _.increasedValue = t17;
      _.decreasedValue = t18;
      _.hint = t19;
      _.hintOverrides = t20;
      _.textDirection = t21;
      _.sortKey = t22;
      _.onTap = t23;
      _.onLongPress = t24;
      _.onScrollLeft = t25;
      _.onScrollRight = t26;
      _.onScrollUp = t27;
      _.onScrollDown = t28;
      _.onIncrease = t29;
      _.onDecrease = t30;
      _.onCopy = t31;
      _.onCut = t32;
      _.onPaste = t33;
      _.onMoveCursorForwardByCharacter = t34;
      _.onMoveCursorBackwardByCharacter = t35;
      _.onSetSelection = t36;
      _.onDidGainAccessibilityFocus = t37;
      _.onDidLoseAccessibilityFocus = t38;
      _.onDismiss = t39;
      _.customSemanticsActions = t40;
    },
    SemanticsNode: function SemanticsNode(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16) {
      var _ = this;
      _.key = t0;
      _.id = t1;
      _._showOnScreen = t2;
      _._semantics$_transform = null;
      _._semantics$_rect = t3;
      _.indexInParent = _.elevationAdjustment = _.parentPaintClipRect = _.parentSemanticsClipRect = null;
      _._isMergedIntoParent = false;
      _._mergeAllDescendantsIntoThisNode = t4;
      _._debugPreviousSnapshot = _._semantics$_children = null;
      _._semantics$_dirty = _._dead = false;
      _._actions = t5;
      _._customSemanticsActions = t6;
      _._actionsAsBits = t7;
      _.tags = null;
      _._flags = t8;
      _._label = t9;
      _._semantics$_value = t10;
      _._decreasedValue = t11;
      _._increasedValue = t12;
      _._hint = t13;
      _._elevation = t14;
      _._thickness = t15;
      _._hintOverrides = null;
      _._textDirection = t16;
      _._platformViewId = _._scrollExtentMin = _._scrollExtentMax = _._scrollPosition = _._scrollIndex = _._scrollChildCount = _._textSelection = _._sortKey = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    SemanticsNode__replaceChildren_closure: function SemanticsNode__replaceChildren_closure(t0) {
      this.$this = t0;
    },
    SemanticsNode__replaceChildren_closure0: function SemanticsNode__replaceChildren_closure0(t0, t1) {
      this.$this = t0;
      this.newChildren = t1;
    },
    SemanticsNode__replaceChildren__closure: function SemanticsNode__replaceChildren__closure() {
    },
    SemanticsNode__replaceChildren__closure0: function SemanticsNode__replaceChildren__closure0(t0) {
      this._box_0 = t0;
    },
    SemanticsNode__replaceChildren_closure1: function SemanticsNode__replaceChildren_closure1(t0) {
      this.newChildren = t0;
    },
    SemanticsNode_getSemanticsData_closure: function SemanticsNode_getSemanticsData_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.customSemanticsActionIds = t2;
    },
    SemanticsNode__childrenInTraversalOrder_closure: function SemanticsNode__childrenInTraversalOrder_closure() {
    },
    SemanticsNode_debugFillProperties_closure: function SemanticsNode_debugFillProperties_closure() {
    },
    SemanticsNode_debugFillProperties_closure0: function SemanticsNode_debugFillProperties_closure0() {
    },
    SemanticsNode_debugFillProperties_closure1: function SemanticsNode_debugFillProperties_closure1() {
    },
    SemanticsNode_debugFillProperties_closure2: function SemanticsNode_debugFillProperties_closure2(t0) {
      this.$this = t0;
    },
    SemanticsNode_debugFillProperties_closure3: function SemanticsNode_debugFillProperties_closure3() {
    },
    SemanticsNode_debugDescribeChildren_closure: function SemanticsNode_debugDescribeChildren_closure(t0) {
      this.childOrder = t0;
    },
    _BoxEdge: function _BoxEdge(t0, t1, t2) {
      this.isLeadingEdge = t0;
      this.offset = t1;
      this.node = t2;
    },
    _SemanticsSortGroup: function _SemanticsSortGroup(t0, t1, t2) {
      this.startOffset = t0;
      this.textDirection = t1;
      this.nodes = t2;
    },
    _SemanticsSortGroup_sortedWithinKnot_closure: function _SemanticsSortGroup_sortedWithinKnot_closure() {
    },
    _SemanticsSortGroup_sortedWithinKnot_search: function _SemanticsSortGroup_sortedWithinKnot_search(t0, t1, t2) {
      this.visitedIds = t0;
      this.edges = t1;
      this.sortedIds = t2;
    },
    _SemanticsSortGroup_sortedWithinKnot_closure0: function _SemanticsSortGroup_sortedWithinKnot_closure0() {
    },
    _SemanticsSortGroup_sortedWithinKnot_closure1: function _SemanticsSortGroup_sortedWithinKnot_closure1(t0) {
      this.nodeMap = t0;
    },
    _TraversalSortNode: function _TraversalSortNode(t0, t1, t2) {
      this.node = t0;
      this.sortKey = t1;
      this.position = t2;
    },
    SemanticsOwner: function SemanticsOwner() {
    },
    SemanticsOwner_sendSemanticsUpdate_closure: function SemanticsOwner_sendSemanticsUpdate_closure(t0) {
      this.$this = t0;
    },
    SemanticsOwner_sendSemanticsUpdate_closure0: function SemanticsOwner_sendSemanticsUpdate_closure0() {
    },
    SemanticsOwner_sendSemanticsUpdate_closure1: function SemanticsOwner_sendSemanticsUpdate_closure1() {
    },
    SemanticsOwner__getSemanticsActionHandlerForId_closure: function SemanticsOwner__getSemanticsActionHandlerForId_closure(t0, t1) {
      this._box_0 = t0;
      this.action = t1;
    },
    SemanticsConfiguration: function SemanticsConfiguration(t0, t1) {
      var _ = this;
      _._hasBeenAnnotated = _.isBlockingSemanticsOfPreviouslyPaintedNodes = _.explicitChildNodes = _._isSemanticBoundary = false;
      _._actions = t0;
      _._actionsAsBits = 0;
      _._platformViewId = _._scrollIndex = _._scrollChildCount = _._indexInParent = _._sortKey = _._onLongPress = _._onTap = null;
      _._isMergingSemanticsOfDescendants = false;
      _._customSemanticsActions = t1;
      _._hint = _._increasedValue = _._decreasedValue = _._semantics$_value = _._label = "";
      _._hintOverrides = null;
      _._thickness = _._elevation = 0;
      _._tagsForChildren = _._scrollExtentMin = _._scrollExtentMax = _._scrollPosition = _._textSelection = _._textDirection = null;
      _._flags = 0;
    },
    SemanticsConfiguration__addArgumentlessAction_closure: function SemanticsConfiguration__addArgumentlessAction_closure(t0) {
      this.handler = t0;
    },
    SemanticsConfiguration_onMoveCursorForwardByCharacter_closure: function SemanticsConfiguration_onMoveCursorForwardByCharacter_closure(t0) {
      this.value = t0;
    },
    SemanticsConfiguration_onMoveCursorBackwardByCharacter_closure: function SemanticsConfiguration_onMoveCursorBackwardByCharacter_closure(t0) {
      this.value = t0;
    },
    SemanticsConfiguration_onSetSelection_closure: function SemanticsConfiguration_onSetSelection_closure(t0) {
      this.value = t0;
    },
    DebugSemanticsDumpOrder: function DebugSemanticsDumpOrder(t0) {
      this._semantics$_name = t0;
    },
    SemanticsSortKey: function SemanticsSortKey() {
    },
    _SemanticsNode_AbstractNode_DiagnosticableTreeMixin: function _SemanticsNode_AbstractNode_DiagnosticableTreeMixin() {
    },
    BasicMessageChannel: function BasicMessageChannel(t0, t1, t2) {
      this.name = t0;
      this.codec = t1;
      this.$ti = t2;
    },
    BasicMessageChannel_setMessageHandler_closure: function BasicMessageChannel_setMessageHandler_closure(t0, t1) {
      this.$this = t0;
      this.handler = t1;
    },
    MethodChannel: function MethodChannel(t0, t1) {
      this.name = t0;
      this.codec = t1;
    },
    MethodChannel_setMethodCallHandler_closure: function MethodChannel_setMethodCallHandler_closure(t0, t1) {
      this.$this = t0;
      this.handler = t1;
    },
    OptionalMethodChannel: function OptionalMethodChannel(t0, t1) {
      this.name = t0;
      this.codec = t1;
    },
    BannerLocation: function BannerLocation(t0) {
      this._banner$_name = t0;
    },
    BannerPainter: function BannerPainter(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.message = t0;
      _.textDirection = t1;
      _.location = t2;
      _.layoutDirection = t3;
      _.color = t4;
      _.textStyle = t5;
      _._prepared = false;
      _._paintBanner = _._paintShadow = _._textPainter = null;
    },
    Banner: function Banner(t0, t1, t2, t3, t4) {
      var _ = this;
      _.child = t0;
      _.message = t1;
      _.textDirection = t2;
      _.location = t3;
      _.key = t4;
    },
    CheckedModeBanner: function CheckedModeBanner(t0, t1) {
      this.child = t0;
      this.key = t1;
    },
    CheckedModeBanner_build_closure: function CheckedModeBanner_build_closure(t0) {
      this._box_0 = t0;
    },
    CheckedModeBanner_debugFillProperties_closure: function CheckedModeBanner_debugFillProperties_closure(t0) {
      this._box_0 = t0;
    },
    ScrollPosition: function ScrollPosition() {
    },
    _ScrollPosition_ViewportOffset_ScrollMetrics: function _ScrollPosition_ViewportOffset_ScrollMetrics() {
    },
    hashObjects: function(objects) {
      var hash,
        t1 = C.NativeFloat64List_methods.fold$1$2(H.assertSubtype(objects, "$isIterable", [P.Object], "$asIterable"), 0, new A.hashObjects_closure(), P.int);
      if (typeof t1 !== "number")
        return H.iae(t1);
      hash = 536870911 & t1 + ((67108863 & t1) << 3);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    },
    hashObjects_closure: function hashObjects_closure() {
    }
  },
  Q = {
    SliderThemeData$: function(activeTickMarkColor, activeTrackColor, disabledActiveTickMarkColor, disabledActiveTrackColor, disabledInactiveTickMarkColor, disabledInactiveTrackColor, disabledThumbColor, inactiveTickMarkColor, inactiveTrackColor, overlayColor, overlayShape, showValueIndicator, thumbColor, thumbShape, tickMarkShape, trackHeight, trackShape, valueIndicatorColor, valueIndicatorShape, valueIndicatorTextStyle) {
      return new Q.SliderThemeData(trackHeight, activeTrackColor, inactiveTrackColor, disabledActiveTrackColor, disabledInactiveTrackColor, activeTickMarkColor, inactiveTickMarkColor, disabledActiveTickMarkColor, disabledInactiveTickMarkColor, thumbColor, disabledThumbColor, overlayColor, valueIndicatorColor, trackShape, tickMarkShape, overlayShape, thumbShape, valueIndicatorShape, showValueIndicator, valueIndicatorTextStyle);
    },
    ShowValueIndicator: function ShowValueIndicator(t0) {
      this._slider_theme$_name = t0;
    },
    SliderThemeData: function SliderThemeData(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19) {
      var _ = this;
      _.trackHeight = t0;
      _.activeTrackColor = t1;
      _.inactiveTrackColor = t2;
      _.disabledActiveTrackColor = t3;
      _.disabledInactiveTrackColor = t4;
      _.activeTickMarkColor = t5;
      _.inactiveTickMarkColor = t6;
      _.disabledActiveTickMarkColor = t7;
      _.disabledInactiveTickMarkColor = t8;
      _.thumbColor = t9;
      _.disabledThumbColor = t10;
      _.overlayColor = t11;
      _.valueIndicatorColor = t12;
      _.trackShape = t13;
      _.tickMarkShape = t14;
      _.overlayShape = t15;
      _.thumbShape = t16;
      _.valueIndicatorShape = t17;
      _.showValueIndicator = t18;
      _.valueIndicatorTextStyle = t19;
    },
    SliderTrackShape: function SliderTrackShape() {
    },
    SliderTickMarkShape: function SliderTickMarkShape() {
    },
    SliderComponentShape: function SliderComponentShape() {
    },
    BaseSliderTrackShape: function BaseSliderTrackShape() {
    },
    RoundedRectSliderTrackShape: function RoundedRectSliderTrackShape() {
    },
    RoundSliderTickMarkShape: function RoundSliderTickMarkShape() {
    },
    RoundSliderThumbShape: function RoundSliderThumbShape() {
    },
    RoundSliderOverlayShape: function RoundSliderOverlayShape() {
    },
    PaddleSliderValueIndicatorShape: function PaddleSliderValueIndicatorShape() {
    },
    _RoundedRectSliderTrackShape_SliderTrackShape_BaseSliderTrackShape: function _RoundedRectSliderTrackShape_SliderTrackShape_BaseSliderTrackShape() {
    },
    TextSpan$: function(children, style, text) {
      return new Q.TextSpan(style, text, children);
    },
    TextSpan: function TextSpan(t0, t1, t2) {
      this.style = t0;
      this.text = t1;
      this.children = t2;
    },
    TextSpan_toPlainText_closure: function TextSpan_toPlainText_closure(t0, t1) {
      this.includeSemanticsLabels = t0;
      this.buffer = t1;
    },
    TextSpan_debugAssertIsValid_closure: function TextSpan_debugAssertIsValid_closure(t0) {
      this.$this = t0;
    },
    TextSpan_debugAssertIsValid__closure: function TextSpan_debugAssertIsValid__closure() {
    },
    TextSpan_debugDescribeChildren_closure: function TextSpan_debugDescribeChildren_closure() {
    },
    TextOverflow: function TextOverflow(t0) {
      this._paragraph$_name = t0;
    },
    RenderParagraph: function RenderParagraph(t0, t1, t2, t3, t4) {
      var _ = this;
      _._paragraph$_textPainter = t0;
      _._softWrap = t1;
      _._paragraph$_overflow = t2;
      _._needsClipping = false;
      _._overflowShader = null;
      _._recognizerOffsets = t3;
      _._paragraph$_recognizers = t4;
      _._cachedBaselines = _._size = _._cachedIntrinsicDimensions = null;
      _._debugActivePointers = 0;
      _.debugCreator = _.parentData = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _._layer = null;
      _._needsCompositingBitsUpdate = false;
      _._needsCompositing = null;
      _._needsPaint = true;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
      _._node$_depth = 0;
      _._node$_parent = _._node$_owner = null;
    },
    RenderParagraph_paint_closure: function RenderParagraph_paint_closure(t0, t1, t2) {
      this.$this = t0;
      this.canvas = t1;
      this.offset = t2;
    },
    RenderParagraph_describeSemanticsConfiguration_closure: function RenderParagraph_describeSemanticsConfiguration_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    RenderParagraph_assembleSemanticsNode_buildSemanticsConfig: function RenderParagraph_assembleSemanticsNode_buildSemanticsConfig(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.rawLabel = t2;
    },
    AssetBundle__utf8decode: function(data) {
      var t1 = H.interceptedTypeCheck(data, "$isByteData").buffer;
      t1.toString;
      return C.C_Utf8Codec.decode$1(H.NativeUint8List_NativeUint8List$view(t1, 0, null));
    },
    AssetBundle: function AssetBundle() {
    },
    CachingAssetBundle: function CachingAssetBundle() {
    },
    PlatformAssetBundle: function PlatformAssetBundle(t0, t1) {
      this._stringCache = t0;
      this._structuredDataCache = t1;
    },
    RawKeyEventDataAndroid: function RawKeyEventDataAndroid(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.flags = t0;
      _.codePoint = t1;
      _.plainCodePoint = t2;
      _.keyCode = t3;
      _.scanCode = t4;
      _.metaState = t5;
    },
    RawKeyEventDataAndroid_getModifierSide_findSide: function RawKeyEventDataAndroid_getModifierSide_findSide(t0) {
      this.$this = t0;
    },
    RawKeyEventDataFuchsia: function RawKeyEventDataFuchsia(t0, t1, t2) {
      this.hidUsage = t0;
      this.codePoint = t1;
      this.modifiers = t2;
    },
    RawKeyEventDataFuchsia_getModifierSide_findSide: function RawKeyEventDataFuchsia_getModifierSide_findSide(t0) {
      this.$this = t0;
    },
    SafeArea$: function(child, $top) {
      return new Q.SafeArea($top, child, null);
    },
    SafeArea: function SafeArea(t0, t1, t2) {
      this.top = t0;
      this.child = t1;
      this.key = t2;
    }
  };
  var holders = [C, H, J, P, W, Y, X, G, S, Z, R, L, D, K, U, N, B, E, F, T, O, V, M, A, Q];
  hunkHelpers.setFunctionNamesIfNecessary(holders);
  var $ = {};
  H.JS_CONST.prototype = {};
  J.Interceptor.prototype = {
    $eq: function(receiver, other) {
      return receiver === other;
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    toString$0: function(receiver) {
      return "Instance of '" + H.Primitives_objectTypeName(receiver) + "'";
    },
    get$runtimeType: function(receiver) {
      return new H.TypeImpl(H.getRti(receiver));
    }
  };
  J.JSBool.prototype = {
    toString$0: function(receiver) {
      return String(receiver);
    },
    get$hashCode: function(receiver) {
      return receiver ? 519018 : 218159;
    },
    get$runtimeType: function(receiver) {
      return C.Type_bool_lhE;
    },
    $isbool: 1
  };
  J.JSNull.prototype = {
    $eq: function(receiver, other) {
      return null == other;
    },
    toString$0: function(receiver) {
      return "null";
    },
    get$hashCode: function(receiver) {
      return 0;
    },
    get$runtimeType: function(receiver) {
      return C.Type_Null_Yyn;
    },
    $isNull: 1
  };
  J.JSObject.prototype = {};
  J.JavaScriptObject.prototype = {
    get$hashCode: function(receiver) {
      return 0;
    },
    get$runtimeType: function(receiver) {
      return C.Type_JSObject_8k0;
    },
    toString$0: function(receiver) {
      return String(receiver);
    }
  };
  J.PlainJavaScriptObject.prototype = {};
  J.UnknownJavaScriptObject.prototype = {};
  J.JavaScriptFunction.prototype = {
    toString$0: function(receiver) {
      var dartClosure = receiver[$.$get$DART_CLOSURE_PROPERTY_NAME()];
      if (dartClosure == null)
        return this.super$JavaScriptObject$toString(receiver);
      return "JavaScript function for " + H.S(J.toString$0$(dartClosure));
    },
    $signature: function() {
      return {func: 1, opt: [,,,,,,,,,,,,,,,,]};
    },
    $isFunction: 1
  };
  J.JSArray.prototype = {
    add$1: function(receiver, value) {
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(receiver, 0));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("add"));
      receiver.push(value);
    },
    insert$2: function(receiver, index, value) {
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(receiver, 0));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("insert"));
      if (index < 0 || index > receiver.length)
        throw H.wrapException(P.RangeError$value(index, null));
      receiver.splice(index, 0, value);
    },
    remove$1: function(receiver, element) {
      var i;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("remove"));
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq$(receiver[i], element)) {
          receiver.splice(i, 1);
          return true;
        }
      return false;
    },
    addAll$1: function(receiver, collection) {
      var i, t1, e, i0;
      H.assertSubtype(collection, "$isIterable", [H.getTypeArgumentByIndex(receiver, 0)], "$asIterable");
      i = receiver.length;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("addAll"));
      for (t1 = J.get$iterator$ax(collection); t1.moveNext$0(); i = i0) {
        e = t1.get$current();
        i0 = i + 1;
        H.assertHelper(i === receiver.length || H.throwExpression(P.ConcurrentModificationError$(receiver)));
        receiver.push(e);
      }
    },
    forEach$1: function(receiver, f) {
      var end, i;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(receiver, 0)]});
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        f.call$1(receiver[i]);
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    map$1$1: function(receiver, f, $T) {
      var t1 = H.getTypeArgumentByIndex(receiver, 0);
      return new H.MappedListIterable(receiver, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    },
    join$1: function(receiver, separator) {
      var i,
        list = new Array(receiver.length);
      list.fixed$length = Array;
      for (i = 0; i < receiver.length; ++i)
        this.$indexSet(list, i, H.S(receiver[i]));
      return list.join(separator);
    },
    fold$1$2: function(receiver, initialValue, combine, $T) {
      var $length, value, i;
      H.assertSubtypeOfRuntimeType(initialValue, $T);
      H.functionTypeCheck(combine, {func: 1, ret: $T, args: [$T, H.getTypeArgumentByIndex(receiver, 0)]});
      $length = receiver.length;
      for (value = initialValue, i = 0; i < $length; ++i) {
        value = combine.call$2(value, receiver[i]);
        if (receiver.length !== $length)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return value;
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, "start", null));
      if (end == null)
        end = receiver.length;
      else if (end < start || end > receiver.length)
        throw H.wrapException(P.RangeError$range(end, start, receiver.length, "end", null));
      if (start === end)
        return H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]);
      return H.setRuntimeTypeInfo(receiver.slice(start, end), [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    sublist$1: function($receiver, start) {
      return this.sublist$2($receiver, start, null);
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(H.IterableElementError_noElement());
    },
    get$last: function(receiver) {
      var t1 = receiver.length;
      if (t1 > 0)
        return receiver[t1 - 1];
      throw H.wrapException(H.IterableElementError_noElement());
    },
    get$single: function(receiver) {
      var t1 = receiver.length;
      if (t1 === 1) {
        if (0 >= t1)
          return H.ioore(receiver, 0);
        return receiver[0];
      }
      if (t1 === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      throw H.wrapException(H.IterableElementError_tooMany());
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      var $length, i,
        t1 = H.getTypeArgumentByIndex(receiver, 0);
      H.assertSubtype(iterable, "$isIterable", [t1], "$asIterable");
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("setRange"));
      P.RangeError_checkValidRange(start, end, receiver.length);
      $length = end - start;
      if ($length === 0)
        return;
      P.RangeError_checkNotNegative(skipCount, "skipCount");
      H.assertSubtype(iterable, "$isList", [t1], "$asList");
      t1 = J.getInterceptor$asx(iterable);
      if (skipCount + $length > t1.get$length(iterable))
        throw H.wrapException(H.IterableElementError_tooFew());
      if (skipCount < start)
        for (i = $length - 1; i >= 0; --i)
          receiver[start + i] = t1.$index(iterable, skipCount + i);
      else
        for (i = 0; i < $length; ++i)
          receiver[start + i] = t1.$index(iterable, skipCount + i);
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    any$1: function(receiver, test) {
      var end, i;
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(receiver, 0)]});
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        if (H.boolConversionCheck(test.call$1(receiver[i])))
          return true;
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    every$1: function(receiver, test) {
      var end, i;
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(receiver, 0)]});
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        if (!H.boolConversionCheck(test.call$1(receiver[i])))
          return false;
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return true;
    },
    sort$1: function(receiver, compare) {
      var t1 = H.getTypeArgumentByIndex(receiver, 0);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("sort"));
      H.Sort_sort(receiver, compare == null ? J._interceptors_JSArray__compareAny$closure() : compare, t1);
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    indexOf$1: function(receiver, element) {
      var i;
      if (0 >= receiver.length)
        return -1;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq$(receiver[i], element))
          return i;
      return -1;
    },
    contains$1: function(receiver, other) {
      var i;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq$(receiver[i], other))
          return true;
      return false;
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.length !== 0;
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    get$iterator: function(receiver) {
      return new J.ArrayIterator(receiver, receiver.length, [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    set$length: function(receiver, newLength) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("set length"));
      if (newLength < 0)
        throw H.wrapException(P.RangeError$range(newLength, 0, null, "newLength", null));
      receiver.length = newLength;
    },
    $index: function(receiver, index) {
      if (index >= receiver.length || index < 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(receiver, 0));
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("indexed set"));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      receiver[index] = value;
    },
    $add: function(receiver, other) {
      var totalLength,
        t1 = [H.getTypeArgumentByIndex(receiver, 0)];
      H.assertSubtype(other, "$isList", t1, "$asList");
      totalLength = receiver.length + J.get$length$asx(other);
      t1 = H.setRuntimeTypeInfo([], t1);
      this.set$length(t1, totalLength);
      this.setRange$3(t1, 0, receiver.length, receiver);
      this.setRange$3(t1, receiver.length, totalLength, other);
      return t1;
    },
    lastIndexWhere$1: function(receiver, test) {
      var start, i;
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(receiver, 0)]});
      start = receiver.length - 1;
      if (start < 0)
        return -1;
      for (i = start; i >= 0; --i) {
        if (i >= receiver.length)
          return H.ioore(receiver, i);
        if (H.boolConversionCheck(test.call$1(receiver[i])))
          return i;
      }
      return -1;
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isList: 1
  };
  J.JSUnmodifiableArray.prototype = {};
  J.ArrayIterator.prototype = {
    get$current: function() {
      return this.__interceptors$_current;
    },
    moveNext$0: function() {
      var t2, _this = this,
        t1 = _this.__interceptors$_iterable,
        $length = t1.length;
      if (_this.__interceptors$_length !== $length)
        throw H.wrapException(H.throwConcurrentModificationError(t1));
      t2 = _this.__interceptors$_index;
      if (t2 >= $length) {
        _this.set$__interceptors$_current(null);
        return false;
      }
      _this.set$__interceptors$_current(t1[t2]);
      ++_this.__interceptors$_index;
      return true;
    },
    set$__interceptors$_current: function(_current) {
      this.__interceptors$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  J.JSNumber.prototype = {
    compareTo$1: function(receiver, b) {
      var bIsNegative;
      H.numTypeCheck(b);
      if (typeof b !== "number")
        throw H.wrapException(H.argumentErrorValue(b));
      if (receiver < b)
        return -1;
      else if (receiver > b)
        return 1;
      else if (receiver === b) {
        if (receiver === 0) {
          bIsNegative = this.get$isNegative(b);
          if (this.get$isNegative(receiver) === bIsNegative)
            return 0;
          if (this.get$isNegative(receiver))
            return -1;
          return 1;
        }
        return 0;
      } else if (isNaN(receiver)) {
        if (isNaN(b))
          return 0;
        return 1;
      } else
        return -1;
    },
    get$isNegative: function(receiver) {
      return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
    },
    get$sign: function(receiver) {
      var t1;
      if (receiver > 0)
        t1 = 1;
      else
        t1 = receiver < 0 ? -1 : receiver;
      return t1;
    },
    toInt$0: function(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
        return t1 + 0;
      }
      throw H.wrapException(P.UnsupportedError$("" + receiver + ".toInt()"));
    },
    floor$0: function(receiver) {
      var truncated, d;
      if (receiver >= 0) {
        if (receiver <= 2147483647)
          return receiver | 0;
      } else if (receiver >= -2147483648) {
        truncated = receiver | 0;
        return receiver === truncated ? truncated : truncated - 1;
      }
      d = Math.floor(receiver);
      if (isFinite(d))
        return d;
      throw H.wrapException(P.UnsupportedError$("" + receiver + ".floor()"));
    },
    round$0: function(receiver) {
      if (receiver > 0) {
        if (receiver !== 1 / 0)
          return Math.round(receiver);
      } else if (receiver > -1 / 0)
        return 0 - Math.round(0 - receiver);
      throw H.wrapException(P.UnsupportedError$("" + receiver + ".round()"));
    },
    clamp$2: function(receiver, lowerLimit, upperLimit) {
      if (typeof lowerLimit !== "number")
        throw H.wrapException(H.argumentErrorValue(lowerLimit));
      if (typeof upperLimit !== "number")
        throw H.wrapException(H.argumentErrorValue(upperLimit));
      if (this.compareTo$1(lowerLimit, upperLimit) > 0)
        throw H.wrapException(H.argumentErrorValue(lowerLimit));
      if (this.compareTo$1(receiver, lowerLimit) < 0)
        return lowerLimit;
      if (this.compareTo$1(receiver, upperLimit) > 0)
        return upperLimit;
      return receiver;
    },
    toStringAsFixed$1: function(receiver, fractionDigits) {
      var result;
      if (fractionDigits > 20)
        throw H.wrapException(P.RangeError$range(fractionDigits, 0, 20, "fractionDigits", null));
      result = receiver.toFixed(fractionDigits);
      if (receiver === 0 && this.get$isNegative(receiver))
        return "-" + result;
      return result;
    },
    toStringAsPrecision$1: function(receiver, precision) {
      var result;
      if (precision < 1 || precision > 21)
        throw H.wrapException(P.RangeError$range(precision, 1, 21, "precision", null));
      result = receiver.toPrecision(precision);
      if (receiver === 0 && this.get$isNegative(receiver))
        return "-" + result;
      return result;
    },
    toRadixString$1: function(receiver, radix) {
      var result, match, t1, exponent;
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
      result = receiver.toString(radix);
      if (C.JSString_methods.codeUnitAt$1(result, result.length - 1) !== 41)
        return result;
      match = /^([\da-z]+)(?:\.([\da-z]+))?\(e\+(\d+)\)$/.exec(result);
      if (match == null)
        H.throwExpression(P.UnsupportedError$("Unexpected toString result: " + result));
      t1 = match.length;
      if (1 >= t1)
        return H.ioore(match, 1);
      result = match[1];
      if (3 >= t1)
        return H.ioore(match, 3);
      exponent = +match[3];
      t1 = match[2];
      if (t1 != null) {
        result += t1;
        exponent -= t1.length;
      }
      return result + C.JSString_methods.$mul("0", exponent);
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode: function(receiver) {
      var absolute, floorLog2, factor, scaled,
        intValue = receiver | 0;
      if (receiver === intValue)
        return 536870911 & intValue;
      absolute = Math.abs(receiver);
      floorLog2 = Math.log(absolute) / 0.6931471805599453 | 0;
      factor = Math.pow(2, floorLog2);
      scaled = absolute < 1 ? absolute / factor : factor / absolute;
      return 536870911 & ((scaled * 9007199254740992 | 0) + (scaled * 3542243181176521 | 0)) * 599197 + floorLog2 * 1259;
    },
    $add: function(receiver, other) {
      H.numTypeCheck(other);
      if (typeof other !== "number")
        throw H.wrapException(H.argumentErrorValue(other));
      return receiver + other;
    },
    $sub: function(receiver, other) {
      H.numTypeCheck(other);
      if (typeof other !== "number")
        throw H.wrapException(H.argumentErrorValue(other));
      return receiver - other;
    },
    $mul: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(H.argumentErrorValue(other));
      return receiver * other;
    },
    $mod: function(receiver, other) {
      var result = receiver % other;
      if (result === 0)
        return 0;
      if (result > 0)
        return result;
      if (other < 0)
        return result - other;
      else
        return result + other;
    },
    _tdivFast$1: function(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this._tdivSlow$1(receiver, other);
    },
    _tdivSlow$1: function(receiver, other) {
      var quotient = receiver / other;
      if (quotient >= -2147483648 && quotient <= 2147483647)
        return quotient | 0;
      if (quotient > 0) {
        if (quotient !== 1 / 0)
          return Math.floor(quotient);
      } else if (quotient > -1 / 0)
        return Math.ceil(quotient);
      throw H.wrapException(P.UnsupportedError$("Result of truncating division is " + H.S(quotient) + ": " + H.S(receiver) + " ~/ " + other));
    },
    _shrOtherPositive$1: function(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = this._shrBothPositive$1(receiver, other);
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrReceiverPositive$1: function(receiver, other) {
      if (other < 0)
        throw H.wrapException(H.argumentErrorValue(other));
      return this._shrBothPositive$1(receiver, other);
    },
    _shrBothPositive$1: function(receiver, other) {
      return other > 31 ? 0 : receiver >>> other;
    },
    $lt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(H.argumentErrorValue(other));
      return receiver < other;
    },
    $gt: function(receiver, other) {
      H.numTypeCheck(other);
      if (typeof other !== "number")
        throw H.wrapException(H.argumentErrorValue(other));
      return receiver > other;
    },
    $le: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(H.argumentErrorValue(other));
      return receiver <= other;
    },
    $ge: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(H.argumentErrorValue(other));
      return receiver >= other;
    },
    get$runtimeType: function(receiver) {
      return C.Type_num_cv7;
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.num];
    },
    $isdouble: 1,
    $isnum: 1
  };
  J.JSInt.prototype = {
    get$sign: function(receiver) {
      var t1;
      if (receiver > 0)
        t1 = 1;
      else
        t1 = receiver < 0 ? -1 : receiver;
      return t1;
    },
    get$runtimeType: function(receiver) {
      return C.Type_int_tHn;
    },
    $isint: 1
  };
  J.JSDouble.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_double_K1J;
    }
  };
  J.JSString.prototype = {
    codeUnitAt$1: function(receiver, index) {
      if (index < 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      if (index >= receiver.length)
        H.throwExpression(H.diagnoseIndexError(receiver, index));
      return receiver.charCodeAt(index);
    },
    _codeUnitAt$1: function(receiver, index) {
      if (index >= receiver.length)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      return receiver.charCodeAt(index);
    },
    matchAsPrefix$2: function(receiver, string, start) {
      var t1, i;
      if (start < 0 || start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      t1 = receiver.length;
      if (start + t1 > string.length)
        return;
      for (i = 0; i < t1; ++i)
        if (this.codeUnitAt$1(string, start + i) !== this._codeUnitAt$1(receiver, i))
          return;
      return new H.StringMatch(start, receiver);
    },
    $add: function(receiver, other) {
      H.stringTypeCheck(other);
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$value(other, null, null));
      return receiver + other;
    },
    endsWith$1: function(receiver, other) {
      var otherLength = other.length,
        t1 = receiver.length;
      if (otherLength > t1)
        return false;
      return other === this.substring$1(receiver, t1 - otherLength);
    },
    replaceRange$3: function(receiver, start, end, replacement) {
      var prefix, suffix;
      end = P.RangeError_checkValidRange(start, end, receiver.length);
      prefix = receiver.substring(0, start);
      suffix = receiver.substring(end);
      return prefix + replacement + suffix;
    },
    startsWith$2: function(receiver, pattern, index) {
      var endIndex;
      if (index < 0 || index > receiver.length)
        throw H.wrapException(P.RangeError$range(index, 0, receiver.length, null, null));
      if (typeof pattern === "string") {
        endIndex = index + pattern.length;
        if (endIndex > receiver.length)
          return false;
        return pattern === receiver.substring(index, endIndex);
      }
      return J.matchAsPrefix$2$s(pattern, receiver, index) != null;
    },
    startsWith$1: function($receiver, pattern) {
      return this.startsWith$2($receiver, pattern, 0);
    },
    substring$2: function(receiver, startIndex, endIndex) {
      if (endIndex == null)
        endIndex = receiver.length;
      if (startIndex < 0)
        throw H.wrapException(P.RangeError$value(startIndex, null));
      if (startIndex > endIndex)
        throw H.wrapException(P.RangeError$value(startIndex, null));
      if (endIndex > receiver.length)
        throw H.wrapException(P.RangeError$value(endIndex, null));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    trim$0: function(receiver) {
      var startIndex, t1, endIndex0,
        result = receiver.trim(),
        endIndex = result.length;
      if (endIndex === 0)
        return result;
      if (this._codeUnitAt$1(result, 0) === 133) {
        startIndex = J.JSString__skipLeadingWhitespace(result, 1);
        if (startIndex === endIndex)
          return "";
      } else
        startIndex = 0;
      t1 = endIndex - 1;
      endIndex0 = this.codeUnitAt$1(result, t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
      if (startIndex === 0 && endIndex0 === endIndex)
        return result;
      return result.substring(startIndex, endIndex0);
    },
    trimLeft$0: function(receiver) {
      var result, startIndex;
      if (typeof receiver.trimLeft != "undefined") {
        result = receiver.trimLeft();
        if (result.length === 0)
          return result;
        startIndex = this._codeUnitAt$1(result, 0) === 133 ? J.JSString__skipLeadingWhitespace(result, 1) : 0;
      } else {
        startIndex = J.JSString__skipLeadingWhitespace(receiver, 0);
        result = receiver;
      }
      if (startIndex === 0)
        return result;
      if (startIndex === result.length)
        return "";
      return result.substring(startIndex);
    },
    trimRight$0: function(receiver) {
      var result, endIndex, t1;
      if (typeof receiver.trimRight != "undefined") {
        result = receiver.trimRight();
        endIndex = result.length;
        if (endIndex === 0)
          return result;
        t1 = endIndex - 1;
        if (this.codeUnitAt$1(result, t1) === 133)
          endIndex = J.JSString__skipTrailingWhitespace(result, t1);
      } else {
        endIndex = J.JSString__skipTrailingWhitespace(receiver, receiver.length);
        result = receiver;
      }
      if (endIndex === result.length)
        return result;
      if (endIndex === 0)
        return "";
      return result.substring(0, endIndex);
    },
    $mul: function(receiver, times) {
      var s, result;
      H.intTypeCheck(times);
      if (typeof times !== "number")
        return H.iae(times);
      if (0 >= times)
        return "";
      if (times === 1 || receiver.length === 0)
        return receiver;
      if (times !== times >>> 0)
        throw H.wrapException(C.C_OutOfMemoryError);
      for (s = receiver, result = ""; true;) {
        if ((times & 1) === 1)
          result = s + result;
        times = times >>> 1;
        if (times === 0)
          break;
        s += s;
      }
      return result;
    },
    padLeft$2: function(receiver, width, padding) {
      var delta = width - receiver.length;
      if (delta <= 0)
        return receiver;
      return this.$mul(padding, delta) + receiver;
    },
    indexOf$2: function(receiver, pattern, start) {
      var t1;
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
      t1 = receiver.indexOf(pattern, start);
      return t1;
    },
    indexOf$1: function($receiver, pattern) {
      return this.indexOf$2($receiver, pattern, 0);
    },
    lastIndexOf$1: function(receiver, pattern) {
      var start = receiver.length,
        t1 = pattern.length;
      if (start + t1 > start)
        start -= t1;
      return receiver.lastIndexOf(pattern, start);
    },
    contains$1: function(receiver, other) {
      return H.stringContainsUnchecked(receiver, other, 0);
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    compareTo$1: function(receiver, other) {
      var t1;
      H.stringTypeCheck(other);
      if (typeof other !== "string")
        throw H.wrapException(H.argumentErrorValue(other));
      if (receiver === other)
        t1 = 0;
      else
        t1 = receiver < other ? -1 : 1;
      return t1;
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$hashCode: function(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = 536870911 & hash + receiver.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10);
        hash ^= hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3);
      hash ^= hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    },
    get$runtimeType: function(receiver) {
      return C.Type_String_k8F;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (index >= receiver.length || index < 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      return receiver[index];
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.String];
    },
    $isPattern: 1,
    $isString: 1
  };
  H.EfficientLengthIterable.prototype = {};
  H.ListIterable.prototype = {
    get$iterator: function(_) {
      var _this = this;
      return new H.ListIterator(_this, _this.get$length(_this), [H.getRuntimeTypeArgument(_this, "ListIterable", 0)]);
    },
    forEach$1: function(_, action) {
      var $length, i, _this = this;
      H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(_this, "ListIterable", 0)]});
      $length = _this.get$length(_this);
      for (i = 0; i < $length; ++i) {
        action.call$1(_this.elementAt$1(0, i));
        if ($length !== _this.get$length(_this))
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    join$1: function(_, separator) {
      var first, t1, i, _this = this,
        $length = _this.get$length(_this);
      if (separator.length !== 0) {
        if ($length === 0)
          return "";
        first = H.S(_this.elementAt$1(0, 0));
        if ($length !== _this.get$length(_this))
          throw H.wrapException(P.ConcurrentModificationError$(_this));
        for (t1 = first, i = 1; i < $length; ++i) {
          t1 = t1 + separator + H.S(_this.elementAt$1(0, i));
          if ($length !== _this.get$length(_this))
            throw H.wrapException(P.ConcurrentModificationError$(_this));
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      } else {
        for (i = 0, t1 = ""; i < $length; ++i) {
          t1 += H.S(_this.elementAt$1(0, i));
          if ($length !== _this.get$length(_this))
            throw H.wrapException(P.ConcurrentModificationError$(_this));
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
    },
    map$1$1: function(_, f, $T) {
      var t1 = H.getRuntimeTypeArgument(this, "ListIterable", 0);
      return new H.MappedListIterable(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    },
    toList$1$growable: function(_, growable) {
      var result, t2, i, _this = this,
        t1 = H.getRuntimeTypeArgument(_this, "ListIterable", 0);
      if (growable) {
        result = H.setRuntimeTypeInfo([], [t1]);
        C.JSArray_methods.set$length(result, _this.get$length(_this));
      } else {
        t2 = new Array(_this.get$length(_this));
        t2.fixed$length = Array;
        result = H.setRuntimeTypeInfo(t2, [t1]);
      }
      for (i = 0; i < _this.get$length(_this); ++i)
        C.JSArray_methods.$indexSet(result, i, _this.elementAt$1(0, i));
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    }
  };
  H.SubListIterable.prototype = {
    get$_endIndex: function() {
      var $length = J.get$length$asx(this._iterable),
        t1 = this._endOrLength;
      if (t1 == null || t1 > $length)
        return $length;
      return t1;
    },
    get$_startIndex: function() {
      var $length = J.get$length$asx(this._iterable),
        t1 = this._start;
      if (t1 > $length)
        return $length;
      return t1;
    },
    get$length: function(_) {
      var t2,
        $length = J.get$length$asx(this._iterable),
        t1 = this._start;
      if (t1 >= $length)
        return 0;
      t2 = this._endOrLength;
      if (t2 == null || t2 >= $length)
        return $length - t1;
      if (typeof t2 !== "number")
        return t2.$sub();
      return t2 - t1;
    },
    elementAt$1: function(_, index) {
      var t1, _this = this,
        realIndex = _this.get$_startIndex() + index;
      if (index >= 0) {
        t1 = _this.get$_endIndex();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = realIndex >= t1;
      } else
        t1 = true;
      if (t1)
        throw H.wrapException(P.IndexError$(index, _this, "index", null, null));
      return J.elementAt$1$ax(_this._iterable, realIndex);
    },
    toList$1$growable: function(_, growable) {
      var $length, t3, result, t4, i, _this = this,
        start = _this._start,
        t1 = _this._iterable,
        t2 = J.getInterceptor$asx(t1),
        end = t2.get$length(t1),
        end0 = _this._endOrLength;
      if (end0 != null && end0 < end)
        end = end0;
      if (typeof end !== "number")
        return end.$sub();
      $length = end - start;
      if ($length < 0)
        $length = 0;
      t3 = _this.$ti;
      if (growable) {
        result = H.setRuntimeTypeInfo([], t3);
        C.JSArray_methods.set$length(result, $length);
      } else {
        t4 = new Array($length);
        t4.fixed$length = Array;
        result = H.setRuntimeTypeInfo(t4, t3);
      }
      for (i = 0; i < $length; ++i) {
        C.JSArray_methods.$indexSet(result, i, t2.elementAt$1(t1, start + i));
        if (t2.get$length(t1) < end)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    }
  };
  H.ListIterator.prototype = {
    get$current: function() {
      return this._current;
    },
    moveNext$0: function() {
      var t3, _this = this,
        t1 = _this._iterable,
        t2 = J.getInterceptor$asx(t1),
        $length = t2.get$length(t1);
      if (_this.__internal$_length !== $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t3 = _this._index;
      if (t3 >= $length) {
        _this.set$_current(null);
        return false;
      }
      _this.set$_current(t2.elementAt$1(t1, t3));
      ++_this._index;
      return true;
    },
    set$_current: function(_current) {
      this._current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  H.MappedIterable.prototype = {
    get$iterator: function(_) {
      return new H.MappedIterator(J.get$iterator$ax(this._iterable), this._f, this.$ti);
    },
    get$length: function(_) {
      return J.get$length$asx(this._iterable);
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$asx(this._iterable);
    },
    $asIterable: function($S, $T) {
      return [$T];
    }
  };
  H.EfficientLengthMappedIterable.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    }
  };
  H.MappedIterator.prototype = {
    moveNext$0: function() {
      var _this = this,
        t1 = _this._iterator;
      if (t1.moveNext$0()) {
        _this.set$_current(_this._f.call$1(t1.get$current()));
        return true;
      }
      _this.set$_current(null);
      return false;
    },
    get$current: function() {
      return this._current;
    },
    set$_current: function(_current) {
      this._current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 1));
    },
    $asIterator: function($S, $T) {
      return [$T];
    }
  };
  H.MappedListIterable.prototype = {
    get$length: function(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1: function(_, index) {
      return this._f.call$1(J.elementAt$1$ax(this._source, index));
    },
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    },
    $asListIterable: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    }
  };
  H.WhereIterable.prototype = {
    get$iterator: function(_) {
      return new H.WhereIterator(J.get$iterator$ax(this._iterable), this._f, this.$ti);
    },
    map$1$1: function(_, f, $T) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      return new H.MappedIterable(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    }
  };
  H.WhereIterator.prototype = {
    moveNext$0: function() {
      var t1, t2;
      for (t1 = this._iterator, t2 = this._f; t1.moveNext$0();)
        if (H.boolConversionCheck(t2.call$1(t1.get$current())))
          return true;
      return false;
    },
    get$current: function() {
      return this._iterator.get$current();
    }
  };
  H.ExpandIterable.prototype = {
    get$iterator: function(_) {
      return new H.ExpandIterator(J.get$iterator$ax(this._iterable), this._f, C.C_EmptyIterator, this.$ti);
    },
    $asIterable: function($S, $T) {
      return [$T];
    }
  };
  H.ExpandIterator.prototype = {
    get$current: function() {
      return this._current;
    },
    moveNext$0: function() {
      var t1, t2, _this = this;
      if (_this._currentExpansion == null)
        return false;
      for (t1 = _this._iterator, t2 = _this._f; !_this._currentExpansion.moveNext$0();) {
        _this.set$_current(null);
        if (t1.moveNext$0()) {
          _this.set$_currentExpansion(null);
          _this.set$_currentExpansion(J.get$iterator$ax(t2.call$1(t1.get$current())));
        } else
          return false;
      }
      _this.set$_current(_this._currentExpansion.get$current());
      return true;
    },
    set$_currentExpansion: function(_currentExpansion) {
      this._currentExpansion = H.assertSubtype(_currentExpansion, "$isIterator", [H.getTypeArgumentByIndex(this, 1)], "$asIterator");
    },
    set$_current: function(_current) {
      this._current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 1));
    },
    $isIterator: 1,
    $asIterator: function($S, $T) {
      return [$T];
    }
  };
  H.EmptyIterator.prototype = {
    moveNext$0: function() {
      return false;
    },
    get$current: function() {
      return;
    },
    $isIterator: 1
  };
  H.WhereTypeIterable.prototype = {
    get$iterator: function(_) {
      return new H.WhereTypeIterator(J.get$iterator$ax(this._source), this.$ti);
    }
  };
  H.WhereTypeIterator.prototype = {
    moveNext$0: function() {
      var t1, t2, t3;
      for (t1 = this._source, t2 = H.getTypeArgumentByIndex(this, 0); t1.moveNext$0();) {
        t3 = t1.get$current();
        if (H.checkSubtypeOfRuntimeType(t3, t2))
          return true;
      }
      return false;
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this._source.get$current(), H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  H.FixedLengthListMixin.prototype = {
    set$length: function(receiver, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot change the length of a fixed-length list"));
    },
    add$1: function(receiver, value) {
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgumentIntercepted(this, receiver, "FixedLengthListMixin", 0));
      throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
    },
    addAll$1: function(receiver, iterable) {
      H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgumentIntercepted(this, receiver, "FixedLengthListMixin", 0)], "$asIterable");
      throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
    },
    remove$1: function(receiver, element) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
    }
  };
  H.ReversedListIterable.prototype = {
    get$length: function(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1: function(_, index) {
      var t1 = this._source,
        t2 = J.getInterceptor$asx(t1);
      return t2.elementAt$1(t1, t2.get$length(t1) - 1 - index);
    }
  };
  H.ConstantMap.prototype = {
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    toString$0: function(_) {
      return P.MapBase_mapToString(this);
    },
    $indexSet: function(_, key, val) {
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
      H.assertSubtypeOfRuntimeType(val, H.getTypeArgumentByIndex(this, 1));
      return H.ConstantMap__throwUnmodifiable();
    },
    remove$1: function(_, key) {
      return H.ConstantMap__throwUnmodifiable();
    },
    addAll$1: function(_, other) {
      H.assertSubtype(other, "$isMap", this.$ti, "$asMap");
      return H.ConstantMap__throwUnmodifiable();
    },
    $isMap: 1
  };
  H.ConstantStringMap.prototype = {
    get$length: function(_) {
      return this.__js_helper$_length;
    },
    containsKey$1: function(key) {
      if (typeof key !== "string")
        return false;
      if ("__proto__" === key)
        return false;
      return this._jsObject.hasOwnProperty(key);
    },
    $index: function(_, key) {
      if (!this.containsKey$1(key))
        return;
      return this._fetch$1(key);
    },
    _fetch$1: function(key) {
      return this._jsObject[H.stringTypeCheck(key)];
    },
    forEach$1: function(_, f) {
      var keys, t2, i, key, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 1);
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(_this, 0), t1]});
      keys = _this._keys;
      for (t2 = keys.length, i = 0; i < t2; ++i) {
        key = keys[i];
        f.call$2(key, H.assertSubtypeOfRuntimeType(_this._fetch$1(key), t1));
      }
    },
    get$keys: function() {
      return new H._ConstantMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function() {
      var _this = this;
      return H.MappedIterable_MappedIterable(_this._keys, new H.ConstantStringMap_values_closure(_this), H.getTypeArgumentByIndex(_this, 0), H.getTypeArgumentByIndex(_this, 1));
    }
  };
  H.ConstantStringMap_values_closure.prototype = {
    call$1: function(key) {
      var t1 = this.$this;
      return H.assertSubtypeOfRuntimeType(t1._fetch$1(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(t1, 0))), H.getTypeArgumentByIndex(t1, 1));
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: H.getTypeArgumentByIndex(t1, 1), args: [H.getTypeArgumentByIndex(t1, 0)]};
    }
  };
  H._ConstantMapKeyIterable.prototype = {
    get$iterator: function(_) {
      var t1 = this._map._keys;
      return new J.ArrayIterator(t1, t1.length, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    get$length: function(_) {
      return this._map._keys.length;
    }
  };
  H.GeneralConstantMap.prototype = {
    _getMap$0: function() {
      var _this = this,
        backingMap = _this.$map;
      if (backingMap == null) {
        backingMap = new H.JsLinkedHashMap(_this.$ti);
        H.fillLiteralMap(_this._jsData, backingMap);
        _this.$map = backingMap;
      }
      return backingMap;
    },
    containsKey$1: function(key) {
      return this._getMap$0().containsKey$1(key);
    },
    $index: function(_, key) {
      return this._getMap$0().$index(0, key);
    },
    forEach$1: function(_, f) {
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)]});
      this._getMap$0().forEach$1(0, f);
    },
    get$keys: function() {
      return this._getMap$0().get$keys();
    },
    get$values: function() {
      return this._getMap$0().get$values();
    },
    get$length: function(_) {
      var t1 = this._getMap$0();
      return t1.get$length(t1);
    }
  };
  H.Instantiation.prototype = {
    Instantiation$1: function(_genericClosure) {
      if (false)
        H.instantiatedGenericFunctionType(0, 0);
    },
    toString$0: function(_) {
      var types = "<" + C.JSArray_methods.join$1(this.get$_types(), ", ") + ">";
      return H.S(this._genericClosure) + " with " + types;
    }
  };
  H.Instantiation1.prototype = {
    get$_types: function() {
      return [new H.TypeImpl(H.getTypeArgumentByIndex(this, 0))];
    },
    call$1: function(a0) {
      return this._genericClosure.call$1$1(a0, this.$ti[0]);
    },
    call$2: function(a0, a1) {
      return this._genericClosure.call$1$2(a0, a1, this.$ti[0]);
    },
    $signature: function() {
      return H.instantiatedGenericFunctionType(H.extractFunctionTypeObjectFromInternal(this._genericClosure), this.$ti);
    }
  };
  H.Instantiation2.prototype = {
    get$_types: function() {
      return [new H.TypeImpl(H.getTypeArgumentByIndex(this, 0)), new H.TypeImpl(H.getTypeArgumentByIndex(this, 1))];
    },
    call$1: function(a0) {
      return this._genericClosure.call$2$1(a0, this.$ti[0], this.$ti[1]);
    },
    $signature: function() {
      return H.instantiatedGenericFunctionType(H.extractFunctionTypeObjectFromInternal(this._genericClosure), this.$ti);
    }
  };
  H.Primitives_initTicker_closure.prototype = {
    call$0: function() {
      return C.JSNumber_methods.floor$0(1000 * this.performance.now());
    },
    $signature: 54
  };
  H.TypeErrorDecoder.prototype = {
    matchTypeError$1: function(message) {
      var result, t1, _this = this,
        match = new RegExp(_this._pattern).exec(message);
      if (match == null)
        return;
      result = Object.create(null);
      t1 = _this._arguments;
      if (t1 !== -1)
        result.arguments = match[t1 + 1];
      t1 = _this._argumentsExpr;
      if (t1 !== -1)
        result.argumentsExpr = match[t1 + 1];
      t1 = _this._expr;
      if (t1 !== -1)
        result.expr = match[t1 + 1];
      t1 = _this._method;
      if (t1 !== -1)
        result.method = match[t1 + 1];
      t1 = _this._receiver;
      if (t1 !== -1)
        result.receiver = match[t1 + 1];
      return result;
    }
  };
  H.NullError.prototype = {
    toString$0: function(_) {
      var t1 = this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(this._message);
      return "NoSuchMethodError: method not found: '" + t1 + "' on null";
    }
  };
  H.JsNoSuchMethodError.prototype = {
    toString$0: function(_) {
      var t2, _this = this,
        _s38_ = "NoSuchMethodError: method not found: '",
        t1 = _this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(_this._message);
      t2 = _this._receiver;
      if (t2 == null)
        return _s38_ + t1 + "' (" + H.S(_this._message) + ")";
      return _s38_ + t1 + "' on '" + t2 + "' (" + H.S(_this._message) + ")";
    }
  };
  H.UnknownJsTypeError.prototype = {
    toString$0: function(_) {
      var t1 = this._message;
      return t1.length === 0 ? "Error" : "Error: " + t1;
    }
  };
  H.ExceptionAndStackTrace.prototype = {};
  H.unwrapException_saveStackTrace.prototype = {
    call$1: function(error) {
      if (!!J.getInterceptor$(error).$isError)
        if (error.$thrownJsError == null)
          error.$thrownJsError = this.ex;
      return error;
    },
    $signature: 23
  };
  H._StackTrace.prototype = {
    toString$0: function(_) {
      var trace,
        t1 = this._trace;
      if (t1 != null)
        return t1;
      t1 = this.__js_helper$_exception;
      trace = t1 !== null && typeof t1 === "object" ? t1.stack : null;
      return this._trace = trace == null ? "" : trace;
    },
    $isStackTrace: 1
  };
  H.Closure.prototype = {
    toString$0: function(_) {
      return "Closure '" + H.Primitives_objectTypeName(this).trim() + "'";
    },
    $isFunction: 1,
    get$$call: function() {
      return this;
    },
    "call*": "call$1",
    $requiredArgCount: 1,
    $defaultValues: null
  };
  H.TearOffClosure.prototype = {};
  H.StaticClosure.prototype = {
    toString$0: function(_) {
      var $name = this.$static_name;
      if ($name == null)
        return "Closure of unknown static method";
      return "Closure '" + H.unminifyOrTag($name) + "'";
    }
  };
  H.BoundClosure.prototype = {
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!(other instanceof H.BoundClosure))
        return false;
      return _this._self === other._self && _this._target === other._target && _this._receiver === other._receiver;
    },
    get$hashCode: function(_) {
      var receiverHashCode,
        t1 = this._receiver;
      if (t1 == null)
        receiverHashCode = H.Primitives_objectHashCode(this._self);
      else
        receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
      return (receiverHashCode ^ H.Primitives_objectHashCode(this._target)) >>> 0;
    },
    toString$0: function(_) {
      var receiver = this._receiver;
      if (receiver == null)
        receiver = this._self;
      return "Closure '" + H.S(this.__js_helper$_name) + "' of " + ("Instance of '" + H.Primitives_objectTypeName(receiver) + "'");
    }
  };
  H.TypeErrorImplementation.prototype = {
    toString$0: function(_) {
      return this.message;
    },
    $isAssertionError: 1,
    get$message: function(receiver) {
      return this.message;
    }
  };
  H.RuntimeError.prototype = {
    toString$0: function(_) {
      return "RuntimeError: " + H.S(this.message);
    }
  };
  H._AssertionError.prototype = {
    toString$0: function(_) {
      return "Assertion failed: " + P.Error_safeToString(this.message);
    }
  };
  H.TypeImpl.prototype = {
    get$_typeName: function() {
      var t1 = this.__typeName;
      return t1 == null ? this.__typeName = H.runtimeTypeToString(this._rti) : t1;
    },
    toString$0: function(_) {
      return this.get$_typeName();
    },
    get$hashCode: function(_) {
      var t1 = this._hashCode;
      return t1 == null ? this._hashCode = C.JSString_methods.get$hashCode(this.get$_typeName()) : t1;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof H.TypeImpl && this.get$_typeName() === other.get$_typeName();
    },
    $isType: 1
  };
  H.JsLinkedHashMap.prototype = {
    get$length: function(_) {
      return this.__js_helper$_length;
    },
    get$isEmpty: function(_) {
      return this.__js_helper$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return !this.get$isEmpty(this);
    },
    get$keys: function() {
      return new H.LinkedHashMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function() {
      var _this = this;
      return H.MappedIterable_MappedIterable(_this.get$keys(), new H.JsLinkedHashMap_values_closure(_this), H.getTypeArgumentByIndex(_this, 0), H.getTypeArgumentByIndex(_this, 1));
    },
    containsKey$1: function(key) {
      var strings, nums, _this = this;
      if (typeof key === "string") {
        strings = _this._strings;
        if (strings == null)
          return false;
        return _this._containsTableEntry$2(strings, key);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = _this._nums;
        if (nums == null)
          return false;
        return _this._containsTableEntry$2(nums, key);
      } else
        return _this.internalContainsKey$1(key);
    },
    internalContainsKey$1: function(key) {
      var _this = this,
        rest = _this._rest;
      if (rest == null)
        return false;
      return _this.internalFindBucketIndex$2(_this._getTableBucket$2(rest, _this.internalComputeHashCode$1(key)), key) >= 0;
    },
    containsValue$1: function(value) {
      return this.get$keys().any$1(0, new H.JsLinkedHashMap_containsValue_closure(this, value));
    },
    addAll$1: function(_, other) {
      H.assertSubtype(other, "$isMap", this.$ti, "$asMap").forEach$1(0, new H.JsLinkedHashMap_addAll_closure(this));
    },
    $index: function(_, key) {
      var strings, cell, t1, nums, _this = this;
      if (typeof key === "string") {
        strings = _this._strings;
        if (strings == null)
          return;
        cell = _this._getTableCell$2(strings, key);
        t1 = cell == null ? null : cell.hashMapCellValue;
        return t1;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = _this._nums;
        if (nums == null)
          return;
        cell = _this._getTableCell$2(nums, key);
        t1 = cell == null ? null : cell.hashMapCellValue;
        return t1;
      } else
        return _this.internalGet$1(key);
    },
    internalGet$1: function(key) {
      var bucket, index, _this = this,
        rest = _this._rest;
      if (rest == null)
        return;
      bucket = _this._getTableBucket$2(rest, _this.internalComputeHashCode$1(key));
      index = _this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      return bucket[index].hashMapCellValue;
    },
    $indexSet: function(_, key, value) {
      var strings, nums, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1));
      if (typeof key === "string") {
        strings = _this._strings;
        _this._addHashTableEntry$3(strings == null ? _this._strings = _this._newHashTable$0() : strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = _this._nums;
        _this._addHashTableEntry$3(nums == null ? _this._nums = _this._newHashTable$0() : nums, key, value);
      } else
        _this.internalSet$2(key, value);
    },
    internalSet$2: function(key, value) {
      var rest, hash, bucket, index, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1));
      rest = _this._rest;
      if (rest == null)
        rest = _this._rest = _this._newHashTable$0();
      hash = _this.internalComputeHashCode$1(key);
      bucket = _this._getTableBucket$2(rest, hash);
      if (bucket == null)
        _this._setTableEntry$3(rest, hash, [_this._newLinkedCell$2(key, value)]);
      else {
        index = _this.internalFindBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index].hashMapCellValue = value;
        else
          bucket.push(_this._newLinkedCell$2(key, value));
      }
    },
    putIfAbsent$2: function(key, ifAbsent) {
      var value, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.functionTypeCheck(ifAbsent, {func: 1, ret: H.getTypeArgumentByIndex(_this, 1)});
      if (_this.containsKey$1(key))
        return _this.$index(0, key);
      value = ifAbsent.call$0();
      _this.$indexSet(0, key, value);
      return value;
    },
    remove$1: function(_, key) {
      var _this = this;
      if (typeof key === "string")
        return _this._removeHashTableEntry$2(_this._strings, key);
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return _this._removeHashTableEntry$2(_this._nums, key);
      else
        return _this.internalRemove$1(key);
    },
    internalRemove$1: function(key) {
      var hash, bucket, index, cell, _this = this,
        rest = _this._rest;
      if (rest == null)
        return;
      hash = _this.internalComputeHashCode$1(key);
      bucket = _this._getTableBucket$2(rest, hash);
      index = _this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      cell = bucket.splice(index, 1)[0];
      _this._unlinkCell$1(cell);
      if (bucket.length === 0)
        _this._deleteTableEntry$2(rest, hash);
      return cell.hashMapCellValue;
    },
    clear$0: function(_) {
      var _this = this;
      if (_this.__js_helper$_length > 0) {
        _this._strings = _this._nums = _this._rest = _this._first = _this._last = null;
        _this.__js_helper$_length = 0;
        _this._modified$0();
      }
    },
    forEach$1: function(_, action) {
      var cell, modifications, _this = this;
      H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(_this, 0), H.getTypeArgumentByIndex(_this, 1)]});
      cell = _this._first;
      modifications = _this._modifications;
      for (; cell != null;) {
        action.call$2(cell.hashMapCellKey, cell.hashMapCellValue);
        if (modifications !== _this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
        cell = cell._next;
      }
    },
    _addHashTableEntry$3: function(table, key, value) {
      var cell, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1));
      cell = _this._getTableCell$2(table, key);
      if (cell == null)
        _this._setTableEntry$3(table, key, _this._newLinkedCell$2(key, value));
      else
        cell.hashMapCellValue = value;
    },
    _removeHashTableEntry$2: function(table, key) {
      var cell;
      if (table == null)
        return;
      cell = this._getTableCell$2(table, key);
      if (cell == null)
        return;
      this._unlinkCell$1(cell);
      this._deleteTableEntry$2(table, key);
      return cell.hashMapCellValue;
    },
    _modified$0: function() {
      this._modifications = this._modifications + 1 & 67108863;
    },
    _newLinkedCell$2: function(key, value) {
      var last, _this = this,
        cell = new H.LinkedHashMapCell(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1)));
      if (_this._first == null)
        _this._first = _this._last = cell;
      else {
        last = _this._last;
        cell._previous = last;
        _this._last = last._next = cell;
      }
      ++_this.__js_helper$_length;
      _this._modified$0();
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var _this = this,
        previous = cell._previous,
        next = cell._next;
      if (previous == null) {
        H.assertHelper(cell == _this._first);
        _this._first = next;
      } else
        previous._next = next;
      if (next == null) {
        H.assertHelper(cell == _this._last);
        _this._last = previous;
      } else
        next._previous = previous;
      --_this.__js_helper$_length;
      _this._modified$0();
    },
    internalComputeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    internalFindBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq$(bucket[i].hashMapCellKey, key))
          return i;
      return -1;
    },
    toString$0: function(_) {
      return P.MapBase_mapToString(this);
    },
    _getTableCell$2: function(table, key) {
      return table[key];
    },
    _getTableBucket$2: function(table, key) {
      return table[key];
    },
    _setTableEntry$3: function(table, key, value) {
      H.assertHelper(value != null);
      table[key] = value;
    },
    _deleteTableEntry$2: function(table, key) {
      delete table[key];
    },
    _containsTableEntry$2: function(table, key) {
      return this._getTableCell$2(table, key) != null;
    },
    _newHashTable$0: function() {
      var _s20_ = "<non-identifier-key>",
        table = Object.create(null);
      this._setTableEntry$3(table, _s20_, table);
      this._deleteTableEntry$2(table, _s20_);
      return table;
    },
    $isLinkedHashMap: 1
  };
  H.JsLinkedHashMap_values_closure.prototype = {
    call$1: function(each) {
      var t1 = this.$this;
      return t1.$index(0, H.assertSubtypeOfRuntimeType(each, H.getTypeArgumentByIndex(t1, 0)));
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: H.getTypeArgumentByIndex(t1, 1), args: [H.getTypeArgumentByIndex(t1, 0)]};
    }
  };
  H.JsLinkedHashMap_containsValue_closure.prototype = {
    call$1: function(each) {
      var t1 = this.$this;
      return J.$eq$(t1.$index(0, H.assertSubtypeOfRuntimeType(each, H.getTypeArgumentByIndex(t1, 0))), this.value);
    },
    $signature: function() {
      return {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(this.$this, 0)]};
    }
  };
  H.JsLinkedHashMap_addAll_closure.prototype = {
    call$2: function(key, value) {
      var t1 = this.$this;
      t1.$indexSet(0, H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(t1, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(t1, 1)));
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: P.Null, args: [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]};
    }
  };
  H.LinkedHashMapCell.prototype = {};
  H.LinkedHashMapKeyIterable.prototype = {
    get$length: function(_) {
      return this._map.__js_helper$_length;
    },
    get$isEmpty: function(_) {
      return this._map.__js_helper$_length === 0;
    },
    get$iterator: function(_) {
      var t1 = this._map,
        t2 = new H.LinkedHashMapKeyIterator(t1, t1._modifications, this.$ti);
      t2._cell = t1._first;
      return t2;
    },
    contains$1: function(_, element) {
      return this._map.containsKey$1(element);
    },
    forEach$1: function(_, f) {
      var t1, cell, modifications;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
      t1 = this._map;
      cell = t1._first;
      modifications = t1._modifications;
      for (; cell != null;) {
        f.call$1(cell.hashMapCellKey);
        if (modifications !== t1._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        cell = cell._next;
      }
    }
  };
  H.LinkedHashMapKeyIterator.prototype = {
    get$current: function() {
      return this.__js_helper$_current;
    },
    moveNext$0: function() {
      var _this = this,
        t1 = _this._map;
      if (_this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = _this._cell;
        if (t1 == null) {
          _this.set$__js_helper$_current(null);
          return false;
        } else {
          _this.set$__js_helper$_current(t1.hashMapCellKey);
          _this._cell = _this._cell._next;
          return true;
        }
      }
    },
    set$__js_helper$_current: function(_current) {
      this.__js_helper$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  H.initHooks_closure.prototype = {
    call$1: function(o) {
      return this.getTag(o);
    },
    $signature: 23
  };
  H.initHooks_closure0.prototype = {
    call$2: function(o, tag) {
      return this.getUnknownTag(o, tag);
    },
    $signature: 178
  };
  H.initHooks_closure1.prototype = {
    call$1: function(tag) {
      return this.prototypeForTag(H.stringTypeCheck(tag));
    },
    $signature: 136
  };
  H.JSSyntaxRegExp.prototype = {
    toString$0: function(_) {
      return "RegExp/" + this.pattern + "/";
    },
    get$_nativeAnchoredVersion: function() {
      var _this = this,
        t1 = _this._nativeAnchoredRegExp;
      if (t1 != null)
        return t1;
      t1 = _this._nativeRegExp;
      return _this._nativeAnchoredRegExp = H.JSSyntaxRegExp_makeNative(_this.pattern + "|()", t1.multiline, !t1.ignoreCase, true);
    },
    firstMatch$1: function(string) {
      var m;
      if (typeof string !== "string")
        H.throwExpression(H.argumentErrorValue(string));
      m = this._nativeRegExp.exec(string);
      if (m == null)
        return;
      return H._MatchImplementation$(this, m);
    },
    _execAnchored$2: function(string, start) {
      var match,
        regexp = this.get$_nativeAnchoredVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      if (0 >= match.length)
        return H.ioore(match, -1);
      if (match.pop() != null)
        return;
      return H._MatchImplementation$(this, match);
    },
    matchAsPrefix$2: function(_, string, start) {
      var t1 = string.length;
      if (start > t1)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      return this._execAnchored$2(string, start);
    },
    matchAsPrefix$1: function($receiver, string) {
      return this.matchAsPrefix$2($receiver, string, 0);
    },
    $isPattern: 1
  };
  H._MatchImplementation.prototype = {
    $index: function(_, index) {
      return C.JSArray_methods.$index(this._match, index);
    }
  };
  H.StringMatch.prototype = {
    $index: function(_, g) {
      H.throwExpression(P.RangeError$value(g, null));
      return this.pattern;
    }
  };
  H.NativeByteBuffer.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_ByteBuffer_RkP;
    },
    asInt64List$2: function(receiver, offsetInBytes, $length) {
      throw H.wrapException(P.UnsupportedError$("Int64List not supported by dart2js."));
    },
    $isByteBuffer: 1
  };
  H.NativeTypedData.prototype = {
    _invalidPosition$3: function(receiver, position, $length, $name) {
      var t1 = P.RangeError$range(position, 0, $length, $name, null);
      throw H.wrapException(t1);
    },
    _checkPosition$3: function(receiver, position, $length, $name) {
      if (position >>> 0 !== position || position > $length)
        this._invalidPosition$3(receiver, position, $length, $name);
    }
  };
  H.NativeByteData.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_ByteData_zNC;
    },
    getInt64$2: function(receiver, byteOffset, endian) {
      throw H.wrapException(P.UnsupportedError$("Int64 accessor not supported by dart2js."));
    },
    setInt64$3: function(receiver, byteOffset, value, endian) {
      throw H.wrapException(P.UnsupportedError$("Int64 accessor not supported by dart2js."));
    },
    $isByteData: 1
  };
  H.NativeTypedArray.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    _setRangeFast$4: function(receiver, start, end, source, skipCount) {
      var count, sourceLength,
        targetLength = receiver.length;
      this._checkPosition$3(receiver, start, targetLength, "start");
      this._checkPosition$3(receiver, end, targetLength, "end");
      if (start > end)
        throw H.wrapException(P.RangeError$range(start, 0, end, null, null));
      count = end - start;
      if (skipCount < 0)
        throw H.wrapException(P.ArgumentError$(skipCount));
      sourceLength = source.length;
      if (sourceLength - skipCount < count)
        throw H.wrapException(P.StateError$("Not enough elements"));
      if (skipCount !== 0 || sourceLength !== count)
        source = source.subarray(skipCount, skipCount + count);
      receiver.set(source, start);
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
    }
  };
  H.NativeTypedArrayOfDouble.prototype = {
    $index: function(receiver, index) {
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.doubleTypeCheck(value);
      H._checkValidIndex(index, receiver, receiver.length);
      receiver[index] = value;
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.double];
    },
    $asFixedLengthListMixin: function() {
      return [P.double];
    },
    $asListMixin: function() {
      return [P.double];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.double];
    },
    $isList: 1,
    $asList: function() {
      return [P.double];
    }
  };
  H.NativeTypedArrayOfInt.prototype = {
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(value);
      H._checkValidIndex(index, receiver, receiver.length);
      receiver[index] = value;
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      H.assertSubtype(iterable, "$isIterable", [P.int], "$asIterable");
      if (!!J.getInterceptor$(iterable).$isNativeTypedArrayOfInt) {
        this._setRangeFast$4(receiver, start, end, iterable, skipCount);
        return;
      }
      this.super$ListMixin$setRange(receiver, start, end, iterable, skipCount);
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $asFixedLengthListMixin: function() {
      return [P.int];
    },
    $asListMixin: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    }
  };
  H.NativeFloat64List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Float64List_LB7;
    },
    $isFloat64List: 1
  };
  H.NativeInt32List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Int32List_O50;
    },
    $index: function(receiver, index) {
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isInt32List: 1
  };
  H.NativeInt8List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Int8List_ekJ;
    },
    $index: function(receiver, index) {
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    }
  };
  H.NativeUint16List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Uint16List_2bx;
    },
    $index: function(receiver, index) {
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    }
  };
  H.NativeUint8List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Uint8List_WLA;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $isNativeUint8List: 1,
    $isUint8List: 1
  };
  H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin.prototype = {};
  H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin.prototype = {};
  H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin.prototype = {};
  H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin.prototype = {};
  P._AsyncRun__initializeScheduleImmediate_internalCallback.prototype = {
    call$1: function(_) {
      var t1 = this._box_0,
        f = t1.storedCallback;
      t1.storedCallback = null;
      f.call$0();
    },
    $signature: 12
  };
  P._AsyncRun__initializeScheduleImmediate_closure.prototype = {
    call$1: function(callback) {
      var t1, t2;
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      t1 = this._box_0;
      H.assertHelper(t1.storedCallback == null);
      t1.storedCallback = callback;
      t1 = this.div;
      t2 = this.span;
      t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
    },
    $signature: 121
  };
  P._AsyncRun__scheduleImmediateJsOverride_internalCallback.prototype = {
    call$0: function() {
      this.callback.call$0();
    },
    $signature: 2
  };
  P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback.prototype = {
    call$0: function() {
      this.callback.call$0();
    },
    $signature: 2
  };
  P._TimerImpl.prototype = {
    _TimerImpl$2: function(milliseconds, callback) {
      if (self.setTimeout != null)
        this._handle = self.setTimeout(H.convertDartClosureToJS(new P._TimerImpl_internalCallback(this, callback), 0), milliseconds);
      else
        throw H.wrapException(P.UnsupportedError$("`setTimeout()` not found."));
    },
    cancel$0: function() {
      if (self.setTimeout != null) {
        var t1 = this._handle;
        if (t1 == null)
          return;
        self.clearTimeout(t1);
        this._handle = null;
      } else
        throw H.wrapException(P.UnsupportedError$("Canceling a timer."));
    },
    $isTimer: 1
  };
  P._TimerImpl_internalCallback.prototype = {
    call$0: function() {
      this.$this._handle = null;
      this.callback.call$0();
    },
    $signature: 1
  };
  P._AsyncAwaitCompleter.prototype = {
    complete$1: function(value) {
      var t1, _this = this;
      H.futureOrCheck(value, {futureOr: 1, type: H.getTypeArgumentByIndex(_this, 0)});
      if (_this.isSync)
        _this._completer.complete$1(value);
      else if (H.checkSubtype(value, "$isFuture", _this.$ti, "$asFuture")) {
        t1 = _this._completer;
        value.then$1$2$onError(t1.get$complete(), t1.get$completeError(), -1);
      } else
        P.scheduleMicrotask(new P._AsyncAwaitCompleter_complete_closure(_this, value));
    },
    completeError$2: function(e, st) {
      if (this.isSync)
        this._completer.completeError$2(e, st);
      else
        P.scheduleMicrotask(new P._AsyncAwaitCompleter_completeError_closure(this, e, st));
    },
    $isCompleter: 1
  };
  P._AsyncAwaitCompleter_complete_closure.prototype = {
    call$0: function() {
      this.$this._completer.complete$1(this.value);
    },
    $signature: 2
  };
  P._AsyncAwaitCompleter_completeError_closure.prototype = {
    call$0: function() {
      this.$this._completer.completeError$2(this.e, this.st);
    },
    $signature: 2
  };
  P._awaitOnObject_closure.prototype = {
    call$1: function(result) {
      return this.bodyFunction.call$2(0, result);
    },
    $signature: 120
  };
  P._awaitOnObject_closure0.prototype = {
    call$2: function(error, stackTrace) {
      this.bodyFunction.call$2(1, new H.ExceptionAndStackTrace(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace")));
    },
    $signature: 57
  };
  P._wrapJsFunctionForAsync_closure.prototype = {
    call$2: function(errorCode, result) {
      this.$protected(H.intTypeCheck(errorCode), result);
    },
    $signature: 94
  };
  P._asyncStarHelper_closure.prototype = {
    call$0: function() {
      var t1 = this.controller,
        t2 = t1.controller,
        t3 = t2._state;
      if ((t3 & 1) !== 0 ? (t2.get$_subscription()._state & 4) !== 0 : (t3 & 2) === 0) {
        t1.isSuspended = true;
        return;
      }
      this.bodyFunctionOrErrorCode.call$2(null, 0);
    },
    $signature: 2
  };
  P._asyncStarHelper_closure0.prototype = {
    call$1: function(_) {
      var errorCode = this.controller.cancelationCompleter != null ? 2 : 0;
      this.bodyFunctionOrErrorCode.call$2(errorCode, null);
    },
    $signature: 12
  };
  P._AsyncStarStreamController.prototype = {
    _AsyncStarStreamController$1: function(body, $T) {
      var t1 = new P._AsyncStarStreamController__resumeBody(body);
      this.set$controller(new P._AsyncStreamController(new P._AsyncStarStreamController_closure(t1), null, new P._AsyncStarStreamController_closure0(this, t1), new P._AsyncStarStreamController_closure1(this, body), [$T]));
    },
    set$controller: function(controller) {
      this.controller = H.assertSubtype(controller, "$isStreamController", this.$ti, "$asStreamController");
    }
  };
  P._AsyncStarStreamController__resumeBody.prototype = {
    call$0: function() {
      P.scheduleMicrotask(new P._AsyncStarStreamController__resumeBody_closure(this.body));
    },
    $signature: 2
  };
  P._AsyncStarStreamController__resumeBody_closure.prototype = {
    call$0: function() {
      this.body.call$2(0, null);
    },
    $signature: 2
  };
  P._AsyncStarStreamController_closure.prototype = {
    call$0: function() {
      this._resumeBody.call$0();
    },
    $signature: 2
  };
  P._AsyncStarStreamController_closure0.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (t1.isSuspended) {
        t1.isSuspended = false;
        this._resumeBody.call$0();
      }
    },
    $signature: 2
  };
  P._AsyncStarStreamController_closure1.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if ((t1.controller._state & 4) === 0) {
        t1.cancelationCompleter = new P._AsyncCompleter(new P._Future($.Zone__current, [null]), [null]);
        if (t1.isSuspended) {
          t1.isSuspended = false;
          P.scheduleMicrotask(new P._AsyncStarStreamController__closure(this.body));
        }
        return t1.cancelationCompleter.future;
      }
    },
    $signature: 89
  };
  P._AsyncStarStreamController__closure.prototype = {
    call$0: function() {
      this.body.call$2(2, null);
    },
    $signature: 2
  };
  P._IterationMarker.prototype = {
    toString$0: function(_) {
      return "IterationMarker(" + this.state + ", " + H.S(this.value) + ")";
    }
  };
  P._SyncStarIterator.prototype = {
    get$current: function() {
      var t1 = this._nestedIterator;
      if (t1 == null)
        return this._async$_current;
      return H.assertSubtypeOfRuntimeType(t1.get$current(), H.getTypeArgumentByIndex(this, 0));
    },
    moveNext$0: function() {
      var t1, value, state, inner, _this = this;
      for (; true;) {
        t1 = _this._nestedIterator;
        if (t1 != null)
          if (t1.moveNext$0())
            return true;
          else
            _this._nestedIterator = null;
        value = function(body, SUCCESS, ERROR) {
          var errorValue,
            errorCode = SUCCESS;
          while (true)
            try {
              return body(errorCode, errorValue);
            } catch (error) {
              errorValue = error;
              errorCode = ERROR;
            }
        }(_this._body, 0, 1);
        if (value instanceof P._IterationMarker) {
          state = value.state;
          if (state === 2) {
            t1 = _this._suspendedBodies;
            if (t1 == null || t1.length === 0) {
              _this.set$_async$_current(null);
              return false;
            }
            if (0 >= t1.length)
              return H.ioore(t1, -1);
            _this._body = t1.pop();
            continue;
          } else {
            t1 = value.value;
            if (state === 3)
              throw t1;
            else {
              H.assertHelper(state === 1);
              inner = J.get$iterator$ax(t1);
              if (!!inner.$is_SyncStarIterator) {
                t1 = _this._suspendedBodies;
                if (t1 == null)
                  t1 = _this._suspendedBodies = [];
                C.JSArray_methods.add$1(t1, _this._body);
                _this._body = inner._body;
                continue;
              } else {
                _this._nestedIterator = inner;
                continue;
              }
            }
          }
        } else {
          _this.set$_async$_current(value);
          return true;
        }
      }
      return false;
    },
    set$_async$_current: function(_current) {
      this._async$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  P._SyncStarIterable.prototype = {
    get$iterator: function(_) {
      return new P._SyncStarIterator(this._outerHelper(), this.$ti);
    }
  };
  P.Future.prototype = {};
  P.Future_Future$delayed_closure.prototype = {
    call$0: function() {
      this.result._complete$1(null);
    },
    $signature: 2
  };
  P.Future_wait_handleError.prototype = {
    call$2: function(theError, theStackTrace) {
      var t1, t2, _this = this;
      H.interceptedTypeCheck(theStackTrace, "$isStackTrace");
      t1 = _this._box_0;
      t2 = --t1.remaining;
      if (t1.values != null) {
        t1.values = null;
        if (t1.remaining === 0 || _this.eagerError)
          _this.result._completeError$2(theError, theStackTrace);
        else {
          t1.error = theError;
          t1.stackTrace = theStackTrace;
        }
      } else if (t2 === 0 && !_this.eagerError)
        _this.result._completeError$2(t1.error, t1.stackTrace);
    },
    $signature: 57
  };
  P.Future_wait_closure.prototype = {
    call$1: function(value) {
      var t1, t2, _this = this;
      H.assertSubtypeOfRuntimeType(value, _this.T);
      t1 = _this._box_0;
      --t1.remaining;
      t2 = t1.values;
      if (t2 != null) {
        C.JSArray_methods.$indexSet(t2, _this.pos, value);
        if (t1.remaining === 0)
          _this.result._completeWithValue$1(t1.values);
      } else if (t1.remaining === 0 && !_this.eagerError)
        _this.result._completeError$2(t1.error, t1.stackTrace);
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [this.T]};
    }
  };
  P._Completer.prototype = {
    completeError$2: function(error, stackTrace) {
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      if (error == null)
        error = new P.NullThrownError();
      if (this.future._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      $.Zone__current.toString;
      this._completeError$2(error, stackTrace);
    },
    completeError$1: function(error) {
      return this.completeError$2(error, null);
    },
    $isCompleter: 1
  };
  P._AsyncCompleter.prototype = {
    complete$1: function(value) {
      var t1;
      H.futureOrCheck(value, {futureOr: 1, type: H.getTypeArgumentByIndex(this, 0)});
      t1 = this.future;
      if (t1._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._asyncComplete$1(value);
    },
    complete$0: function() {
      return this.complete$1(null);
    },
    _completeError$2: function(error, stackTrace) {
      this.future._asyncCompleteError$2(error, stackTrace);
    }
  };
  P._SyncCompleter.prototype = {
    complete$1: function(value) {
      var t1;
      H.futureOrCheck(value, {futureOr: 1, type: H.getTypeArgumentByIndex(this, 0)});
      t1 = this.future;
      if (t1._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._complete$1(value);
    },
    complete$0: function() {
      return this.complete$1(null);
    },
    _completeError$2: function(error, stackTrace) {
      this.future._completeError$2(error, stackTrace);
    }
  };
  P._FutureListener.prototype = {
    matchesErrorTest$1: function(asyncError) {
      if (this.state !== 6)
        return true;
      return this.result._zone.runUnary$2$2(H.functionTypeCheck(this.callback, {func: 1, ret: P.bool, args: [P.Object]}), asyncError.error, P.bool, P.Object);
    },
    handleError$1: function(asyncError) {
      var errorCallback, t2, t3, _this = this,
        t1 = (_this.state & 2) !== 0;
      if (t1) {
        H.assertHelper(t1);
        t1 = _this.errorCallback != null;
      } else
        t1 = false;
      H.assertHelper(t1);
      errorCallback = _this.errorCallback;
      t1 = P.Object;
      t2 = {futureOr: 1, type: H.getTypeArgumentByIndex(_this, 1)};
      t3 = _this.result._zone;
      if (H.functionTypeTest(errorCallback, {func: 1, args: [P.Object, P.StackTrace]}))
        return H.futureOrCheck(t3.runBinary$3$3(errorCallback, asyncError.error, asyncError.stackTrace, null, t1, P.StackTrace), t2);
      else {
        H.assertHelper(H.functionTypeTest(errorCallback, {func: 1, args: [P.Object]}));
        return H.futureOrCheck(t3.runUnary$2$2(errorCallback, asyncError.error, null, t1), t2);
      }
    }
  };
  P._Future.prototype = {
    then$1$2$onError: function(f, onError, $R) {
      var currentZone,
        t1 = H.getTypeArgumentByIndex(this, 0);
      H.functionTypeCheck(f, {func: 1, ret: {futureOr: 1, type: $R}, args: [t1]});
      currentZone = $.Zone__current;
      if (currentZone !== C.C__RootZone) {
        currentZone.toString;
        H.functionTypeCheck(f, {func: 1, ret: {futureOr: 1, type: $R}, args: [t1]});
        if (onError != null)
          onError = P._registerErrorHandler(onError, currentZone);
      }
      return this._thenNoZoneRegistration$1$2(f, onError, $R);
    },
    then$1$1: function(f, $R) {
      return this.then$1$2$onError(f, null, $R);
    },
    then$1: function(f) {
      return this.then$1$2$onError(f, null, null);
    },
    _thenNoZoneRegistration$1$2: function(f, onError, $E) {
      var result, t2,
        t1 = H.getTypeArgumentByIndex(this, 0);
      H.functionTypeCheck(f, {func: 1, ret: {futureOr: 1, type: $E}, args: [t1]});
      result = new P._Future($.Zone__current, [$E]);
      t2 = onError == null ? 1 : 3;
      this._addListener$1(new P._FutureListener(result, t2, f, onError, [t1, $E]));
      return result;
    },
    whenComplete$1: function(action) {
      var t1, result;
      H.functionTypeCheck(action, {func: 1});
      t1 = $.Zone__current;
      result = new P._Future(t1, this.$ti);
      if (t1 !== C.C__RootZone) {
        t1.toString;
        H.functionTypeCheck(action, {func: 1, ret: null});
      }
      t1 = H.getTypeArgumentByIndex(this, 0);
      this._addListener$1(new P._FutureListener(result, 8, action, null, [t1, t1]));
      return result;
    },
    _cloneResult$1: function(source) {
      H.assertHelper(this._state < 4);
      H.assertHelper(source._state >= 4);
      this._state = source._state;
      this._resultOrListeners = source._resultOrListeners;
    },
    _addListener$1: function(listener) {
      var t1, source, _this = this;
      H.assertHelper(listener._nextListener == null);
      t1 = _this._state;
      if (t1 <= 1) {
        listener._nextListener = H.interceptedTypeCheck(_this._resultOrListeners, "$is_FutureListener");
        _this._resultOrListeners = listener;
      } else {
        if (t1 === 2) {
          source = H.interceptedTypeCheck(_this._resultOrListeners, "$is_Future");
          if (source._state < 4) {
            source._addListener$1(listener);
            return;
          }
          _this._cloneResult$1(source);
        }
        H.assertHelper(_this._state >= 4);
        t1 = _this._zone;
        t1.toString;
        P._rootScheduleMicrotask(null, null, t1, H.functionTypeCheck(new P._Future__addListener_closure(_this, listener), {func: 1, ret: -1}));
      }
    },
    _prependListeners$1: function(listeners) {
      var t1, existingListeners, cursor, cursor0, source, _this = this, _box_0 = {};
      _box_0.listeners = listeners;
      if (listeners == null)
        return;
      t1 = _this._state;
      if (t1 <= 1) {
        existingListeners = H.interceptedTypeCheck(_this._resultOrListeners, "$is_FutureListener");
        cursor = _this._resultOrListeners = listeners;
        if (existingListeners != null) {
          for (; cursor0 = cursor._nextListener, cursor0 != null; cursor = cursor0)
            ;
          cursor._nextListener = existingListeners;
        }
      } else {
        if (t1 === 2) {
          source = H.interceptedTypeCheck(_this._resultOrListeners, "$is_Future");
          if (source._state < 4) {
            source._prependListeners$1(listeners);
            return;
          }
          _this._cloneResult$1(source);
        }
        H.assertHelper(_this._state >= 4);
        _box_0.listeners = _this._reverseListeners$1(listeners);
        t1 = _this._zone;
        t1.toString;
        P._rootScheduleMicrotask(null, null, t1, H.functionTypeCheck(new P._Future__prependListeners_closure(_box_0, _this), {func: 1, ret: -1}));
      }
    },
    _removeListeners$0: function() {
      var current, _this = this;
      H.assertHelper(_this._state < 4);
      current = H.interceptedTypeCheck(_this._resultOrListeners, "$is_FutureListener");
      _this._resultOrListeners = null;
      return _this._reverseListeners$1(current);
    },
    _reverseListeners$1: function(listeners) {
      var current, prev, next;
      for (current = listeners, prev = null; current != null; prev = current, current = next) {
        next = current._nextListener;
        current._nextListener = prev;
      }
      return prev;
    },
    _complete$1: function(value) {
      var t2, listeners, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.futureOrCheck(value, {futureOr: 1, type: t1});
      H.assertHelper(_this._state < 4);
      t2 = _this.$ti;
      if (H.checkSubtype(value, "$isFuture", t2, "$asFuture"))
        if (H.checkSubtype(value, "$is_Future", t2, null))
          P._Future__chainCoreFuture(value, _this);
        else
          P._Future__chainForeignFuture(value, _this);
      else {
        listeners = _this._removeListeners$0();
        H.assertSubtypeOfRuntimeType(value, t1);
        H.assertHelper(_this._state < 4);
        _this._state = 4;
        _this._resultOrListeners = value;
        P._Future__propagateToListeners(_this, listeners);
      }
    },
    _completeWithValue$1: function(value) {
      var listeners, _this = this;
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 0));
      H.assertHelper(_this._state < 4);
      H.assertHelper(!H.checkSubtype(value, "$isFuture", _this.$ti, "$asFuture"));
      listeners = _this._removeListeners$0();
      H.assertHelper(_this._state < 4);
      _this._state = 4;
      _this._resultOrListeners = value;
      P._Future__propagateToListeners(_this, listeners);
    },
    _completeError$2: function(error, stackTrace) {
      var listeners, _this = this;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      H.assertHelper(_this._state < 4);
      listeners = _this._removeListeners$0();
      H.assertHelper(_this._state < 4);
      _this._state = 8;
      _this._resultOrListeners = new P.AsyncError(error, stackTrace);
      P._Future__propagateToListeners(_this, listeners);
    },
    _completeError$1: function(error) {
      return this._completeError$2(error, null);
    },
    _asyncComplete$1: function(value) {
      var t1, _this = this;
      H.futureOrCheck(value, {futureOr: 1, type: H.getTypeArgumentByIndex(_this, 0)});
      H.assertHelper(_this._state < 4);
      if (H.checkSubtype(value, "$isFuture", _this.$ti, "$asFuture")) {
        _this._chainFuture$1(value);
        return;
      }
      H.assertHelper(_this._state === 0);
      _this._state = 1;
      t1 = _this._zone;
      t1.toString;
      P._rootScheduleMicrotask(null, null, t1, H.functionTypeCheck(new P._Future__asyncComplete_closure(_this, value), {func: 1, ret: -1}));
    },
    _chainFuture$1: function(value) {
      var _this = this,
        t1 = _this.$ti;
      H.assertSubtype(value, "$isFuture", t1, "$asFuture");
      if (H.checkSubtype(value, "$is_Future", t1, null)) {
        if (value._state === 8) {
          H.assertHelper(_this._state === 0);
          _this._state = 1;
          t1 = _this._zone;
          t1.toString;
          P._rootScheduleMicrotask(null, null, t1, H.functionTypeCheck(new P._Future__chainFuture_closure(_this, value), {func: 1, ret: -1}));
        } else
          P._Future__chainCoreFuture(value, _this);
        return;
      }
      P._Future__chainForeignFuture(value, _this);
    },
    _asyncCompleteError$2: function(error, stackTrace) {
      var t1, _this = this;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      H.assertHelper(_this._state < 4);
      H.assertHelper(_this._state === 0);
      _this._state = 1;
      t1 = _this._zone;
      t1.toString;
      P._rootScheduleMicrotask(null, null, t1, H.functionTypeCheck(new P._Future__asyncCompleteError_closure(_this, error, stackTrace), {func: 1, ret: -1}));
    },
    $isFuture: 1
  };
  P._Future__addListener_closure.prototype = {
    call$0: function() {
      P._Future__propagateToListeners(this.$this, this.listener);
    },
    $signature: 2
  };
  P._Future__prependListeners_closure.prototype = {
    call$0: function() {
      P._Future__propagateToListeners(this.$this, this._box_0.listeners);
    },
    $signature: 2
  };
  P._Future__chainForeignFuture_closure.prototype = {
    call$1: function(value) {
      var t1 = this.target;
      H.assertHelper(t1._state === 1);
      H.assertHelper(t1._state === 1);
      t1._state = 0;
      t1._complete$1(value);
    },
    $signature: 12
  };
  P._Future__chainForeignFuture_closure0.prototype = {
    call$2: function(error, stackTrace) {
      var t1;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      t1 = this.target;
      H.assertHelper(t1._state === 1);
      t1._completeError$2(error, stackTrace);
    },
    call$1: function(error) {
      return this.call$2(error, null);
    },
    $signature: 99
  };
  P._Future__chainForeignFuture_closure1.prototype = {
    call$0: function() {
      this.target._completeError$2(this.e, this.s);
    },
    $signature: 2
  };
  P._Future__asyncComplete_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._completeWithValue$1(H.assertSubtypeOfRuntimeType(this.value, H.getTypeArgumentByIndex(t1, 0)));
    },
    $signature: 2
  };
  P._Future__chainFuture_closure.prototype = {
    call$0: function() {
      P._Future__chainCoreFuture(this.value, this.$this);
    },
    $signature: 2
  };
  P._Future__asyncCompleteError_closure.prototype = {
    call$0: function() {
      this.$this._completeError$2(this.error, this.stackTrace);
    },
    $signature: 2
  };
  P._Future__propagateToListeners_handleWhenCompleteCallback.prototype = {
    call$0: function() {
      var completeResult, e, s, t3, exception, originalSource, _this = this,
        t1 = _this.listener,
        t2 = t1.state;
      H.assertHelper((t2 & 1) === 0);
      t3 = (t2 & 2) === 0;
      H.assertHelper(t3);
      completeResult = null;
      try {
        H.assertHelper(t3);
        H.assertHelper(t2 === 8);
        completeResult = t1.result._zone.run$1$1(H.functionTypeCheck(t1.callback, {func: 1}), null);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        if (_this.hasError) {
          t1 = _this._box_1.source;
          H.assertHelper(t1._state === 8);
          t1 = H.interceptedTypeCheck(t1._resultOrListeners, "$isAsyncError").error;
          t2 = e;
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = false;
        t2 = _this._box_0;
        if (t1) {
          t1 = _this._box_1.source;
          H.assertHelper(t1._state === 8);
          t2.listenerValueOrError = H.interceptedTypeCheck(t1._resultOrListeners, "$isAsyncError");
        } else
          t2.listenerValueOrError = new P.AsyncError(e, s);
        t2.listenerHasError = true;
        return;
      }
      if (!!J.getInterceptor$(completeResult).$isFuture) {
        if (completeResult instanceof P._Future && completeResult._state >= 4) {
          if (completeResult._state === 8) {
            t1 = completeResult;
            H.assertHelper(t1._state === 8);
            t2 = _this._box_0;
            t2.listenerValueOrError = H.interceptedTypeCheck(t1._resultOrListeners, "$isAsyncError");
            t2.listenerHasError = true;
          }
          return;
        }
        originalSource = _this._box_1.source;
        t1 = _this._box_0;
        t1.listenerValueOrError = completeResult.then$1$1(new P._Future__propagateToListeners_handleWhenCompleteCallback_closure(originalSource), null);
        t1.listenerHasError = false;
      }
    },
    $signature: 1
  };
  P._Future__propagateToListeners_handleWhenCompleteCallback_closure.prototype = {
    call$1: function(_) {
      return this.originalSource;
    },
    $signature: 92
  };
  P._Future__propagateToListeners_handleValueCallback.prototype = {
    call$0: function() {
      var e, s, t1, t2, t3, t4, exception, _this = this;
      try {
        t1 = _this.listener;
        t2 = H.getTypeArgumentByIndex(t1, 0);
        t3 = H.assertSubtypeOfRuntimeType(_this.sourceResult, t2);
        H.assertHelper((t1.state & 1) !== 0);
        t4 = H.getTypeArgumentByIndex(t1, 1);
        _this._box_0.listenerValueOrError = t1.result._zone.runUnary$2$2(H.functionTypeCheck(t1.callback, {func: 1, ret: {futureOr: 1, type: t4}, args: [t2]}), t3, {futureOr: 1, type: t4}, t2);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        t1 = _this._box_0;
        t1.listenerValueOrError = new P.AsyncError(e, s);
        t1.listenerHasError = true;
      }
    },
    $signature: 1
  };
  P._Future__propagateToListeners_handleError.prototype = {
    call$0: function() {
      var asyncError, e, s, t1, t2, exception, t3, t4, _this = this;
      try {
        t1 = _this._box_1.source;
        H.assertHelper(t1._state === 8);
        asyncError = H.interceptedTypeCheck(t1._resultOrListeners, "$isAsyncError");
        t1 = _this.listener;
        if (H.boolConversionCheck(t1.matchesErrorTest$1(asyncError))) {
          H.assertHelper((t1.state & 2) !== 0);
          t2 = t1.errorCallback != null;
        } else
          t2 = false;
        if (t2) {
          t2 = _this._box_0;
          t2.listenerValueOrError = t1.handleError$1(asyncError);
          t2.listenerHasError = false;
        }
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        t1 = _this._box_1;
        t2 = t1.source;
        H.assertHelper(t2._state === 8);
        t2 = H.interceptedTypeCheck(t2._resultOrListeners, "$isAsyncError").error;
        t3 = e;
        t4 = _this._box_0;
        if (t2 == null ? t3 == null : t2 === t3) {
          t1 = t1.source;
          H.assertHelper(t1._state === 8);
          t4.listenerValueOrError = H.interceptedTypeCheck(t1._resultOrListeners, "$isAsyncError");
        } else
          t4.listenerValueOrError = new P.AsyncError(e, s);
        t4.listenerHasError = true;
      }
    },
    $signature: 1
  };
  P._AsyncCallbackEntry.prototype = {};
  P.Stream.prototype = {
    get$length: function(_) {
      var t1 = {},
        future = new P._Future($.Zone__current, [P.int]);
      t1.count = 0;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_length_closure(t1, this), true, new P.Stream_length_closure0(t1, future), future.get$_completeError());
      return future;
    },
    get$isEmpty: function(_) {
      var t1 = {},
        future = new P._Future($.Zone__current, [P.bool]);
      t1.subscription = null;
      t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_isEmpty_closure(t1, this, future), true, new P.Stream_isEmpty_closure0(future), future.get$_completeError());
      return future;
    }
  };
  P.Stream_Stream$fromIterable_closure.prototype = {
    call$0: function() {
      return new P._IterablePendingEvents(J.get$iterator$ax(this.elements), [this.T]);
    },
    $signature: function() {
      return {func: 1, ret: [P._IterablePendingEvents, this.T]};
    }
  };
  P.Stream_length_closure.prototype = {
    call$1: function(_) {
      H.assertSubtypeOfRuntimeType(_, H.getRuntimeTypeArgument(this.$this, "Stream", 0));
      ++this._box_0.count;
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
    }
  };
  P.Stream_length_closure0.prototype = {
    call$0: function() {
      this.future._complete$1(this._box_0.count);
    },
    $signature: 2
  };
  P.Stream_isEmpty_closure.prototype = {
    call$1: function(_) {
      H.assertSubtypeOfRuntimeType(_, H.getRuntimeTypeArgument(this.$this, "Stream", 0));
      P._cancelAndValue(this._box_0.subscription, this.future, false);
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
    }
  };
  P.Stream_isEmpty_closure0.prototype = {
    call$0: function() {
      this.future._complete$1(true);
    },
    $signature: 2
  };
  P.StreamTransformerBase.prototype = {};
  P._StreamController.prototype = {
    get$_pendingEvents: function() {
      var t1, _this = this;
      H.assertHelper((_this._state & 3) === 0);
      if ((_this._state & 8) === 0)
        return H.assertSubtype(_this._varData, "$is_PendingEvents", _this.$ti, "$as_PendingEvents");
      t1 = _this.$ti;
      return H.assertSubtype(H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState").varData, "$is_PendingEvents", t1, "$as_PendingEvents");
    },
    _ensurePendingEvents$0: function() {
      var t1, state, t2, _this = this;
      H.assertHelper((_this._state & 3) === 0);
      if ((_this._state & 8) === 0) {
        t1 = _this._varData;
        if (t1 == null)
          t1 = _this._varData = new P._StreamImplEvents(_this.$ti);
        return H.assertSubtype(t1, "$is_StreamImplEvents", _this.$ti, "$as_StreamImplEvents");
      }
      t1 = _this.$ti;
      state = H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState");
      t2 = state.varData;
      return H.assertSubtype(t2 == null ? state.varData = new P._StreamImplEvents(t1) : t2, "$is_StreamImplEvents", t1, "$as_StreamImplEvents");
    },
    get$_subscription: function() {
      var t1, _this = this;
      H.assertHelper((_this._state & 1) !== 0);
      if ((_this._state & 8) !== 0) {
        t1 = _this.$ti;
        return H.assertSubtype(H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState").varData, "$is_ControllerSubscription", t1, "$as_ControllerSubscription");
      }
      return H.assertSubtype(_this._varData, "$is_ControllerSubscription", _this.$ti, "$as_ControllerSubscription");
    },
    _badEventState$0: function() {
      var t1 = this._state;
      if ((t1 & 4) !== 0)
        return new P.StateError("Cannot add event after closing");
      H.assertHelper((t1 & 8) !== 0);
      return new P.StateError("Cannot add event while adding a stream");
    },
    addStream$2$cancelOnError: function(source, cancelOnError) {
      var t2, t3, t4, t5, _this = this,
        t1 = _this.$ti;
      H.assertSubtype(source, "$isStream", t1, "$asStream");
      t2 = _this._state;
      if (t2 >= 4)
        throw H.wrapException(_this._badEventState$0());
      if ((t2 & 2) !== 0) {
        t1 = new P._Future($.Zone__current, [null]);
        t1._asyncComplete$1(null);
        return t1;
      }
      t2 = _this._varData;
      t3 = new P._Future($.Zone__current, [null]);
      t4 = source.listen$4$cancelOnError$onDone$onError(_this.get$_async$_add(), false, _this.get$_close(), _this.get$_addError());
      t5 = _this._state;
      if ((t5 & 1) !== 0 ? (_this.get$_subscription()._state & 4) !== 0 : (t5 & 2) === 0)
        t4.pause$0();
      _this._varData = new P._StreamControllerAddStreamState(t2, t3, t4, t1);
      _this._state |= 8;
      return t3;
    },
    _ensureDoneFuture$0: function() {
      var t1 = this._doneFuture;
      if (t1 == null)
        t1 = this._doneFuture = (this._state & 2) !== 0 ? $.$get$Future__nullFuture() : new P._Future($.Zone__current, [null]);
      return t1;
    },
    close$0: function() {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 4) !== 0)
        return _this._ensureDoneFuture$0();
      if (t1 >= 4)
        throw H.wrapException(_this._badEventState$0());
      t1 = _this._state = t1 | 4;
      if ((t1 & 1) !== 0)
        _this._sendDone$0();
      else if ((t1 & 3) === 0)
        _this._ensurePendingEvents$0().add$1(0, C.C__DelayedDone);
      return _this._ensureDoneFuture$0();
    },
    _async$_add$1: function(value) {
      var t1, _this = this;
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 0));
      t1 = _this._state;
      if ((t1 & 1) !== 0)
        _this._sendData$1(value);
      else if ((t1 & 3) === 0)
        _this._ensurePendingEvents$0().add$1(0, new P._DelayedData(value, _this.$ti));
    },
    _addError$2: function(error, stackTrace) {
      var t1;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      t1 = this._state;
      if ((t1 & 1) !== 0)
        this._sendError$2(error, stackTrace);
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, new P._DelayedError(error, stackTrace));
    },
    _close$0: function() {
      var addState, _this = this;
      H.assertHelper((_this._state & 8) !== 0);
      addState = H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", _this.$ti, "$as_StreamControllerAddStreamState");
      _this._varData = addState.varData;
      _this._state &= 4294967287;
      addState.addStreamFuture._asyncComplete$1(null);
    },
    _subscribe$4: function(onData, onError, onDone, cancelOnError) {
      var t2, t3, t4, subscription, pendingEvents, addState, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]});
      H.functionTypeCheck(onDone, {func: 1, ret: -1});
      if ((_this._state & 3) !== 0)
        throw H.wrapException(P.StateError$("Stream has already been listened to."));
      t2 = $.Zone__current;
      t3 = cancelOnError ? 1 : 0;
      t4 = _this.$ti;
      subscription = new P._ControllerSubscription(_this, t2, t3, t4);
      subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, t1);
      pendingEvents = _this.get$_pendingEvents();
      t1 = _this._state |= 1;
      if ((t1 & 8) !== 0) {
        addState = H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t4, "$as_StreamControllerAddStreamState");
        addState.varData = subscription;
        addState.addSubscription.resume$0();
      } else
        _this._varData = subscription;
      subscription._setPendingEvents$1(pendingEvents);
      subscription._guardCallback$1(new P._StreamController__subscribe_closure(_this));
      return subscription;
    },
    _recordCancel$1: function(subscription) {
      var result, e, s, exception, result0, _this = this,
        t1 = _this.$ti;
      H.assertSubtype(subscription, "$isStreamSubscription", t1, "$asStreamSubscription");
      result = null;
      if ((_this._state & 8) !== 0)
        result = H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState").cancel$0();
      _this._varData = null;
      _this._state = _this._state & 4294967286 | 2;
      if (result == null)
        try {
          result = H.interceptedTypeCheck(_this.onCancel.call$0(), "$isFuture");
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          result0 = new P._Future($.Zone__current, [null]);
          result0._asyncCompleteError$2(e, s);
          result = result0;
        }
      else
        result = result.whenComplete$1(_this.onCancel);
      t1 = new P._StreamController__recordCancel_complete(_this);
      if (result != null)
        result = result.whenComplete$1(t1);
      else
        t1.call$0();
      return result;
    },
    $isStreamController: 1,
    $is_StreamControllerLifecycle: 1,
    $is_EventDispatch: 1
  };
  P._StreamController__subscribe_closure.prototype = {
    call$0: function() {
      P._runGuarded(this.$this.onListen);
    },
    $signature: 2
  };
  P._StreamController__recordCancel_complete.prototype = {
    call$0: function() {
      var t1 = this.$this._doneFuture;
      if (t1 != null && t1._state === 0)
        t1._asyncComplete$1(null);
    },
    $signature: 1
  };
  P._AsyncStreamControllerDispatch.prototype = {
    _sendData$1: function(data) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      H.assertSubtypeOfRuntimeType(data, t1);
      this.get$_subscription()._addPending$1(new P._DelayedData(data, [t1]));
    },
    _sendError$2: function(error, stackTrace) {
      this.get$_subscription()._addPending$1(new P._DelayedError(error, stackTrace));
    },
    _sendDone$0: function() {
      this.get$_subscription()._addPending$1(C.C__DelayedDone);
    }
  };
  P._AsyncStreamController.prototype = {};
  P._ControllerStream.prototype = {
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      return this._async$_controller._subscribe$4(H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]}), onError, H.functionTypeCheck(onDone, {func: 1, ret: -1}), cancelOnError);
    },
    get$hashCode: function(_) {
      return (H.Primitives_objectHashCode(this._async$_controller) ^ 892482866) >>> 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      return other instanceof P._ControllerStream && other._async$_controller === this._async$_controller;
    }
  };
  P._ControllerSubscription.prototype = {
    _onCancel$0: function() {
      return this._async$_controller._recordCancel$1(this);
    },
    _onPause$0: function() {
      var t1 = this._async$_controller,
        t2 = H.getTypeArgumentByIndex(t1, 0);
      H.assertSubtype(this, "$isStreamSubscription", [t2], "$asStreamSubscription");
      if ((t1._state & 8) !== 0)
        H.assertSubtype(t1._varData, "$is_StreamControllerAddStreamState", [t2], "$as_StreamControllerAddStreamState").addSubscription.pause$0();
      P._runGuarded(t1.onPause);
    },
    _onResume$0: function() {
      var t1 = this._async$_controller,
        t2 = H.getTypeArgumentByIndex(t1, 0);
      H.assertSubtype(this, "$isStreamSubscription", [t2], "$asStreamSubscription");
      if ((t1._state & 8) !== 0)
        H.assertSubtype(t1._varData, "$is_StreamControllerAddStreamState", [t2], "$as_StreamControllerAddStreamState").addSubscription.resume$0();
      P._runGuarded(t1.onResume);
    }
  };
  P._AddStreamState.prototype = {
    cancel$0: function() {
      var cancel = this.addSubscription.cancel$0();
      if (cancel == null) {
        this.addStreamFuture._asyncComplete$1(null);
        return;
      }
      return cancel.whenComplete$1(new P._AddStreamState_cancel_closure(this));
    }
  };
  P._AddStreamState_cancel_closure.prototype = {
    call$0: function() {
      this.$this.addStreamFuture._asyncComplete$1(null);
    },
    $signature: 2
  };
  P._StreamControllerAddStreamState.prototype = {};
  P._BufferingStreamSubscription.prototype = {
    _BufferingStreamSubscription$4: function(onData, onError, onDone, cancelOnError, $T) {
      var t2, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]});
      t2 = _this._zone;
      t2.toString;
      _this.set$_onData(H.functionTypeCheck(onData, {func: 1, ret: null, args: [t1]}));
      if (H.functionTypeTest(onError, {func: 1, ret: -1, args: [P.Object, P.StackTrace]}))
        _this._onError = t2.registerBinaryCallback$3$1(onError, null, P.Object, P.StackTrace);
      else if (H.functionTypeTest(onError, {func: 1, ret: -1, args: [P.Object]}))
        _this._onError = H.functionTypeCheck(onError, {func: 1, ret: null, args: [P.Object]});
      else
        H.throwExpression(P.ArgumentError$("handleError callback must take either an Object (the error), or both an Object (the error) and a StackTrace."));
      H.functionTypeCheck(onDone, {func: 1, ret: -1});
      _this.set$_onDone(H.functionTypeCheck(onDone, {func: 1, ret: -1}));
    },
    _setPendingEvents$1: function(pendingEvents) {
      var _this = this;
      H.assertSubtype(pendingEvents, "$is_PendingEvents", _this.$ti, "$as_PendingEvents");
      H.assertHelper(_this._pending == null);
      if (pendingEvents == null)
        return;
      _this.set$_pending(pendingEvents);
      if (!pendingEvents.get$isEmpty(pendingEvents)) {
        _this._state = (_this._state | 64) >>> 0;
        _this._pending.schedule$1(_this);
      }
    },
    pause$0: function() {
      var t2, t3, _this = this,
        t1 = _this._state;
      if ((t1 & 8) !== 0)
        return;
      t2 = (t1 + 128 | 4) >>> 0;
      _this._state = t2;
      if (t1 < 128 && _this._pending != null) {
        t3 = _this._pending;
        if (t3._state === 1)
          t3._state = 3;
      }
      if ((t1 & 4) === 0 && (t2 & 32) === 0)
        _this._guardCallback$1(_this.get$_onPause());
    },
    resume$0: function() {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 >= 128) {
        t1 = _this._state -= 128;
        if (t1 < 128) {
          if ((t1 & 64) !== 0) {
            t1 = _this._pending;
            t1 = !t1.get$isEmpty(t1);
          } else
            t1 = false;
          if (t1)
            _this._pending.schedule$1(_this);
          else {
            H.assertHelper(_this.get$_mayResumeInput());
            t1 = (_this._state & 4294967291) >>> 0;
            _this._state = t1;
            if ((t1 & 32) === 0)
              _this._guardCallback$1(_this.get$_onResume());
          }
        }
      }
    },
    cancel$0: function() {
      var _this = this,
        t1 = (_this._state & 4294967279) >>> 0;
      _this._state = t1;
      if ((t1 & 8) === 0)
        _this._async$_cancel$0();
      t1 = _this._cancelFuture;
      return t1 == null ? $.$get$Future__nullFuture() : t1;
    },
    get$_mayResumeInput: function() {
      if (this._state < 128) {
        var t1 = this._pending;
        t1 = t1 == null || t1.get$isEmpty(t1);
      } else
        t1 = false;
      return t1;
    },
    _async$_cancel$0: function() {
      var t2, _this = this,
        t1 = _this._state = (_this._state | 8) >>> 0;
      if ((t1 & 64) !== 0) {
        t2 = _this._pending;
        if (t2._state === 1)
          t2._state = 3;
      }
      if ((t1 & 32) === 0)
        _this.set$_pending(null);
      _this._cancelFuture = _this._onCancel$0();
    },
    _onPause$0: function() {
      H.assertHelper((this._state & 4) !== 0);
    },
    _onResume$0: function() {
      H.assertHelper((this._state & 4) === 0);
    },
    _onCancel$0: function() {
      H.assertHelper((this._state & 8) !== 0);
      return;
    },
    _addPending$1: function($event) {
      var _this = this,
        t1 = _this.$ti,
        pending = H.assertSubtype(_this._pending, "$is_StreamImplEvents", t1, "$as_StreamImplEvents");
      if (pending == null) {
        pending = new P._StreamImplEvents(t1);
        _this.set$_pending(pending);
      }
      pending.add$1(0, $event);
      t1 = _this._state;
      if ((t1 & 64) === 0) {
        t1 = (t1 | 64) >>> 0;
        _this._state = t1;
        if (t1 < 128)
          _this._pending.schedule$1(_this);
      }
    },
    _sendData$1: function(data) {
      var t2, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.assertSubtypeOfRuntimeType(data, t1);
      H.assertHelper((_this._state & 8) === 0);
      H.assertHelper(_this._state < 128);
      H.assertHelper((_this._state & 32) === 0);
      t2 = _this._state;
      _this._state = (t2 | 32) >>> 0;
      _this._zone.runUnaryGuarded$1$2(_this._onData, data, t1);
      _this._state = (_this._state & 4294967263) >>> 0;
      _this._checkState$1((t2 & 4) !== 0);
    },
    _sendError$2: function(error, stackTrace) {
      var t1, t2, _this = this;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      H.assertHelper((_this._state & 8) === 0);
      H.assertHelper(_this._state < 128);
      H.assertHelper((_this._state & 32) === 0);
      t1 = _this._state;
      t2 = new P._BufferingStreamSubscription__sendError_sendError(_this, error, stackTrace);
      if ((t1 & 1) !== 0) {
        _this._state = (t1 | 16) >>> 0;
        _this._async$_cancel$0();
        t1 = _this._cancelFuture;
        if (t1 != null && t1 !== $.$get$Future__nullFuture())
          t1.whenComplete$1(t2);
        else
          t2.call$0();
      } else {
        t2.call$0();
        _this._checkState$1((t1 & 4) !== 0);
      }
    },
    _sendDone$0: function() {
      var t1, t2, _this = this;
      H.assertHelper((_this._state & 8) === 0);
      H.assertHelper(_this._state < 128);
      H.assertHelper((_this._state & 32) === 0);
      t1 = new P._BufferingStreamSubscription__sendDone_sendDone(_this);
      _this._async$_cancel$0();
      _this._state = (_this._state | 16) >>> 0;
      t2 = _this._cancelFuture;
      if (t2 != null && t2 !== $.$get$Future__nullFuture())
        t2.whenComplete$1(t1);
      else
        t1.call$0();
    },
    _guardCallback$1: function(callback) {
      var t1, _this = this;
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      H.assertHelper((_this._state & 32) === 0);
      t1 = _this._state;
      _this._state = (t1 | 32) >>> 0;
      callback.call$0();
      _this._state = (_this._state & 4294967263) >>> 0;
      _this._checkState$1((t1 & 4) !== 0);
    },
    _checkState$1: function(wasInputPaused) {
      var t1, isInputPaused, _this = this;
      H.assertHelper((_this._state & 32) === 0);
      if ((_this._state & 64) !== 0) {
        t1 = _this._pending;
        t1 = t1.get$isEmpty(t1);
      } else
        t1 = false;
      if (t1) {
        t1 = (_this._state & 4294967231) >>> 0;
        _this._state = t1;
        if ((t1 & 4) !== 0 && _this.get$_mayResumeInput())
          _this._state = (_this._state & 4294967291) >>> 0;
      }
      for (; true; wasInputPaused = isInputPaused) {
        t1 = _this._state;
        if ((t1 & 8) !== 0) {
          _this.set$_pending(null);
          return;
        }
        isInputPaused = (t1 & 4) !== 0;
        if (wasInputPaused === isInputPaused)
          break;
        _this._state = (t1 ^ 32) >>> 0;
        if (isInputPaused)
          _this._onPause$0();
        else
          _this._onResume$0();
        _this._state = (_this._state & 4294967263) >>> 0;
      }
      t1 = _this._state;
      if ((t1 & 64) !== 0 && t1 < 128)
        _this._pending.schedule$1(_this);
    },
    set$_onData: function(_onData) {
      this._onData = H.functionTypeCheck(_onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
    },
    set$_onDone: function(_onDone) {
      this._onDone = H.functionTypeCheck(_onDone, {func: 1, ret: -1});
    },
    set$_pending: function(_pending) {
      this._pending = H.assertSubtype(_pending, "$is_PendingEvents", this.$ti, "$as_PendingEvents");
    },
    $isStreamSubscription: 1,
    $is_EventDispatch: 1
  };
  P._BufferingStreamSubscription__sendError_sendError.prototype = {
    call$0: function() {
      var onError, t3, t4, t5, t6,
        t1 = this.$this,
        t2 = t1._state;
      if ((t2 & 8) !== 0 && (t2 & 16) === 0)
        return;
      t1._state = (t2 | 32) >>> 0;
      onError = t1._onError;
      t2 = this.error;
      t3 = P.Object;
      t4 = t1._zone;
      if (H.functionTypeTest(onError, {func: 1, ret: -1, args: [P.Object, P.StackTrace]}))
        t4.runBinaryGuarded$2$3(onError, t2, this.stackTrace, t3, P.StackTrace);
      else {
        t5 = t1._onError;
        t6 = {func: 1, ret: -1, args: [P.Object]};
        H.assertHelper(H.functionTypeTest(t5, t6));
        t4.runUnaryGuarded$1$2(H.functionTypeCheck(t1._onError, t6), t2, t3);
      }
      t1._state = (t1._state & 4294967263) >>> 0;
    },
    $signature: 1
  };
  P._BufferingStreamSubscription__sendDone_sendDone.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._state;
      if ((t2 & 16) === 0)
        return;
      t1._state = (t2 | 42) >>> 0;
      t1._zone.runGuarded$1(t1._onDone);
      t1._state = (t1._state & 4294967263) >>> 0;
    },
    $signature: 1
  };
  P._StreamImpl.prototype = {
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      return this._createSubscription$4(H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]}), onError, H.functionTypeCheck(onDone, {func: 1, ret: -1}), cancelOnError);
    },
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      return P._BufferingStreamSubscription$(H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]}), onError, H.functionTypeCheck(onDone, {func: 1, ret: -1}), cancelOnError, t1);
    }
  };
  P._GeneratedStreamImpl.prototype = {
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      var _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]});
      H.functionTypeCheck(onDone, {func: 1, ret: -1});
      if (_this._isUsed)
        throw H.wrapException(P.StateError$("Stream has already been listened to."));
      _this._isUsed = true;
      t1 = P._BufferingStreamSubscription$(onData, onError, onDone, cancelOnError, t1);
      t1._setPendingEvents$1(_this._pending.call$0());
      return t1;
    }
  };
  P._IterablePendingEvents.prototype = {
    get$isEmpty: function(_) {
      return this._async$_iterator == null;
    },
    handleNext$1: function(dispatch) {
      var hasMore, e, s, t1, exception, _this = this;
      H.assertSubtype(dispatch, "$is_EventDispatch", _this.$ti, "$as_EventDispatch");
      t1 = _this._async$_iterator;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No events pending."));
      hasMore = null;
      try {
        hasMore = t1.moveNext$0();
        if (H.boolConversionCheck(hasMore))
          dispatch._sendData$1(_this._async$_iterator.get$current());
        else {
          _this.set$_async$_iterator(null);
          dispatch._sendDone$0();
        }
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        if (hasMore == null) {
          _this.set$_async$_iterator(C.C_EmptyIterator);
          dispatch._sendError$2(e, s);
        } else
          dispatch._sendError$2(e, s);
      }
    },
    set$_async$_iterator: function(_iterator) {
      this._async$_iterator = H.assertSubtype(_iterator, "$isIterator", this.$ti, "$asIterator");
    }
  };
  P._DelayedEvent.prototype = {
    set$next: function(next) {
      this.next = H.interceptedTypeCheck(next, "$is_DelayedEvent");
    },
    get$next: function() {
      return this.next;
    }
  };
  P._DelayedData.prototype = {
    perform$1: function(dispatch) {
      H.assertSubtype(dispatch, "$is_EventDispatch", this.$ti, "$as_EventDispatch")._sendData$1(this.value);
    }
  };
  P._DelayedError.prototype = {
    perform$1: function(dispatch) {
      dispatch._sendError$2(this.error, this.stackTrace);
    },
    $as_DelayedEvent: function() {
    }
  };
  P._DelayedDone.prototype = {
    perform$1: function(dispatch) {
      dispatch._sendDone$0();
    },
    get$next: function() {
      return;
    },
    set$next: function(_) {
      throw H.wrapException(P.StateError$("No events after a done."));
    },
    $is_DelayedEvent: 1,
    $as_DelayedEvent: function() {
    }
  };
  P._PendingEvents.prototype = {
    schedule$1: function(dispatch) {
      var t1, _this = this;
      H.assertSubtype(dispatch, "$is_EventDispatch", _this.$ti, "$as_EventDispatch");
      if (_this._state === 1)
        return;
      H.assertHelper(!_this.get$isEmpty(_this));
      t1 = _this._state;
      if (t1 >= 1) {
        H.assertHelper(t1 === 3);
        _this._state = 1;
        return;
      }
      P.scheduleMicrotask(new P._PendingEvents_schedule_closure(_this, dispatch));
      _this._state = 1;
    }
  };
  P._PendingEvents_schedule_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        oldState = t1._state;
      t1._state = 0;
      if (oldState === 3)
        return;
      t1.handleNext$1(this.dispatch);
    },
    $signature: 2
  };
  P._StreamImplEvents.prototype = {
    get$isEmpty: function(_) {
      return this.lastPendingEvent == null;
    },
    add$1: function(_, $event) {
      var _this = this,
        t1 = _this.lastPendingEvent;
      if (t1 == null)
        _this.firstPendingEvent = _this.lastPendingEvent = $event;
      else {
        t1.set$next($event);
        _this.lastPendingEvent = $event;
      }
    },
    handleNext$1: function(dispatch) {
      var $event, t1, _this = this;
      H.assertSubtype(dispatch, "$is_EventDispatch", _this.$ti, "$as_EventDispatch");
      H.assertHelper(_this._state !== 1);
      $event = _this.firstPendingEvent;
      t1 = $event.get$next();
      _this.firstPendingEvent = t1;
      if (t1 == null)
        _this.lastPendingEvent = null;
      $event.perform$1(dispatch);
    }
  };
  P._StreamIterator.prototype = {};
  P._cancelAndValue_closure.prototype = {
    call$0: function() {
      return this.future._complete$1(this.value);
    },
    $signature: 1
  };
  P.AsyncError.prototype = {
    toString$0: function(_) {
      return H.S(this.error);
    },
    $isError: 1
  };
  P._Zone.prototype = {$isZone: 1};
  P._rootHandleUncaughtError_closure.prototype = {
    call$0: function() {
      var error,
        t1 = this._box_0,
        t2 = t1.error;
      t1 = t2 == null ? t1.error = new P.NullThrownError() : t2;
      t2 = this.stackTrace;
      if (t2 == null)
        throw H.wrapException(t1);
      error = H.wrapException(t1);
      error.stack = t2.toString$0(0);
      throw error;
    },
    $signature: 2
  };
  P._RootZone.prototype = {
    runGuarded$1: function(f) {
      var e, s, exception, _null = null;
      H.functionTypeCheck(f, {func: 1, ret: -1});
      try {
        if (C.C__RootZone === $.Zone__current) {
          f.call$0();
          return;
        }
        P._rootRun(_null, _null, this, f, -1);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._rootHandleUncaughtError(_null, _null, this, e, H.interceptedTypeCheck(s, "$isStackTrace"));
      }
    },
    runUnaryGuarded$1$2: function(f, arg, $T) {
      var e, s, exception, _null = null;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [$T]});
      H.assertSubtypeOfRuntimeType(arg, $T);
      try {
        if (C.C__RootZone === $.Zone__current) {
          f.call$1(arg);
          return;
        }
        P._rootRunUnary(_null, _null, this, f, arg, -1, $T);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._rootHandleUncaughtError(_null, _null, this, e, H.interceptedTypeCheck(s, "$isStackTrace"));
      }
    },
    runBinaryGuarded$2$3: function(f, arg1, arg2, T1, T2) {
      var e, s, exception, _null = null;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [T1, T2]});
      H.assertSubtypeOfRuntimeType(arg1, T1);
      H.assertSubtypeOfRuntimeType(arg2, T2);
      try {
        if (C.C__RootZone === $.Zone__current) {
          f.call$2(arg1, arg2);
          return;
        }
        P._rootRunBinary(_null, _null, this, f, arg1, arg2, -1, T1, T2);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._rootHandleUncaughtError(_null, _null, this, e, H.interceptedTypeCheck(s, "$isStackTrace"));
      }
    },
    bindCallback$1$1: function(f, $R) {
      return new P._RootZone_bindCallback_closure(this, H.functionTypeCheck(f, {func: 1, ret: $R}), $R);
    },
    bindCallbackGuarded$1: function(f) {
      return new P._RootZone_bindCallbackGuarded_closure(this, H.functionTypeCheck(f, {func: 1, ret: -1}));
    },
    $index: function(_, key) {
      return;
    },
    run$1$1: function(f, $R) {
      H.functionTypeCheck(f, {func: 1, ret: $R});
      if ($.Zone__current === C.C__RootZone)
        return f.call$0();
      return P._rootRun(null, null, this, f, $R);
    },
    runUnary$2$2: function(f, arg, $R, $T) {
      H.functionTypeCheck(f, {func: 1, ret: $R, args: [$T]});
      H.assertSubtypeOfRuntimeType(arg, $T);
      if ($.Zone__current === C.C__RootZone)
        return f.call$1(arg);
      return P._rootRunUnary(null, null, this, f, arg, $R, $T);
    },
    runBinary$3$3: function(f, arg1, arg2, $R, T1, T2) {
      H.functionTypeCheck(f, {func: 1, ret: $R, args: [T1, T2]});
      H.assertSubtypeOfRuntimeType(arg1, T1);
      H.assertSubtypeOfRuntimeType(arg2, T2);
      if ($.Zone__current === C.C__RootZone)
        return f.call$2(arg1, arg2);
      return P._rootRunBinary(null, null, this, f, arg1, arg2, $R, T1, T2);
    },
    registerBinaryCallback$3$1: function(f, $R, T1, T2) {
      return H.functionTypeCheck(f, {func: 1, ret: $R, args: [T1, T2]});
    }
  };
  P._RootZone_bindCallback_closure.prototype = {
    call$0: function() {
      return this.$this.run$1$1(this.f, this.R);
    },
    $signature: function() {
      return {func: 1, ret: this.R};
    }
  };
  P._RootZone_bindCallbackGuarded_closure.prototype = {
    call$0: function() {
      return this.$this.runGuarded$1(this.f);
    },
    $signature: 1
  };
  P._HashMap.prototype = {
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$keys: function() {
      return new P._HashMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
    },
    containsKey$1: function(key) {
      var strings, t1;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._collection$_strings;
        return strings == null ? false : strings[key] != null;
      } else {
        t1 = this._containsKey$1(key);
        return t1;
      }
    },
    _containsKey$1: function(key) {
      var rest = this._collection$_rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(this._getBucket$2(rest, key), key) >= 0;
    },
    addAll$1: function(_, other) {
      H.assertSubtype(other, "$isMap", this.$ti, "$asMap").forEach$1(0, new P._HashMap_addAll_closure(this));
    },
    $index: function(_, key) {
      var strings, t1, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._collection$_strings;
        t1 = strings == null ? null : P._HashMap__getTableEntry(strings, key);
        return t1;
      } else if (typeof key === "number" && (key & 1073741823) === key) {
        nums = this._collection$_nums;
        t1 = nums == null ? null : P._HashMap__getTableEntry(nums, key);
        return t1;
      } else
        return this._get$1(key);
    },
    _get$1: function(key) {
      var bucket, index,
        rest = this._collection$_rest;
      if (rest == null)
        return;
      bucket = this._getBucket$2(rest, key);
      index = this._findBucketIndex$2(bucket, key);
      return index < 0 ? null : bucket[index + 1];
    },
    $indexSet: function(_, key, value) {
      var strings, nums, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1));
      if (typeof key === "string" && key !== "__proto__") {
        strings = _this._collection$_strings;
        _this._collection$_addHashTableEntry$3(strings == null ? _this._collection$_strings = P._HashMap__newHashTable() : strings, key, value);
      } else if (typeof key === "number" && (key & 1073741823) === key) {
        nums = _this._collection$_nums;
        _this._collection$_addHashTableEntry$3(nums == null ? _this._collection$_nums = P._HashMap__newHashTable() : nums, key, value);
      } else
        _this._collection$_set$2(key, value);
    },
    _collection$_set$2: function(key, value) {
      var rest, hash, bucket, index, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1));
      rest = _this._collection$_rest;
      if (rest == null)
        rest = _this._collection$_rest = P._HashMap__newHashTable();
      hash = _this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null) {
        P._HashMap__setTableEntry(rest, hash, [key, value]);
        ++_this._collection$_length;
        _this._collection$_keys = null;
      } else {
        index = _this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index + 1] = value;
        else {
          bucket.push(key, value);
          ++_this._collection$_length;
          _this._collection$_keys = null;
        }
      }
    },
    putIfAbsent$2: function(key, ifAbsent) {
      var value, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.functionTypeCheck(ifAbsent, {func: 1, ret: H.getTypeArgumentByIndex(_this, 1)});
      if (_this.containsKey$1(key))
        return _this.$index(0, key);
      value = ifAbsent.call$0();
      _this.$indexSet(0, key, value);
      return value;
    },
    remove$1: function(_, key) {
      var t1 = this._remove$1(key);
      return t1;
    },
    _remove$1: function(key) {
      var bucket, index, _this = this,
        rest = _this._collection$_rest;
      if (rest == null)
        return;
      bucket = _this._getBucket$2(rest, key);
      index = _this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      --_this._collection$_length;
      _this._collection$_keys = null;
      return bucket.splice(index, 2)[1];
    },
    forEach$1: function(_, action) {
      var keys, $length, i, key, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(action, {func: 1, ret: -1, args: [t1, H.getTypeArgumentByIndex(_this, 1)]});
      keys = _this._computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        key = keys[i];
        action.call$2(H.assertSubtypeOfRuntimeType(key, t1), _this.$index(0, key));
        if (keys !== _this._collection$_keys)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
    },
    _computeKeys$0: function() {
      var result, strings, names, entries, index, i, nums, rest, bucket, $length, i0, _this = this,
        t1 = _this._collection$_keys;
      if (t1 != null)
        return t1;
      result = new Array(_this._collection$_length);
      result.fixed$length = Array;
      strings = _this._collection$_strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = _this._collection$_nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = _this._collection$_rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; i0 += 2) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      H.assertHelper(index === _this._collection$_length);
      return _this._collection$_keys = result;
    },
    _collection$_addHashTableEntry$3: function(table, key, value) {
      var _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1));
      if (table[key] == null) {
        ++_this._collection$_length;
        _this._collection$_keys = null;
      }
      P._HashMap__setTableEntry(table, key, value);
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 1073741823;
    },
    _getBucket$2: function(table, key) {
      return table[this._computeHashCode$1(key)];
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2)
        if (J.$eq$(bucket[i], key))
          return i;
      return -1;
    },
    $isHashMap: 1
  };
  P._HashMap_addAll_closure.prototype = {
    call$2: function(key, value) {
      var t1 = this.$this;
      t1.$indexSet(0, H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(t1, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(t1, 1)));
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: P.Null, args: [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]};
    }
  };
  P._HashMapKeyIterable.prototype = {
    get$length: function(_) {
      return this._collection$_map._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_map._collection$_length === 0;
    },
    get$iterator: function(_) {
      var t1 = this._collection$_map;
      return new P._HashMapKeyIterator(t1, t1._computeKeys$0(), this.$ti);
    },
    contains$1: function(_, element) {
      return this._collection$_map.containsKey$1(element);
    },
    forEach$1: function(_, f) {
      var t1, keys, $length, i;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
      t1 = this._collection$_map;
      keys = t1._computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        f.call$1(keys[i]);
        if (keys !== t1._collection$_keys)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
      }
    }
  };
  P._HashMapKeyIterator.prototype = {
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var _this = this,
        keys = _this._collection$_keys,
        offset = _this._offset,
        t1 = _this._collection$_map;
      if (keys !== t1._collection$_keys)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (offset >= keys.length) {
        _this.set$_collection$_current(null);
        return false;
      } else {
        _this.set$_collection$_current(keys[offset]);
        _this._offset = offset + 1;
        return true;
      }
    },
    set$_collection$_current: function(_current) {
      this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  P._LinkedIdentityHashMap.prototype = {
    internalComputeHashCode$1: function(key) {
      return H.objectHashCode(key) & 1073741823;
    },
    internalFindBucketIndex$2: function(bucket, key) {
      var $length, i, t1;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i) {
        t1 = bucket[i].hashMapCellKey;
        if (t1 == null ? key == null : t1 === key)
          return i;
      }
      return -1;
    }
  };
  P._HashSet.prototype = {
    _newSet$0: function() {
      return new P._HashSet(this.$ti);
    },
    get$iterator: function(_) {
      return new P._HashSetIterator(this, this._computeElements$0(), this.$ti);
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    contains$1: function(_, object) {
      var nums;
      if (typeof object === "number" && (object & 1073741823) === object) {
        nums = this._collection$_nums;
        return nums == null ? false : nums[object] != null;
      } else
        return this._contains$1(object);
    },
    _contains$1: function(object) {
      var rest = this._collection$_rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(this._getBucket$2(rest, object), object) >= 0;
    },
    add$1: function(_, element) {
      var strings, nums, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      if (typeof element === "string" && element !== "__proto__") {
        strings = _this._collection$_strings;
        return _this._collection$_addHashTableEntry$2(strings == null ? _this._collection$_strings = P._HashSet__newHashTable() : strings, element);
      } else if (typeof element === "number" && (element & 1073741823) === element) {
        nums = _this._collection$_nums;
        return _this._collection$_addHashTableEntry$2(nums == null ? _this._collection$_nums = P._HashSet__newHashTable() : nums, element);
      } else
        return _this._add$1(element);
    },
    _add$1: function(element) {
      var rest, hash, bucket, t1, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      rest = _this._collection$_rest;
      if (rest == null)
        rest = _this._collection$_rest = P._HashSet__newHashTable();
      hash = _this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null) {
        t1 = [element];
        H.assertHelper(t1 != null);
        rest[hash] = t1;
      } else {
        if (_this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(element);
      }
      ++_this._collection$_length;
      _this._collection$_elements = null;
      return true;
    },
    addAll$1: function(_, objects) {
      var t1;
      for (t1 = J.get$iterator$ax(H.assertSubtype(objects, "$isIterable", this.$ti, "$asIterable")); t1.moveNext$0();)
        this.add$1(0, t1.get$current());
    },
    remove$1: function(_, object) {
      var _this = this;
      if (typeof object === "string" && object !== "__proto__")
        return _this._collection$_removeHashTableEntry$2(_this._collection$_strings, object);
      else if (typeof object === "number" && (object & 1073741823) === object)
        return _this._collection$_removeHashTableEntry$2(_this._collection$_nums, object);
      else
        return _this._remove$1(object);
    },
    _remove$1: function(object) {
      var bucket, index, _this = this,
        rest = _this._collection$_rest;
      if (rest == null)
        return false;
      bucket = _this._getBucket$2(rest, object);
      index = _this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      --_this._collection$_length;
      _this._collection$_elements = null;
      bucket.splice(index, 1);
      return true;
    },
    clear$0: function(_) {
      var _this = this;
      if (_this._collection$_length > 0) {
        _this._collection$_strings = _this._collection$_nums = _this._collection$_rest = _this._collection$_elements = null;
        _this._collection$_length = 0;
      }
    },
    _computeElements$0: function() {
      var result, strings, names, entries, index, i, nums, rest, bucket, $length, i0, _this = this,
        t1 = _this._collection$_elements;
      if (t1 != null)
        return t1;
      result = new Array(_this._collection$_length);
      result.fixed$length = Array;
      strings = _this._collection$_strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = _this._collection$_nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = _this._collection$_rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; ++i0) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      H.assertHelper(index === _this._collection$_length);
      return _this._collection$_elements = result;
    },
    _collection$_addHashTableEntry$2: function(table, element) {
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
      if (table[element] != null)
        return false;
      table[element] = 0;
      ++this._collection$_length;
      this._collection$_elements = null;
      return true;
    },
    _collection$_removeHashTableEntry$2: function(table, element) {
      if (table != null && table[element] != null) {
        delete table[element];
        --this._collection$_length;
        this._collection$_elements = null;
        return true;
      } else
        return false;
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 1073741823;
    },
    _getBucket$2: function(table, element) {
      return table[this._computeHashCode$1(element)];
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq$(bucket[i], element))
          return i;
      return -1;
    },
    $isHashSet: 1
  };
  P._HashSetIterator.prototype = {
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var _this = this,
        elements = _this._collection$_elements,
        offset = _this._offset,
        t1 = _this._collection$_set;
      if (elements !== t1._collection$_elements)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (offset >= elements.length) {
        _this.set$_collection$_current(null);
        return false;
      } else {
        _this.set$_collection$_current(elements[offset]);
        _this._offset = offset + 1;
        return true;
      }
    },
    set$_collection$_current: function(_current) {
      this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  P._LinkedHashSet.prototype = {
    _newSet$0: function() {
      return new P._LinkedHashSet(this.$ti);
    },
    get$iterator: function(_) {
      return P._LinkedHashSetIterator$(this, this._collection$_modifications, H.getTypeArgumentByIndex(this, 0));
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    contains$1: function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._collection$_strings;
        if (strings == null)
          return false;
        return H.interceptedTypeCheck(strings[object], "$is_LinkedHashSetCell") != null;
      } else if (typeof object === "number" && (object & 1073741823) === object) {
        nums = this._collection$_nums;
        if (nums == null)
          return false;
        return H.interceptedTypeCheck(nums[object], "$is_LinkedHashSetCell") != null;
      } else
        return this._contains$1(object);
    },
    _contains$1: function(object) {
      var rest = this._collection$_rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(this._getBucket$2(rest, object), object) >= 0;
    },
    forEach$1: function(_, action) {
      var cell, modifications, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(action, {func: 1, ret: -1, args: [t1]});
      cell = _this._collection$_first;
      modifications = _this._collection$_modifications;
      for (; cell != null;) {
        action.call$1(H.assertSubtypeOfRuntimeType(cell._collection$_element, t1));
        if (modifications !== _this._collection$_modifications)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
        cell = cell._collection$_next;
      }
    },
    add$1: function(_, element) {
      var strings, nums, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      if (typeof element === "string" && element !== "__proto__") {
        strings = _this._collection$_strings;
        return _this._collection$_addHashTableEntry$2(strings == null ? _this._collection$_strings = P._LinkedHashSet__newHashTable() : strings, element);
      } else if (typeof element === "number" && (element & 1073741823) === element) {
        nums = _this._collection$_nums;
        return _this._collection$_addHashTableEntry$2(nums == null ? _this._collection$_nums = P._LinkedHashSet__newHashTable() : nums, element);
      } else
        return _this._add$1(element);
    },
    _add$1: function(element) {
      var rest, hash, bucket, t1, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      rest = _this._collection$_rest;
      if (rest == null)
        rest = _this._collection$_rest = P._LinkedHashSet__newHashTable();
      hash = _this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null) {
        t1 = [_this._collection$_newLinkedCell$1(element)];
        H.assertHelper(t1 != null);
        rest[hash] = t1;
      } else {
        if (_this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(_this._collection$_newLinkedCell$1(element));
      }
      return true;
    },
    remove$1: function(_, object) {
      var _this = this;
      if (typeof object === "string" && object !== "__proto__")
        return _this._collection$_removeHashTableEntry$2(_this._collection$_strings, object);
      else if (typeof object === "number" && (object & 1073741823) === object)
        return _this._collection$_removeHashTableEntry$2(_this._collection$_nums, object);
      else
        return _this._remove$1(object);
    },
    _remove$1: function(object) {
      var bucket, index, _this = this,
        rest = _this._collection$_rest;
      if (rest == null)
        return false;
      bucket = _this._getBucket$2(rest, object);
      index = _this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      _this._collection$_unlinkCell$1(bucket.splice(index, 1)[0]);
      return true;
    },
    clear$0: function(_) {
      var _this = this;
      if (_this._collection$_length > 0) {
        _this._collection$_strings = _this._collection$_nums = _this._collection$_rest = _this._collection$_first = _this._collection$_last = null;
        _this._collection$_length = 0;
        _this._collection$_modified$0();
      }
    },
    _collection$_addHashTableEntry$2: function(table, element) {
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
      if (H.interceptedTypeCheck(table[element], "$is_LinkedHashSetCell") != null)
        return false;
      table[element] = this._collection$_newLinkedCell$1(element);
      return true;
    },
    _collection$_removeHashTableEntry$2: function(table, element) {
      var cell;
      if (table == null)
        return false;
      cell = H.interceptedTypeCheck(table[element], "$is_LinkedHashSetCell");
      if (cell == null)
        return false;
      this._collection$_unlinkCell$1(cell);
      delete table[element];
      return true;
    },
    _collection$_modified$0: function() {
      this._collection$_modifications = 1073741823 & this._collection$_modifications + 1;
    },
    _collection$_newLinkedCell$1: function(element) {
      var last, _this = this,
        cell = new P._LinkedHashSetCell(H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0)));
      if (_this._collection$_first == null)
        _this._collection$_first = _this._collection$_last = cell;
      else {
        last = _this._collection$_last;
        cell._collection$_previous = last;
        _this._collection$_last = last._collection$_next = cell;
      }
      ++_this._collection$_length;
      _this._collection$_modified$0();
      return cell;
    },
    _collection$_unlinkCell$1: function(cell) {
      var _this = this,
        previous = cell._collection$_previous,
        next = cell._collection$_next;
      if (previous == null) {
        H.assertHelper(cell == _this._collection$_first);
        _this._collection$_first = next;
      } else
        previous._collection$_next = next;
      if (next == null) {
        H.assertHelper(cell == _this._collection$_last);
        _this._collection$_last = previous;
      } else
        next._collection$_previous = previous;
      --_this._collection$_length;
      _this._collection$_modified$0();
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 1073741823;
    },
    _getBucket$2: function(table, element) {
      return table[this._computeHashCode$1(element)];
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq$(bucket[i]._collection$_element, element))
          return i;
      return -1;
    },
    $isLinkedHashSet: 1
  };
  P._LinkedIdentityHashSet.prototype = {
    _newSet$0: function() {
      return new P._LinkedIdentityHashSet(this.$ti);
    },
    _computeHashCode$1: function(key) {
      return H.objectHashCode(key) & 1073741823;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i, t1;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i) {
        t1 = bucket[i]._collection$_element;
        if (t1 == null ? element == null : t1 === element)
          return i;
      }
      return -1;
    }
  };
  P._LinkedHashSetCell.prototype = {};
  P._LinkedHashSetIterator.prototype = {
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var _this = this,
        t1 = _this._collection$_set;
      if (_this._collection$_modifications !== t1._collection$_modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = _this._collection$_cell;
        if (t1 == null) {
          _this.set$_collection$_current(null);
          return false;
        } else {
          _this.set$_collection$_current(H.assertSubtypeOfRuntimeType(t1._collection$_element, H.getTypeArgumentByIndex(_this, 0)));
          _this._collection$_cell = _this._collection$_cell._collection$_next;
          return true;
        }
      }
    },
    set$_collection$_current: function(_current) {
      this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  P.HashMap_HashMap$from_closure.prototype = {
    call$2: function(k, v) {
      this.result.$indexSet(0, H.assertSubtypeOfRuntimeType(k, this.K), H.assertSubtypeOfRuntimeType(v, this.V));
    },
    $signature: 21
  };
  P.HashSet.prototype = {$isEfficientLengthIterable: 1, $isIterable: 1, $isSet: 1};
  P.IterableMixin.prototype = {
    map$1$1: function(_, f, $T) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      return H.MappedIterable_MappedIterable(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), t1, $T);
    },
    forEach$1: function(_, f) {
      var t1, _this = this;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(_this, 0)]});
      for (t1 = H.getTypeArgumentByIndex(_this, 0), t1 = new P._SplayTreeKeyIterator(_this, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, t1]]), _this._modificationCount, _this._splayCount, [t1]), t1._findLeftMostDescendent$1(_this._root); t1.moveNext$0();)
        f.call$1(t1.get$current());
    },
    join$1: function(_, separator) {
      var _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0),
        iterator = new P._SplayTreeKeyIterator(_this, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, t1]]), _this._modificationCount, _this._splayCount, [t1]);
      iterator._findLeftMostDescendent$1(_this._root);
      if (!iterator.moveNext$0())
        return "";
      if (separator === "") {
        t1 = "";
        do
          t1 += H.S(iterator.get$current());
        while (iterator.moveNext$0());
      } else {
        t1 = H.S(iterator.get$current());
        for (; iterator.moveNext$0();)
          t1 = t1 + separator + H.S(iterator.get$current());
      }
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    get$length: function(_) {
      var t1, it, count, _this = this;
      H.assertHelper(false);
      t1 = H.getTypeArgumentByIndex(_this, 0);
      it = new P._SplayTreeKeyIterator(_this, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, t1]]), _this._modificationCount, _this._splayCount, [t1]);
      it._findLeftMostDescendent$1(_this._root);
      for (count = 0; it.moveNext$0();)
        ++count;
      return count;
    },
    get$isEmpty: function(_) {
      var _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      t1 = new P._SplayTreeKeyIterator(_this, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, t1]]), _this._modificationCount, _this._splayCount, [t1]);
      t1._findLeftMostDescendent$1(_this._root);
      return !t1.moveNext$0();
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToShortString(this, "(", ")");
    }
  };
  P.IterableBase.prototype = {};
  P.LinkedHashMap_LinkedHashMap$from_closure.prototype = {
    call$2: function(k, v) {
      this.result.$indexSet(0, H.assertSubtypeOfRuntimeType(k, this.K), H.assertSubtypeOfRuntimeType(v, this.V));
    },
    $signature: 21
  };
  P.LinkedHashSet.prototype = {$isEfficientLengthIterable: 1, $isIterable: 1, $isSet: 1};
  P.ListBase.prototype = {$isEfficientLengthIterable: 1, $isIterable: 1, $isList: 1};
  P.ListMixin.prototype = {
    get$iterator: function(receiver) {
      return new H.ListIterator(receiver, this.get$length(receiver), [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]);
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    forEach$1: function(receiver, action) {
      var $length, i, _this = this;
      H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0)]});
      $length = _this.get$length(receiver);
      for (i = 0; i < $length; ++i) {
        action.call$1(_this.$index(receiver, i));
        if ($length !== _this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    get$isEmpty: function(receiver) {
      return this.get$length(receiver) === 0;
    },
    get$isNotEmpty: function(receiver) {
      return this.get$length(receiver) !== 0;
    },
    join$1: function(receiver, separator) {
      var t1;
      if (this.get$length(receiver) === 0)
        return "";
      t1 = P.StringBuffer__writeAll("", receiver, separator);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    map$1$1: function(receiver, f, $T) {
      var t1 = H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0);
      return new H.MappedListIterable(receiver, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    },
    fold$1$2: function(receiver, initialValue, combine, $T) {
      var $length, value, i, _this = this;
      H.assertSubtypeOfRuntimeType(initialValue, $T);
      H.functionTypeCheck(combine, {func: 1, ret: $T, args: [$T, H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0)]});
      $length = _this.get$length(receiver);
      for (value = initialValue, i = 0; i < $length; ++i) {
        value = combine.call$2(value, _this.$index(receiver, i));
        if ($length !== _this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return value;
    },
    add$1: function(receiver, element) {
      var t1, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0));
      t1 = _this.get$length(receiver);
      _this.set$length(receiver, t1 + 1);
      _this.$indexSet(receiver, t1, element);
    },
    addAll$1: function(receiver, iterable) {
      var i, t1, element, i0, _this = this;
      H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0)], "$asIterable");
      i = _this.get$length(receiver);
      for (t1 = iterable.get$iterator(iterable); t1.moveNext$0(); i = i0) {
        element = t1.get$current();
        H.assertHelper(_this.get$length(receiver) === i || H.throwExpression(P.ConcurrentModificationError$(receiver)));
        i0 = i + 1;
        _this.set$length(receiver, i0);
        _this.$indexSet(receiver, i, element);
      }
    },
    remove$1: function(receiver, element) {
      var i;
      for (i = 0; i < this.get$length(receiver); ++i)
        this.$index(receiver, i);
      return false;
    },
    sort$1: function(receiver, compare) {
      var t1 = H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
      H.Sort_sort(receiver, compare, t1);
    },
    $add: function(receiver, other) {
      var result, _this = this,
        t1 = [H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0)];
      H.assertSubtype(other, "$isList", t1, "$asList");
      result = H.setRuntimeTypeInfo([], t1);
      C.JSArray_methods.set$length(result, _this.get$length(receiver) + J.get$length$asx(other));
      C.JSArray_methods.setRange$3(result, 0, _this.get$length(receiver), receiver);
      C.JSArray_methods.setRange$3(result, _this.get$length(receiver), result.length, other);
      return result;
    },
    fillRange$3: function(receiver, start, end, fill) {
      var i;
      H.assertSubtypeOfRuntimeType(fill, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
      P.RangeError_checkValidRange(start, end, this.get$length(receiver));
      for (i = start; i < end; ++i)
        this.$indexSet(receiver, i, fill);
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      var $length, otherStart, otherList, i, _this = this,
        t1 = H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0);
      H.assertSubtype(iterable, "$isIterable", [t1], "$asIterable");
      P.RangeError_checkValidRange(start, end, _this.get$length(receiver));
      $length = end - start;
      if ($length === 0)
        return;
      P.RangeError_checkNotNegative(skipCount, "skipCount");
      if (H.checkSubtype(iterable, "$isList", [t1], "$asList")) {
        otherStart = skipCount;
        otherList = iterable;
      } else {
        otherList = H.SubListIterable$(iterable, skipCount, null, H.getRuntimeTypeArgumentIntercepted(J.getInterceptor$(iterable), iterable, "ListMixin", 0)).toList$1$growable(0, false);
        otherStart = 0;
      }
      t1 = J.getInterceptor$asx(otherList);
      if (otherStart + $length > t1.get$length(otherList))
        throw H.wrapException(H.IterableElementError_tooFew());
      if (otherStart < start)
        for (i = $length - 1; i >= 0; --i)
          _this.$indexSet(receiver, start + i, t1.$index(otherList, otherStart + i));
      else
        for (i = 0; i < $length; ++i)
          _this.$indexSet(receiver, start + i, t1.$index(otherList, otherStart + i));
    },
    indexOf$1: function(receiver, element) {
      var i;
      for (i = 0; i < this.get$length(receiver); ++i)
        this.$index(receiver, i);
      return -1;
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    }
  };
  P.MapBase.prototype = {};
  P.MapBase_mapToString_closure.prototype = {
    call$2: function(k, v) {
      var t2,
        t1 = this._box_0;
      if (!t1.first)
        this.result._contents += ", ";
      t1.first = false;
      t1 = this.result;
      t2 = t1._contents += H.S(k);
      t1._contents = t2 + ": ";
      t1._contents += H.S(v);
    },
    $signature: 21
  };
  P.MapMixin.prototype = {
    forEach$1: function(_, action) {
      var t1, key, _this = this;
      H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(_this, "MapMixin", 0), H.getRuntimeTypeArgument(_this, "MapMixin", 1)]});
      for (t1 = _this.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        key = t1.get$current();
        action.call$2(key, _this.$index(0, key));
      }
    },
    addAll$1: function(_, other) {
      var t1, key;
      H.assertSubtype(other, "$isMap", [H.getRuntimeTypeArgument(this, "MapMixin", 0), H.getRuntimeTypeArgument(this, "MapMixin", 1)], "$asMap");
      for (t1 = other.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        key = t1.get$current();
        this.$indexSet(0, key, other.$index(0, key));
      }
    },
    containsKey$1: function(key) {
      return this.get$keys().contains$1(0, key);
    },
    get$length: function(_) {
      var t1 = this.get$keys();
      return t1.get$length(t1);
    },
    get$isEmpty: function(_) {
      var t1 = this.get$keys();
      return t1.get$isEmpty(t1);
    },
    toString$0: function(_) {
      return P.MapBase_mapToString(this);
    },
    $isMap: 1
  };
  P.ListQueue.prototype = {
    get$iterator: function(_) {
      var _this = this;
      return new P._ListQueueIterator(_this, _this._tail, _this._modificationCount, _this._head, _this.$ti);
    },
    forEach$1: function(_, f) {
      var modificationCount, i, t1, _this = this;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(_this, 0)]});
      modificationCount = _this._modificationCount;
      for (i = _this._head; i !== _this._tail; i = (i + 1 & _this._table.length - 1) >>> 0) {
        t1 = _this._table;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        f.call$1(t1[i]);
        if (modificationCount !== _this._modificationCount)
          H.throwExpression(P.ConcurrentModificationError$(_this));
      }
    },
    get$isEmpty: function(_) {
      return this._head === this._tail;
    },
    get$length: function(_) {
      return (this._tail - this._head & this._table.length - 1) >>> 0;
    },
    get$first: function(_) {
      var t2,
        t1 = this._head;
      if (t1 === this._tail)
        throw H.wrapException(H.IterableElementError_noElement());
      t2 = this._table;
      if (t1 >= t2.length)
        return H.ioore(t2, t1);
      return t2[t1];
    },
    elementAt$1: function(_, index) {
      var t1, t2, t3;
      P.RangeError_checkValidIndex(index, this, null, null);
      t1 = this._table;
      t2 = t1.length;
      t3 = (this._head + index & t2 - 1) >>> 0;
      if (t3 < 0 || t3 >= t2)
        return H.ioore(t1, t3);
      return t1[t3];
    },
    addAll$1: function(_, elements) {
      var addCount, $length, t2, t3, t4, newCapacity, newTable, endSpace, preSpace, element, _this = this,
        t1 = _this.$ti;
      H.assertSubtype(elements, "$isIterable", t1, "$asIterable");
      if (H.checkSubtype(elements, "$isList", t1, "$asList")) {
        addCount = elements.length;
        $length = _this.get$length(_this);
        t2 = $length + addCount;
        t3 = _this._table;
        t4 = t3.length;
        if (t2 >= t4) {
          H.assertHelper(t2 >= _this.get$length(_this));
          newCapacity = P.ListQueue__nextPowerOf2(t2 + (t2 >>> 1));
          if (typeof newCapacity !== "number")
            return H.iae(newCapacity);
          t3 = new Array(newCapacity);
          t3.fixed$length = Array;
          newTable = H.setRuntimeTypeInfo(t3, t1);
          _this._tail = _this._writeToList$1(newTable);
          _this.set$_table(newTable);
          _this._head = 0;
          C.JSArray_methods.setRange$4(_this._table, $length, t2, elements, 0);
          _this._tail += addCount;
        } else {
          t1 = _this._tail;
          endSpace = t4 - t1;
          if (addCount < endSpace) {
            C.JSArray_methods.setRange$4(t3, t1, t1 + addCount, elements, 0);
            _this._tail += addCount;
          } else {
            preSpace = addCount - endSpace;
            C.JSArray_methods.setRange$4(t3, t1, t1 + endSpace, elements, 0);
            C.JSArray_methods.setRange$4(_this._table, 0, preSpace, elements, endSpace);
            _this._tail = preSpace;
          }
        }
        ++_this._modificationCount;
      } else
        for (t1 = J.get$iterator$ax(elements), t2 = H.getTypeArgumentByIndex(_this, 0); t1.moveNext$0();) {
          element = H.assertSubtypeOfRuntimeType(t1.get$current(), t2);
          C.JSArray_methods.$indexSet(_this._table, _this._tail, element);
          t3 = (_this._tail + 1 & _this._table.length - 1) >>> 0;
          _this._tail = t3;
          if (_this._head === t3)
            _this._grow$0();
          ++_this._modificationCount;
        }
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    removeFirst$0: function() {
      var t2, result, _this = this,
        t1 = _this._head;
      if (t1 === _this._tail)
        throw H.wrapException(H.IterableElementError_noElement());
      ++_this._modificationCount;
      t2 = _this._table;
      if (t1 >= t2.length)
        return H.ioore(t2, t1);
      result = t2[t1];
      C.JSArray_methods.$indexSet(t2, t1, null);
      _this._head = (_this._head + 1 & _this._table.length - 1) >>> 0;
      return result;
    },
    _grow$0: function() {
      var newTable, t2, split, _this = this,
        t1 = new Array(_this._table.length * 2);
      t1.fixed$length = Array;
      newTable = H.setRuntimeTypeInfo(t1, _this.$ti);
      t1 = _this._table;
      t2 = _this._head;
      split = t1.length - t2;
      C.JSArray_methods.setRange$4(newTable, 0, split, t1, t2);
      C.JSArray_methods.setRange$4(newTable, split, split + _this._head, _this._table, 0);
      _this._head = 0;
      _this._tail = _this._table.length;
      _this.set$_table(newTable);
    },
    _writeToList$1: function(target) {
      var t1, t2, t3, $length, firstPartSize, _this = this;
      H.assertSubtype(target, "$isList", _this.$ti, "$asList");
      H.assertHelper(target.length >= _this.get$length(_this));
      t1 = _this._head;
      t2 = _this._tail;
      t3 = _this._table;
      if (t1 <= t2) {
        $length = t2 - t1;
        C.JSArray_methods.setRange$4(target, 0, $length, t3, t1);
        return $length;
      } else {
        firstPartSize = t3.length - t1;
        C.JSArray_methods.setRange$4(target, 0, firstPartSize, t3, t1);
        C.JSArray_methods.setRange$4(target, firstPartSize, firstPartSize + _this._tail, _this._table, 0);
        return _this._tail + firstPartSize;
      }
    },
    set$_table: function(_table) {
      this._table = H.assertSubtype(_table, "$isList", this.$ti, "$asList");
    },
    $isQueue: 1
  };
  P._ListQueueIterator.prototype = {
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t2, t3, _this = this,
        t1 = _this._queue;
      if (_this._modificationCount !== t1._modificationCount)
        H.throwExpression(P.ConcurrentModificationError$(t1));
      t2 = _this._position;
      if (t2 === _this._end) {
        _this.set$_collection$_current(null);
        return false;
      }
      t3 = t1._table;
      if (t2 >= t3.length)
        return H.ioore(t3, t2);
      _this.set$_collection$_current(t3[t2]);
      _this._position = (_this._position + 1 & t1._table.length - 1) >>> 0;
      return true;
    },
    set$_collection$_current: function(_current) {
      this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  P.SetMixin.prototype = {
    get$isEmpty: function(_) {
      return this._count === 0;
    },
    addAll$1: function(_, elements) {
      var t1;
      H.assertSubtype(elements, "$isIterable", [H.getTypeArgumentByIndex(this, 0)], "$asIterable");
      for (t1 = elements.get$iterator(elements); t1.moveNext$0();)
        this.add$1(0, t1.get$current());
    },
    toList$1$growable: function(_, growable) {
      var result, t2, i, i0, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      if (growable) {
        result = H.setRuntimeTypeInfo([], [t1]);
        C.JSArray_methods.set$length(result, _this._count);
      } else {
        t2 = new Array(_this._count);
        t2.fixed$length = Array;
        result = H.setRuntimeTypeInfo(t2, [t1]);
      }
      for (t1 = H.getTypeArgumentByIndex(_this, 0), t1 = new P._SplayTreeKeyIterator(_this, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, t1]]), _this._modificationCount, _this._splayCount, [t1]), t1._findLeftMostDescendent$1(_this._root), i = 0; t1.moveNext$0(); i = i0) {
        i0 = i + 1;
        C.JSArray_methods.$indexSet(result, i, t1.get$current());
      }
      return result;
    },
    map$1$1: function(_, f, $T) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      return new H.EfficientLengthMappedIterable(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    forEach$1: function(_, f) {
      var t1, _this = this;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(_this, 0)]});
      for (t1 = H.getTypeArgumentByIndex(_this, 0), t1 = new P._SplayTreeKeyIterator(_this, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, t1]]), _this._modificationCount, _this._splayCount, [t1]), t1._findLeftMostDescendent$1(_this._root); t1.moveNext$0();)
        f.call$1(t1.get$current());
    },
    join$1: function(_, separator) {
      var _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0),
        iterator = new P._SplayTreeKeyIterator(_this, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, t1]]), _this._modificationCount, _this._splayCount, [t1]);
      iterator._findLeftMostDescendent$1(_this._root);
      if (!iterator.moveNext$0())
        return "";
      if (separator === "") {
        t1 = "";
        do
          t1 += H.S(iterator.get$current());
        while (iterator.moveNext$0());
      } else {
        t1 = H.S(iterator.get$current());
        for (; iterator.moveNext$0();)
          t1 = t1 + separator + H.S(iterator.get$current());
      }
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  P._SetBase.prototype = {
    difference$1: function(other) {
      var result, t1, element;
      H.assertSubtype(other, "$isSet", [P.Object], "$asSet");
      result = this._newSet$0();
      for (t1 = this.get$iterator(this); t1.moveNext$0();) {
        element = t1.get$current();
        if (!other.contains$1(0, element))
          result.add$1(0, element);
      }
      return result;
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    addAll$1: function(_, elements) {
      var t1;
      for (t1 = J.get$iterator$ax(H.assertSubtype(elements, "$isIterable", this.$ti, "$asIterable")); t1.moveNext$0();)
        this.add$1(0, t1.get$current());
    },
    toList$1$growable: function(_, growable) {
      var t1, i, i0, _this = this,
        result = H.setRuntimeTypeInfo([], _this.$ti);
      C.JSArray_methods.set$length(result, _this.get$length(_this));
      for (t1 = _this.get$iterator(_this), i = 0; t1.moveNext$0(); i = i0) {
        i0 = i + 1;
        C.JSArray_methods.$indexSet(result, i, t1.get$current());
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    map$1$1: function(_, f, $T) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      return new H.EfficientLengthMappedIterable(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    },
    get$single: function(_) {
      var it, _this = this;
      if (_this.get$length(_this) > 1)
        throw H.wrapException(H.IterableElementError_tooMany());
      it = _this.get$iterator(_this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      return it.get$current();
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    forEach$1: function(_, f) {
      var t1;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1.get$current());
    },
    join$1: function(_, separator) {
      var t1,
        iterator = this.get$iterator(this);
      if (!iterator.moveNext$0())
        return "";
      if (separator === "") {
        t1 = "";
        do
          t1 += H.S(iterator.get$current());
        while (iterator.moveNext$0());
      } else {
        t1 = H.S(iterator.get$current());
        for (; iterator.moveNext$0();)
          t1 = t1 + separator + H.S(iterator.get$current());
      }
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isSet: 1
  };
  P._SplayTreeNode.prototype = {
    set$left: function(left) {
      this.left = H.assertSubtype(left, "$is_SplayTreeNode", this.$ti, "$as_SplayTreeNode");
    },
    set$right: function(right) {
      this.right = H.assertSubtype(right, "$is_SplayTreeNode", this.$ti, "$as_SplayTreeNode");
    }
  };
  P._SplayTree.prototype = {
    _splayMax$1: function(node) {
      var current, t2,
        t1 = H.getRuntimeTypeArgument(this, "_SplayTree", 1);
      H.assertSubtypeOfRuntimeType(node, t1);
      for (current = node; t2 = current.right, t2 != null; current = t2) {
        H.assertSubtypeOfRuntimeType(t2, t1);
        current.set$right(t2.left);
        t2.set$left(current);
      }
      return current;
    },
    _splay$1: function(key) {
      var current, left, t1, t2, right, left0, comp, t3, t4, t5, tmp, current0, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getRuntimeTypeArgument(_this, "_SplayTree", 0));
      current = _this._root;
      if (current == null)
        return -1;
      left = _this._dummy;
      for (t1 = H.getRuntimeTypeArgument(_this, "_SplayTree", 1), t2 = H.getTypeArgumentByIndex(_this, 0), right = left, left0 = right, comp = null; true;) {
        t3 = H.assertSubtypeOfRuntimeType(current.key, t2);
        H.assertSubtypeOfRuntimeType(key, t2);
        t4 = _this._comparator;
        t3 = t4.call$2(t3, key);
        if (typeof t3 !== "number")
          return t3.$gt();
        if (t3 > 0) {
          t5 = current.left;
          if (t5 == null) {
            comp = t3;
            break;
          }
          t3 = t4.call$2(H.assertSubtypeOfRuntimeType(t5.key, t2), key);
          if (typeof t3 !== "number")
            return t3.$gt();
          if (t3 > 0) {
            tmp = current.left;
            current.set$left(tmp.right);
            tmp.set$right(current);
            H.assertSubtypeOfRuntimeType(tmp, t1);
            if (tmp.left == null) {
              comp = t3;
              current = tmp;
              break;
            }
            current = tmp;
          }
          right.set$left(current);
          current0 = H.assertSubtypeOfRuntimeType(current.left, t1);
          comp = t3;
          right = current;
          current = current0;
        } else {
          if (t3 < 0) {
            t5 = current.right;
            if (t5 == null) {
              comp = t3;
              break;
            }
            t3 = t4.call$2(H.assertSubtypeOfRuntimeType(t5.key, t2), key);
            if (typeof t3 !== "number")
              return t3.$lt();
            if (t3 < 0) {
              tmp = H.assertSubtypeOfRuntimeType(current.right, t1);
              current.set$right(tmp.left);
              tmp.set$left(current);
              if (tmp.right == null) {
                comp = t3;
                current = tmp;
                break;
              }
              current = tmp;
            }
            left0.set$right(current);
            current0 = H.assertSubtypeOfRuntimeType(current.right, t1);
          } else {
            comp = t3;
            break;
          }
          comp = t3;
          left0 = current;
          current = current0;
        }
      }
      left0.set$right(current.left);
      right.set$left(current.right);
      current.set$left(left.right);
      current.set$right(left.left);
      _this.set$_root(current);
      left.set$right(null);
      left.set$left(null);
      ++_this._splayCount;
      return comp;
    },
    _remove$1: function(key) {
      var result, t1, t2, right, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getRuntimeTypeArgument(_this, "_SplayTree", 0));
      if (_this._root == null)
        return;
      if (_this._splay$1(key) !== 0)
        return;
      result = _this._root;
      --_this._count;
      t1 = result.left;
      t2 = H.getRuntimeTypeArgument(_this, "_SplayTree", 1);
      if (t1 == null)
        _this.set$_root(H.assertSubtypeOfRuntimeType(result.right, t2));
      else {
        right = H.assertSubtypeOfRuntimeType(result.right, t2);
        _this.set$_root(_this._splayMax$1(H.assertSubtypeOfRuntimeType(t1, t2)));
        _this._root.set$right(right);
      }
      ++_this._modificationCount;
      return result;
    },
    _addNewRoot$2: function(node, comp) {
      var t1, _this = this;
      H.assertSubtypeOfRuntimeType(node, H.getRuntimeTypeArgument(_this, "_SplayTree", 1));
      ++_this._count;
      ++_this._modificationCount;
      t1 = _this._root;
      if (t1 == null) {
        _this.set$_root(node);
        return;
      }
      if (typeof comp !== "number")
        return comp.$lt();
      if (comp < 0) {
        node.set$left(t1);
        node.set$right(_this._root.right);
        _this._root.set$right(null);
      } else {
        node.set$right(t1);
        node.set$left(_this._root.left);
        _this._root.set$left(null);
      }
      _this.set$_root(node);
    }
  };
  P._SplayTreeIterator.prototype = {
    get$current: function() {
      var t1 = this._currentNode;
      if (t1 == null)
        return;
      return H.assertSubtype(t1, "$is_SplayTreeNode", [H.getTypeArgumentByIndex(this, 0)], "$as_SplayTreeNode").key;
    },
    _findLeftMostDescendent$1: function(node) {
      var t1;
      H.assertSubtype(node, "$is_SplayTreeNode", [H.getRuntimeTypeArgument(this, "_SplayTreeIterator", 0)], "$as_SplayTreeNode");
      for (t1 = this._workList; node != null;) {
        C.JSArray_methods.add$1(t1, node);
        node = node.left;
      }
    },
    moveNext$0: function() {
      var t2, t3, _this = this,
        t1 = _this._tree;
      if (_this._modificationCount !== t1._modificationCount)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t2 = _this._workList;
      if (t2.length === 0) {
        _this.set$_currentNode(null);
        return false;
      }
      if (t1._splayCount !== _this._splayCount && _this._currentNode != null) {
        t3 = H.assertSubtype(_this._currentNode, "$is_SplayTreeNode", [H.getRuntimeTypeArgument(_this, "_SplayTreeIterator", 0)], "$as_SplayTreeNode");
        C.JSArray_methods.set$length(t2, 0);
        if (t3 == null)
          _this._findLeftMostDescendent$1(t1._root);
        else {
          t1._splay$1(t3.key);
          _this._findLeftMostDescendent$1(t1._root.right);
          H.assertHelper(t2.length !== 0);
        }
      }
      if (0 >= t2.length)
        return H.ioore(t2, -1);
      _this.set$_currentNode(t2.pop());
      _this._findLeftMostDescendent$1(_this._currentNode.right);
      return true;
    },
    set$_currentNode: function(_currentNode) {
      this._currentNode = H.assertSubtype(_currentNode, "$is_SplayTreeNode", [H.getRuntimeTypeArgument(this, "_SplayTreeIterator", 0)], "$as_SplayTreeNode");
    },
    $isIterator: 1,
    $asIterator: function($K, $T) {
      return [$T];
    }
  };
  P._SplayTreeKeyIterator.prototype = {
    $as_SplayTreeIterator: function($K) {
      return [$K, $K];
    },
    $asIterator: null
  };
  P.SplayTreeSet.prototype = {
    get$iterator: function(_) {
      var _this = this,
        t1 = new P._SplayTreeKeyIterator(_this, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, H.getTypeArgumentByIndex(_this, 0)]]), _this._modificationCount, _this._splayCount, _this.$ti);
      t1._findLeftMostDescendent$1(_this._root);
      return t1;
    },
    get$length: function(_) {
      return this._count;
    },
    get$isEmpty: function(_) {
      return this._root == null;
    },
    add$1: function(_, element) {
      var compare, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      compare = _this._splay$1(element);
      if (compare === 0)
        return false;
      _this._addNewRoot$2(new P._SplayTreeNode(element, _this.$ti), compare);
      return true;
    },
    remove$1: function(_, object) {
      if (!H.boolConversionCheck(this._validKey.call$1(object)))
        return false;
      return this._remove$1(H.assertSubtypeOfRuntimeType(object, H.getTypeArgumentByIndex(this, 0))) != null;
    },
    addAll$1: function(_, elements) {
      var t2, _i, element, compare,
        t1 = this.$ti;
      H.assertSubtype(elements, "$isIterable", t1, "$asIterable");
      for (t2 = elements.length, _i = 0; _i < elements.length; elements.length === t2 || (0, H.throwConcurrentModificationError)(elements), ++_i) {
        element = elements[_i];
        compare = this._splay$1(element);
        if (compare !== 0)
          this._addNewRoot$2(new P._SplayTreeNode(element, t1), compare);
      }
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    set$_root: function(_root) {
      this._root = H.assertSubtype(_root, "$is_SplayTreeNode", this.$ti, "$as_SplayTreeNode");
    },
    $isEfficientLengthIterable: 1,
    $as_SplayTree: function($E) {
      return [$E, [P._SplayTreeNode, $E]];
    },
    $isIterable: 1,
    $isSet: 1
  };
  P.SplayTreeSet_closure.prototype = {
    call$1: function(v) {
      return H.checkSubtypeOfRuntimeType(v, this.E);
    },
    $signature: 180
  };
  P._ListBase_Object_ListMixin.prototype = {};
  P._SplayTreeSet__SplayTree_IterableMixin.prototype = {};
  P._SplayTreeSet__SplayTree_IterableMixin_SetMixin.prototype = {};
  P._JsonMap.prototype = {
    $index: function(_, key) {
      var result,
        t1 = this._processed;
      if (t1 == null)
        return this.get$_upgradedMap().$index(0, key);
      else if (typeof key !== "string")
        return;
      else {
        result = t1[key];
        return typeof result == "undefined" ? this._process$1(key) : result;
      }
    },
    get$length: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this.get$_upgradedMap();
        t1 = t1.get$length(t1);
      } else
        t1 = this._convert$_computeKeys$0().length;
      return t1;
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    get$keys: function() {
      if (this._processed == null)
        return this.get$_upgradedMap().get$keys();
      return new P._JsonMapKeyIterable(this);
    },
    $indexSet: function(_, key, value) {
      var processed, original, _this = this;
      if (_this._processed == null)
        _this.get$_upgradedMap().$indexSet(0, key, value);
      else if (_this.containsKey$1(key)) {
        processed = _this._processed;
        processed[key] = value;
        original = _this._original;
        if (original == null ? processed != null : original !== processed)
          original[key] = null;
      } else
        _this._upgrade$0().$indexSet(0, key, value);
    },
    addAll$1: function(_, other) {
      H.assertSubtype(other, "$isMap", [P.String, null], "$asMap").forEach$1(0, new P._JsonMap_addAll_closure(this));
    },
    containsKey$1: function(key) {
      if (this._processed == null)
        return this.get$_upgradedMap().containsKey$1(key);
      return Object.prototype.hasOwnProperty.call(this._original, key);
    },
    remove$1: function(_, key) {
      if (this._processed != null && !this.containsKey$1(key))
        return;
      return this._upgrade$0().remove$1(0, key);
    },
    forEach$1: function(_, f) {
      var keys, i, key, value, _this = this;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String,,]});
      if (_this._processed == null)
        return _this.get$_upgradedMap().forEach$1(0, f);
      keys = _this._convert$_computeKeys$0();
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        value = _this._processed[key];
        if (typeof value == "undefined") {
          value = P._convertJsonToDartLazy(_this._original[key]);
          _this._processed[key] = value;
        }
        f.call$2(key, value);
        if (keys !== _this._data)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
    },
    get$_upgradedMap: function() {
      H.assertHelper(this._processed == null);
      return this._data;
    },
    _convert$_computeKeys$0: function() {
      var keys, _this = this;
      H.assertHelper(_this._processed != null);
      keys = H.listTypeCheck(_this._data);
      if (keys == null)
        keys = _this._data = H.setRuntimeTypeInfo(Object.keys(_this._original), [P.String]);
      return keys;
    },
    _upgrade$0: function() {
      var result, keys, i, t1, key, _this = this;
      if (_this._processed == null)
        return _this.get$_upgradedMap();
      result = P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
      keys = _this._convert$_computeKeys$0();
      for (i = 0; t1 = keys.length, i < t1; ++i) {
        key = keys[i];
        result.$indexSet(0, key, _this.$index(0, key));
      }
      if (t1 === 0)
        C.JSArray_methods.add$1(keys, null);
      else
        C.JSArray_methods.set$length(keys, 0);
      _this._original = _this._processed = null;
      return _this._data = result;
    },
    _process$1: function(key) {
      var result;
      if (!Object.prototype.hasOwnProperty.call(this._original, key))
        return;
      result = P._convertJsonToDartLazy(this._original[key]);
      return this._processed[key] = result;
    },
    $asMapMixin: function() {
      return [P.String, null];
    },
    $asMap: function() {
      return [P.String, null];
    }
  };
  P._JsonMap_addAll_closure.prototype = {
    call$2: function(key, value) {
      this.$this.$indexSet(0, key, value);
    },
    $signature: 179
  };
  P._JsonMapKeyIterable.prototype = {
    get$length: function(_) {
      var t1 = this._convert$_parent;
      return t1.get$length(t1);
    },
    elementAt$1: function(_, index) {
      var t1 = this._convert$_parent;
      if (t1._processed == null)
        t1 = t1.get$keys().elementAt$1(0, index);
      else {
        t1 = t1._convert$_computeKeys$0();
        if (index < 0 || index >= t1.length)
          return H.ioore(t1, index);
        t1 = t1[index];
      }
      return t1;
    },
    get$iterator: function(_) {
      var t1 = this._convert$_parent;
      if (t1._processed == null) {
        t1 = t1.get$keys();
        t1 = t1.get$iterator(t1);
      } else {
        t1 = t1._convert$_computeKeys$0();
        t1 = new J.ArrayIterator(t1, t1.length, [H.getTypeArgumentByIndex(t1, 0)]);
      }
      return t1;
    },
    contains$1: function(_, key) {
      return this._convert$_parent.containsKey$1(key);
    },
    $asEfficientLengthIterable: function() {
      return [P.String];
    },
    $asListIterable: function() {
      return [P.String];
    },
    $asIterable: function() {
      return [P.String];
    }
  };
  P.Base64Codec.prototype = {
    normalize$3: function(source, start, end) {
      var inverseAlphabet, i, sliceStart, buffer, firstPadding, firstPaddingSourceIndex, paddingCount, i0, char, i1, digit1, digit2, char0, value, t2, endLength, $length,
        _s31_ = "Invalid base64 encoding length ",
        t1 = source.length;
      end = P.RangeError_checkValidRange(start, end, t1);
      inverseAlphabet = $.$get$_Base64Decoder__inverseAlphabet();
      for (i = start, sliceStart = i, buffer = null, firstPadding = -1, firstPaddingSourceIndex = -1, paddingCount = 0; i < end; i = i0) {
        i0 = i + 1;
        char = C.JSString_methods._codeUnitAt$1(source, i);
        if (char === 37) {
          i1 = i0 + 2;
          if (i1 <= end) {
            H.assertHelper(i1 <= t1);
            digit1 = H.hexDigitValue(C.JSString_methods._codeUnitAt$1(source, i0));
            digit2 = H.hexDigitValue(C.JSString_methods._codeUnitAt$1(source, i0 + 1));
            char0 = digit1 * 16 + digit2 - (digit2 & 256);
            if (char0 === 37)
              char0 = -1;
            i0 = i1;
          } else
            char0 = -1;
        } else
          char0 = char;
        if (0 <= char0 && char0 <= 127) {
          if (char0 < 0 || char0 >= inverseAlphabet.length)
            return H.ioore(inverseAlphabet, char0);
          value = inverseAlphabet[char0];
          if (value >= 0) {
            char0 = C.JSString_methods.codeUnitAt$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", value);
            if (char0 === char)
              continue;
            char = char0;
          } else {
            if (value === -1) {
              if (firstPadding < 0) {
                t2 = buffer == null ? null : buffer._contents.length;
                if (t2 == null)
                  t2 = 0;
                firstPadding = t2 + (i - sliceStart);
                firstPaddingSourceIndex = i;
              }
              ++paddingCount;
              if (char === 61)
                continue;
            }
            char = char0;
          }
          if (value !== -2) {
            if (buffer == null)
              buffer = new P.StringBuffer("");
            buffer._contents += C.JSString_methods.substring$2(source, sliceStart, i);
            buffer._contents += H.Primitives_stringFromCharCode(char);
            sliceStart = i0;
            continue;
          }
        }
        throw H.wrapException(P.FormatException$("Invalid base64 data", source, i));
      }
      if (buffer != null) {
        t1 = buffer._contents += C.JSString_methods.substring$2(source, sliceStart, end);
        t2 = t1.length;
        if (firstPadding >= 0)
          P.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, t2);
        else {
          endLength = C.JSInt_methods.$mod(t2 - 1, 4) + 1;
          if (endLength === 1)
            throw H.wrapException(P.FormatException$(_s31_, source, end));
          for (; endLength < 4;) {
            t1 += "=";
            buffer._contents = t1;
            ++endLength;
          }
        }
        t1 = buffer._contents;
        return C.JSString_methods.replaceRange$3(source, start, end, t1.charCodeAt(0) == 0 ? t1 : t1);
      }
      $length = end - start;
      if (firstPadding >= 0)
        P.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, $length);
      else {
        endLength = C.JSInt_methods.$mod($length, 4);
        if (endLength === 1)
          throw H.wrapException(P.FormatException$(_s31_, source, end));
        if (endLength > 1)
          source = C.JSString_methods.replaceRange$3(source, end, end, endLength === 2 ? "==" : "=");
      }
      return source;
    },
    $asCodec: function() {
      return [[P.List, P.int], P.String];
    }
  };
  P.Base64Encoder.prototype = {
    $asConverter: function() {
      return [[P.List, P.int], P.String];
    }
  };
  P.Codec.prototype = {};
  P.Converter.prototype = {};
  P.Encoding.prototype = {
    $asCodec: function() {
      return [P.String, [P.List, P.int]];
    }
  };
  P.JsonUnsupportedObjectError.prototype = {
    toString$0: function(_) {
      var safeString = P.Error_safeToString(this.unsupportedObject);
      return (this.cause != null ? "Converting object to an encodable object failed:" : "Converting object did not return an encodable object:") + " " + safeString;
    }
  };
  P.JsonCyclicError.prototype = {
    toString$0: function(_) {
      return "Cyclic error in JSON stringify";
    }
  };
  P.JsonCodec.prototype = {
    decode$1: function(source) {
      var t1 = P._parseJson(source, this.get$decoder()._reviver);
      return t1;
    },
    encode$1: function(value) {
      var t1 = P._JsonStringStringifier_stringify(value, this.get$encoder()._toEncodable, null);
      return t1;
    },
    get$encoder: function() {
      return C.JsonEncoder_null;
    },
    get$decoder: function() {
      return C.JsonDecoder_null;
    },
    $asCodec: function() {
      return [P.Object, P.String];
    }
  };
  P.JsonEncoder.prototype = {
    $asConverter: function() {
      return [P.Object, P.String];
    }
  };
  P.JsonDecoder.prototype = {
    $asConverter: function() {
      return [P.String, P.Object];
    }
  };
  P._JsonStringifier.prototype = {
    writeStringContent$1: function(s) {
      var t1, t2, offset, i, charCode, t3,
        $length = s.length;
      for (t1 = J.getInterceptor$s(s), t2 = this._sink, offset = 0, i = 0; i < $length; ++i) {
        charCode = t1._codeUnitAt$1(s, i);
        if (charCode > 92)
          continue;
        if (charCode < 32) {
          if (i > offset)
            t2._contents += C.JSString_methods.substring$2(s, offset, i);
          offset = i + 1;
          t2._contents += H.Primitives_stringFromCharCode(92);
          switch (charCode) {
            case 8:
              t2._contents += H.Primitives_stringFromCharCode(98);
              break;
            case 9:
              t2._contents += H.Primitives_stringFromCharCode(116);
              break;
            case 10:
              t2._contents += H.Primitives_stringFromCharCode(110);
              break;
            case 12:
              t2._contents += H.Primitives_stringFromCharCode(102);
              break;
            case 13:
              t2._contents += H.Primitives_stringFromCharCode(114);
              break;
            default:
              t2._contents += H.Primitives_stringFromCharCode(117);
              t2._contents += H.Primitives_stringFromCharCode(48);
              t2._contents += H.Primitives_stringFromCharCode(48);
              t3 = charCode >>> 4 & 15;
              t2._contents += H.Primitives_stringFromCharCode(t3 < 10 ? 48 + t3 : 87 + t3);
              t3 = charCode & 15;
              t2._contents += H.Primitives_stringFromCharCode(t3 < 10 ? 48 + t3 : 87 + t3);
              break;
          }
        } else if (charCode === 34 || charCode === 92) {
          if (i > offset)
            t2._contents += C.JSString_methods.substring$2(s, offset, i);
          offset = i + 1;
          t2._contents += H.Primitives_stringFromCharCode(92);
          t2._contents += H.Primitives_stringFromCharCode(charCode);
        }
      }
      if (offset === 0)
        t2._contents += H.S(s);
      else if (offset < $length)
        t2._contents += t1.substring$2(s, offset, $length);
    },
    _checkCycle$1: function(object) {
      var t1, t2, i, t3;
      for (t1 = this._seen, t2 = t1.length, i = 0; i < t2; ++i) {
        t3 = t1[i];
        if (object == null ? t3 == null : object === t3)
          throw H.wrapException(new P.JsonCyclicError(object, null));
      }
      C.JSArray_methods.add$1(t1, object);
    },
    _removeSeen$1: function(object) {
      var t2,
        t1 = this._seen;
      H.assertHelper(t1.length !== 0);
      t2 = C.JSArray_methods.get$last(t1);
      H.assertHelper(t2 == null ? object == null : t2 === object);
      if (0 >= t1.length)
        return H.ioore(t1, -1);
      t1.pop();
    },
    writeObject$1: function(object) {
      var customJson, e, t1, exception, _this = this;
      if (_this.writeJsonValue$1(object))
        return;
      _this._checkCycle$1(object);
      try {
        customJson = _this._toEncodable.call$1(object);
        if (!_this.writeJsonValue$1(customJson)) {
          t1 = P.JsonUnsupportedObjectError$(object, null, _this.get$_partialResult());
          throw H.wrapException(t1);
        }
        _this._removeSeen$1(object);
      } catch (exception) {
        e = H.unwrapException(exception);
        t1 = P.JsonUnsupportedObjectError$(object, e, _this.get$_partialResult());
        throw H.wrapException(t1);
      }
    },
    writeJsonValue$1: function(object) {
      var t1, success, _this = this;
      if (typeof object === "number") {
        if (!isFinite(object))
          return false;
        _this._sink._contents += C.JSNumber_methods.toString$0(object);
        return true;
      } else if (object === true) {
        _this._sink._contents += "true";
        return true;
      } else if (object === false) {
        _this._sink._contents += "false";
        return true;
      } else if (object == null) {
        _this._sink._contents += "null";
        return true;
      } else if (typeof object === "string") {
        t1 = _this._sink;
        t1._contents += '"';
        _this.writeStringContent$1(object);
        t1._contents += '"';
        return true;
      } else {
        t1 = J.getInterceptor$(object);
        if (!!t1.$isList) {
          _this._checkCycle$1(object);
          _this.writeList$1(object);
          _this._removeSeen$1(object);
          return true;
        } else if (!!t1.$isMap) {
          _this._checkCycle$1(object);
          success = _this.writeMap$1(object);
          _this._removeSeen$1(object);
          return success;
        } else
          return false;
      }
    },
    writeList$1: function(list) {
      var t2, i,
        t1 = this._sink;
      t1._contents += "[";
      t2 = J.getInterceptor$asx(list);
      if (t2.get$isNotEmpty(list)) {
        this.writeObject$1(t2.$index(list, 0));
        for (i = 1; i < t2.get$length(list); ++i) {
          t1._contents += ",";
          this.writeObject$1(t2.$index(list, i));
        }
      }
      t1._contents += "]";
    },
    writeMap$1: function(map) {
      var t1, keyValueList, i, t2, separator, t3, _this = this, _box_0 = {};
      if (map.get$isEmpty(map)) {
        _this._sink._contents += "{}";
        return true;
      }
      t1 = map.get$length(map) * 2;
      keyValueList = new Array(t1);
      keyValueList.fixed$length = Array;
      i = _box_0.i = 0;
      _box_0.allStringKeys = true;
      map.forEach$1(0, new P._JsonStringifier_writeMap_closure(_box_0, keyValueList));
      if (!_box_0.allStringKeys)
        return false;
      t2 = _this._sink;
      t2._contents += "{";
      for (separator = '"'; i < t1; i += 2, separator = ',"') {
        t2._contents += separator;
        _this.writeStringContent$1(H.stringTypeCheck(keyValueList[i]));
        t2._contents += '":';
        t3 = i + 1;
        if (t3 >= t1)
          return H.ioore(keyValueList, t3);
        _this.writeObject$1(keyValueList[t3]);
      }
      t2._contents += "}";
      return true;
    }
  };
  P._JsonStringifier_writeMap_closure.prototype = {
    call$2: function(key, value) {
      var t1, t2;
      if (typeof key !== "string")
        this._box_0.allStringKeys = false;
      t1 = this.keyValueList;
      t2 = this._box_0;
      C.JSArray_methods.$indexSet(t1, t2.i++, key);
      C.JSArray_methods.$indexSet(t1, t2.i++, value);
    },
    $signature: 21
  };
  P._JsonStringStringifier.prototype = {
    get$_partialResult: function() {
      var t1 = this._sink._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  P.Utf8Codec.prototype = {
    decode$1: function(codeUnits) {
      H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
      return new P.Utf8Decoder(false).convert$1(codeUnits);
    },
    get$encoder: function() {
      return C.C_Utf8Encoder;
    }
  };
  P.Utf8Encoder.prototype = {
    convert$1: function(string) {
      var t1, encoder, endPosition, t2, lastCodeUnit,
        end = P.RangeError_checkValidRange(0, null, string.length),
        $length = end - 0;
      if ($length === 0)
        return new Uint8Array(0);
      t1 = new Uint8Array($length * 3);
      encoder = new P._Utf8Encoder(t1);
      endPosition = encoder._fillBuffer$3(string, 0, end);
      t2 = end - 1;
      H.assertHelper(endPosition >= t2);
      if (endPosition !== end) {
        lastCodeUnit = C.JSString_methods.codeUnitAt$1(string, t2);
        H.assertHelper((lastCodeUnit & 64512) === 55296);
        H.assertHelper(!encoder._writeSurrogate$2(lastCodeUnit, 0));
      }
      return new Uint8Array(t1.subarray(0, H._checkValidRange(0, encoder._bufferIndex, t1.length)));
    },
    $asConverter: function() {
      return [P.String, [P.List, P.int]];
    }
  };
  P._Utf8Encoder.prototype = {
    _writeSurrogate$2: function(leadingSurrogate, nextCodeUnit) {
      var rune, t3, t4, _this = this,
        t1 = _this._convert$_buffer,
        t2 = t1.length;
      if ((nextCodeUnit & 64512) === 56320) {
        rune = 65536 + ((leadingSurrogate & 1023) << 10) | nextCodeUnit & 1023;
        H.assertHelper(rune > 65535);
        H.assertHelper(rune <= 1114111);
        t3 = _this._bufferIndex;
        t4 = _this._bufferIndex = t3 + 1;
        if (t3 >= t2)
          return H.ioore(t1, t3);
        t1[t3] = 240 | rune >>> 18;
        t3 = _this._bufferIndex = t4 + 1;
        if (t4 >= t2)
          return H.ioore(t1, t4);
        t1[t4] = 128 | rune >>> 12 & 63;
        t4 = _this._bufferIndex = t3 + 1;
        if (t3 >= t2)
          return H.ioore(t1, t3);
        t1[t3] = 128 | rune >>> 6 & 63;
        _this._bufferIndex = t4 + 1;
        if (t4 >= t2)
          return H.ioore(t1, t4);
        t1[t4] = 128 | rune & 63;
        return true;
      } else {
        t3 = _this._bufferIndex;
        t4 = _this._bufferIndex = t3 + 1;
        if (t3 >= t2)
          return H.ioore(t1, t3);
        t1[t3] = 224 | leadingSurrogate >>> 12;
        t3 = _this._bufferIndex = t4 + 1;
        if (t4 >= t2)
          return H.ioore(t1, t4);
        t1[t4] = 128 | leadingSurrogate >>> 6 & 63;
        _this._bufferIndex = t3 + 1;
        if (t3 >= t2)
          return H.ioore(t1, t3);
        t1[t3] = 128 | leadingSurrogate & 63;
        return false;
      }
    },
    _fillBuffer$3: function(str, start, end) {
      var t1, t2, stringIndex, codeUnit, t3, stringIndex0, t4, _this = this;
      if (start !== end && (C.JSString_methods.codeUnitAt$1(str, end - 1) & 64512) === 55296)
        --end;
      for (t1 = _this._convert$_buffer, t2 = t1.length, stringIndex = start; stringIndex < end; ++stringIndex) {
        codeUnit = C.JSString_methods._codeUnitAt$1(str, stringIndex);
        if (codeUnit <= 127) {
          t3 = _this._bufferIndex;
          if (t3 >= t2)
            break;
          _this._bufferIndex = t3 + 1;
          t1[t3] = codeUnit;
        } else if ((codeUnit & 64512) === 55296) {
          if (_this._bufferIndex + 3 >= t2)
            break;
          stringIndex0 = stringIndex + 1;
          if (_this._writeSurrogate$2(codeUnit, C.JSString_methods._codeUnitAt$1(str, stringIndex0)))
            stringIndex = stringIndex0;
        } else if (codeUnit <= 2047) {
          t3 = _this._bufferIndex;
          t4 = t3 + 1;
          if (t4 >= t2)
            break;
          _this._bufferIndex = t4;
          if (t3 >= t2)
            return H.ioore(t1, t3);
          t1[t3] = 192 | codeUnit >>> 6;
          _this._bufferIndex = t4 + 1;
          t1[t4] = 128 | codeUnit & 63;
        } else {
          H.assertHelper(codeUnit <= 65535);
          t3 = _this._bufferIndex;
          if (t3 + 2 >= t2)
            break;
          t4 = _this._bufferIndex = t3 + 1;
          if (t3 >= t2)
            return H.ioore(t1, t3);
          t1[t3] = 224 | codeUnit >>> 12;
          t3 = _this._bufferIndex = t4 + 1;
          if (t4 >= t2)
            return H.ioore(t1, t4);
          t1[t4] = 128 | codeUnit >>> 6 & 63;
          _this._bufferIndex = t3 + 1;
          if (t3 >= t2)
            return H.ioore(t1, t3);
          t1[t3] = 128 | codeUnit & 63;
        }
      }
      return stringIndex;
    }
  };
  P.Utf8Decoder.prototype = {
    convert$1: function(codeUnits) {
      var result, end, oneBytes, firstPart, buffer, start, isFirstCharacter, decoder, t1;
      H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
      result = P.Utf8Decoder__convertIntercepted(false, codeUnits, 0, null);
      if (result != null)
        return result;
      end = P.RangeError_checkValidRange(0, null, codeUnits.length);
      oneBytes = P._scanOneByteCharacters(codeUnits, 0, end);
      if (oneBytes > 0) {
        firstPart = P.String_String$fromCharCodes(codeUnits, 0, oneBytes);
        if (oneBytes === end)
          return firstPart;
        buffer = new P.StringBuffer(firstPart);
        start = oneBytes;
        isFirstCharacter = false;
      } else {
        start = 0;
        buffer = null;
        isFirstCharacter = true;
      }
      if (buffer == null)
        buffer = new P.StringBuffer("");
      decoder = new P._Utf8Decoder(false, buffer);
      decoder._isFirstCharacter = isFirstCharacter;
      decoder.convert$3(codeUnits, start, end);
      if (decoder._expectedUnits > 0) {
        H.throwExpression(P.FormatException$("Unfinished UTF-8 octet sequence", codeUnits, end));
        buffer._contents += H.Primitives_stringFromCharCode(65533);
        decoder._extraUnits = decoder._expectedUnits = decoder._convert$_value = 0;
      }
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $asConverter: function() {
      return [[P.List, P.int], P.String];
    }
  };
  P._Utf8Decoder.prototype = {
    convert$3: function(codeUnits, startIndex, endIndex) {
      var value, expectedUnits, extraUnits, t1, t2, i, unit, t3, oneBytes, i0, i1, t4, _this = this,
        _s21_ = "Bad UTF-8 encoding 0x";
      H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
      value = _this._convert$_value;
      expectedUnits = _this._expectedUnits;
      extraUnits = _this._extraUnits;
      _this._extraUnits = _this._expectedUnits = _this._convert$_value = 0;
      $label0$0:
        for (t1 = codeUnits.length, t2 = _this._stringSink, i = startIndex; true; i = i1) {
          $label1$1:
            if (expectedUnits > 0) {
              do {
                if (i === endIndex)
                  break $label0$0;
                if (i < 0 || i >= t1)
                  return H.ioore(codeUnits, i);
                unit = codeUnits[i];
                if ((unit & 192) !== 128) {
                  t3 = P.FormatException$(_s21_ + C.JSInt_methods.toRadixString$1(unit, 16), codeUnits, i);
                  throw H.wrapException(t3);
                } else {
                  value = (value << 6 | unit & 63) >>> 0;
                  --expectedUnits;
                  ++i;
                }
              } while (expectedUnits > 0);
              t3 = extraUnits - 1;
              if (t3 < 0 || t3 >= 4)
                return H.ioore(C.List_127_2047_65535_1114111, t3);
              if (value <= C.List_127_2047_65535_1114111[t3]) {
                t3 = P.FormatException$("Overlong encoding of 0x" + C.JSInt_methods.toRadixString$1(value, 16), codeUnits, i - extraUnits - 1);
                throw H.wrapException(t3);
              }
              if (value > 1114111) {
                t3 = P.FormatException$("Character outside valid Unicode range: 0x" + C.JSInt_methods.toRadixString$1(value, 16), codeUnits, i - extraUnits - 1);
                throw H.wrapException(t3);
              }
              if (!_this._isFirstCharacter || value !== 65279)
                t2._contents += H.Primitives_stringFromCharCode(value);
              _this._isFirstCharacter = false;
            }
          for (t3 = i < endIndex; t3;) {
            oneBytes = P._scanOneByteCharacters(codeUnits, i, endIndex);
            if (oneBytes > 0) {
              _this._isFirstCharacter = false;
              i0 = i + oneBytes;
              H.assertHelper(i0 <= endIndex);
              t2._contents += P.String_String$fromCharCodes(codeUnits, i, i0);
              if (i0 === endIndex)
                break;
            } else
              i0 = i;
            i1 = i0 + 1;
            if (i0 < 0 || i0 >= t1)
              return H.ioore(codeUnits, i0);
            unit = codeUnits[i0];
            H.assertHelper(unit > 127);
            if ((unit & 224) === 192) {
              value = unit & 31;
              expectedUnits = 1;
              extraUnits = 1;
              continue $label0$0;
            }
            if ((unit & 240) === 224) {
              value = unit & 15;
              expectedUnits = 2;
              extraUnits = 2;
              continue $label0$0;
            }
            if ((unit & 248) === 240 && unit < 245) {
              value = unit & 7;
              expectedUnits = 3;
              extraUnits = 3;
              continue $label0$0;
            }
            t4 = P.FormatException$(_s21_ + C.JSInt_methods.toRadixString$1(unit, 16), codeUnits, i1 - 1);
            throw H.wrapException(t4);
          }
          break $label0$0;
        }
      if (expectedUnits > 0) {
        _this._convert$_value = value;
        _this._expectedUnits = expectedUnits;
        _this._extraUnits = extraUnits;
      }
    }
  };
  P.bool.prototype = {};
  P.Comparable.prototype = {};
  P.double.prototype = {};
  P.Duration.prototype = {
    $add: function(_, other) {
      return new P.Duration(this._duration + H.interceptedTypeCheck(other, "$isDuration")._duration);
    },
    $sub: function(_, other) {
      return new P.Duration(this._duration - H.interceptedTypeCheck(other, "$isDuration")._duration);
    },
    $mul: function(_, factor) {
      if (typeof factor !== "number")
        return H.iae(factor);
      return new P.Duration(C.JSNumber_methods.round$0(this._duration * factor));
    },
    $lt: function(_, other) {
      return C.JSInt_methods.$lt(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration);
    },
    $gt: function(_, other) {
      return this._duration > H.interceptedTypeCheck(other, "$isDuration")._duration;
    },
    $le: function(_, other) {
      return C.JSInt_methods.$le(this._duration, other.get$_duration());
    },
    $ge: function(_, other) {
      return this._duration >= other._duration;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof P.Duration && this._duration === other._duration;
    },
    get$hashCode: function(_) {
      return C.JSInt_methods.get$hashCode(this._duration);
    },
    compareTo$1: function(_, other) {
      return C.JSInt_methods.compareTo$1(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration);
    },
    toString$0: function(_) {
      var twoDigitMinutes, twoDigitSeconds, sixDigitUs,
        t1 = new P.Duration_toString_twoDigits(),
        t2 = this._duration;
      if (t2 < 0)
        return "-" + new P.Duration(0 - t2).toString$0(0);
      twoDigitMinutes = t1.call$1(C.JSInt_methods._tdivFast$1(t2, 60000000) % 60);
      twoDigitSeconds = t1.call$1(C.JSInt_methods._tdivFast$1(t2, 1000000) % 60);
      sixDigitUs = new P.Duration_toString_sixDigits().call$1(t2 % 1000000);
      return "" + C.JSInt_methods._tdivFast$1(t2, 3600000000) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.Duration];
    }
  };
  P.Duration_toString_sixDigits.prototype = {
    call$1: function(n) {
      if (n >= 100000)
        return "" + n;
      if (n >= 10000)
        return "0" + n;
      if (n >= 1000)
        return "00" + n;
      if (n >= 100)
        return "000" + n;
      if (n >= 10)
        return "0000" + n;
      return "00000" + n;
    },
    $signature: 27
  };
  P.Duration_toString_twoDigits.prototype = {
    call$1: function(n) {
      if (n >= 10)
        return "" + n;
      return "0" + n;
    },
    $signature: 27
  };
  P.Error.prototype = {};
  P.AssertionError.prototype = {
    toString$0: function(_) {
      return "Assertion failed";
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.NullThrownError.prototype = {
    toString$0: function(_) {
      return "Throw of null.";
    }
  };
  P.ArgumentError.prototype = {
    get$_errorName: function() {
      return "Invalid argument" + (!this._hasValue ? "(s)" : "");
    },
    get$_errorExplanation: function() {
      return "";
    },
    toString$0: function(_) {
      var message, prefix, explanation, errorValue, _this = this,
        t1 = _this.name,
        nameString = t1 != null ? " (" + t1 + ")" : "";
      t1 = _this.message;
      message = t1 == null ? "" : ": " + H.S(t1);
      prefix = _this.get$_errorName() + nameString + message;
      if (!_this._hasValue)
        return prefix;
      explanation = _this.get$_errorExplanation();
      errorValue = P.Error_safeToString(_this.invalidValue);
      return prefix + explanation + ": " + errorValue;
    }
  };
  P.RangeError.prototype = {
    get$_errorName: function() {
      return "RangeError";
    },
    get$_errorExplanation: function() {
      var t1, explanation, t2, _this = this;
      H.assertHelper(_this._hasValue);
      t1 = _this.start;
      if (t1 == null) {
        t1 = _this.end;
        explanation = t1 != null ? ": Not less than or equal to " + H.S(t1) : "";
      } else {
        t2 = _this.end;
        if (t2 == null)
          explanation = ": Not greater than or equal to " + H.S(t1);
        else if (t2 > t1)
          explanation = ": Not in range " + H.S(t1) + ".." + H.S(t2) + ", inclusive";
        else
          explanation = t2 < t1 ? ": Valid value range is empty" : ": Only valid value is " + H.S(t1);
      }
      return explanation;
    }
  };
  P.IndexError.prototype = {
    get$_errorName: function() {
      return "RangeError";
    },
    get$_errorExplanation: function() {
      var invalidValue, t1;
      H.assertHelper(this._hasValue);
      invalidValue = H.intTypeCheck(this.invalidValue);
      if (typeof invalidValue !== "number")
        return invalidValue.$lt();
      if (invalidValue < 0)
        return ": index must not be negative";
      t1 = this.length;
      if (t1 === 0)
        return ": no indices are valid";
      return ": index should be less than " + t1;
    },
    get$length: function(receiver) {
      return this.length;
    }
  };
  P.UnsupportedError.prototype = {
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    }
  };
  P.UnimplementedError.prototype = {
    toString$0: function(_) {
      var t1 = this.message;
      return t1 != null ? "UnimplementedError: " + t1 : "UnimplementedError";
    }
  };
  P.StateError.prototype = {
    toString$0: function(_) {
      return "Bad state: " + this.message;
    }
  };
  P.ConcurrentModificationError.prototype = {
    toString$0: function(_) {
      var t1 = this.modifiedObject;
      if (t1 == null)
        return "Concurrent modification during iteration.";
      return "Concurrent modification during iteration: " + P.Error_safeToString(t1) + ".";
    }
  };
  P.OutOfMemoryError.prototype = {
    toString$0: function(_) {
      return "Out of Memory";
    },
    $isError: 1
  };
  P.StackOverflowError.prototype = {
    toString$0: function(_) {
      return "Stack Overflow";
    },
    $isError: 1
  };
  P.CyclicInitializationError.prototype = {
    toString$0: function(_) {
      var t1 = this.variableName;
      return t1 == null ? "Reading static variable during its initialization" : "Reading static variable '" + t1 + "' during its initialization";
    }
  };
  P._Exception.prototype = {
    toString$0: function(_) {
      return "Exception: " + this.message;
    },
    $isException: 1
  };
  P.FormatException.prototype = {
    toString$0: function(_) {
      var source, lineNum, lineStart, previousCharWasCR, i, char, lineEnd, end, start, prefix, postfix, slice,
        t1 = this.message,
        report = "" !== t1 ? "FormatException: " + t1 : "FormatException",
        offset = this.offset,
        objectSource = this.source;
      if (typeof objectSource === "string") {
        if (offset != null)
          t1 = offset < 0 || offset > objectSource.length;
        else
          t1 = false;
        if (t1)
          offset = null;
        if (offset == null) {
          source = objectSource.length > 78 ? C.JSString_methods.substring$2(objectSource, 0, 75) + "..." : objectSource;
          return report + "\n" + source;
        }
        for (lineNum = 1, lineStart = 0, previousCharWasCR = false, i = 0; i < offset; ++i) {
          char = C.JSString_methods._codeUnitAt$1(objectSource, i);
          if (char === 10) {
            if (lineStart !== i || !previousCharWasCR)
              ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = false;
          } else if (char === 13) {
            ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = true;
          }
        }
        report = lineNum > 1 ? report + (" (at line " + lineNum + ", character " + (offset - lineStart + 1) + ")\n") : report + (" (at character " + (offset + 1) + ")\n");
        lineEnd = objectSource.length;
        for (i = offset; i < lineEnd; ++i) {
          char = C.JSString_methods.codeUnitAt$1(objectSource, i);
          if (char === 10 || char === 13) {
            lineEnd = i;
            break;
          }
        }
        if (lineEnd - lineStart > 78)
          if (offset - lineStart < 75) {
            end = lineStart + 75;
            start = lineStart;
            prefix = "";
            postfix = "...";
          } else {
            if (lineEnd - offset < 75) {
              start = lineEnd - 75;
              end = lineEnd;
              postfix = "";
            } else {
              start = offset - 36;
              end = offset + 36;
              postfix = "...";
            }
            prefix = "...";
          }
        else {
          end = lineEnd;
          start = lineStart;
          prefix = "";
          postfix = "";
        }
        slice = C.JSString_methods.substring$2(objectSource, start, end);
        return report + prefix + slice + postfix + "\n" + C.JSString_methods.$mul(" ", offset - start + prefix.length) + "^\n";
      } else
        return offset != null ? report + (" (at offset " + H.S(offset) + ")") : report;
    },
    $isException: 1
  };
  P.int.prototype = {};
  P.Iterable.prototype = {
    map$1$1: function(_, f, $T) {
      var t1 = H.getRuntimeTypeArgument(this, "Iterable", 0);
      return H.MappedIterable_MappedIterable(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), t1, $T);
    },
    contains$1: function(_, element) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (J.$eq$(t1.get$current(), element))
          return true;
      return false;
    },
    forEach$1: function(_, f) {
      var t1;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(this, "Iterable", 0)]});
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1.get$current());
    },
    join$1: function(_, separator) {
      var t1,
        iterator = this.get$iterator(this);
      if (!iterator.moveNext$0())
        return "";
      if (separator === "") {
        t1 = "";
        do
          t1 += H.S(iterator.get$current());
        while (iterator.moveNext$0());
      } else {
        t1 = H.S(iterator.get$current());
        for (; iterator.moveNext$0();)
          t1 = t1 + separator + H.S(iterator.get$current());
      }
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    any$1: function(_, test) {
      var t1;
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getRuntimeTypeArgument(this, "Iterable", 0)]});
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (H.boolConversionCheck(test.call$1(t1.get$current())))
          return true;
      return false;
    },
    toList$1$growable: function(_, growable) {
      return P.List_List$from(this, true, H.getRuntimeTypeArgument(this, "Iterable", 0));
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    get$length: function(_) {
      var it, count;
      H.assertHelper(!this.$isEfficientLengthIterable);
      it = this.get$iterator(this);
      for (count = 0; it.moveNext$0();)
        ++count;
      return count;
    },
    get$isEmpty: function(_) {
      return !this.get$iterator(this).moveNext$0();
    },
    get$first: function(_) {
      var it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      return it.get$current();
    },
    get$single: function(_) {
      var result,
        it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      result = it.get$current();
      if (it.moveNext$0())
        throw H.wrapException(H.IterableElementError_tooMany());
      return result;
    },
    firstWhere$2$orElse: function(_, test, orElse) {
      var element,
        t1 = H.getRuntimeTypeArgument(this, "Iterable", 0);
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
      H.functionTypeCheck(orElse, {func: 1, ret: t1});
      for (t1 = this.get$iterator(this); t1.moveNext$0();) {
        element = t1.get$current();
        if (H.boolConversionCheck(test.call$1(element)))
          return element;
      }
      return orElse.call$0();
    },
    elementAt$1: function(_, index) {
      var t1, elementIndex, element;
      P.RangeError_checkNotNegative(index, "index");
      for (t1 = this.get$iterator(this), elementIndex = 0; t1.moveNext$0();) {
        element = t1.get$current();
        if (index === elementIndex)
          return element;
        ++elementIndex;
      }
      throw H.wrapException(P.IndexError$(index, this, "index", null, elementIndex));
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToShortString(this, "(", ")");
    }
  };
  P.Iterator.prototype = {};
  P.List.prototype = {$isEfficientLengthIterable: 1, $isIterable: 1};
  P.Map.prototype = {};
  P.Null.prototype = {
    get$hashCode: function(_) {
      return P.Object.prototype.get$hashCode.call(this, this);
    },
    toString$0: function(_) {
      return "null";
    }
  };
  P.num.prototype = {$isComparable: 1,
    $asComparable: function() {
      return [P.num];
    }
  };
  P.Object.prototype = {constructor: P.Object, $isObject: 1,
    $eq: function(_, other) {
      return this === other;
    },
    get$hashCode: function(_) {
      return H.Primitives_objectHashCode(this);
    },
    toString$0: function(_) {
      return "Instance of '" + H.Primitives_objectTypeName(this) + "'";
    },
    get$runtimeType: function(_) {
      return new H.TypeImpl(H.getRti(this));
    },
    toString: function() {
      return this.toString$0(this);
    }
  };
  P.Set.prototype = {};
  P.StackTrace.prototype = {};
  P.Stopwatch.prototype = {
    get$elapsedMicroseconds: function() {
      var t2, ticks,
        t1 = this._stop;
      if (t1 == null)
        t1 = H.intTypeCheck($.Primitives_timerTicks.call$0());
      t2 = this._core$_start;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      ticks = t1 - t2;
      t1 = $.Stopwatch__frequency;
      if (t1 === 1000000)
        return ticks;
      H.assertHelper(t1 === 1000);
      return ticks * 1000;
    },
    start$0: function() {
      var t1, t2, t3, _this = this;
      if (_this._stop != null) {
        t1 = _this._core$_start;
        t2 = H.intTypeCheck($.Primitives_timerTicks.call$0());
        t3 = _this._stop;
        if (typeof t2 !== "number")
          return t2.$sub();
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (typeof t1 !== "number")
          return t1.$add();
        _this._core$_start = t1 + (t2 - t3);
        _this._stop = null;
      }
    },
    stop$0: function() {
      if (this._stop == null)
        this._stop = H.intTypeCheck($.Primitives_timerTicks.call$0());
    },
    reset$0: function() {
      var t1 = this._stop;
      this._core$_start = t1 == null ? H.intTypeCheck($.Primitives_timerTicks.call$0()) : t1;
    }
  };
  P.String.prototype = {$isComparable: 1,
    $asComparable: function() {
      return [P.String];
    },
    $isPattern: 1
  };
  P.StringBuffer.prototype = {
    get$length: function(_) {
      return this._contents.length;
    },
    writeln$1: function(obj) {
      this._contents += H.S(obj) + "\n";
    },
    writeln$0: function() {
      return this.writeln$1("");
    },
    toString$0: function(_) {
      var t1 = this._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    get$isEmpty: function(_) {
      return this._contents.length === 0;
    },
    $isStringSink: 1
  };
  P.Type.prototype = {};
  P.Uri__parseIPv4Address_error.prototype = {
    call$2: function(msg, position) {
      throw H.wrapException(P.FormatException$("Illegal IPv4 address, " + msg, this.host, position));
    },
    $signature: 143
  };
  P.Uri_parseIPv6Address_error.prototype = {
    call$2: function(msg, position) {
      throw H.wrapException(P.FormatException$("Illegal IPv6 address, " + msg, this.host, position));
    },
    call$1: function(msg) {
      return this.call$2(msg, null);
    },
    $signature: 83
  };
  P.Uri_parseIPv6Address_parseHex.prototype = {
    call$2: function(start, end) {
      var value;
      if (end - start > 4)
        this.error.call$2("an IPv6 part can only contain a maximum of 4 hex digits", start);
      value = P.int_parse(C.JSString_methods.substring$2(this.host, start, end), null, 16);
      if (typeof value !== "number")
        return value.$lt();
      if (value < 0 || value > 65535)
        this.error.call$2("each part must be in the range of `0x0..0xFFFF`", start);
      return value;
    },
    $signature: 162
  };
  P._Uri.prototype = {
    get$userInfo: function() {
      return this._userInfo;
    },
    get$host: function() {
      var t1 = this._host;
      if (t1 == null)
        return "";
      if (C.JSString_methods.startsWith$1(t1, "["))
        return C.JSString_methods.substring$2(t1, 1, t1.length - 1);
      return t1;
    },
    get$port: function() {
      var t1 = this._port;
      if (t1 == null)
        return P._Uri__defaultPort(this.scheme);
      return t1;
    },
    get$query: function() {
      var t1 = this._query;
      return t1 == null ? "" : t1;
    },
    get$fragment: function() {
      var t1 = this._fragment;
      return t1 == null ? "" : t1;
    },
    get$hasAuthority: function() {
      return this._host != null;
    },
    get$hasQuery: function() {
      return this._query != null;
    },
    get$hasFragment: function() {
      return this._fragment != null;
    },
    toString$0: function(_) {
      var t2, t3, t4, _this = this,
        t1 = _this._core$_text;
      if (t1 == null) {
        t1 = _this.scheme;
        t2 = t1.length !== 0 ? t1 + ":" : "";
        t3 = _this._host;
        t4 = t3 == null;
        if (!t4 || t1 === "file") {
          t1 = t2 + "//";
          t2 = _this._userInfo;
          if (t2.length !== 0)
            t1 = t1 + H.S(t2) + "@";
          if (!t4)
            t1 += t3;
          t2 = _this._port;
          if (t2 != null)
            t1 = t1 + ":" + H.S(t2);
        } else
          t1 = t2;
        t1 += _this.path;
        t2 = _this._query;
        if (t2 != null)
          t1 = t1 + "?" + t2;
        t2 = _this._fragment;
        if (t2 != null)
          t1 = t1 + "#" + t2;
        t1 = _this._core$_text = t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      return t1;
    },
    $eq: function(_, other) {
      var t1, t2, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!!J.getInterceptor$(other).$isUri)
        if (_this.scheme === other.get$scheme())
          if (_this._host != null === other.get$hasAuthority())
            if (_this._userInfo == other.get$userInfo())
              if (_this.get$host() == other.get$host())
                if (_this.get$port() == other.get$port())
                  if (_this.path === other.get$path(other)) {
                    t1 = _this._query;
                    t2 = t1 == null;
                    if (!t2 === other.get$hasQuery()) {
                      if (t2)
                        t1 = "";
                      if (t1 === other.get$query()) {
                        t1 = _this._fragment;
                        t2 = t1 == null;
                        if (!t2 === other.get$hasFragment()) {
                          if (t2)
                            t1 = "";
                          t1 = t1 === other.get$fragment();
                        } else
                          t1 = false;
                      } else
                        t1 = false;
                    } else
                      t1 = false;
                  } else
                    t1 = false;
                else
                  t1 = false;
              else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1 = this._hashCodeCache;
      return t1 == null ? this._hashCodeCache = C.JSString_methods.get$hashCode(this.toString$0(0)) : t1;
    },
    $isUri: 1,
    get$scheme: function() {
      return this.scheme;
    },
    get$path: function(receiver) {
      return this.path;
    }
  };
  P._Uri__Uri$notSimple_closure.prototype = {
    call$1: function(_) {
      throw H.wrapException(P.FormatException$("Invalid port", this.uri, this.portStart + 1));
    },
    $signature: 72
  };
  P._Uri__makePath_closure.prototype = {
    call$1: function(s) {
      return P._Uri__uriEncode(C.List_qg40, s, C.C_Utf8Codec, false);
    },
    $signature: 56
  };
  P.UriData.prototype = {
    get$uri: function() {
      var t2, queryIndex, end, query, _this = this, _null = null,
        t1 = _this._uriCache;
      if (t1 != null)
        return t1;
      t1 = _this._separatorIndices;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t2 = _this._core$_text;
      t1 = t1[0] + 1;
      queryIndex = C.JSString_methods.indexOf$2(t2, "?", t1);
      end = t2.length;
      if (queryIndex >= 0) {
        query = P._Uri__normalizeOrSubstring(t2, queryIndex + 1, end, C.List_CVk, false);
        end = queryIndex;
      } else
        query = _null;
      return _this._uriCache = new P._DataUri("data", _null, _null, _null, P._Uri__normalizeOrSubstring(t2, t1, end, C.List_qg4, false), query, _null);
    },
    toString$0: function(_) {
      var t2,
        t1 = this._separatorIndices;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t2 = this._core$_text;
      return t1[0] === -1 ? "data:" + t2 : t2;
    }
  };
  P._createTables_closure.prototype = {
    call$1: function(_) {
      return new Uint8Array(96);
    },
    $signature: 67
  };
  P._createTables_build.prototype = {
    call$2: function(state, defaultTransition) {
      var t1 = this.tables;
      if (state >= t1.length)
        return H.ioore(t1, state);
      t1 = t1[state];
      J.fillRange$3$x(t1, 0, 96, defaultTransition);
      return t1;
    },
    $signature: 71
  };
  P._createTables_setChars.prototype = {
    call$3: function(target, chars, transition) {
      var t1, t2, i, t3;
      for (t1 = chars.length, t2 = target.length, i = 0; i < t1; ++i) {
        t3 = C.JSString_methods._codeUnitAt$1(chars, i) ^ 96;
        if (t3 >= t2)
          return H.ioore(target, t3);
        target[t3] = transition;
      }
    },
    $signature: 50
  };
  P._createTables_setRange.prototype = {
    call$3: function(target, range, transition) {
      var i, n, t1, t2;
      for (i = C.JSString_methods._codeUnitAt$1(range, 0), n = C.JSString_methods._codeUnitAt$1(range, 1), t1 = target.length; i <= n; ++i) {
        t2 = (i ^ 96) >>> 0;
        if (t2 >= t1)
          return H.ioore(target, t2);
        target[t2] = transition;
      }
    },
    $signature: 50
  };
  P._SimpleUri.prototype = {
    get$hasAuthority: function() {
      return this._hostStart > 0;
    },
    get$hasQuery: function() {
      return this._queryStart < this._fragmentStart;
    },
    get$hasFragment: function() {
      return this._fragmentStart < this._uri.length;
    },
    get$_isHttp: function() {
      return this._schemeEnd === 4 && C.JSString_methods.startsWith$1(this._uri, "http");
    },
    get$_isHttps: function() {
      return this._schemeEnd === 5 && C.JSString_methods.startsWith$1(this._uri, "https");
    },
    get$scheme: function() {
      var t2, _this = this, _s4_ = "file",
        _s7_ = "package",
        t1 = _this._schemeEnd;
      if (t1 <= 0)
        return "";
      t2 = _this._schemeCache;
      if (t2 != null)
        return t2;
      if (_this.get$_isHttp())
        t1 = _this._schemeCache = "http";
      else if (_this.get$_isHttps()) {
        _this._schemeCache = "https";
        t1 = "https";
      } else if (t1 === 4 && C.JSString_methods.startsWith$1(_this._uri, _s4_)) {
        _this._schemeCache = _s4_;
        t1 = _s4_;
      } else if (t1 === 7 && C.JSString_methods.startsWith$1(_this._uri, _s7_)) {
        _this._schemeCache = _s7_;
        t1 = _s7_;
      } else {
        t1 = C.JSString_methods.substring$2(_this._uri, 0, t1);
        _this._schemeCache = t1;
      }
      return t1;
    },
    get$userInfo: function() {
      var t1 = this._hostStart,
        t2 = this._schemeEnd + 3;
      return t1 > t2 ? C.JSString_methods.substring$2(this._uri, t2, t1 - 1) : "";
    },
    get$host: function() {
      var t1 = this._hostStart;
      return t1 > 0 ? C.JSString_methods.substring$2(this._uri, t1, this._portStart) : "";
    },
    get$port: function() {
      var _this = this;
      if (_this._hostStart > 0 && _this._portStart + 1 < _this._pathStart)
        return P.int_parse(C.JSString_methods.substring$2(_this._uri, _this._portStart + 1, _this._pathStart), null, null);
      if (_this.get$_isHttp())
        return 80;
      if (_this.get$_isHttps())
        return 443;
      return 0;
    },
    get$path: function(_) {
      return C.JSString_methods.substring$2(this._uri, this._pathStart, this._queryStart);
    },
    get$query: function() {
      var t1 = this._queryStart,
        t2 = this._fragmentStart;
      return t1 < t2 ? C.JSString_methods.substring$2(this._uri, t1 + 1, t2) : "";
    },
    get$fragment: function() {
      var t1 = this._fragmentStart,
        t2 = this._uri;
      return t1 < t2.length ? C.JSString_methods.substring$1(t2, t1 + 1) : "";
    },
    get$hashCode: function(_) {
      var t1 = this._hashCodeCache;
      return t1 == null ? this._hashCodeCache = C.JSString_methods.get$hashCode(this._uri) : t1;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      return !!J.getInterceptor$(other).$isUri && this._uri === other.toString$0(0);
    },
    toString$0: function(_) {
      return this._uri;
    },
    $isUri: 1
  };
  P._DataUri.prototype = {};
  P.ServiceExtensionResponse.prototype = {};
  P.Flow.prototype = {};
  P._SyncBlock.prototype = {};
  W.DomException.prototype = {
    toString$0: function(receiver) {
      return String(receiver);
    }
  };
  P._ReceivePortImpl.prototype = {
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [,]});
      H.functionTypeCheck(onDone, {func: 1, ret: -1});
      throw H.wrapException(P.UnsupportedError$("ReceivePort.listen"));
    },
    get$sendPort: function() {
      return H.throwExpression(P.UnsupportedError$("ReceivePort.sendPort"));
    },
    $asStream: function() {
    }
  };
  P.ByteBuffer.prototype = {};
  P.Endian.prototype = {};
  P.ByteData.prototype = {};
  P.Int8List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    }
  };
  P.Uint8List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    }
  };
  P.Uint16List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    }
  };
  P.Int32List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    }
  };
  P.Float64List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.double];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.double];
    },
    $isList: 1,
    $asList: function() {
      return [P.double];
    }
  };
  P.SceneBuilder.prototype = {
    pushTransform$1: function(matrix4) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    pushOffset$2: function(dx, dy) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    pushClipRect$2$clipBehavior: function(rect, clipBehavior) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    pushOpacity$2$offset: function(alpha, offset) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    pop$0: function() {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    addPerformanceOverlay$2: function(enabledOptions, bounds) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    addPicture$4$isComplexHint$willChangeHint: function(offset, picture, isComplexHint, willChangeHint) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    addPicture$2: function(offset, picture) {
      return this.addPicture$4$isComplexHint$willChangeHint(offset, picture, false, false);
    },
    build$0: function() {
      throw H.wrapException(P.UnimplementedError$(null));
    }
  };
  P.OffsetBase.prototype = {
    $lt: function(_, other) {
      var t1;
      H.interceptedTypeCheck(other, "$isOffsetBase");
      t1 = this._dx;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (C.JSNumber_methods.$lt(t1, other._dx)) {
        t1 = this._dy;
        if (typeof t1 !== "number")
          return t1.$lt();
        t1 = C.JSNumber_methods.$lt(t1, other._dy);
      } else
        t1 = false;
      return t1;
    },
    $le: function(_, other) {
      var t1 = this._dx,
        t2 = other.get$_dx();
      if (typeof t1 !== "number")
        return t1.$le();
      if (C.JSNumber_methods.$le(t1, t2)) {
        t1 = this._dy;
        t2 = other.get$_dy();
        if (typeof t1 !== "number")
          return t1.$le();
        t2 = C.JSNumber_methods.$le(t1, t2);
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    $gt: function(_, other) {
      var t1, t2;
      H.interceptedTypeCheck(other, "$isOffsetBase");
      t1 = this._dx;
      t2 = other._dx;
      if (typeof t1 !== "number")
        return t1.$gt();
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 > t2) {
        t1 = this._dy;
        t2 = other._dy;
        if (typeof t1 !== "number")
          return t1.$gt();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = t1 > t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    $ge: function(_, other) {
      var t1 = this._dx,
        t2 = other.get$_dx();
      if (typeof t1 !== "number")
        return t1.$ge();
      if (C.JSNumber_methods.$ge(t1, t2)) {
        t1 = this._dy;
        t2 = other.get$_dy();
        if (typeof t1 !== "number")
          return t1.$ge();
        t2 = C.JSNumber_methods.$ge(t1, t2);
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof P.OffsetBase))
        return false;
      return this._dx == other._dx && this._dy == other._dy;
    },
    get$hashCode: function(_) {
      return P.hashValues(this._dx, this._dy, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t1 = new H.TypeImpl(H.getRti(this)).toString$0(0) + "(",
        t2 = this._dx;
      t1 = t1 + H.S(t2 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t2, 1)) + ", ";
      t2 = this._dy;
      return t1 + H.S(t2 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t2, 1)) + ")";
    }
  };
  P.Offset.prototype = {
    get$distance: function() {
      var t2,
        t1 = this._dx;
      if (typeof t1 !== "number")
        return t1.$mul();
      t2 = this._dy;
      if (typeof t2 !== "number")
        return t2.$mul();
      return Math.sqrt(t1 * t1 + t2 * t2);
    },
    get$distanceSquared: function() {
      var t2,
        t1 = this._dx;
      if (typeof t1 !== "number")
        return t1.$mul();
      t2 = this._dy;
      if (typeof t2 !== "number")
        return t2.$mul();
      return t1 * t1 + t2 * t2;
    },
    $sub: function(_, other) {
      var t1, t2, t3, t4;
      H.interceptedTypeCheck(other, "$isOffset");
      t1 = this._dx;
      t2 = other._dx;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this._dy;
      t4 = other._dy;
      if (typeof t3 !== "number")
        return t3.$sub();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return new P.Offset(t1 - t2, t3 - t4);
    },
    $add: function(_, other) {
      var t1, t2, t3, t4;
      H.interceptedTypeCheck(other, "$isOffset");
      t1 = this._dx;
      t2 = other._dx;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this._dy;
      t4 = other._dy;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return new P.Offset(t1 + t2, t3 + t4);
    },
    $mul: function(_, operand) {
      var t2,
        t1 = this._dx;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof operand !== "number")
        return H.iae(operand);
      t2 = this._dy;
      if (typeof t2 !== "number")
        return t2.$mul();
      return new P.Offset(t1 * operand, t2 * operand);
    },
    $div: function(_, operand) {
      var t2,
        t1 = this._dx;
      if (typeof t1 !== "number")
        return t1.$div();
      t2 = this._dy;
      if (typeof t2 !== "number")
        return t2.$div();
      return new P.Offset(t1 / operand, t2 / operand);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof P.Offset))
        return false;
      return this._dx == other._dx && this._dy == other._dy;
    },
    get$hashCode: function(_) {
      return P.hashValues(this._dx, this._dy, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t2,
        t1 = this._dx;
      t1 = "Offset(" + H.S(t1 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t1, 1)) + ", ";
      t2 = this._dy;
      return t1 + H.S(t2 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t2, 1)) + ")";
    }
  };
  P.Size.prototype = {
    get$isEmpty: function(_) {
      var t1 = this._dx;
      if (typeof t1 !== "number")
        return t1.$le();
      if (!(t1 <= 0)) {
        t1 = this._dy;
        if (typeof t1 !== "number")
          return t1.$le();
        t1 = t1 <= 0;
      } else
        t1 = true;
      return t1;
    },
    $sub: function(_, other) {
      var t1, t2, t3, t4, _this = this;
      H.interceptedTypeCheck(other, "$isOffsetBase");
      t1 = J.getInterceptor$(other);
      if (!!t1.$isSize) {
        t1 = _this._dx;
        t2 = other._dx;
        if (typeof t1 !== "number")
          return t1.$sub();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t3 = _this._dy;
        t4 = other._dy;
        if (typeof t3 !== "number")
          return t3.$sub();
        if (typeof t4 !== "number")
          return H.iae(t4);
        return new P.Offset(t1 - t2, t3 - t4);
      }
      if (!!t1.$isOffset) {
        t1 = _this._dx;
        t2 = other._dx;
        if (typeof t1 !== "number")
          return t1.$sub();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t3 = _this._dy;
        t4 = other._dy;
        if (typeof t3 !== "number")
          return t3.$sub();
        if (typeof t4 !== "number")
          return H.iae(t4);
        return new P.Size(t1 - t2, t3 - t4);
      }
      throw H.wrapException(P.ArgumentError$(other));
    },
    $add: function(_, other) {
      var t1, t2, t3, t4;
      H.interceptedTypeCheck(other, "$isOffset");
      t1 = this._dx;
      t2 = other._dx;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this._dy;
      t4 = other._dy;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return new P.Size(t1 + t2, t3 + t4);
    },
    $mul: function(_, operand) {
      var t2,
        t1 = this._dx;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof operand !== "number")
        return H.iae(operand);
      t2 = this._dy;
      if (typeof t2 !== "number")
        return t2.$mul();
      return new P.Size(t1 * operand, t2 * operand);
    },
    $div: function(_, operand) {
      var t2,
        t1 = this._dx;
      if (typeof t1 !== "number")
        return t1.$div();
      t2 = this._dy;
      if (typeof t2 !== "number")
        return t2.$div();
      return new P.Size(t1 / operand, t2 / operand);
    },
    center$1: function(origin) {
      var t3, t4,
        t1 = origin._dx,
        t2 = this._dx;
      if (typeof t2 !== "number")
        return t2.$div();
      if (typeof t1 !== "number")
        return t1.$add();
      t3 = origin._dy;
      t4 = this._dy;
      if (typeof t4 !== "number")
        return t4.$div();
      if (typeof t3 !== "number")
        return t3.$add();
      return new P.Offset(t1 + t2 / 2, t3 + t4 / 2);
    },
    contains$1: function(_, offset) {
      var t2,
        t1 = offset._dx;
      if (typeof t1 !== "number")
        return t1.$ge();
      if (t1 >= 0) {
        t2 = this._dx;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (t1 < t2) {
          t1 = offset._dy;
          if (typeof t1 !== "number")
            return t1.$ge();
          if (t1 >= 0) {
            t2 = this._dy;
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = t1 < t2;
            t1 = t2;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof P.Size))
        return false;
      return this._dx == other._dx && this._dy == other._dy;
    },
    get$hashCode: function(_) {
      return P.hashValues(this._dx, this._dy, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t2,
        t1 = this._dx;
      t1 = "Size(" + H.S(t1 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t1, 1)) + ", ";
      t2 = this._dy;
      return t1 + H.S(t2 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t2, 1)) + ")";
    }
  };
  P.Rect.prototype = {
    get$isEmpty: function(_) {
      var _this = this,
        t1 = _this.left,
        t2 = _this.right;
      if (typeof t1 !== "number")
        return t1.$ge();
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (!(t1 >= t2)) {
        t1 = _this.top;
        t2 = _this.bottom;
        if (typeof t1 !== "number")
          return t1.$ge();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = t1 >= t2;
        t1 = t2;
      } else
        t1 = true;
      return t1;
    },
    shift$1: function(offset) {
      var t3, t4, t5, t6, _this = this,
        t1 = _this.left,
        t2 = offset._dx;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = _this.top;
      t4 = offset._dy;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = _this.right;
      if (typeof t5 !== "number")
        return t5.$add();
      t6 = _this.bottom;
      if (typeof t6 !== "number")
        return t6.$add();
      return P.Rect$fromLTRB(t1 + t2, t3 + t4, t5 + t2, t6 + t4);
    },
    inflate$1: function(delta) {
      var t2, t3, t4, _this = this,
        t1 = _this.left;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof delta !== "number")
        return H.iae(delta);
      t2 = _this.top;
      if (typeof t2 !== "number")
        return t2.$sub();
      t3 = _this.right;
      if (typeof t3 !== "number")
        return t3.$add();
      t4 = _this.bottom;
      if (typeof t4 !== "number")
        return t4.$add();
      return P.Rect$fromLTRB(t1 - delta, t2 - delta, t3 + delta, t4 + delta);
    },
    intersect$1: function(other) {
      var t2, t3, t4, _this = this,
        t1 = other.left;
      t1 = Math.max(H.checkNum(_this.left), H.checkNum(t1));
      t2 = other.top;
      t2 = Math.max(H.checkNum(_this.top), H.checkNum(t2));
      t3 = other.right;
      t3 = Math.min(H.checkNum(_this.right), H.checkNum(t3));
      t4 = other.bottom;
      return P.Rect$fromLTRB(t1, t2, t3, Math.min(H.checkNum(_this.bottom), H.checkNum(t4)));
    },
    get$shortestSide: function() {
      var t3, t4, _this = this,
        t1 = _this.right,
        t2 = _this.left;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = _this.bottom;
      t4 = _this.top;
      if (typeof t3 !== "number")
        return t3.$sub();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return Math.min(Math.abs(t1 - t2), Math.abs(t3 - t4));
    },
    get$center: function() {
      var t3, t4, _this = this,
        t1 = _this.left,
        t2 = _this.right;
      if (typeof t2 !== "number")
        return t2.$sub();
      if (typeof t1 !== "number")
        return H.iae(t1);
      t3 = _this.top;
      t4 = _this.bottom;
      if (typeof t4 !== "number")
        return t4.$sub();
      if (typeof t3 !== "number")
        return H.iae(t3);
      return new P.Offset(t1 + (t2 - t1) / 2, t3 + (t4 - t3) / 2);
    },
    contains$1: function(_, offset) {
      var _this = this,
        t1 = offset._dx,
        t2 = _this.left;
      if (typeof t1 !== "number")
        return t1.$ge();
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 >= t2) {
        t2 = _this.right;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (t1 < t2) {
          t1 = offset._dy;
          t2 = _this.top;
          if (typeof t1 !== "number")
            return t1.$ge();
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (t1 >= t2) {
            t2 = _this.bottom;
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = t1 < t2;
            t1 = t2;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$isRect");
      return _this.left == other.left && _this.top == other.top && _this.right == other.right && _this.bottom == other.bottom;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.left, _this.top, _this.right, _this.bottom, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var _this = this;
      return "Rect.fromLTRB(" + J.toStringAsFixed$1$n(_this.left, 1) + " " + J.toStringAsFixed$1$n(_this.top, 1) + ", " + J.toStringAsFixed$1$n(_this.right, 1) + ", " + J.toStringAsFixed$1$n(_this.bottom, 1) + ")";
    }
  };
  P.Radius.prototype = {
    $sub: function(_, other) {
      var t1, t2, t3, t4;
      H.interceptedTypeCheck(other, "$isRadius");
      t1 = this.x;
      t2 = other.x;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this.y;
      t4 = other.y;
      if (typeof t3 !== "number")
        return t3.$sub();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return new P.Radius(t1 - t2, t3 - t4);
    },
    $add: function(_, other) {
      var t1, t2, t3, t4;
      H.interceptedTypeCheck(other, "$isRadius");
      t1 = this.x;
      t2 = other.x;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this.y;
      t4 = other.y;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return new P.Radius(t1 + t2, t3 + t4);
    },
    $mul: function(_, operand) {
      var t2,
        t1 = this.x;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof operand !== "number")
        return H.iae(operand);
      t2 = this.y;
      if (typeof t2 !== "number")
        return t2.$mul();
      return new P.Radius(t1 * operand, t2 * operand);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$isRadius");
      return other.x == _this.x && other.y == _this.y;
    },
    get$hashCode: function(_) {
      return P.hashValues(this.x, this.y, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t1 = this.x,
        t2 = this.y,
        t3 = J.getInterceptor$n(t1);
      return t1 == t2 ? "Radius.circular(" + t3.toStringAsFixed$1(t1, 1) + ")" : "Radius.elliptical(" + t3.toStringAsFixed$1(t1, 1) + ", " + J.toStringAsFixed$1$n(t2, 1) + ")";
    }
  };
  P.RRect.prototype = {
    shift$1: function(offset) {
      var t3, t4, t5, t6, _this = this,
        t1 = _this.left,
        t2 = offset._dx;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = _this.top;
      t4 = offset._dy;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = _this.right;
      if (typeof t5 !== "number")
        return t5.$add();
      t6 = _this.bottom;
      if (typeof t6 !== "number")
        return t6.$add();
      return P.RRect$_raw(_this.blRadiusX, _this.blRadiusY, t6 + t4, _this.brRadiusX, _this.brRadiusY, t1 + t2, t5 + t2, _this.tlRadiusX, _this.tlRadiusY, t3 + t4, _this.trRadiusX, _this.trRadiusY);
    },
    inflate$1: function(delta) {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, _this = this,
        t1 = _this.left;
      if (typeof t1 !== "number")
        return t1.$sub();
      t2 = _this.top;
      if (typeof t2 !== "number")
        return t2.$sub();
      t3 = _this.right;
      if (typeof t3 !== "number")
        return t3.$add();
      t4 = _this.bottom;
      if (typeof t4 !== "number")
        return t4.$add();
      t5 = _this.tlRadiusX;
      if (typeof t5 !== "number")
        return t5.$add();
      t6 = _this.tlRadiusY;
      if (typeof t6 !== "number")
        return t6.$add();
      t7 = _this.trRadiusX;
      if (typeof t7 !== "number")
        return t7.$add();
      t8 = _this.trRadiusY;
      if (typeof t8 !== "number")
        return t8.$add();
      t9 = _this.blRadiusX;
      if (typeof t9 !== "number")
        return t9.$add();
      t10 = _this.blRadiusY;
      if (typeof t10 !== "number")
        return t10.$add();
      t11 = _this.brRadiusX;
      if (typeof t11 !== "number")
        return t11.$add();
      t12 = _this.brRadiusY;
      if (typeof t12 !== "number")
        return t12.$add();
      return P.RRect$_raw(t9 + delta, t10 + delta, t4 + delta, t11 + delta, t12 + delta, t1 - delta, t3 + delta, t5 + delta, t6 + delta, t2 - delta, t7 + delta, t8 + delta);
    },
    get$isEmpty: function(_) {
      var _this = this,
        t1 = _this.left,
        t2 = _this.right;
      if (typeof t1 !== "number")
        return t1.$ge();
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (!(t1 >= t2)) {
        t1 = _this.top;
        t2 = _this.bottom;
        if (typeof t1 !== "number")
          return t1.$ge();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = t1 >= t2;
        t1 = t2;
      } else
        t1 = true;
      return t1;
    },
    _getMin$4: function(min, radius1, radius2, limit) {
      var sum;
      if (typeof radius1 !== "number")
        return radius1.$add();
      if (typeof radius2 !== "number")
        return H.iae(radius2);
      sum = radius1 + radius2;
      if (sum > limit && sum !== 0)
        return Math.min(min, limit / sum);
      return min;
    },
    contains$1: function(_, point) {
      var t3, t4, t5, t6, t7, scale, t8, t9, t10, t11, t12, t13, t14, t15, scaledTop, scaledLeft, scaledRight, scaledBottom, scaled, x, y, radiusY, radiusX, _this = this,
        t1 = point._dx,
        t2 = _this.left;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (!(t1 < t2)) {
        t3 = _this.right;
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(t1 >= t3)) {
          t3 = point._dy;
          t4 = _this.top;
          if (typeof t3 !== "number")
            return t3.$lt();
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (!(t3 < t4)) {
            t4 = _this.bottom;
            if (typeof t4 !== "number")
              return H.iae(t4);
            t4 = t3 >= t4;
            t3 = t4;
          } else
            t3 = true;
        } else
          t3 = true;
      } else
        t3 = true;
      if (t3)
        return false;
      t3 = _this.blRadiusY;
      t4 = _this.tlRadiusY;
      t5 = _this.bottom;
      t6 = _this.top;
      if (typeof t5 !== "number")
        return t5.$sub();
      if (typeof t6 !== "number")
        return H.iae(t6);
      t7 = t5 - t6;
      scale = _this._getMin$4(1, t3, t4, t7);
      t8 = _this.tlRadiusX;
      t9 = _this.trRadiusX;
      t10 = _this.right;
      if (typeof t10 !== "number")
        return t10.$sub();
      t11 = t10 - t2;
      t12 = _this.trRadiusY;
      t13 = _this.brRadiusY;
      t14 = _this.brRadiusX;
      t15 = _this.blRadiusX;
      scale = _this._getMin$4(_this._getMin$4(_this._getMin$4(scale, t8, t9, t11), t12, t13, t7), t14, t15, t11);
      if (scale < 1) {
        scaledTop = t6 * scale;
        scaledLeft = t2 * scale;
        scaledRight = t10 * scale;
        scaledBottom = t5 * scale;
      } else {
        scaledBottom = t5;
        scaledRight = t10;
        scaledTop = t6;
        scaledLeft = t2;
      }
      scaled = P.RRect$_raw(t15, t3, scaledBottom, t14, t13, scaledLeft, scaledRight, t8, t4, scaledTop, t9, t12);
      t3 = scaled.tlRadiusX;
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (t1 < t2 + t3) {
        t4 = point._dy;
        t7 = scaled.tlRadiusY;
        if (typeof t7 !== "number")
          return H.iae(t7);
        if (typeof t4 !== "number")
          return t4.$lt();
        t7 = t4 < t6 + t7;
        t4 = t7;
      } else
        t4 = false;
      if (t4) {
        x = t1 - t2 - t3;
        t1 = point._dy;
        if (typeof t1 !== "number")
          return t1.$sub();
        t2 = scaled.tlRadiusY;
        if (typeof t2 !== "number")
          return H.iae(t2);
        y = t1 - t6 - t2;
        radiusY = t2;
        radiusX = t3;
      } else {
        t3 = scaled.trRadiusX;
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (t1 > t10 - t3) {
          t4 = point._dy;
          t7 = scaled.trRadiusY;
          if (typeof t7 !== "number")
            return H.iae(t7);
          if (typeof t4 !== "number")
            return t4.$lt();
          t7 = t4 < t6 + t7;
          t4 = t7;
        } else
          t4 = false;
        if (t4) {
          x = t1 - t10 + t3;
          t1 = point._dy;
          if (typeof t1 !== "number")
            return t1.$sub();
          t2 = scaled.trRadiusY;
          if (typeof t2 !== "number")
            return H.iae(t2);
          y = t1 - t6 - t2;
          radiusY = t2;
          radiusX = t3;
        } else {
          t3 = scaled.brRadiusX;
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (t1 > t10 - t3) {
            t4 = point._dy;
            t6 = scaled.brRadiusY;
            if (typeof t6 !== "number")
              return H.iae(t6);
            if (typeof t4 !== "number")
              return t4.$gt();
            t6 = t4 > t5 - t6;
            t4 = t6;
          } else
            t4 = false;
          if (t4) {
            x = t1 - t10 + t3;
            t1 = point._dy;
            if (typeof t1 !== "number")
              return t1.$sub();
            t2 = scaled.brRadiusY;
            if (typeof t2 !== "number")
              return H.iae(t2);
            y = t1 - t5 + t2;
            radiusY = t2;
            radiusX = t3;
          } else {
            t3 = scaled.blRadiusX;
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (t1 < t2 + t3) {
              t4 = point._dy;
              t6 = scaled.blRadiusY;
              if (typeof t6 !== "number")
                return H.iae(t6);
              if (typeof t4 !== "number")
                return t4.$gt();
              t6 = t4 > t5 - t6;
              t4 = t6;
            } else
              t4 = false;
            if (t4) {
              x = t1 - t2 - t3;
              t1 = point._dy;
              if (typeof t1 !== "number")
                return t1.$sub();
              t2 = scaled.blRadiusY;
              if (typeof t2 !== "number")
                return H.iae(t2);
              y = t1 - t5 + t2;
            } else
              return true;
            radiusY = t2;
            radiusX = t3;
          }
        }
      }
      x /= radiusX;
      y /= radiusY;
      if (x * x + y * y > 1)
        return false;
      return true;
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$isRRect");
      return _this.left == other.left && _this.top == other.top && _this.right == other.right && _this.bottom == other.bottom && _this.tlRadiusX == other.tlRadiusX && _this.tlRadiusY == other.tlRadiusY && _this.trRadiusX == other.trRadiusX && _this.trRadiusY == other.trRadiusY && _this.blRadiusX == other.blRadiusX && _this.blRadiusY == other.blRadiusY && _this.brRadiusX == other.brRadiusX && _this.brRadiusY == other.brRadiusY;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.left, _this.top, _this.right, _this.bottom, _this.tlRadiusX, _this.tlRadiusY, _this.trRadiusX, _this.trRadiusY, _this.blRadiusX, _this.blRadiusY, _this.brRadiusX, _this.brRadiusY, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t5, t6, _this = this,
        rect = J.toStringAsFixed$1$n(_this.left, 1) + ", " + J.toStringAsFixed$1$n(_this.top, 1) + ", " + J.toStringAsFixed$1$n(_this.right, 1) + ", " + J.toStringAsFixed$1$n(_this.bottom, 1),
        t1 = _this.tlRadiusX,
        t2 = _this.tlRadiusY,
        t3 = _this.trRadiusX,
        t4 = _this.trRadiusY;
      if (new P.Radius(t1, t2).$eq(0, new P.Radius(t3, t4))) {
        t5 = _this.brRadiusX;
        t6 = _this.brRadiusY;
        t5 = new P.Radius(t3, t4).$eq(0, new P.Radius(t5, t6)) && new P.Radius(t5, t6).$eq(0, new P.Radius(_this.blRadiusX, _this.blRadiusY));
      } else
        t5 = false;
      if (t5) {
        if (t1 == t2)
          return "RRect.fromLTRBR(" + rect + ", " + J.toStringAsFixed$1$n(t1, 1) + ")";
        return "RRect.fromLTRBXY(" + rect + ", " + J.toStringAsFixed$1$n(t1, 1) + ", " + J.toStringAsFixed$1$n(t2, 1) + ")";
      }
      return "RRect.fromLTRBAndCorners(" + rect + ", topLeft: " + new P.Radius(t1, t2).toString$0(0) + ", topRight: " + new P.Radius(t3, t4).toString$0(0) + ", bottomRight: " + new P.Radius(_this.brRadiusX, _this.brRadiusY).toString$0(0) + ", bottomLeft: " + new P.Radius(_this.blRadiusX, _this.blRadiusY).toString$0(0) + ")";
    }
  };
  P._HashEnd.prototype = {};
  P.Color.prototype = {
    withOpacity$1: function(opacity) {
      var t1;
      if (typeof opacity !== "number")
        return opacity.$ge();
      H.assertHelper(opacity >= 0 && opacity <= 1);
      t1 = this.value;
      return P.Color$fromARGB(C.JSNumber_methods.round$0(255 * opacity), (16711680 & t1) >>> 16, (65280 & t1) >>> 8, (255 & t1) >>> 0);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(this))))
        return false;
      return this.value === H.interceptedTypeCheck(other, "$isColor").value;
    },
    get$hashCode: function(_) {
      return C.JSInt_methods.get$hashCode(this.value);
    },
    toString$0: function(_) {
      return "Color(0x" + C.JSString_methods.padLeft$2(C.JSInt_methods.toRadixString$1(this.value, 16), 8, "0") + ")";
    }
  };
  P.BlendMode.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.FilterQuality.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.StrokeCap.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.StrokeJoin.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.PaintingStyle.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.Clip.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.Paint.prototype = {
    get$color: function() {
      return new P.Color(((this._ui$_data.getInt32(4, true) ^ 4278190080) & 4294967295) >>> 0);
    },
    set$color: function(value) {
      H.assertHelper(value != null);
      this._ui$_data.setInt32(4, (value.value ^ 4278190080) >>> 0, true);
    },
    get$blendMode: function() {
      var encoded = this._ui$_data.getInt32(8, true),
        t1 = $.$get$Paint__kBlendModeDefault();
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = (encoded ^ t1) >>> 0;
      if (t1 >= 29)
        return H.ioore(C.List_2TY, t1);
      return C.List_2TY[t1];
    },
    set$blendMode: function(value) {
      var t1, t2;
      H.assertHelper(value != null);
      t1 = value.index;
      t2 = $.$get$Paint__kBlendModeDefault();
      if (typeof t2 !== "number")
        return H.iae(t2);
      this._ui$_data.setInt32(8, t1 ^ t2, true);
    },
    set$style: function(value) {
      this._ui$_data.setInt32(12, value.index, true);
    },
    set$strokeWidth: function(value) {
      this._ui$_data.setFloat32(16, value, true);
    },
    get$maskFilter: function() {
      var t2,
        t1 = this._ui$_data;
      switch (t1.getInt32(48, true)) {
        case 0:
          return;
        case 1:
          t2 = t1.getInt32(52, true);
          if (t2 < 0 || t2 >= 4)
            return H.ioore(C.List_DVN, t2);
          return P.MaskFilter$blur(C.List_DVN[t2], t1.getFloat32(56, true));
      }
      return;
    },
    set$maskFilter: function(value) {
      var t1 = this._ui$_data;
      if (value == null) {
        t1.setInt32(48, 0, true);
        t1.setInt32(52, 0, true);
        t1.setFloat32(56, 0, true);
      } else {
        t1.setInt32(48, 1, true);
        t1.setInt32(52, value._style.index, true);
        t1.setFloat32(56, value._sigma, true);
      }
    },
    get$shader: function() {
      var t1 = this._objects;
      if (t1 == null)
        return;
      return t1[0];
    },
    set$shader: function(value) {
      var t1 = this._objects;
      if (t1 == null) {
        t1 = new Array(2);
        t1.fixed$length = Array;
        this._objects = t1;
      }
      C.JSArray_methods.$indexSet(t1, 0, value);
    },
    get$colorFilter: function() {
      var t2,
        t1 = this._ui$_data;
      switch (t1.getInt32(36, true)) {
        case 0:
          return;
        case 1:
          t2 = t1.getInt32(40, true);
          t1 = t1.getInt32(44, true);
          if (t1 < 0 || t1 >= 29)
            return H.ioore(C.List_2TY, t1);
          return new P.ColorFilter(new P.Color((t2 & 4294967295) >>> 0), C.List_2TY[t1], null, 1);
        case 2:
          return new P.ColorFilter(null, null, H.assertSubtype(this._objects[1], "$isList", [P.double], "$asList"), 2);
        case 3:
          return C.ColorFilter_null_null_null_3;
        case 4:
          return C.ColorFilter_null_null_null_4;
      }
      return;
    },
    toString$0: function(_) {
      var t3, semicolon, t4, _this = this, _s2_ = "; ",
        t1 = _this._ui$_data,
        t2 = t1.getInt32(12, true);
      if (t2 < 0 || t2 >= 2)
        return H.ioore(C.List_PaintingStyle_0_PaintingStyle_1, t2);
      if (C.List_PaintingStyle_0_PaintingStyle_1[t2] === C.PaintingStyle_1) {
        t2 = t1.getInt32(12, true);
        if (t2 < 0 || t2 >= 2)
          return H.ioore(C.List_PaintingStyle_0_PaintingStyle_1, t2);
        t2 = "Paint(" + C.List_PaintingStyle_0_PaintingStyle_1[t2].toString$0(0);
        t2 = t1.getFloat32(16, true) !== 0 ? t2 + (" " + C.JSNumber_methods.toStringAsFixed$1(t1.getFloat32(16, true), 1)) : t2 + " hairline";
        t3 = t1.getInt32(20, true);
        if (t3 < 0 || t3 >= 3)
          return H.ioore(C.List_gap, t3);
        if (C.List_gap[t3] !== C.StrokeCap_0) {
          t3 = t1.getInt32(20, true);
          if (t3 < 0 || t3 >= 3)
            return H.ioore(C.List_gap, t3);
          t3 = t2 + (" " + C.List_gap[t3].toString$0(0));
          t2 = t3;
        }
        t3 = t1.getInt32(24, true);
        if (t3 < 0 || t3 >= 3)
          return H.ioore(C.List_6FR, t3);
        if (C.List_6FR[t3] === C.StrokeJoin_0) {
          if (t1.getFloat32(28, true) !== 4) {
            t3 = t1.getInt32(24, true);
            if (t3 < 0 || t3 >= 3)
              return H.ioore(C.List_6FR, t3);
            t3 = t2 + (" " + C.List_6FR[t3].toString$0(0) + " up to " + C.JSNumber_methods.toStringAsFixed$1(t1.getFloat32(28, true), 1));
            t2 = t3;
          }
        } else {
          t3 = t1.getInt32(24, true);
          if (t3 < 0 || t3 >= 3)
            return H.ioore(C.List_6FR, t3);
          t3 = t2 + (" " + C.List_6FR[t3].toString$0(0));
          t2 = t3;
        }
        semicolon = _s2_;
      } else {
        semicolon = "";
        t2 = "Paint(";
      }
      if (t1.getInt32(0, true) !== 0) {
        t2 += semicolon + "antialias off";
        semicolon = _s2_;
      }
      if (!_this.get$color().$eq(0, C.Color_4278190080)) {
        _this.get$color();
        t2 += semicolon + _this.get$color().toString$0(0);
        semicolon = _s2_;
      }
      if (_this.get$blendMode().index !== $.$get$Paint__kBlendModeDefault()) {
        t2 += semicolon + _this.get$blendMode().toString$0(0);
        semicolon = _s2_;
      }
      if (_this.get$colorFilter() != null) {
        t2 += semicolon + "colorFilter: " + H.S(_this.get$colorFilter());
        semicolon = _s2_;
      }
      if (_this.get$maskFilter() != null) {
        t2 += semicolon + "maskFilter: " + H.S(_this.get$maskFilter());
        semicolon = _s2_;
      }
      t3 = t1.getInt32(32, true);
      if (t3 < 0 || t3 >= 4)
        return H.ioore(C.List_cOY, t3);
      if (C.List_cOY[t3] !== C.FilterQuality_0) {
        t3 = semicolon + "filterQuality: ";
        t4 = t1.getInt32(32, true);
        if (t4 < 0 || t4 >= 4)
          return H.ioore(C.List_cOY, t4);
        t4 = t2 + (t3 + C.List_cOY[t4].toString$0(0));
        t2 = t4;
        semicolon = _s2_;
      }
      if (_this.get$shader() != null) {
        t2 += semicolon + "shader: " + H.S(_this.get$shader());
        semicolon = _s2_;
      }
      t1 = (t1.getInt32(60, true) === 1 ? t2 + (semicolon + "invert: " + (t1.getInt32(60, true) === 1)) : t2) + ")";
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  P.Image.prototype = {};
  P.PathFillType.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.PathOperation.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.Path.prototype = {
    set$fillType: function(value) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    addRect$1: function(rect) {
      P._rectIsValid(rect);
      throw H.wrapException(P.UnimplementedError$(null));
    },
    addOval$1: function(oval) {
      P._rectIsValid(oval);
      throw H.wrapException(P.UnimplementedError$(null));
    },
    addRRect$1: function(rrect) {
      P._rrectIsValid(rrect);
      throw H.wrapException(P.UnimplementedError$(null));
    },
    contains$1: function(_, point) {
      P._offsetIsValid(point);
      throw H.wrapException(P.UnimplementedError$(null));
    },
    shift$1: function(offset) {
      P._offsetIsValid(offset);
      throw H.wrapException(P.UnimplementedError$(null));
    },
    transform$1: function(matrix4) {
      throw H.wrapException(P.UnimplementedError$(null));
    }
  };
  P.BlurStyle.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.MaskFilter.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof P.MaskFilter))
        return false;
      return this._style === other._style && this._sigma === other._sigma;
    },
    get$hashCode: function(_) {
      return P.hashValues(this._style, this._sigma, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      return "MaskFilter.blur(" + this._style.toString$0(0) + ", " + C.JSNumber_methods.toStringAsFixed$1(this._sigma, 1) + ")";
    }
  };
  P.ColorFilter.prototype = {
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (!(other instanceof P.ColorFilter))
        return false;
      if (_this._type !== other._type)
        return false;
      if (!P._listEquals(_this._matrix, other._matrix, P.double))
        return false;
      return J.$eq$(_this._color, other._color) && _this._blendMode == other._blendMode;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this._color, _this._blendMode, P.hashList(_this._matrix), _this._type, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var _this = this;
      switch (_this._type) {
        case 1:
          return "ColorFilter.mode(" + H.S(_this._color) + ", " + H.S(_this._blendMode) + ")";
        case 2:
          return "ColorFilter.matrix(" + H.S(_this._matrix) + ")";
        case 3:
          return "ColorFilter.linearToSrgbGamma()";
        case 4:
          return "ColorFilter.srgbToLinearGamma()";
        default:
          return "Unknown ColorFilter type. This is an error. If you're seeing this, please file an issue at https://github.com/flutter/flutter/issues/new.";
      }
    }
  };
  P.Shader.prototype = {};
  P.TileMode.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.Gradient0.prototype = {};
  P.ClipOp.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.Canvas.prototype = {
    save$0: function() {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    saveLayer$2: function(bounds, paint) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    restore$0: function() {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    getSaveCount$0: function() {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    translate$2: function(dx, dy) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    rotate$1: function(radians) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    transform$1: function(matrix4) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    clipRect$3$clipOp$doAntiAlias: function(rect, clipOp, doAntiAlias) {
      P._rectIsValid(rect);
      throw H.wrapException(P.UnimplementedError$(null));
    },
    clipRect$2$doAntiAlias: function(rect, doAntiAlias) {
      return this.clipRect$3$clipOp$doAntiAlias(rect, C.ClipOp_1, doAntiAlias);
    },
    clipRect$1: function(rect) {
      return this.clipRect$3$clipOp$doAntiAlias(rect, C.ClipOp_1, true);
    },
    clipRRect$2$doAntiAlias: function(rrect, doAntiAlias) {
      P._rrectIsValid(rrect);
      throw H.wrapException(P.UnimplementedError$(null));
    },
    clipRRect$1: function(rrect) {
      return this.clipRRect$2$doAntiAlias(rrect, true);
    },
    clipPath$2$doAntiAlias: function(path, doAntiAlias) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    clipPath$1: function(path) {
      return this.clipPath$2$doAntiAlias(path, true);
    },
    drawRect$2: function(rect, paint) {
      P._rectIsValid(rect);
      H.assertHelper(paint != null);
      throw H.wrapException(P.UnimplementedError$(null));
    },
    drawRRect$2: function(rrect, paint) {
      P._rrectIsValid(rrect);
      H.assertHelper(paint != null);
      throw H.wrapException(P.UnimplementedError$(null));
    },
    drawDRRect$3: function(outer, inner, paint) {
      P._rrectIsValid(outer);
      P._rrectIsValid(inner);
      throw H.wrapException(P.UnimplementedError$(null));
    },
    drawCircle$3: function(c, radius, paint) {
      P._offsetIsValid(c);
      H.assertHelper(paint != null);
      throw H.wrapException(P.UnimplementedError$(null));
    },
    drawPath$2: function(path, paint) {
      H.assertHelper(paint != null);
      throw H.wrapException(P.UnimplementedError$(null));
    },
    drawParagraph$2: function(paragraph, offset) {
      H.assertHelper(false);
      P._offsetIsValid(offset);
      throw H.wrapException(P.UnimplementedError$(null));
    }
  };
  P.PictureRecorder.prototype = {
    endRecording$0: function() {
      throw H.wrapException(P.UnimplementedError$(null));
    }
  };
  P.Shadow.prototype = {
    toPaint$0: function() {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!(other instanceof P.Shadow))
        return false;
      return J.$eq$(_this.color, other.color) && J.$eq$(_this.offset, other.offset) && _this.blurRadius == other.blurRadius;
    },
    get$hashCode: function(_) {
      return P.hashValues(this.color, this.offset, this.blurRadius, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      return "TextShadow(" + H.S(this.color) + ", " + H.S(this.offset) + ", " + H.S(this.blurRadius) + ")";
    }
  };
  P.PointerDeviceKind.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.PointerSignalKind.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.PointerData.prototype = {};
  P.PointerDataPacket.prototype = {};
  P.SemanticsAction.prototype = {
    toString$0: function(_) {
      switch (this.index) {
        case 1:
          return "SemanticsAction.tap";
        case 2:
          return "SemanticsAction.longPress";
        case 4:
          return "SemanticsAction.scrollLeft";
        case 8:
          return "SemanticsAction.scrollRight";
        case 16:
          return "SemanticsAction.scrollUp";
        case 32:
          return "SemanticsAction.scrollDown";
        case 64:
          return "SemanticsAction.increase";
        case 128:
          return "SemanticsAction.decrease";
        case 256:
          return "SemanticsAction.showOnScreen";
        case 512:
          return "SemanticsAction.moveCursorForwardByCharacter";
        case 1024:
          return "SemanticsAction.moveCursorBackwardByCharacter";
        case 2048:
          return "SemanticsAction.setSelection";
        case 4096:
          return "SemanticsAction.copy";
        case 8192:
          return "SemanticsAction.cut";
        case 16384:
          return "SemanticsAction.paste";
        case 32768:
          return "SemanticsAction.didGainAccessibilityFocus";
        case 65536:
          return "SemanticsAction.didLoseAccessibilityFocus";
        case 131072:
          return "SemanticsAction.customAction";
        case 262144:
          return "SemanticsAction.dismiss";
        case 524288:
          return "SemanticsAction.moveCursorForwardByWord";
        case 1048576:
          return "SemanticsAction.moveCursorBackwardByWord";
      }
      return;
    }
  };
  P.SemanticsFlag.prototype = {
    toString$0: function(_) {
      switch (this.index) {
        case 1:
          return "SemanticsFlag.hasCheckedState";
        case 2:
          return "SemanticsFlag.isChecked";
        case 4:
          return "SemanticsFlag.isSelected";
        case 8:
          return "SemanticsFlag.isButton";
        case 16:
          return "SemanticsFlag.isTextField";
        case 32:
          return "SemanticsFlag.isFocused";
        case 64:
          return "SemanticsFlag.hasEnabledState";
        case 128:
          return "SemanticsFlag.isEnabled";
        case 256:
          return "SemanticsFlag.isInMutuallyExclusiveGroup";
        case 512:
          return "SemanticsFlag.isHeader";
        case 1024:
          return "SemanticsFlag.isObscured";
        case 2048:
          return "SemanticsFlag.scopesRoute";
        case 4096:
          return "SemanticsFlag.namesRoute";
        case 8192:
          return "SemanticsFlag.isHidden";
        case 16384:
          return "SemanticsFlag.isImage";
        case 32768:
          return "SemanticsFlag.isLiveRegion";
        case 65536:
          return "SemanticsFlag.hasToggledState";
        case 131072:
          return "SemanticsFlag.isToggled";
        case 262144:
          return "SemanticsFlag.hasImplicitScrolling";
      }
      return;
    }
  };
  P.SemanticsUpdateBuilder.prototype = {
    updateNode$24$actions$additionalActions$childrenInHitTestOrder$childrenInTraversalOrder$decreasedValue$elevation$flags$hint$id$increasedValue$label$platformViewId$rect$scrollChildren$scrollExtentMax$scrollExtentMin$scrollIndex$scrollPosition$textDirection$textSelectionBase$textSelectionExtent$thickness$transform$value: function(actions, additionalActions, childrenInHitTestOrder, childrenInTraversalOrder, decreasedValue, elevation, flags, hint, id, increasedValue, label, platformViewId, rect, scrollChildren, scrollExtentMax, scrollExtentMin, scrollIndex, scrollPosition, textDirection, textSelectionBase, textSelectionExtent, thickness, transform, value) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    updateCustomAction$4$hint$id$label$overrideId: function(hint, id, label, overrideId) {
      H.assertHelper(id != null);
      throw H.wrapException(P.UnimplementedError$(null));
    },
    build$0: function() {
      throw H.wrapException(P.UnimplementedError$(null));
    }
  };
  P.FontStyle.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.FontWeight.prototype = {
    toString$0: function(_) {
      return C.Map_yXAeS.$index(0, this.index);
    }
  };
  P.TextAlign.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.TextBaseline.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.TextDecoration.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof P.TextDecoration))
        return false;
      return this._mask === other._mask;
    },
    get$hashCode: function(_) {
      return C.JSInt_methods.get$hashCode(this._mask);
    },
    toString$0: function(_) {
      var values,
        t1 = this._mask;
      if (t1 === 0)
        return "TextDecoration.none";
      values = H.setRuntimeTypeInfo([], [P.String]);
      if ((t1 & 1) !== 0)
        C.JSArray_methods.add$1(values, "underline");
      if ((t1 & 2) !== 0)
        C.JSArray_methods.add$1(values, "overline");
      if ((t1 & 4) !== 0)
        C.JSArray_methods.add$1(values, "lineThrough");
      t1 = values.length;
      if (t1 === 1) {
        if (0 >= t1)
          return H.ioore(values, 0);
        return "TextDecoration." + values[0];
      }
      return "TextDecoration.combine([" + C.JSArray_methods.join$1(values, ", ") + "])";
    }
  };
  P.TextDecorationStyle.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.TextStyle.prototype = {
    $eq: function(_, other) {
      var t1, t2, index, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!(other instanceof P.TextStyle))
        return false;
      if (_this._fontFamily === other._fontFamily)
        if (_this._fontSize == other._fontSize)
          if (_this._letterSpacing == other._letterSpacing)
            if (_this._wordSpacing == other._wordSpacing)
              if (_this._height == other._height)
                if (_this._decorationThickness == other._decorationThickness)
                  t1 = _this._background != other._background || _this._foreground != other._foreground;
                else
                  t1 = true;
              else
                t1 = true;
            else
              t1 = true;
          else
            t1 = true;
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        return false;
      for (t1 = _this._encoded, t2 = other._encoded, index = 0; index < 8; ++index)
        if (t1[index] !== t2[index])
          return false;
      if (!P._listEquals(_this._shadows, other._shadows, P.Shadow))
        return false;
      if (!P._listEquals(_this._fontFamilyFallback, other._fontFamilyFallback, P.String))
        return false;
      return true;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(P.hashList(_this._encoded), _this._fontFamily, _this._fontFamilyFallback, _this._fontSize, _this._letterSpacing, _this._wordSpacing, _this._height, _this._locale, _this._background, _this._foreground, _this._shadows, _this._decorationThickness, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t3, _this = this,
        _s11_ = "unspecified",
        t1 = _this._encoded,
        t2 = "TextStyle(color: " + H.S((t1[0] & 2) === 2 ? new P.Color((t1[1] & 4294967295) >>> 0) : _s11_) + ", decoration: ";
      t2 = t2 + H.S((t1[0] & 4) === 4 ? new P.TextDecoration(t1[2]) : _s11_) + ", decorationColor: ";
      t2 = t2 + H.S((t1[0] & 8) === 8 ? new P.Color((t1[3] & 4294967295) >>> 0) : _s11_) + ", decorationStyle: ";
      if ((t1[0] & 16) === 16) {
        t3 = t1[4];
        if (t3 < 0 || t3 >= 5)
          return H.ioore(C.List_yGF, t3);
        t3 = C.List_yGF[t3];
      } else
        t3 = _s11_;
      t3 = t2 + H.S(t3) + ", decorationThickness: ";
      t2 = t3 + H.S((t1[0] & 32) === 32 ? _this._decorationThickness : _s11_) + ", fontWeight: ";
      if ((t1[0] & 64) === 64) {
        t3 = t1[5];
        if (t3 < 0 || t3 >= 9)
          return H.ioore(C.List_27p, t3);
        t3 = C.List_27p[t3];
      } else
        t3 = _s11_;
      t3 = t2 + H.S(t3) + ", fontStyle: ";
      if ((t1[0] & 128) === 128) {
        t2 = t1[6];
        if (t2 < 0 || t2 >= 2)
          return H.ioore(C.List_FontStyle_0_FontStyle_1, t2);
        t2 = C.List_FontStyle_0_FontStyle_1[t2];
      } else
        t2 = _s11_;
      t2 = t3 + H.S(t2) + ", textBaseline: ";
      if ((t1[0] & 256) === 256) {
        t3 = t1[7];
        if (t3 < 0 || t3 >= 2)
          return H.ioore(C.List_TextBaseline_0_TextBaseline_1, t3);
        t3 = C.List_TextBaseline_0_TextBaseline_1[t3];
      } else
        t3 = _s11_;
      t3 = t2 + H.S(t3) + ", fontFamily: ";
      t2 = (t1[0] & 512) === 512;
      t3 += t2 && true ? _this._fontFamily : _s11_;
      t3 + ", fontFamilyFallback: ";
      t2;
      t3 + ", fontFamilyFallback: unspecified";
      t2 = t3 + ", fontFamilyFallback: unspecified, fontSize: ";
      t2 = t2 + H.S((t1[0] & 1024) === 1024 ? _this._fontSize : _s11_) + ", letterSpacing: ";
      t2 = t2 + ((t1[0] & 2048) === 2048 ? H.S(_this._letterSpacing) + "x" : _s11_) + ", wordSpacing: ";
      t2 = t2 + ((t1[0] & 4096) === 4096 ? H.S(_this._wordSpacing) + "x" : _s11_) + ", height: ";
      t2 = t2 + ((t1[0] & 8192) === 8192 ? H.S(_this._height) + "x" : _s11_) + ", locale: ";
      t2 = t2 + H.S((t1[0] & 16384) === 16384 ? _this._locale : _s11_) + ", background: ";
      t2 = t2 + H.S((t1[0] & 32768) === 32768 ? _this._background : _s11_) + ", foreground: ";
      t2 = t2 + H.S((t1[0] & 65536) === 65536 ? _this._foreground : _s11_) + ", shadows: ";
      return t2 + H.S((t1[0] & 131072) === 131072 ? _this._shadows : _s11_) + ")";
    }
  };
  P.ParagraphStyle.prototype = {
    $eq: function(_, other) {
      var t1, t2, index, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isParagraphStyle");
      if (_this._fontFamily != other._fontFamily || _this._fontSize != other._fontSize || _this._height != other._height || !J.$eq$(_this._strutStyle, other._strutStyle) || _this._ellipsis != other._ellipsis || !J.$eq$(_this._locale, other._locale))
        return false;
      for (t1 = _this._encoded, t2 = other._encoded, index = 0; index < 6; ++index)
        if (t1[index] !== t2[index])
          return false;
      return true;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(P.hashList(_this._encoded), _this._fontFamily, _this._fontSize, _this._height, _this._ellipsis, _this._locale, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t3, _this = this,
        _s11_ = "unspecified",
        t1 = new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(textAlign: ",
        t2 = _this._encoded;
      if ((t2[0] & 2) === 2) {
        t3 = t2[1];
        if (t3 < 0 || t3 >= 6)
          return H.ioore(C.List_WPl, t3);
        t3 = C.List_WPl[t3];
      } else
        t3 = _s11_;
      t3 = t1 + H.S(t3) + ", textDirection: ";
      if ((t2[0] & 4) === 4) {
        t1 = t2[2];
        if (t1 < 0 || t1 >= 2)
          return H.ioore(C.List_TextDirection_0_TextDirection_1, t1);
        t1 = C.List_TextDirection_0_TextDirection_1[t1];
      } else
        t1 = _s11_;
      t1 = t3 + H.S(t1) + ", fontWeight: ";
      if ((t2[0] & 8) === 8) {
        t3 = t2[3];
        if (t3 < 0 || t3 >= 9)
          return H.ioore(C.List_27p, t3);
        t3 = C.List_27p[t3];
      } else
        t3 = _s11_;
      t3 = t1 + H.S(t3) + ", fontStyle: ";
      if ((t2[0] & 16) === 16) {
        t1 = t2[4];
        if (t1 < 0 || t1 >= 2)
          return H.ioore(C.List_FontStyle_0_FontStyle_1, t1);
        t1 = C.List_FontStyle_0_FontStyle_1[t1];
      } else
        t1 = _s11_;
      t1 = t3 + H.S(t1) + ", maxLines: ";
      t1 = t1 + H.S((t2[0] & 32) === 32 ? t2[5] : _s11_) + ", fontFamily: ";
      t1 = t1 + H.S((t2[0] & 64) === 64 ? _this._fontFamily : _s11_) + ", fontSize: ";
      t1 = t1 + H.S((t2[0] & 128) === 128 ? _this._fontSize : _s11_) + ", height: ";
      t1 = t1 + ((t2[0] & 256) === 256 ? H.S(_this._height) + "x" : _s11_) + ", ellipsis: ";
      t1 = t1 + ((t2[0] & 512) === 512 ? '"' + H.S(_this._ellipsis) + '"' : _s11_) + ", locale: ";
      return t1 + H.S((t2[0] & 1024) === 1024 ? _this._locale : _s11_) + ")";
    }
  };
  P.TextDirection.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.TextAffinity.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.ParagraphConstraints.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(this))))
        return false;
      return H.interceptedTypeCheck(other, "$isParagraphConstraints").width == this.width;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.width);
    },
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(width: " + H.S(this.width) + ")";
    }
  };
  P.ParagraphBuilder.prototype = {
    pushStyle$1: function(style) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    pop$0: function() {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    addText$1: function(text) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    build$0: function() {
      throw H.wrapException(P.UnimplementedError$(null));
    }
  };
  P.AppLifecycleState.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  P.WindowPadding.prototype = {
    toString$0: function(_) {
      var _this = this;
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(left: " + _this.left + ", top: " + _this.top + ", right: " + _this.right + ", bottom: " + _this.bottom + ")";
    }
  };
  P.Locale.prototype = {
    $eq: function(_, other) {
      var t1;
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!(other instanceof P.Locale))
        return false;
      if (P.Locale__replaceDeprecatedLanguageSubtag(this._languageCode) === P.Locale__replaceDeprecatedLanguageSubtag(other._languageCode))
        t1 = P.Locale__replaceDeprecatedRegionSubtag(this._countryCode) === P.Locale__replaceDeprecatedRegionSubtag(other._countryCode);
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return P.hashValues(P.Locale__replaceDeprecatedLanguageSubtag(this._languageCode), null, P.Locale__replaceDeprecatedRegionSubtag(this._countryCode), C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t1 = P.Locale__replaceDeprecatedLanguageSubtag(this._languageCode);
      t1 += "_" + P.Locale__replaceDeprecatedRegionSubtag(this._countryCode);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  P.Window.prototype = {
    get$defaultRouteName: function() {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    scheduleFrame$0: function() {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    updateSemantics$1: function(update) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    sendPlatformMessage$3: function($name, data, callback) {
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.ByteData]});
      throw H.wrapException(P.UnimplementedError$(null));
    },
    set$_onMetricsChanged: function(_onMetricsChanged) {
      H.functionTypeCheck(_onMetricsChanged, {func: 1, ret: -1});
    },
    set$_onLocaleChanged: function(_onLocaleChanged) {
      H.functionTypeCheck(_onLocaleChanged, {func: 1, ret: -1});
    },
    set$_onPlatformBrightnessChanged: function(_onPlatformBrightnessChanged) {
      H.functionTypeCheck(_onPlatformBrightnessChanged, {func: 1, ret: -1});
    },
    set$_onTextScaleFactorChanged: function(_onTextScaleFactorChanged) {
      H.functionTypeCheck(_onTextScaleFactorChanged, {func: 1, ret: -1});
    },
    set$_onBeginFrame: function(_onBeginFrame) {
      H.functionTypeCheck(_onBeginFrame, {func: 1, ret: -1, args: [P.Duration]});
    },
    set$_onDrawFrame: function(_onDrawFrame) {
      H.functionTypeCheck(_onDrawFrame, {func: 1, ret: -1});
    },
    set$_onPointerDataPacket: function(_onPointerDataPacket) {
      H.functionTypeCheck(_onPointerDataPacket, {func: 1, ret: -1, args: [P.PointerDataPacket]});
    },
    set$_onSemanticsEnabledChanged: function(_onSemanticsEnabledChanged) {
      H.functionTypeCheck(_onSemanticsEnabledChanged, {func: 1, ret: -1});
    },
    set$_onSemanticsAction: function(_onSemanticsAction) {
      H.functionTypeCheck(_onSemanticsAction, {func: 1, ret: -1, args: [P.int, P.SemanticsAction, P.ByteData]});
    },
    set$_onAccessibilityFeaturesChanged: function(_onAccessibilityFeaturesChanged) {
      H.functionTypeCheck(_onAccessibilityFeaturesChanged, {func: 1, ret: -1});
    },
    set$_onPlatformMessage: function(_onPlatformMessage) {
      H.functionTypeCheck(_onPlatformMessage, {func: 1, ret: -1, args: [P.String, P.ByteData, {func: 1, ret: -1, args: [P.ByteData]}]});
    }
  };
  P.Brightness.prototype = {
    toString$0: function(_) {
      return this._ui$_name;
    }
  };
  Y.HeapPriorityQueue.prototype = {
    get$isEmpty: function(_) {
      return this._length === 0;
    },
    get$length: function(_) {
      return this._length;
    },
    toString$0: function(_) {
      var t1 = this._priority_queue$_queue;
      return P.IterableBase_iterableToShortString(H.SubListIterable$(t1, 0, this._length, H.getTypeArgumentByIndex(t1, 0)), "(", ")");
    },
    _bubbleUp$2: function(element, index) {
      var t1, parentIndex, t2, $parent, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      for (t1 = _this.comparison; index > 0; index = parentIndex) {
        parentIndex = C.JSInt_methods._tdivFast$1(index - 1, 2);
        t2 = _this._priority_queue$_queue;
        if (parentIndex < 0 || parentIndex >= t2.length)
          return H.ioore(t2, parentIndex);
        $parent = t2[parentIndex];
        if (J.$gt$n(t1.call$2(element, $parent), 0))
          break;
        C.JSArray_methods.$indexSet(_this._priority_queue$_queue, index, $parent);
      }
      C.JSArray_methods.$indexSet(_this._priority_queue$_queue, index, element);
    },
    _bubbleDown$2: function(element, index) {
      var rightChildIndex, t1, t2, leftChildIndex, t3, leftChild, rightChild, comp, minChild, minChildIndex, child, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      rightChildIndex = index * 2 + 2;
      for (t1 = _this.comparison; t2 = _this._length, rightChildIndex < t2; index = minChildIndex) {
        leftChildIndex = rightChildIndex - 1;
        t2 = _this._priority_queue$_queue;
        t3 = t2.length;
        if (leftChildIndex < 0 || leftChildIndex >= t3)
          return H.ioore(t2, leftChildIndex);
        leftChild = t2[leftChildIndex];
        if (rightChildIndex < 0 || rightChildIndex >= t3)
          return H.ioore(t2, rightChildIndex);
        rightChild = t2[rightChildIndex];
        comp = t1.call$2(leftChild, rightChild);
        if (typeof comp !== "number")
          return comp.$lt();
        if (comp < 0) {
          minChild = leftChild;
          minChildIndex = leftChildIndex;
        } else {
          minChild = rightChild;
          minChildIndex = rightChildIndex;
        }
        comp = t1.call$2(element, minChild);
        if (typeof comp !== "number")
          return comp.$le();
        if (comp <= 0) {
          C.JSArray_methods.$indexSet(_this._priority_queue$_queue, index, element);
          return;
        }
        C.JSArray_methods.$indexSet(_this._priority_queue$_queue, index, minChild);
        rightChildIndex = minChildIndex * 2 + 2;
      }
      leftChildIndex = rightChildIndex - 1;
      if (leftChildIndex < t2) {
        t2 = _this._priority_queue$_queue;
        if (leftChildIndex < 0 || leftChildIndex >= t2.length)
          return H.ioore(t2, leftChildIndex);
        child = t2[leftChildIndex];
        comp = t1.call$2(element, child);
        if (typeof comp !== "number")
          return comp.$gt();
        if (comp > 0) {
          C.JSArray_methods.$indexSet(_this._priority_queue$_queue, index, child);
          index = leftChildIndex;
        }
      }
      C.JSArray_methods.$indexSet(_this._priority_queue$_queue, index, element);
    },
    set$_priority_queue$_queue: function(_queue) {
      this._priority_queue$_queue = H.assertSubtype(_queue, "$isList", this.$ti, "$asList");
    },
    $isPriorityQueue: 1
  };
  X.AnimationStatus.prototype = {
    toString$0: function(_) {
      return this._animation$_name;
    }
  };
  X.Animation.prototype = {
    drive$1$1: function(child, $U) {
      var t1;
      H.assertSubtype(child, "$isAnimatable", [$U], "$asAnimatable");
      t1 = [P.double];
      H.assertHelper(H.checkSubtype(this, "$isAnimation", t1, "$asAnimation"));
      H.assertSubtype(this, "$isAnimation", t1, "$asAnimation");
      child.toString;
      return new R._AnimatedEvaluation(this, child, [H.getRuntimeTypeArgument(child, "Animatable", 0)]);
    },
    toString$0: function(_) {
      var _this = this;
      return _this.get$runtimeType(_this).toString$0(0) + "#" + Y.shortHash(_this) + "(" + _this.toStringDetails$0() + ")";
    },
    toStringDetails$0: function() {
      var icon, _this = this;
      H.assertHelper(_this.get$status(_this) != null);
      switch (_this.get$status(_this)) {
        case C.AnimationStatus_1:
          icon = "\u25b6";
          break;
        case C.AnimationStatus_2:
          icon = "\u25c0";
          break;
        case C.AnimationStatus_3:
          icon = "\u23ed";
          break;
        case C.AnimationStatus_0:
          icon = "\u23ee";
          break;
        default:
          icon = null;
      }
      H.assertHelper(icon != null);
      return H.S(icon);
    }
  };
  G._AnimationDirection.prototype = {
    toString$0: function(_) {
      return this._animation_controller$_name;
    }
  };
  G.AnimationBehavior.prototype = {
    toString$0: function(_) {
      return this._animation_controller$_name;
    }
  };
  G.AnimationController.prototype = {
    get$value: function() {
      return this._animation_controller$_value;
    },
    set$value: function(newValue) {
      var _this = this;
      H.assertHelper(newValue != null);
      _this.stop$0();
      _this._internalSetValue$1(newValue);
      _this.notifyListeners$0();
      _this._checkStatusChanged$0();
    },
    _internalSetValue$1: function(newValue) {
      var _this = this,
        t1 = _this.lowerBound,
        t2 = _this.upperBound,
        t3 = _this._animation_controller$_value = C.JSNumber_methods.clamp$2(newValue, t1, t2);
      if (t3 === t1)
        _this._status = C.AnimationStatus_0;
      else if (t3 === t2)
        _this._status = C.AnimationStatus_3;
      else
        _this._status = _this._direction === C._AnimationDirection_0 ? C.AnimationStatus_1 : C.AnimationStatus_2;
    },
    get$status: function(_) {
      return this._status;
    },
    forward$1$from: function(from) {
      var _this = this;
      H.assertHelper(new G.AnimationController_forward_closure(_this).call$0());
      if (H.assertTest(_this._ticker != null))
        H.assertThrow("AnimationController.forward() called after AnimationController.dispose()\nAnimationController methods should not be used after calling dispose.");
      _this._direction = C._AnimationDirection_0;
      if (from != null)
        _this.set$value(from);
      return _this._animateToInternal$1(_this.upperBound);
    },
    forward$0: function() {
      return this.forward$1$from(null);
    },
    reverse$1$from: function(from) {
      var _this = this;
      H.assertHelper(new G.AnimationController_reverse_closure(_this).call$0());
      if (H.assertTest(_this._ticker != null))
        H.assertThrow("AnimationController.reverse() called after AnimationController.dispose()\nAnimationController methods should not be used after calling dispose.");
      _this._direction = C._AnimationDirection_1;
      return _this._animateToInternal$1(_this.lowerBound);
    },
    reverse$0: function() {
      return this.reverse$1$from(null);
    },
    _animateToInternal$3$curve$duration: function(target, curve, duration) {
      var scale, range, t1, remainingFraction, simulationDuration, t2, _this = this;
      if (H.boolConversionCheck($.SemanticsBinding__instance.get$disableAnimations()))
        switch (C.AnimationBehavior_0) {
          case C.AnimationBehavior_0:
            scale = 0.05;
            break;
          case C.AnimationBehavior_1:
            scale = 1;
            break;
          default:
            scale = 1;
        }
      else
        scale = 1;
      if (duration == null) {
        H.assertHelper(new G.AnimationController__animateToInternal_closure(_this).call$0());
        range = _this.upperBound - _this.lowerBound;
        if (isFinite(range)) {
          t1 = _this._animation_controller$_value;
          if (typeof t1 !== "number")
            return H.iae(t1);
          remainingFraction = Math.abs(target - t1) / range;
        } else
          remainingFraction = 1;
        simulationDuration = new P.Duration(C.JSNumber_methods.round$0(_this.duration._duration * remainingFraction));
      } else
        simulationDuration = target === _this._animation_controller$_value ? C.Duration_0 : duration;
      _this.stop$0();
      t1 = simulationDuration._duration;
      if (t1 === 0) {
        if (_this._animation_controller$_value !== target) {
          _this._animation_controller$_value = C.JSInt_methods.clamp$2(target, _this.lowerBound, _this.upperBound);
          _this.notifyListeners$0();
        }
        _this._status = _this._direction === C._AnimationDirection_0 ? C.AnimationStatus_3 : C.AnimationStatus_0;
        _this._checkStatusChanged$0();
        t1 = -1;
        t1 = new M.TickerFuture(new P._AsyncCompleter(new P._Future($.Zone__current, [t1]), [t1]));
        t1._ticker$_complete$0();
        return t1;
      }
      H.assertHelper(t1 > 0);
      t2 = _this._ticker;
      H.assertHelper(!(t2 != null && t2._future != null));
      return _this._startSimulation$1(new G._InterpolationSimulation(t1 * scale / 1000000, _this._animation_controller$_value, target, curve, C.Tolerance_Gdw));
    },
    _animateToInternal$1: function(target) {
      return this._animateToInternal$3$curve$duration(target, C.C__Linear, null);
    },
    _startSimulation$1: function(simulation) {
      var result, _this = this,
        t1 = _this._ticker;
      H.assertHelper(!(t1 != null && t1._future != null));
      _this._simulation = simulation;
      _this._animation_controller$_value = J.clamp$2$n(simulation.x$1(0), _this.lowerBound, _this.upperBound);
      result = _this._ticker.start$0();
      _this._status = _this._direction === C._AnimationDirection_0 ? C.AnimationStatus_1 : C.AnimationStatus_2;
      _this._checkStatusChanged$0();
      return result;
    },
    stop$1$canceled: function(canceled) {
      if (H.assertTest(this._ticker != null))
        H.assertThrow("AnimationController.stop() called after AnimationController.dispose()\nAnimationController methods should not be used after calling dispose.");
      this._simulation = null;
      this._ticker.stop$1$canceled(canceled);
    },
    stop$0: function() {
      return this.stop$1$canceled(true);
    },
    dispose$0: function() {
      var _this = this;
      H.assertHelper(new G.AnimationController_dispose_closure(_this).call$0());
      _this._ticker.dispose$0();
      _this._ticker = null;
      _this.super$AnimationEagerListenerMixin$dispose();
    },
    _checkStatusChanged$0: function() {
      var _this = this,
        newStatus = _this._status;
      if (_this._lastReportedStatus != newStatus) {
        _this._lastReportedStatus = newStatus;
        _this.notifyStatusListeners$1(newStatus);
      }
    },
    _tick$1: function(elapsed) {
      var _this = this,
        elapsedInSeconds = elapsed._duration / 1000000;
      H.assertHelper(elapsedInSeconds >= 0);
      _this._animation_controller$_value = J.clamp$2$n(_this._simulation.x$1(elapsedInSeconds), _this.lowerBound, _this.upperBound);
      if (_this._simulation.isDone$1(elapsedInSeconds)) {
        _this._status = _this._direction === C._AnimationDirection_0 ? C.AnimationStatus_3 : C.AnimationStatus_0;
        _this.stop$1$canceled(false);
      }
      _this.notifyListeners$0();
      _this._checkStatusChanged$0();
    },
    toStringDetails$0: function() {
      var ticker, label, _this = this,
        t1 = _this._ticker,
        t2 = t1 == null,
        paused = !t2 && t1._future != null ? "" : "; paused";
      if (t2)
        ticker = "; DISPOSED";
      else
        ticker = t1._muted ? "; silenced" : "";
      t1 = _this.debugLabel;
      label = t1 == null ? "" : "; for " + t1;
      return _this.super$Animation$toStringDetails() + " " + J.toStringAsFixed$1$n(_this._animation_controller$_value, 3) + paused + ticker + label;
    },
    $asAnimation: function() {
      return [P.double];
    }
  };
  G.AnimationController_forward_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  G.AnimationController_reverse_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  G.AnimationController__animateToInternal_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  G.AnimationController_dispose_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (t1._ticker == null)
        throw H.wrapException(U.FlutterError$("AnimationController.dispose() called more than once.\nA given " + H.getRuntimeType(t1).toString$0(0) + " cannot be disposed more than once.\nThe following " + H.getRuntimeType(t1).toString$0(0) + " object was disposed multiple times:\n  " + t1.toString$0(0)));
      return true;
    },
    $signature: 0
  };
  G._InterpolationSimulation.prototype = {
    x$1: function(timeInSeconds) {
      var t1, t2, t3, _this = this,
        t = C.JSDouble_methods.clamp$2(timeInSeconds / _this._durationInSeconds, 0, 1);
      if (t === 0)
        return _this._begin;
      else {
        t1 = _this._animation_controller$_end;
        if (t === 1)
          return t1;
        else {
          t2 = _this._begin;
          if (typeof t2 !== "number")
            return H.iae(t2);
          t3 = _this._curve.transform$1(t);
          if (typeof t3 !== "number")
            return H.iae(t3);
          return t2 + (t1 - t2) * t3;
        }
      }
    },
    isDone$1: function(timeInSeconds) {
      return timeInSeconds > this._durationInSeconds;
    }
  };
  G._AnimationController_Animation_AnimationEagerListenerMixin.prototype = {};
  G._AnimationController_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin.prototype = {};
  G._AnimationController_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin.prototype = {};
  S._AlwaysCompleteAnimation.prototype = {
    addListener$1: function(listener) {
      H.functionTypeCheck(listener, {func: 1, ret: -1});
    },
    removeListener$1: function(listener) {
      H.functionTypeCheck(listener, {func: 1, ret: -1});
    },
    addStatusListener$1: function(listener) {
      H.functionTypeCheck(listener, {func: 1, ret: -1, args: [X.AnimationStatus]});
    },
    removeStatusListener$1: function(listener) {
      H.functionTypeCheck(listener, {func: 1, ret: -1, args: [X.AnimationStatus]});
    },
    get$status: function(_) {
      return C.AnimationStatus_3;
    },
    get$value: function() {
      return 1;
    },
    toString$0: function(_) {
      return "kAlwaysCompleteAnimation";
    },
    $asAnimation: function() {
      return [P.double];
    }
  };
  S._AlwaysDismissedAnimation.prototype = {
    addListener$1: function(listener) {
      H.functionTypeCheck(listener, {func: 1, ret: -1});
    },
    removeListener$1: function(listener) {
      H.functionTypeCheck(listener, {func: 1, ret: -1});
    },
    addStatusListener$1: function(listener) {
      H.functionTypeCheck(listener, {func: 1, ret: -1, args: [X.AnimationStatus]});
    },
    removeStatusListener$1: function(listener) {
      H.functionTypeCheck(listener, {func: 1, ret: -1, args: [X.AnimationStatus]});
    },
    get$status: function(_) {
      return C.AnimationStatus_0;
    },
    get$value: function() {
      return 0;
    },
    toString$0: function(_) {
      return "kAlwaysDismissedAnimation";
    },
    $asAnimation: function() {
      return [P.double];
    }
  };
  S.AnimationWithParentMixin.prototype = {
    addListener$1: function(listener) {
      H.functionTypeCheck(listener, {func: 1, ret: -1});
      return this.get$parent().addListener$1(listener);
    },
    removeListener$1: function(listener) {
      H.functionTypeCheck(listener, {func: 1, ret: -1});
      return this.get$parent().removeListener$1(listener);
    },
    addStatusListener$1: function(listener) {
      H.functionTypeCheck(listener, {func: 1, ret: -1, args: [X.AnimationStatus]});
      return this.get$parent().addStatusListener$1(listener);
    },
    removeStatusListener$1: function(listener) {
      H.functionTypeCheck(listener, {func: 1, ret: -1, args: [X.AnimationStatus]});
      return this.get$parent().removeStatusListener$1(listener);
    },
    get$status: function(_) {
      var t1 = this.get$parent();
      return t1.get$status(t1);
    }
  };
  S.ProxyAnimation.prototype = {
    set$parent: function(value) {
      var t1, t2, _this = this;
      H.assertSubtype(value, "$isAnimation", [P.double], "$asAnimation");
      t1 = _this._animations$_parent;
      if (value == t1)
        return;
      if (t1 != null) {
        _this._animations$_status = t1.get$status(t1);
        _this._animations$_value = H.doubleTypeCheck(_this._animations$_parent.get$value());
        if (_this.AnimationLazyListenerMixin__listenerCounter > 0)
          _this.didStopListening$0();
      }
      _this.set$_animations$_parent(value);
      if (_this._animations$_parent != null) {
        if (_this.AnimationLazyListenerMixin__listenerCounter > 0)
          _this.didStartListening$0();
        t1 = _this._animations$_value;
        t2 = _this._animations$_parent.get$value();
        if (t1 == null ? t2 != null : t1 !== t2)
          _this.notifyListeners$0();
        t1 = _this._animations$_status;
        t2 = _this._animations$_parent;
        if (t1 != t2.get$status(t2)) {
          t1 = _this._animations$_parent;
          _this.notifyStatusListeners$1(t1.get$status(t1));
        }
        _this._animations$_value = _this._animations$_status = null;
      }
    },
    didStartListening$0: function() {
      var _this = this,
        t1 = _this._animations$_parent;
      if (t1 != null) {
        t1.addListener$1(_this.get$notifyListeners());
        _this._animations$_parent.addStatusListener$1(_this.get$notifyStatusListeners());
      }
    },
    didStopListening$0: function() {
      var _this = this,
        t1 = _this._animations$_parent;
      if (t1 != null) {
        t1.removeListener$1(_this.get$notifyListeners());
        _this._animations$_parent.removeStatusListener$1(_this.get$notifyStatusListeners());
      }
    },
    get$status: function(_) {
      var t1 = this._animations$_parent;
      return t1 != null ? t1.get$status(t1) : this._animations$_status;
    },
    get$value: function() {
      var t1 = this._animations$_parent;
      return t1 != null ? t1.get$value() : this._animations$_value;
    },
    toString$0: function(_) {
      var _this = this,
        t1 = _this._animations$_parent;
      if (t1 == null)
        return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(null; " + _this.super$Animation$toStringDetails() + " " + J.toStringAsFixed$1$n(_this.get$value(), 3) + ")";
      return t1.toString$0(0) + "\u27a9" + new H.TypeImpl(H.getRti(_this)).toString$0(0);
    },
    set$_animations$_parent: function(_parent) {
      this._animations$_parent = H.assertSubtype(_parent, "$isAnimation", [P.double], "$asAnimation");
    },
    $asAnimation: function() {
      return [P.double];
    }
  };
  S.ReverseAnimation.prototype = {
    addListener$1: function(listener) {
      H.functionTypeCheck(listener, {func: 1, ret: -1});
      this.didRegisterListener$0();
      this.parent.get$parent().addListener$1(listener);
    },
    removeListener$1: function(listener) {
      H.functionTypeCheck(listener, {func: 1, ret: -1});
      this.parent.get$parent().removeListener$1(listener);
      this.didUnregisterListener$0();
    },
    didStartListening$0: function() {
      var t1 = H.functionTypeCheck(this.get$_statusChangeHandler(), {func: 1, ret: -1, args: [X.AnimationStatus]});
      this.parent.get$parent().addStatusListener$1(t1);
    },
    didStopListening$0: function() {
      var t1 = H.functionTypeCheck(this.get$_statusChangeHandler(), {func: 1, ret: -1, args: [X.AnimationStatus]});
      this.parent.get$parent().removeStatusListener$1(t1);
    },
    _statusChangeHandler$1: function($status) {
      this.notifyStatusListeners$1(this._reverseStatus$1(H.interceptedTypeCheck($status, "$isAnimationStatus")));
    },
    get$status: function(_) {
      var t1 = this.parent.get$parent();
      return this._reverseStatus$1(t1.get$status(t1));
    },
    get$value: function() {
      var t1 = this.parent.get$value();
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 1 - t1;
    },
    _reverseStatus$1: function($status) {
      H.assertHelper($status != null);
      switch ($status) {
        case C.AnimationStatus_1:
          return C.AnimationStatus_2;
        case C.AnimationStatus_2:
          return C.AnimationStatus_1;
        case C.AnimationStatus_3:
          return C.AnimationStatus_0;
        case C.AnimationStatus_0:
          return C.AnimationStatus_3;
      }
      return;
    },
    toString$0: function(_) {
      return this.parent.toString$0(0) + "\u27aa" + new H.TypeImpl(H.getRti(this)).toString$0(0);
    },
    $asAnimation: function() {
      return [P.double];
    }
  };
  S.CurvedAnimation.prototype = {
    _updateCurveDirection$1: function($status) {
      var _this = this;
      switch (H.interceptedTypeCheck($status, "$isAnimationStatus")) {
        case C.AnimationStatus_0:
        case C.AnimationStatus_3:
          _this._curveDirection = null;
          break;
        case C.AnimationStatus_1:
          if (_this._curveDirection == null)
            _this._curveDirection = C.AnimationStatus_1;
          break;
        case C.AnimationStatus_2:
          if (_this._curveDirection == null)
            _this._curveDirection = C.AnimationStatus_2;
          break;
      }
    },
    get$_useForwardCurve: function() {
      if (this.reverseCurve != null) {
        var t1 = this._curveDirection;
        if (t1 == null) {
          t1 = this.parent;
          t1 = t1.get$status(t1);
        }
        t1 = t1 !== C.AnimationStatus_2;
      } else
        t1 = true;
      return t1;
    },
    get$value: function() {
      var _this = this,
        activeCurve = _this.get$_useForwardCurve() ? _this.curve : _this.reverseCurve,
        t = _this.parent.get$value();
      if (activeCurve == null)
        return t;
      if (t === 0 || t === 1) {
        H.assertHelper(new S.CurvedAnimation_value_closure(activeCurve, t).call$0());
        return t;
      }
      return activeCurve.transform$1(t);
    },
    toString$0: function(_) {
      var _this = this,
        t1 = _this.reverseCurve;
      if (t1 == null)
        return H.S(_this.parent) + "\u27a9" + _this.curve.toString$0(0);
      if (_this.get$_useForwardCurve())
        return H.S(_this.parent) + "\u27a9" + _this.curve.toString$0(0) + "\u2092\u2099/" + t1.toString$0(0);
      return H.S(_this.parent) + "\u27a9" + _this.curve.toString$0(0) + "/" + t1.toString$0(0) + "\u2092\u2099";
    },
    $asAnimation: function() {
      return [P.double];
    },
    get$parent: function() {
      return this.parent;
    }
  };
  S.CurvedAnimation_value_closure.prototype = {
    call$0: function() {
      var t1 = this.activeCurve,
        t2 = this.t,
        transformedValue = t1.transform$1(t2),
        roundedTransformedValue = J.round$0$n(transformedValue);
      if (roundedTransformedValue !== t2)
        throw H.wrapException(U.FlutterError$("Invalid curve endpoint at " + H.S(t2) + ".\nCurves must map 0.0 to near zero and 1.0 to near one but " + H.getRuntimeType(t1).toString$0(0) + " mapped " + H.S(t2) + " to " + H.S(transformedValue) + ", which is near " + roundedTransformedValue + "."));
      return true;
    },
    $signature: 0
  };
  S._TrainHoppingMode.prototype = {
    toString$0: function(_) {
      return this._animations$_name;
    }
  };
  S.TrainHoppingAnimation.prototype = {
    _statusChangeHandler$1: function($status) {
      var t1, _this = this;
      H.interceptedTypeCheck($status, "$isAnimationStatus");
      H.assertHelper(_this._currentTrain != null);
      t1 = _this._lastStatus;
      if ($status != t1) {
        _this.notifyListeners$0();
        _this._lastStatus = $status;
        t1 = $status;
      }
      H.assertHelper(t1 != null);
    },
    get$status: function(_) {
      var t1 = this._currentTrain;
      return t1.get$status(t1);
    },
    _valueChangeHandler$0: function() {
      var hop, t1, t2, _this = this;
      H.assertHelper(_this._currentTrain != null);
      if (_this._nextTrain != null) {
        H.assertHelper(_this._mode != null);
        switch (_this._mode) {
          case C._TrainHoppingMode_0:
            hop = J.$le$n(_this._nextTrain.get$value(), _this._currentTrain.get$value());
            break;
          case C._TrainHoppingMode_1:
            hop = J.$ge$n(_this._nextTrain.get$value(), _this._currentTrain.get$value());
            break;
          default:
            hop = false;
        }
        if (hop) {
          t1 = _this._currentTrain;
          t2 = _this.get$_statusChangeHandler();
          t1.removeStatusListener$1(t2);
          t1.removeListener$1(_this.get$_valueChangeHandler());
          _this.set$_currentTrain(_this._nextTrain);
          _this.set$_nextTrain(null);
          _this._currentTrain.addStatusListener$1(t2);
          t2 = _this._currentTrain;
          _this._statusChangeHandler$1(t2.get$status(t2));
        }
      } else
        hop = false;
      t1 = _this._currentTrain.get$value();
      t2 = _this._lastValue;
      if (t1 != t2) {
        _this.notifyListeners$0();
        _this._lastValue = t1;
      } else
        t1 = t2;
      H.assertHelper(t1 != null);
      if (hop && _this.onSwitchedTrain != null)
        _this.onSwitchedTrain.call$0();
    },
    get$value: function() {
      return this._currentTrain.get$value();
    },
    dispose$0: function() {
      var t1, t2, _this = this;
      H.assertHelper(_this._currentTrain != null);
      _this._currentTrain.removeStatusListener$1(_this.get$_statusChangeHandler());
      t1 = _this.get$_valueChangeHandler();
      _this._currentTrain.removeListener$1(t1);
      _this.set$_currentTrain(null);
      t2 = _this._nextTrain;
      if (t2 != null)
        t2.removeListener$1(t1);
      _this.set$_nextTrain(null);
      _this.super$AnimationEagerListenerMixin$dispose();
    },
    toString$0: function(_) {
      var _this = this;
      if (_this._nextTrain != null)
        return H.S(_this._currentTrain) + "\u27a9" + new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(next: " + H.S(_this._nextTrain) + ")";
      return H.S(_this._currentTrain) + "\u27a9" + new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(no next)";
    },
    set$_currentTrain: function(_currentTrain) {
      this._currentTrain = H.assertSubtype(_currentTrain, "$isAnimation", [P.double], "$asAnimation");
    },
    set$_nextTrain: function(_nextTrain) {
      this._nextTrain = H.assertSubtype(_nextTrain, "$isAnimation", [P.double], "$asAnimation");
    },
    $asAnimation: function() {
      return [P.double];
    }
  };
  S.CompoundAnimation.prototype = {
    didStartListening$0: function() {
      var t3, _this = this,
        t1 = _this.first,
        t2 = _this.get$_maybeNotifyListeners();
      t1.addListener$1(t2);
      t3 = _this.get$_maybeNotifyStatusListeners();
      t1.addStatusListener$1(t3);
      t1 = _this.next;
      t1.addListener$1(t2);
      t1.addStatusListener$1(t3);
    },
    didStopListening$0: function() {
      var t3, _this = this,
        t1 = _this.first,
        t2 = _this.get$_maybeNotifyListeners();
      t1.removeListener$1(t2);
      t3 = _this.get$_maybeNotifyStatusListeners();
      t1.removeStatusListener$1(t3);
      t1 = _this.next;
      t1.removeListener$1(t2);
      t1.removeStatusListener$1(t3);
    },
    get$status: function(_) {
      var t1 = this.next;
      if (t1.get$status(t1) === C.AnimationStatus_1 || t1.get$status(t1) === C.AnimationStatus_2)
        return t1.get$status(t1);
      t1 = this.first;
      return t1.get$status(t1);
    },
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(" + this.first.toString$0(0) + ", " + this.next.toString$0(0) + ")";
    },
    _maybeNotifyStatusListeners$1: function(_) {
      var _this = this;
      H.interceptedTypeCheck(_, "$isAnimationStatus");
      if (_this.get$status(_this) != _this._lastStatus) {
        _this._lastStatus = _this.get$status(_this);
        _this.notifyStatusListeners$1(_this.get$status(_this));
      }
    },
    _maybeNotifyListeners$0: function() {
      var _this = this;
      if (!J.$eq$(_this.get$value(), _this._lastValue)) {
        _this.set$_lastValue(_this.get$value());
        _this.notifyListeners$0();
      }
    },
    set$_lastValue: function(_lastValue) {
      this._lastValue = H.assertSubtypeOfRuntimeType(_lastValue, H.getTypeArgumentByIndex(this, 0));
    }
  };
  S.AnimationMin.prototype = {
    get$value: function() {
      var t1 = this.first.get$value(),
        t2 = this.next.get$value();
      return Math.min(H.checkNum(t1), H.checkNum(t2));
    }
  };
  S._CompoundAnimation_Animation_AnimationLazyListenerMixin.prototype = {};
  S._CompoundAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin.prototype = {};
  S._CompoundAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin.prototype = {};
  S._CurvedAnimation_Animation_AnimationWithParentMixin.prototype = {};
  S._ProxyAnimation_Animation_AnimationLazyListenerMixin.prototype = {};
  S._ProxyAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin.prototype = {};
  S._ProxyAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin.prototype = {};
  S._ReverseAnimation_Animation_AnimationLazyListenerMixin.prototype = {};
  S._ReverseAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalStatusListenersMixin.prototype = {};
  S._TrainHoppingAnimation_Animation_AnimationEagerListenerMixin.prototype = {};
  S._TrainHoppingAnimation_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin.prototype = {};
  S._TrainHoppingAnimation_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin.prototype = {};
  Z.Curve.prototype = {
    transform$1: function(t) {
      if (typeof t !== "number")
        return t.$ge();
      H.assertHelper(t >= 0 && t <= 1);
      if (t === 0 || t === 1)
        return t;
      return this.transformInternal$1(t);
    },
    transformInternal$1: function(t) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    }
  };
  Z._Linear.prototype = {
    transformInternal$1: function(t) {
      return t;
    }
  };
  Z.Interval.prototype = {
    transformInternal$1: function(t) {
      var t2,
        t1 = this.begin;
      if (typeof t1 !== "number")
        return t1.$ge();
      H.assertHelper(t1 >= 0);
      H.assertHelper(t1 <= 1);
      t2 = this.end;
      H.assertHelper(t2 >= 0);
      H.assertHelper(t2 <= 1);
      H.assertHelper(t2 >= t1);
      t = C.JSDouble_methods.clamp$2((t - t1) / (t2 - t1), 0, 1);
      if (t === 0 || t === 1)
        return t;
      return this.curve.transform$1(t);
    },
    toString$0: function(_) {
      var _this = this,
        t1 = _this.curve;
      if (!t1.$is_Linear)
        return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(" + H.S(_this.begin) + "\u22ef" + H.S(_this.end) + ")\u27a9" + t1.toString$0(0);
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(" + H.S(_this.begin) + "\u22ef" + H.S(_this.end) + ")";
    }
  };
  Z.Threshold.prototype = {
    transformInternal$1: function(t) {
      var t1 = this.threshold;
      H.assertHelper(t1 >= 0);
      H.assertHelper(t1 <= 1);
      return t < t1 ? 0 : 1;
    }
  };
  Z.Cubic.prototype = {
    _evaluateCubic$3: function(a, b, m) {
      var t1 = 1 - m;
      return 3 * a * t1 * t1 * m + 3 * b * t1 * m * m + m * m * m;
    },
    transformInternal$1: function(t) {
      var t1, t2, start, end, midpoint, estimate, _this = this;
      for (t1 = _this.a, t2 = _this.c, start = 0, end = 1; true;) {
        midpoint = (start + end) / 2;
        estimate = _this._evaluateCubic$3(t1, t2, midpoint);
        if (Math.abs(t - estimate) < 0.001)
          return _this._evaluateCubic$3(_this.b, _this.d, midpoint);
        if (estimate < t)
          start = midpoint;
        else
          end = midpoint;
      }
    },
    toString$0: function(_) {
      var _this = this;
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(" + C.JSDouble_methods.toStringAsFixed$1(_this.a, 2) + ", " + C.JSNumber_methods.toStringAsFixed$1(_this.b, 2) + ", " + C.JSNumber_methods.toStringAsFixed$1(_this.c, 2) + ", " + C.JSNumber_methods.toStringAsFixed$1(_this.d, 2) + ")";
    }
  };
  Z.FlippedCurve.prototype = {
    transformInternal$1: function(t) {
      var t1 = this.curve.transform$1(1 - t);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 1 - t1;
    },
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(" + this.curve.toString$0(0) + ")";
    }
  };
  S.AnimationLazyListenerMixin.prototype = {
    didRegisterListener$0: function() {
      var _this = this;
      H.assertHelper(_this.AnimationLazyListenerMixin__listenerCounter >= 0);
      if (_this.AnimationLazyListenerMixin__listenerCounter === 0)
        _this.didStartListening$0();
      ++_this.AnimationLazyListenerMixin__listenerCounter;
    },
    didUnregisterListener$0: function() {
      H.assertHelper(this.AnimationLazyListenerMixin__listenerCounter >= 1);
      if (--this.AnimationLazyListenerMixin__listenerCounter === 0)
        this.didStopListening$0();
    }
  };
  S.AnimationEagerListenerMixin.prototype = {
    didRegisterListener$0: function() {
    },
    didUnregisterListener$0: function() {
    },
    dispose$0: function() {
    }
  };
  S.AnimationLocalListenersMixin.prototype = {
    addListener$1: function(listener) {
      var t1;
      H.functionTypeCheck(listener, {func: 1, ret: -1});
      this.didRegisterListener$0();
      t1 = this.AnimationLocalListenersMixin__listeners;
      H.assertSubtypeOfRuntimeType(listener, H.getTypeArgumentByIndex(t1, 0));
      t1._isDirty = true;
      C.JSArray_methods.add$1(t1._list, listener);
    },
    removeListener$1: function(listener) {
      var t1 = this.AnimationLocalListenersMixin__listeners;
      listener = H.assertSubtypeOfRuntimeType(H.functionTypeCheck(listener, {func: 1, ret: -1}), H.getTypeArgumentByIndex(t1, 0));
      t1._isDirty = true;
      if (C.JSArray_methods.remove$1(t1._list, listener))
        this.didUnregisterListener$0();
    },
    notifyListeners$0: function() {
      var listener, exception, stack, t2, _i, exception0, t3,
        t1 = this.AnimationLocalListenersMixin__listeners,
        localListeners = P.List_List$from(t1, true, {func: 1, ret: -1});
      for (t2 = localListeners.length, _i = 0; _i < localListeners.length; localListeners.length === t2 || (0, H.throwConcurrentModificationError)(localListeners), ++_i) {
        listener = localListeners[_i];
        try {
          if (t1.contains$1(0, listener))
            listener.call$0();
        } catch (exception0) {
          exception = H.unwrapException(exception0);
          stack = H.getTraceFromException(exception0);
          t3 = "while notifying listeners for " + new H.TypeImpl(H.getRti(this)).toString$0(0);
          U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(new U.FlutterErrorDetails(exception, stack, "animation library", t3, new S.AnimationLocalListenersMixin_notifyListeners_closure(this), false));
        }
      }
    }
  };
  S.AnimationLocalListenersMixin_notifyListeners_closure.prototype = {
    call$1: function(information) {
      var t1 = this.$this;
      information._contents += "The " + new H.TypeImpl(H.getRti(t1)).toString$0(0) + " notifying listeners was:\n";
      information._contents += "  " + t1.toString$0(0);
    },
    $signature: 3
  };
  S.AnimationLocalStatusListenersMixin.prototype = {
    addStatusListener$1: function(listener) {
      var t1;
      H.functionTypeCheck(listener, {func: 1, ret: -1, args: [X.AnimationStatus]});
      this.didRegisterListener$0();
      t1 = this.AnimationLocalStatusListenersMixin__statusListeners;
      H.assertSubtypeOfRuntimeType(listener, H.getTypeArgumentByIndex(t1, 0));
      t1._isDirty = true;
      C.JSArray_methods.add$1(t1._list, listener);
    },
    removeStatusListener$1: function(listener) {
      var t1 = this.AnimationLocalStatusListenersMixin__statusListeners;
      listener = H.assertSubtypeOfRuntimeType(H.functionTypeCheck(listener, {func: 1, ret: -1, args: [X.AnimationStatus]}), H.getTypeArgumentByIndex(t1, 0));
      t1._isDirty = true;
      if (C.JSArray_methods.remove$1(t1._list, listener))
        this.didUnregisterListener$0();
    },
    notifyStatusListeners$1: function($status) {
      var listener, exception, stack, t1, localListeners, t2, _i, exception0, t3;
      H.interceptedTypeCheck($status, "$isAnimationStatus");
      t1 = this.AnimationLocalStatusListenersMixin__statusListeners;
      localListeners = P.List_List$from(t1, true, {func: 1, ret: -1, args: [X.AnimationStatus]});
      for (t2 = localListeners.length, _i = 0; _i < localListeners.length; localListeners.length === t2 || (0, H.throwConcurrentModificationError)(localListeners), ++_i) {
        listener = localListeners[_i];
        try {
          if (t1.contains$1(0, listener))
            listener.call$1($status);
        } catch (exception0) {
          exception = H.unwrapException(exception0);
          stack = H.getTraceFromException(exception0);
          t3 = "while notifying status listeners for " + new H.TypeImpl(H.getRti(this)).toString$0(0);
          U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(new U.FlutterErrorDetails(exception, stack, "animation library", t3, new S.AnimationLocalStatusListenersMixin_notifyStatusListeners_closure(this), false));
        }
      }
    }
  };
  S.AnimationLocalStatusListenersMixin_notifyStatusListeners_closure.prototype = {
    call$1: function(information) {
      var t1 = this.$this;
      information._contents += "The " + new H.TypeImpl(H.getRti(t1)).toString$0(0) + " notifying status listeners was:\n";
      information._contents += "  " + t1.toString$0(0);
    },
    $signature: 3
  };
  R.Animatable.prototype = {
    chain$1: function($parent) {
      return new R._ChainedEvaluation(H.assertSubtype($parent, "$isAnimatable", [P.double], "$asAnimatable"), this, [H.getRuntimeTypeArgument(this, "Animatable", 0)]);
    }
  };
  R._AnimatedEvaluation.prototype = {
    get$value: function() {
      return this._evaluatable.transform$1(H.assertSubtype(this.parent, "$isAnimation", [P.double], "$asAnimation").get$value());
    },
    toString$0: function(_) {
      var t1 = this.parent,
        t2 = this._evaluatable;
      return t1.toString$0(0) + "\u27a9" + t2.toString$0(0) + "\u27a9" + H.S(t2.transform$1(H.assertSubtype(t1, "$isAnimation", [P.double], "$asAnimation").get$value()));
    },
    toStringDetails$0: function() {
      return this.super$Animation$toStringDetails() + " " + this._evaluatable.toString$0(0);
    },
    get$parent: function() {
      return this.parent;
    }
  };
  R._ChainedEvaluation.prototype = {
    transform$1: function(t) {
      return this._evaluatable.transform$1(this._tween$_parent.transform$1(t));
    },
    toString$0: function(_) {
      return H.S(this._tween$_parent) + "\u27a9" + this._evaluatable.toString$0(0);
    }
  };
  R.Tween.prototype = {
    lerp$1: function(t) {
      var t1, _this = this;
      H.assertHelper(_this.begin != null);
      H.assertHelper(_this.end != null);
      t1 = _this.begin;
      return H.assertSubtypeOfRuntimeType(J.$add$ansx(t1, J.$mul$ns(J.$sub$n(_this.end, t1), t)), H.getRuntimeTypeArgument(_this, "Tween", 0));
    },
    transform$1: function(t) {
      if (t === 0)
        return this.begin;
      if (t === 1)
        return this.end;
      return this.lerp$1(t);
    },
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(" + H.S(this.begin) + " \u2192 " + H.S(this.end) + ")";
    },
    set$begin: function(begin) {
      this.begin = H.assertSubtypeOfRuntimeType(begin, H.getRuntimeTypeArgument(this, "Tween", 0));
    },
    set$end: function(end) {
      this.end = H.assertSubtypeOfRuntimeType(end, H.getRuntimeTypeArgument(this, "Tween", 0));
    }
  };
  R.ReverseTween.prototype = {
    lerp$1: function(t) {
      if (typeof t !== "number")
        return H.iae(t);
      return this.parent.lerp$1(1 - t);
    }
  };
  R.ColorTween.prototype = {
    lerp$1: function(t) {
      return P.Color_lerp(this.begin, this.end, t);
    },
    $asAnimatable: function() {
      return [P.Color];
    },
    $asTween: function() {
      return [P.Color];
    }
  };
  R.RectTween.prototype = {
    lerp$1: function(t) {
      return P.Rect_lerp(this.begin, this.end, t);
    },
    $asAnimatable: function() {
      return [P.Rect];
    },
    $asTween: function() {
      return [P.Rect];
    }
  };
  R.IntTween.prototype = {
    lerp$1: function(t) {
      var t1 = this.begin;
      return J.round$0$n(J.$add$ansx(t1, J.$mul$ns(J.$sub$n(this.end, t1), t)));
    },
    $asAnimatable: function() {
      return [P.int];
    },
    $asTween: function() {
      return [P.int];
    }
  };
  R.CurveTween.prototype = {
    transform$1: function(t) {
      if (t === 0 || t === 1) {
        H.assertHelper(J.round$0$n(this.curve.transform$1(t)) === t);
        return t;
      }
      return this.curve.transform$1(t);
    },
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(curve: " + this.curve.toString$0(0) + ")";
    },
    $asAnimatable: function() {
      return [P.double];
    }
  };
  R.__AnimatedEvaluation_Animation_AnimationWithParentMixin.prototype = {};
  L.CupertinoLocalizations.prototype = {};
  L._CupertinoLocalizationsDelegate.prototype = {
    isSupported$1: function(locale) {
      return P.Locale__replaceDeprecatedLanguageSubtag(locale._languageCode) === "en";
    },
    load$1: function(locale) {
      return new O.SynchronousFuture(C.C_DefaultCupertinoLocalizations, [L.CupertinoLocalizations]);
    },
    shouldReload$1: function(old) {
      H.interceptedTypeCheck(old, "$is_CupertinoLocalizationsDelegate");
      return false;
    },
    toString$0: function(_) {
      return "DefaultCupertinoLocalizations.delegate(en_US)";
    },
    $asLocalizationsDelegate: function() {
      return [L.CupertinoLocalizations];
    }
  };
  L.DefaultCupertinoLocalizations.prototype = {$isCupertinoLocalizations: 1};
  D.CupertinoPageRoute_buildPageTransitions_closure.prototype = {
    call$0: function() {
      return D.CupertinoPageRoute__isPopGestureEnabled(this.route, this.T);
    },
    $signature: 0
  };
  D.CupertinoPageRoute_buildPageTransitions_closure0.prototype = {
    call$0: function() {
      var t3,
        t1 = this.route,
        t2 = this.T;
      H.assertHelper(D.CupertinoPageRoute__isPopGestureEnabled(t1, t2));
      t3 = t1._navigator$_navigator;
      t1 = t1._routes$_controller;
      t3.didStartUserGesture$0();
      return new D._CupertinoBackGestureController(t1, t3, [t2]);
    },
    $signature: function() {
      return {func: 1, ret: [D._CupertinoBackGestureController, this.T]};
    }
  };
  D.CupertinoPageTransition.prototype = {
    build$1: function(context) {
      var textDirection, t1, _this = this;
      E.debugCheckHasDirectionality(context);
      textDirection = T.Directionality_of(context);
      t1 = _this._primaryShadowAnimation;
      return K.SlideTransition$(K.SlideTransition$(new K.DecoratedBoxTransition(t1, _this.child, t1, null), _this._primaryPositionAnimation, textDirection, true), _this._secondaryPositionAnimation, textDirection, false);
    }
  };
  D._CupertinoBackGestureDetector.prototype = {
    createState$0: function() {
      return new D._CupertinoBackGestureDetectorState(C._StateLifecycle_0, this.$ti);
    },
    enabledCallback$0: function() {
      return this.enabledCallback.call$0();
    },
    onStartPopGesture$0: function() {
      return this.onStartPopGesture.call$0();
    },
    get$child: function() {
      return this.child;
    }
  };
  D._CupertinoBackGestureDetectorState.prototype = {
    initState$0: function() {
      var t1, _this = this;
      _this.super$State$initState();
      t1 = P.int;
      t1 = new O.HorizontalDragGestureRecognizer(C.DragStartBehavior_1, C._DragState_0, P.LinkedHashMap_LinkedHashMap$_empty(t1, R.VelocityTracker), P.LinkedHashMap_LinkedHashMap$_empty(t1, D.GestureArenaEntry), P.HashSet_HashSet(t1), _this, null);
      t1.set$onStart(_this.get$_handleDragStart());
      t1.set$onUpdate(_this.get$_handleDragUpdate());
      t1.set$onEnd(_this.get$_handleDragEnd());
      t1.set$onCancel(_this.get$_handleDragCancel());
      _this._recognizer = t1;
    },
    dispose$0: function() {
      var t1 = this._recognizer;
      t1._velocityTrackers.clear$0(0);
      t1.super$OneSequenceGestureRecognizer$dispose();
      this.super$State$dispose();
    },
    _handleDragStart$1: function(details) {
      var _this = this;
      H.interceptedTypeCheck(details, "$isDragStartDetails");
      H.assertHelper(_this._element != null);
      H.assertHelper(_this._backGestureController == null);
      _this.set$_backGestureController(_this._widget.onStartPopGesture$0());
    },
    _handleDragUpdate$1: function(details) {
      var t1, t2, t3, _this = this;
      H.interceptedTypeCheck(details, "$isDragUpdateDetails");
      H.assertHelper(_this._element != null);
      H.assertHelper(_this._backGestureController != null);
      t1 = _this._backGestureController;
      t2 = details.primaryDelta;
      t3 = _this._element.get$size()._dx;
      if (typeof t2 !== "number")
        return t2.$div();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = _this._convertToLogical$1(t2 / t3);
      t1 = t1.controller;
      t2 = t1._animation_controller$_value;
      if (typeof t2 !== "number")
        return t2.$sub();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t1.set$value(t2 - t3);
    },
    _handleDragEnd$1: function(details) {
      var t1, t2, t3, _this = this;
      H.interceptedTypeCheck(details, "$isDragEndDetails");
      H.assertHelper(_this._element != null);
      H.assertHelper(_this._backGestureController != null);
      t1 = _this._backGestureController;
      t2 = details.velocity.pixelsPerSecond._dx;
      t3 = _this._element.get$size()._dx;
      if (typeof t2 !== "number")
        return t2.$div();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t1.dragEnd$1(_this._convertToLogical$1(t2 / t3));
      _this.set$_backGestureController(null);
    },
    _handleDragCancel$0: function() {
      H.assertHelper(this._element != null);
      var t1 = this._backGestureController;
      if (t1 != null)
        t1.dragEnd$1(0);
      this.set$_backGestureController(null);
    },
    _route$_handlePointerDown$1: function($event) {
      if (H.boolConversionCheck(this._widget.enabledCallback$0()))
        this._recognizer.addPointer$1($event);
    },
    _convertToLogical$1: function(value) {
      switch (T.Directionality_of(this._element)) {
        case C.TextDirection_0:
          return -value;
        case C.TextDirection_1:
          return value;
      }
      return;
    },
    build$1: function(context) {
      var dragAreaWidth, _null = null;
      E.debugCheckHasDirectionality(context);
      dragAreaWidth = Math.max(H.checkNum(T.Directionality_of(context) === C.TextDirection_1 ? F.MediaQuery_of(context, false).padding.left : F.MediaQuery_of(context, false).padding.right), 20);
      return T.Stack$(C.AlignmentDirectional_m1_m1, H.setRuntimeTypeInfo([this._widget.child, new T.PositionedDirectional(0, 0, 0, dragAreaWidth, T.Listener$(C.HitTestBehavior_2, _null, _null, this.get$_route$_handlePointerDown(), _null), _null)], [N.Widget]), C.StackFit_2);
    },
    set$_backGestureController: function(_backGestureController) {
      this._backGestureController = H.assertSubtype(_backGestureController, "$is_CupertinoBackGestureController", this.$ti, "$as_CupertinoBackGestureController");
    },
    $asState: function($T) {
      return [[D._CupertinoBackGestureDetector, $T]];
    }
  };
  D._CupertinoBackGestureController.prototype = {
    dragEnd$1: function(velocity) {
      var animateForward, t2, t3, animationStatusCallback, _this = this, t1 = {};
      if (typeof velocity !== "number")
        return velocity.abs$0();
      if (Math.abs(velocity) >= 1)
        animateForward = !(velocity > 0) || false;
      else {
        t2 = _this.controller._animation_controller$_value;
        if (typeof t2 !== "number")
          return t2.$gt();
        animateForward = t2 > 0.5 && true;
      }
      if (animateForward) {
        t2 = _this.controller;
        t3 = P.Duration$(0, Math.min(J.floor$0$n(P.lerpDouble(800, 0, t2._animation_controller$_value)), 300), 0);
        if (H.assertTest(t2._ticker != null))
          H.assertThrow("AnimationController.animateTo() called after AnimationController.dispose()\nAnimationController methods should not be used after calling dispose.");
        t2._direction = C._AnimationDirection_0;
        t2._animateToInternal$3$curve$duration(1, C.Cubic_2Vk, t3);
      } else {
        _this.navigator.pop$1$0(P.Object);
        t2 = _this.controller;
        t3 = t2._ticker;
        if (t3 != null && t3._future != null) {
          t3 = P.Duration$(0, J.floor$0$n(P.lerpDouble(0, 800, t2._animation_controller$_value)), 0);
          if (H.assertTest(t2._ticker != null))
            H.assertThrow("AnimationController.animateBack() called after AnimationController.dispose()\nAnimationController methods should not be used after calling dispose.");
          t2._direction = C._AnimationDirection_1;
          t2._animateToInternal$3$curve$duration(0, C.Cubic_2Vk, t3);
        }
      }
      t3 = t2._ticker;
      if (t3 != null && t3._future != null) {
        t1.animationStatusCallback = null;
        animationStatusCallback = new D._CupertinoBackGestureController_dragEnd_closure(t1, _this);
        t1.animationStatusCallback = animationStatusCallback;
        t2.addStatusListener$1(animationStatusCallback);
      }
    }
  };
  D._CupertinoBackGestureController_dragEnd_closure.prototype = {
    call$1: function($status) {
      var t1;
      H.interceptedTypeCheck($status, "$isAnimationStatus");
      t1 = this.$this;
      t1.navigator.didStopUserGesture$0();
      t1.controller.removeStatusListener$1(this._box_0.animationStatusCallback);
    },
    $signature: 78
  };
  D._CupertinoEdgeShadowDecoration.prototype = {
    lerpFrom$2: function(a, t) {
      if (!(a instanceof D._CupertinoEdgeShadowDecoration))
        return D._CupertinoEdgeShadowDecoration_lerp(null, this, t);
      return D._CupertinoEdgeShadowDecoration_lerp(a, this, t);
    },
    lerpTo$2: function(b, t) {
      if (!(b instanceof D._CupertinoEdgeShadowDecoration))
        return D._CupertinoEdgeShadowDecoration_lerp(this, null, t);
      return D._CupertinoEdgeShadowDecoration_lerp(this, b, t);
    },
    createBoxPainter$1: function(onChanged) {
      return new D._CupertinoEdgeShadowPainter(this, H.functionTypeCheck(onChanged, {func: 1, ret: -1}));
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!new H.TypeImpl(H.getRti(this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      return J.$eq$(this.edgeGradient, H.interceptedTypeCheck(other, "$is_CupertinoEdgeShadowDecoration").edgeGradient);
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.edgeGradient);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Diagnosticable$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("edgeGradient", this.edgeGradient, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, T.LinearGradient);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  D._CupertinoEdgeShadowPainter.prototype = {
    paint$3: function(canvas, offset, configuration) {
      var textDirection, deltaX, t1, t2, t3, t4, rect, paint,
        gradient = this._route$_decoration.edgeGradient;
      if (gradient == null)
        return;
      textDirection = configuration.textDirection;
      H.assertHelper(textDirection != null);
      switch (textDirection) {
        case C.TextDirection_0:
          deltaX = configuration.size._dx;
          break;
        case C.TextDirection_1:
          t1 = configuration.size._dx;
          if (typeof t1 !== "number")
            return t1.$negate();
          deltaX = -t1;
          break;
        default:
          deltaX = null;
      }
      t1 = configuration.size;
      t2 = offset._dx;
      t3 = offset._dy;
      t4 = t1._dx;
      t1 = t1._dy;
      if (typeof t2 !== "number")
        return t2.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (typeof deltaX !== "number")
        return H.iae(deltaX);
      rect = P.Rect$fromLTRB(t2 + deltaX, t3 + 0, t2 + t4 + deltaX, t3 + t1 + 0);
      paint = new P.Paint(new DataView(new ArrayBuffer(75)));
      paint.set$shader(P.Gradient$linear(gradient.begin.resolve$1(textDirection).withinRect$1(rect), gradient.end.resolve$1(textDirection).withinRect$1(rect), gradient.colors, gradient._impliedStops$0(), gradient.tileMode));
      canvas.drawRect$2(rect, paint);
    }
  };
  R.CupertinoTextThemeData.prototype = {};
  K.CupertinoTheme.prototype = {
    build$1: function(context) {
      var _null = null;
      return new K._InheritedCupertinoTheme(this, Y.IconTheme$(this.child, new T.IconThemeData(this.data.get$primaryColor(), _null, _null), _null), _null);
    }
  };
  K._InheritedCupertinoTheme.prototype = {
    updateShouldNotify$1: function(old) {
      return this.theme.data !== H.interceptedTypeCheck(old, "$is_InheritedCupertinoTheme").theme.data;
    }
  };
  K.CupertinoThemeData.prototype = {
    get$brightness: function() {
      return C.Brightness_1;
    },
    get$primaryColor: function() {
      var t1 = this.get$brightness() === C.Brightness_1 ? C.Color_4278221567 : C.Color_4294939904;
      return t1;
    },
    get$primaryContrastingColor: function() {
      var t1 = this.get$brightness() === C.Brightness_1 ? C.Color_4294967295 : C.Color_4278190080;
      return t1;
    },
    get$textTheme: function() {
      this.get$brightness();
      this.get$primaryColor();
      var t1 = new R.CupertinoTextThemeData();
      return t1;
    },
    get$barBackgroundColor: function() {
      var t1 = this.get$brightness() === C.Brightness_1 ? C.Color_3438868728 : C.Color_3072401697;
      return t1;
    },
    get$scaffoldBackgroundColor: function() {
      var t1 = this.get$brightness() === C.Brightness_1 ? C.Color_4294967295 : C.Color_4278190080;
      return t1;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      t1 = _this.get$brightness();
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, t1, C.Brightness_1, C.DiagnosticLevel_3, "brightness", true, true, C.DiagnosticsTreeStyle_5, [P.Brightness]));
      t1 = P.Color;
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("primaryColor", _this.get$primaryColor(), C.CupertinoThemeData_MFd.get$primaryColor(), _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("primaryContrastingColor", _this.get$primaryContrastingColor(), C.CupertinoThemeData_MFd.get$primaryContrastingColor(), _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("textTheme", _this.get$textTheme(), C.CupertinoThemeData_MFd.get$textTheme(), _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, R.CupertinoTextThemeData));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("barBackgroundColor", _this.get$barBackgroundColor(), C.CupertinoThemeData_MFd.get$barBackgroundColor(), _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("scaffoldBackgroundColor", _this.get$scaffoldBackgroundColor(), C.CupertinoThemeData_MFd.get$scaffoldBackgroundColor(), _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
    }
  };
  U.FlutterErrorDetails.prototype = {
    exceptionAsString$0: function() {
      var message, fullMessage, t2, position,
        longMessage = this.exception,
        t1 = J.getInterceptor$(longMessage);
      if (!!t1.$isAssertionError) {
        message = H.stringTypeCheck(longMessage.get$message(longMessage));
        fullMessage = longMessage.toString$0(0);
        if (typeof message === "string" && message !== fullMessage) {
          t1 = fullMessage.length;
          t2 = message.length;
          if (t1 > t2) {
            position = J.getInterceptor$s(fullMessage).lastIndexOf$1(fullMessage, message);
            longMessage = position === t1 - t2 && position > 2 && C.JSString_methods.substring$2(fullMessage, position - 2, position) === ": " ? J.trimRight$0$s(message) + "\n" + C.JSString_methods.substring$2(fullMessage, 0, position - 2) : null;
          } else
            longMessage = null;
        } else
          longMessage = null;
        if (longMessage == null)
          longMessage = fullMessage;
      } else if (!(typeof longMessage === "string"))
        longMessage = !!t1.$isError || !!t1.$isException ? t1.toString$0(longMessage) : "  " + H.S(t1.toString$0(longMessage));
      longMessage = J.trimRight$0$s(longMessage);
      return longMessage.length === 0 ? "  <no message available>" : longMessage;
    },
    toString$0: function(_) {
      var t3, stackLines, _this = this,
        _s11_ = "Exception \n",
        buffer = new P.StringBuffer(""),
        t1 = _this.library,
        t2 = t1 === "";
      if (t2) {
        t3 = _this.context;
        t3 = t3 != null && t3 !== "";
      } else
        t3 = true;
      if (t3) {
        if (!t2) {
          t1 = buffer._contents = "Error caught by " + t1;
          t2 = _this.context;
          if (t2 != null && t2 !== "") {
            t1 += ", ";
            buffer._contents = t1;
          }
        } else {
          buffer._contents = _s11_;
          t1 = _s11_;
        }
        t2 = _this.context;
        t1 = buffer._contents = (t2 != null && t2 !== "" ? buffer._contents = t1 + ("thrown " + H.S(t2)) : t1) + ".\n";
      } else
        t1 = buffer._contents = "An error was caught.";
      buffer._contents = t1 + (_this.exceptionAsString$0() + "\n");
      t1 = _this.informationCollector;
      if (t1 != null)
        t1.call$1(buffer);
      t1 = _this.stack;
      if (t1 != null) {
        stackLines = U.FlutterError_defaultStackFilter(H.setRuntimeTypeInfo(C.JSString_methods.trimRight$0(t1.toString$0(0)).split("\n"), [P.String]));
        buffer._contents = P.StringBuffer__writeAll(buffer._contents, stackLines, "\n");
      }
      t1 = buffer._contents;
      return C.JSString_methods.trimRight$0(t1.charCodeAt(0) == 0 ? t1 : t1);
    }
  };
  U.FlutterError.prototype = {
    get$message: function(_) {
      return H.stringTypeCheck(this.message);
    },
    toString$0: function(_) {
      return H.stringTypeCheck(this.message);
    }
  };
  U.FlutterError_dumpErrorToConsole_closure.prototype = {
    call$0: function() {
      return this._box_0.reportError = true;
    },
    $signature: 0
  };
  N.BindingBase.prototype = {
    BindingBase$0: function() {
      var t1, t2, _this = this;
      P.Timeline_startSync("Framework initialization", null, null);
      H.assertHelper(!$.BindingBase__debugInitialized);
      _this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding$initInstances();
      $.WidgetsBinding__instance = _this;
      _this.WidgetsBinding__buildOwner.set$onBuildScheduled(_this.get$_handleBuildScheduled());
      t1 = $.$get$window();
      t1.toString;
      t2 = {func: 1, ret: -1};
      t1.set$_onLocaleChanged(H.functionTypeCheck(_this.get$handleLocaleChanged(), t2));
      t1.set$_onAccessibilityFeaturesChanged(H.functionTypeCheck(_this.get$handleAccessibilityFeaturesChanged(), t2));
      C.MethodChannel_89P.setMethodCallHandler$1(_this.get$_handleNavigationInvocation());
      C.BasicMessageChannel_Qma.setMessageHandler$1(_this.get$_handleSystemMessage());
      H.assertHelper($.BindingBase__debugInitialized);
      H.assertHelper(!$.BindingBase__debugServiceExtensionsRegistered);
      _this.initServiceExtensions$0();
      H.assertHelper($.BindingBase__debugServiceExtensionsRegistered);
      t2 = P.String;
      P.postEvent("Flutter.FrameworkInitialization", P.LinkedHashMap_LinkedHashMap$_empty(t2, t2));
      P.Timeline_finishSync();
    },
    initInstances$0: function() {
      H.assertHelper(!$.BindingBase__debugInitialized);
      H.assertHelper(new N.BindingBase_initInstances_closure().call$0());
    },
    initServiceExtensions$0: function() {
      var _this = this;
      H.assertHelper(!$.BindingBase__debugServiceExtensionsRegistered);
      H.assertHelper(new N.BindingBase_initServiceExtensions_closure(_this).call$0());
      _this.registerSignalServiceExtension$2$callback$name(N.binding0___exitApplication$closure(), "exit");
      _this.registerServiceExtension$2$callback$name(new N.BindingBase_initServiceExtensions_closure0(), "saveCompilationTrace");
      H.assertHelper(new N.BindingBase_initServiceExtensions_closure1(_this).call$0());
      H.assertHelper(new N.BindingBase_initServiceExtensions_closure2().call$0());
    },
    lockEvents$1: function(callback) {
      var future;
      H.functionTypeCheck(callback, {func: 1, ret: [P.Future, -1]});
      P.Timeline_startSync("Lock events", null, null);
      ++this._lockCount;
      future = callback.call$0();
      if (H.assertTest(future != null))
        H.assertThrow("The lockEvents() callback returned null; it should return a Future<void> that completes when the lock is to expire.");
      future.whenComplete$1(new N.BindingBase_lockEvents_closure(this));
      return future;
    },
    unlocked$0: function() {
      H.assertHelper(this._lockCount <= 0);
    },
    reassembleApplication$0: function() {
      return this.lockEvents$1(this.get$performReassemble());
    },
    performReassemble$0: function() {
      $.FlutterError__errorCount = 0;
      var t1 = new P._Future($.Zone__current, [-1]);
      t1._asyncComplete$1(null);
      return t1;
    },
    registerSignalServiceExtension$2$callback$name: function(callback, $name) {
      this.registerServiceExtension$2$callback$name(new N.BindingBase_registerSignalServiceExtension_closure(H.functionTypeCheck(callback, {func: 1, ret: [P.Future, -1]})), $name);
    },
    registerBoolServiceExtension$3$getter$name$setter: function(getter, $name, setter) {
      H.functionTypeCheck(getter, {func: 1, ret: [P.Future, P.bool]});
      this.registerServiceExtension$2$callback$name(new N.BindingBase_registerBoolServiceExtension_closure(this, H.functionTypeCheck(setter, {func: 1, ret: [P.Future, -1], args: [P.bool]}), $name, getter), $name);
    },
    registerNumericServiceExtension$3$getter$name$setter: function(getter, $name, setter) {
      H.functionTypeCheck(getter, {func: 1, ret: [P.Future, P.double]});
      this.registerServiceExtension$2$callback$name(new N.BindingBase_registerNumericServiceExtension_closure(this, $name, H.functionTypeCheck(setter, {func: 1, ret: [P.Future, -1], args: [P.double]}), getter), $name);
    },
    _postExtensionStateChangedEvent$2: function($name, value) {
      var t1 = P.String;
      P.postEvent("Flutter.ServiceExtensionStateChanged", H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_literal(["extension", "ext.flutter." + $name, "value", value], t1, null), "$isMap", [t1, null], "$asMap"));
    },
    registerStringServiceExtension$3$getter$name$setter: function(getter, $name, setter) {
      H.functionTypeCheck(getter, {func: 1, ret: [P.Future, P.String]});
      this.registerServiceExtension$2$callback$name(new N.BindingBase_registerStringServiceExtension_closure(this, H.functionTypeCheck(setter, {func: 1, ret: [P.Future, -1], args: [P.String]}), $name, getter), $name);
    },
    registerServiceExtension$2$callback$name: function(callback, $name) {
      var methodName, t1;
      H.functionTypeCheck(callback, {func: 1, ret: [P.Future, [P.Map, P.String,,]], args: [[P.Map, P.String, P.String]]});
      methodName = "ext.flutter." + $name;
      if (!C.JSString_methods.startsWith$1(methodName, "ext."))
        H.throwExpression(P.ArgumentError$value(methodName, "method", "Must begin with ext."));
      t1 = $.$get$_extensions();
      if (t1.$index(0, methodName) != null)
        H.throwExpression(P.ArgumentError$("Extension already registered: " + methodName));
      t1.$indexSet(0, methodName, new N.BindingBase_registerServiceExtension_closure(methodName, callback));
    },
    registerServiceExtension$0: function() {
      return this.registerServiceExtension$2$callback$name(null, null);
    },
    toString$0: function(_) {
      return "<" + new H.TypeImpl(H.getRti(this)).toString$0(0) + ">";
    }
  };
  N.BindingBase_initInstances_closure.prototype = {
    call$0: function() {
      return $.BindingBase__debugInitialized = true;
    },
    $signature: 0
  };
  N.BindingBase_initServiceExtensions_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1.registerSignalServiceExtension$2$callback$name(t1.get$reassembleApplication(), "reassemble");
      return true;
    },
    $signature: 0
  };
  N.BindingBase_initServiceExtensions_closure0.prototype = {
    call$1: function(parameters) {
      var t1 = P.String;
      return this.$call$body$BindingBase_initServiceExtensions_closure(H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap"));
    },
    $call$body$BindingBase_initServiceExtensions_closure: function(parameters) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String,,]),
        $async$returnValue;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = P.LinkedHashMap_LinkedHashMap$_literal(["value", P.saveCompilationTrace()], P.String, null);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 8
  };
  N.BindingBase_initServiceExtensions_closure1.prototype = {
    call$0: function() {
      var _s16_ = "platformOverride",
        t1 = this.$this;
      t1.registerServiceExtension$2$callback$name(new N.BindingBase_initServiceExtensions__closure(t1, _s16_), _s16_);
      return true;
    },
    $signature: 0
  };
  N.BindingBase_initServiceExtensions__closure.prototype = {
    call$1: function(parameters) {
      var t1 = P.String;
      return this.$call$body$BindingBase_initServiceExtensions__closure(H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap"));
    },
    $call$body$BindingBase_initServiceExtensions__closure: function(parameters) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String,,]),
        $async$returnValue, $async$self = this, t1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = parameters.containsKey$1("value") ? 3 : 4;
              break;
            case 3:
              // then
              switch (parameters.$index(0, "value")) {
                case "android":
                  $.debugDefaultTargetPlatformOverride = C.TargetPlatform_0;
                  break;
                case "iOS":
                  $.debugDefaultTargetPlatformOverride = C.TargetPlatform_2;
                  break;
                case "fuchsia":
                  $.debugDefaultTargetPlatformOverride = C.TargetPlatform_1;
                  break;
                case "default":
                default:
                  $.debugDefaultTargetPlatformOverride = null;
              }
              t1 = $async$self.$this;
              t1._postExtensionStateChangedEvent$2($async$self.platformOverrideExtensionName, C.JSString_methods.substring$1(J.toString$0$(T.defaultTargetPlatform()), (C.Type_TargetPlatform_ud1.toString$0(0) + ".").length));
              $async$goto = 5;
              return P._asyncAwait(t1.lockEvents$1(t1.get$performReassemble()), $async$call$1);
            case 5:
              // returning from await.
            case 4:
              // join
              $async$returnValue = P.LinkedHashMap_LinkedHashMap$_literal(["value", C.JSString_methods.substring$1(J.toString$0$(T.defaultTargetPlatform()), (C.Type_TargetPlatform_ud1.toString$0(0) + ".").length)], P.String, null);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 8
  };
  N.BindingBase_initServiceExtensions_closure2.prototype = {
    call$0: function() {
      return $.BindingBase__debugServiceExtensionsRegistered = true;
    },
    $signature: 0
  };
  N.BindingBase_lockEvents_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (--t1._lockCount <= 0) {
        P.Timeline_finishSync();
        t1.super$_WidgetsFlutterBinding_BindingBase_GestureBinding$unlocked();
        if (t1.SchedulerBinding__taskQueue._length !== 0)
          t1._ensureEventLoopCallback$0();
      }
    },
    $signature: 2
  };
  N.BindingBase_registerSignalServiceExtension_closure.prototype = {
    call$1: function(parameters) {
      var t1 = P.String;
      return this.$call$body$BindingBase_registerSignalServiceExtension_closure(H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap"));
    },
    $call$body$BindingBase_registerSignalServiceExtension_closure: function(parameters) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String,,]),
        $async$returnValue, $async$self = this;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self.callback.call$0(), $async$call$1);
            case 3:
              // returning from await.
              $async$returnValue = P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 8
  };
  N.BindingBase_registerBoolServiceExtension_closure.prototype = {
    call$1: function(parameters) {
      var t1 = P.String;
      return this.$call$body$BindingBase_registerBoolServiceExtension_closure(H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap"));
    },
    $call$body$BindingBase_registerBoolServiceExtension_closure: function(parameters) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String,,]),
        $async$returnValue, $async$self = this, t1, $async$temp1, $async$temp2;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = parameters.containsKey$1("enabled") ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 5;
              return P._asyncAwait($async$self.setter.call$1(J.$eq$(parameters.$index(0, "enabled"), "true")), $async$call$1);
            case 5:
              // returning from await.
              $async$temp1 = H;
              $async$goto = 6;
              return P._asyncAwait($async$self.getter.call$0(), $async$call$1);
            case 6:
              // returning from await.
              t1 = $async$temp1.boolConversionCheck($async$result) ? "true" : "false";
              $async$self.$this._postExtensionStateChangedEvent$2($async$self.name, t1);
            case 4:
              // join
              $async$temp1 = P;
              $async$temp2 = H;
              $async$goto = 7;
              return P._asyncAwait($async$self.getter.call$0(), $async$call$1);
            case 7:
              // returning from await.
              $async$returnValue = $async$temp1.LinkedHashMap_LinkedHashMap$_literal(["enabled", $async$temp2.boolConversionCheck($async$result) ? "true" : "false"], P.String, null);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 8
  };
  N.BindingBase_registerNumericServiceExtension_closure.prototype = {
    call$1: function(parameters) {
      var t1 = P.String;
      return this.$call$body$BindingBase_registerNumericServiceExtension_closure(H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap"));
    },
    $call$body$BindingBase_registerNumericServiceExtension_closure: function(parameters) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String,,]),
        $async$returnValue, $async$self = this, t1, $async$temp1, $async$temp2, $async$temp3;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.name;
              $async$goto = parameters.containsKey$1(t1) ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 5;
              return P._asyncAwait($async$self.setter.call$1(P.double_parse(parameters.$index(0, t1))), $async$call$1);
            case 5:
              // returning from await.
              $async$temp1 = $async$self.$this;
              $async$temp2 = t1;
              $async$temp3 = J;
              $async$goto = 6;
              return P._asyncAwait($async$self.getter.call$0(), $async$call$1);
            case 6:
              // returning from await.
              $async$temp1._postExtensionStateChangedEvent$2($async$temp2, $async$temp3.toString$0$($async$result));
            case 4:
              // join
              $async$temp1 = P;
              $async$temp2 = t1;
              $async$temp3 = J;
              $async$goto = 7;
              return P._asyncAwait($async$self.getter.call$0(), $async$call$1);
            case 7:
              // returning from await.
              $async$returnValue = $async$temp1.LinkedHashMap_LinkedHashMap$_literal([$async$temp2, $async$temp3.toString$0$($async$result)], P.String, null);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 8
  };
  N.BindingBase_registerStringServiceExtension_closure.prototype = {
    call$1: function(parameters) {
      var t1 = P.String;
      return this.$call$body$BindingBase_registerStringServiceExtension_closure(H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap"));
    },
    $call$body$BindingBase_registerStringServiceExtension_closure: function(parameters) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String,,]),
        $async$returnValue, $async$self = this, $async$temp1, $async$temp2;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = parameters.containsKey$1("value") ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 5;
              return P._asyncAwait($async$self.setter.call$1(parameters.$index(0, "value")), $async$call$1);
            case 5:
              // returning from await.
              $async$temp1 = $async$self.$this;
              $async$temp2 = $async$self.name;
              $async$goto = 6;
              return P._asyncAwait($async$self.getter.call$0(), $async$call$1);
            case 6:
              // returning from await.
              $async$temp1._postExtensionStateChangedEvent$2($async$temp2, $async$result);
            case 4:
              // join
              $async$temp1 = P;
              $async$goto = 7;
              return P._asyncAwait($async$self.getter.call$0(), $async$call$1);
            case 7:
              // returning from await.
              $async$returnValue = $async$temp1.LinkedHashMap_LinkedHashMap$_literal(["value", $async$result], P.String, null);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 8
  };
  N.BindingBase_registerServiceExtension_closure.prototype = {
    call$2: function(method, parameters) {
      var t1;
      H.stringTypeCheck(method);
      t1 = P.String;
      H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap");
      return this.$call$body$BindingBase_registerServiceExtension_closure(method, parameters);
    },
    $call$body$BindingBase_registerServiceExtension_closure: function(method, parameters) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.ServiceExtensionResponse),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, caughtException, caughtStack, result, exception, stack, exception0, t1, t2, $async$exception0;
      var $async$call$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              H.assertHelper(method === $async$self.methodName);
              H.assertHelper(new N.BindingBase_registerServiceExtension__closure(method, parameters).call$0());
              $async$goto = 3;
              return P._asyncAwait(E.debugInstrumentAction("Wait for outer event loop", new N.BindingBase_registerServiceExtension__closure0(), -1), $async$call$2);
            case 3:
              // returning from await.
              caughtException = null;
              caughtStack = null;
              result = null;
              $async$handler = 5;
              $async$goto = 8;
              return P._asyncAwait($async$self.callback.call$1(parameters), $async$call$2);
            case 8:
              // returning from await.
              result = $async$result;
              $async$handler = 2;
              // goto after finally
              $async$goto = 7;
              break;
            case 5:
              // catch
              $async$handler = 4;
              $async$exception0 = $async$currentError;
              exception = H.unwrapException($async$exception0);
              stack = H.getTraceFromException($async$exception0);
              caughtException = exception;
              caughtStack = stack;
              // goto after finally
              $async$goto = 7;
              break;
            case 4:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 7:
              // after finally
              if (caughtException == null) {
                J.$indexSet$ax(result, "type", "_extensionType");
                J.$indexSet$ax(result, "method", method);
                t1 = C.C_JsonCodec.encode$1(result);
                $async$returnValue = new P.ServiceExtensionResponse(t1, null, null);
                // goto return
                $async$goto = 1;
                break;
              } else {
                t1 = caughtException;
                t2 = caughtStack;
                U.FlutterError_reportError(U.FlutterErrorDetails$('during a service extension callback for "' + H.S(method) + '"', t1, null, "Flutter framework", false, t2));
                t2 = P.String;
                t2 = C.C_JsonCodec.encode$1(P.LinkedHashMap_LinkedHashMap$_literal(["exception", J.toString$0$(caughtException), "stack", J.toString$0$(caughtStack), "method", method], t2, t2));
                P.ServiceExtensionResponse__validateErrorCode(-32000);
                $async$returnValue = new P.ServiceExtensionResponse(null, -32000, t2);
                // goto return
                $async$goto = 1;
                break;
              }
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$2, $async$completer);
    },
    $signature: 96
  };
  N.BindingBase_registerServiceExtension__closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  N.BindingBase_registerServiceExtension__closure0.prototype = {
    call$0: function() {
      return P.Future_Future$delayed(C.Duration_0, -1);
    },
    $signature: 6
  };
  B.Listenable.prototype = {};
  B.ChangeNotifier.prototype = {
    _debugAssertNotDisposed$0: function() {
      H.assertHelper(new B.ChangeNotifier__debugAssertNotDisposed_closure(this).call$0());
      return true;
    },
    dispose$0: function() {
      this._debugAssertNotDisposed$0();
      this.set$_change_notifier$_listeners(null);
    },
    notifyListeners$0: function() {
      var listener, exception, stack, t1, localListeners, _i, exception0, t2, _this = this;
      _this._debugAssertNotDisposed$0();
      t1 = _this.ChangeNotifier__listeners;
      if (t1 != null) {
        localListeners = P.List_List$from(t1, true, {func: 1, ret: -1});
        for (t1 = localListeners.length, _i = 0; _i < localListeners.length; localListeners.length === t1 || (0, H.throwConcurrentModificationError)(localListeners), ++_i) {
          listener = localListeners[_i];
          try {
            if (_this.ChangeNotifier__listeners.contains$1(0, listener))
              listener.call$0();
          } catch (exception0) {
            exception = H.unwrapException(exception0);
            stack = H.getTraceFromException(exception0);
            t2 = "while dispatching notifications for " + new H.TypeImpl(H.getRti(_this)).toString$0(0);
            U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(new U.FlutterErrorDetails(exception, stack, "foundation library", t2, new B.ChangeNotifier_notifyListeners_closure(_this), false));
          }
        }
      }
    },
    set$_change_notifier$_listeners: function(_listeners) {
      this.ChangeNotifier__listeners = H.assertSubtype(_listeners, "$isObserverList", [{func: 1, ret: -1}], "$asObserverList");
    },
    $isListenable: 1
  };
  B.ChangeNotifier__debugAssertNotDisposed_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (t1.ChangeNotifier__listeners == null)
        throw H.wrapException(U.FlutterError$("A " + H.getRuntimeType(t1).toString$0(0) + " was used after being disposed.\nOnce you have called dispose() on a " + H.getRuntimeType(t1).toString$0(0) + ", it can no longer be used."));
      return true;
    },
    $signature: 0
  };
  B.ChangeNotifier_notifyListeners_closure.prototype = {
    call$1: function(information) {
      var t1 = this.$this;
      information._contents += "The " + new H.TypeImpl(H.getRti(t1)).toString$0(0) + " sending notification was:\n";
      information._contents += "  " + t1.toString$0(0);
    },
    $signature: 3
  };
  B._MergingListenable.prototype = {
    addListener$1: function(listener) {
      var t1, t2, _i, child;
      H.functionTypeCheck(listener, {func: 1, ret: -1});
      for (t1 = this._change_notifier$_children, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        child = t1[_i];
        if (child != null)
          child.addListener$1(listener);
      }
    },
    removeListener$1: function(listener) {
      var t1, t2, _i, child;
      H.functionTypeCheck(listener, {func: 1, ret: -1});
      for (t1 = this._change_notifier$_children, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        child = t1[_i];
        if (child != null)
          child.removeListener$1(listener);
      }
    },
    toString$0: function(_) {
      return "Listenable.merge([" + C.JSArray_methods.join$1(this._change_notifier$_children, ", ") + "])";
    }
  };
  E.debugInstrumentAction_closure.prototype = {
    call$0: function() {
      this._box_0.instrument = false;
      return true;
    },
    $signature: 0
  };
  E.debugInstrumentAction_closure0.prototype = {
    call$0: function() {
      var t1 = this.stopwatch;
      t1.stop$0();
      D.print__debugPrintThrottled$closure().call$1('Action "' + this.description + '" took ' + P.Duration$(t1.get$elapsedMicroseconds(), 0, 0).toString$0(0));
    },
    $signature: 2
  };
  Y.DiagnosticLevel.prototype = {
    toString$0: function(_) {
      return this._diagnostics$_name;
    }
  };
  Y.DiagnosticsTreeStyle.prototype = {
    toString$0: function(_) {
      return this._diagnostics$_name;
    }
  };
  Y.TextTreeConfiguration.prototype = {};
  Y._PrefixedStringBuilder.prototype = {
    write$1: function(s) {
      var t2, t3, lineTerminated, parts, i, _this = this,
        t1 = s.length;
      if (t1 === 0)
        return;
      if (s === "\n") {
        t1 = _this._buffer;
        t2 = t1._contents;
        if (t2.length === 0)
          t2 = t1._contents += C.JSString_methods.trimRight$0(_this.prefixLineOne);
        else if (_this._atLineStart) {
          t2 = t1._contents += C.JSString_methods.trimRight$0(_this.prefixOtherLines);
          _this._hasMultipleLines = true;
        }
        t1._contents = t2 + "\n";
        _this._atLineStart = true;
        return;
      }
      t2 = _this._buffer;
      t3 = t2._contents;
      if (t3.length === 0)
        t2._contents = t3 + _this.prefixLineOne;
      else if (_this._atLineStart) {
        t2._contents = t3 + _this.prefixOtherLines;
        _this._hasMultipleLines = true;
      }
      if (J.getInterceptor$s(s).endsWith$1(s, "\n")) {
        s = C.JSString_methods.substring$2(s, 0, t1 - 1);
        lineTerminated = true;
      } else
        lineTerminated = false;
      parts = s.split("\n");
      t1 = parts.length;
      if (0 >= t1)
        return H.ioore(parts, 0);
      t3 = t2._contents += H.S(parts[0]);
      for (i = 1; i < t1; ++i) {
        t3 += "\n";
        t2._contents = t3;
        t2._contents = t3 + _this.prefixOtherLines;
        t3 = t2._contents += H.S(parts[i]);
      }
      if (lineTerminated)
        t2._contents = t3 + "\n";
      _this._atLineStart = lineTerminated;
    },
    writeRaw$1: function(text) {
      if (text.length === 0)
        return;
      this._buffer._contents += text;
      this._atLineStart = C.JSString_methods.endsWith$1(text, "\n");
    },
    writeRawLine$1: function(line) {
      var t1, t2;
      if (line.length === 0)
        return;
      t1 = this._buffer;
      t2 = t1._contents += line;
      if (!C.JSString_methods.endsWith$1(line, "\n"))
        t1._contents = t2 + "\n";
      this._atLineStart = true;
    },
    toString$0: function(_) {
      var t1 = this._buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  Y._NoDefaultValue.prototype = {};
  Y.DiagnosticsNode.prototype = {
    get$level: function() {
      return C.DiagnosticLevel_3;
    },
    get$emptyBodyDescription: function() {
      return;
    },
    toJsonMap$0: function() {
      var _this = this;
      return P.LinkedHashMap_LinkedHashMap$_literal(["name", _this.name, "showSeparator", _this.showSeparator, "description", _this.toDescription$0(), "level", Y.describeEnum(_this.get$level()), "showName", _this.get$showName(), "emptyBodyDescription", _this.get$emptyBodyDescription(), "style", Y.describeEnum(_this.get$style()), "valueToString", J.toString$0$(_this.get$value()), "type", new H.TypeImpl(H.getRti(_this)).get$_typeName(), "hasChildren", _this.getChildren$0().length !== 0], P.String, P.Object);
    },
    toString$2$minLevel$parentConfiguration: function(_, minLevel, parentConfiguration) {
      var description, t1, _this = this;
      H.assertHelper(_this.get$style() != null);
      if (_this.get$style() === C.DiagnosticsTreeStyle_5)
        return _this.toStringDeep$2$minLevel$parentConfiguration(minLevel, parentConfiguration);
      description = _this.toDescription$1$parentConfiguration(parentConfiguration);
      t1 = _this.name;
      if (t1 == null || t1.length === 0 || !_this.get$showName())
        return description;
      if (C.JSString_methods.contains$1(description, "\n")) {
        t1 = H.S(t1);
        t1 = t1 + (_this.showSeparator ? ":" : "") + "\n" + description;
      } else {
        t1 = H.S(t1);
        t1 = t1 + (_this.showSeparator ? ":" : "") + " " + description;
      }
      return t1;
    },
    toString$0: function($receiver) {
      return this.toString$2$minLevel$parentConfiguration($receiver, C.DiagnosticLevel_3, null);
    },
    toString$1$minLevel: function($receiver, minLevel) {
      return this.toString$2$minLevel$parentConfiguration($receiver, minLevel, null);
    },
    get$textTreeConfiguration: function() {
      H.assertHelper(this.get$style() != null);
      switch (this.get$style()) {
        case C.DiagnosticsTreeStyle_2:
          return $.$get$denseTextConfiguration();
        case C.DiagnosticsTreeStyle_0:
          return $.$get$sparseTextConfiguration();
        case C.DiagnosticsTreeStyle_1:
          return $.$get$dashedTextConfiguration();
        case C.DiagnosticsTreeStyle_4:
          return $.$get$whitespaceTextConfiguration();
        case C.DiagnosticsTreeStyle_3:
          return $.$get$transitionTextConfiguration();
        case C.DiagnosticsTreeStyle_5:
          return $.$get$singleLineTextConfiguration();
      }
      return;
    },
    toStringDeep$4$minLevel$parentConfiguration$prefixLineOne$prefixOtherLines: function(minLevel, parentConfiguration, prefixLineOne, prefixOtherLines) {
      var children, config, builder, description, t1, t2, properties, t3, i, property, propertyStyle, message, lines, j, line, prefixChildren, prefix, child, childConfig, lastChildPrefixLineOne, nextChildStyle, childPrefixLineOne, _this = this;
      if (prefixOtherLines == null)
        prefixOtherLines = prefixLineOne;
      children = _this.getChildren$0();
      config = _this.get$textTreeConfiguration();
      if (prefixOtherLines.length === 0)
        prefixOtherLines += config.prefixOtherLinesRootNode;
      builder = new Y._PrefixedStringBuilder(prefixLineOne, prefixOtherLines, new P.StringBuffer(""));
      description = _this.toDescription$1$parentConfiguration(parentConfiguration);
      if (description.length === 0) {
        if (_this.get$showName() && _this.name != null)
          builder.write$1(_this.name);
      } else {
        t1 = _this.name;
        if (t1 != null && t1.length !== 0 && _this.get$showName()) {
          builder.write$1(t1);
          if (_this.showSeparator)
            builder.write$1(config.afterName);
          builder.write$1(config.isNameOnOwnLine || C.JSString_methods.contains$1(description, "\n") ? "\n" : " ");
          if (C.JSString_methods.contains$1(description, "\n") && _this.get$style() === C.DiagnosticsTreeStyle_5)
            builder.prefixOtherLines += "  ";
        }
        t1 = builder.prefixOtherLines;
        builder.prefixOtherLines = t1 + (children.length === 0 ? config.propertyPrefixNoChildren : config.propertyPrefixIfChildren);
        builder.write$1(description);
      }
      t1 = _this.getProperties$0();
      t2 = H.getTypeArgumentByIndex(t1, 0);
      properties = P.List_List$from(new H.WhereIterable(t1, H.functionTypeCheck(new Y.DiagnosticsNode_toStringDeep_closure(minLevel), {func: 1, ret: P.bool, args: [t2]}), [t2]), true, t2);
      if (properties.length !== 0 || children.length !== 0 || _this.get$emptyBodyDescription() != null)
        builder.write$1(config.afterDescriptionIfBody);
      t1 = config.lineBreakProperties;
      if (t1)
        builder.write$1(config.lineBreak);
      if (properties.length !== 0)
        builder.write$1(config.beforeProperties);
      t2 = builder.prefixOtherLines;
      t3 = config.bodyIndent;
      builder.prefixOtherLines = t2 + t3;
      if (_this.get$emptyBodyDescription() != null && properties.length === 0 && children.length === 0 && prefixLineOne.length !== 0) {
        builder.write$1(_this.get$emptyBodyDescription());
        if (t1)
          builder.write$1(config.lineBreak);
      }
      for (i = 0; t2 = properties.length, i < t2; ++i) {
        property = properties[i];
        if (i > 0)
          builder.write$1(config.propertySeparator);
        if (property.get$style() !== C.DiagnosticsTreeStyle_5) {
          propertyStyle = property.get$textTreeConfiguration();
          t2 = builder.prefixOtherLines;
          builder.writeRaw$1(property.toStringDeep$4$minLevel$parentConfiguration$prefixLineOne$prefixOtherLines(minLevel, config, t2 + propertyStyle.prefixLineOne, t2 + propertyStyle.linkCharacter + propertyStyle.prefixOtherLines));
          continue;
        }
        H.assertHelper(property.get$style() === C.DiagnosticsTreeStyle_5);
        message = property.toString$2$minLevel$parentConfiguration(0, minLevel, config);
        if (!t1 || message.length < 65)
          builder.write$1(message);
        else {
          lines = message.split("\n");
          for (j = 0; j < lines.length; ++j) {
            line = lines[j];
            if (j > 0)
              builder.write$1(config.lineBreak);
            builder.write$1(D.debugWordWrap(line, 65, "  ").join$1(0, "\n"));
          }
        }
        if (t1)
          builder.write$1(config.lineBreak);
      }
      if (t2 !== 0)
        builder.write$1(config.afterProperties);
      if (!t1)
        builder.write$1(config.lineBreak);
      prefixChildren = prefixOtherLines + t3;
      if (children.length === 0 && config.addBlankLineIfNoChildren && builder._hasMultipleLines) {
        prefix = C.JSString_methods.trimRight$0(prefixChildren);
        if (prefix.length !== 0)
          builder.writeRaw$1(prefix + config.lineBreak);
      }
      if (children.length !== 0 && config.showChildren) {
        if (config.isBlankLineBetweenPropertiesAndChildren && properties.length !== 0 && C.JSArray_methods.get$first(children).get$textTreeConfiguration().isBlankLineBetweenPropertiesAndChildren)
          builder.write$1(config.lineBreak);
        for (i = 0; i < children.length; ++i) {
          child = children[i];
          t1 = child != null;
          H.assertHelper(t1);
          childConfig = t1 && child.get$style() !== C.DiagnosticsTreeStyle_5 ? child.get$textTreeConfiguration() : config;
          t1 = children.length;
          if (i === t1 - 1) {
            lastChildPrefixLineOne = prefixChildren + childConfig.prefixLastChildLineOne;
            t1 = childConfig.childLinkSpace;
            builder.writeRawLine$1(child.toStringDeep$4$minLevel$parentConfiguration$prefixLineOne$prefixOtherLines(minLevel, config, lastChildPrefixLineOne, prefixChildren + t1 + childConfig.prefixOtherLines));
            t2 = childConfig.footer;
            if (t2.length !== 0)
              builder.writeRaw$1(prefixChildren + t1 + t2);
          } else {
            t2 = i + 1;
            if (t2 >= t1)
              return H.ioore(children, t2);
            t2 = H.interceptedTypeCheck(children[t2], "$isDiagnosticsNode");
            nextChildStyle = t2 != null && t2.get$style() !== C.DiagnosticsTreeStyle_5 ? t2.get$textTreeConfiguration() : config;
            childPrefixLineOne = prefixChildren + childConfig.prefixLineOne;
            t1 = nextChildStyle.linkCharacter;
            builder.writeRawLine$1(child.toStringDeep$4$minLevel$parentConfiguration$prefixLineOne$prefixOtherLines(minLevel, config, childPrefixLineOne, prefixChildren + t1 + childConfig.prefixOtherLines));
            t2 = childConfig.footer;
            if (t2.length !== 0)
              builder.writeRaw$1(prefixChildren + t1 + t2);
          }
        }
      }
      t1 = builder._buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    toStringDeep$2$minLevel$parentConfiguration: function(minLevel, parentConfiguration) {
      return this.toStringDeep$4$minLevel$parentConfiguration$prefixLineOne$prefixOtherLines(minLevel, parentConfiguration, "", null);
    },
    toStringDeep$3$minLevel$prefixLineOne$prefixOtherLines: function(minLevel, prefixLineOne, prefixOtherLines) {
      return this.toStringDeep$4$minLevel$parentConfiguration$prefixLineOne$prefixOtherLines(minLevel, null, prefixLineOne, prefixOtherLines);
    },
    get$showName: function() {
      return this.showName;
    },
    get$style: function() {
      return this.style;
    }
  };
  Y.DiagnosticsNode_toStringDeep_closure.prototype = {
    call$1: function(n) {
      return H.interceptedTypeCheck(n, "$isDiagnosticsNode").get$level().index >= this.minLevel.index;
    },
    $signature: 18
  };
  Y.MessageProperty.prototype = {
    $asDiagnosticsProperty: function() {
      return [-1];
    }
  };
  Y.StringProperty.prototype = {
    toJsonMap$0: function() {
      var json = this.super$DiagnosticsProperty$toJsonMap();
      json.$indexSet(0, "quoted", this.quoted);
      return json;
    },
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var t1, _this = this,
        text = _this._description;
      if (text == null) {
        _this._maybeCacheValue$0();
        text = _this._value;
      }
      if (parentConfiguration != null && !parentConfiguration.lineBreakProperties && text != null)
        text = H.stringReplaceAllUnchecked(text, "\n", "\\n");
      if (_this.quoted && text != null) {
        t1 = _this.ifEmpty;
        if (t1 != null && text.length === 0)
          return t1;
        return '"' + text + '"';
      }
      return J.toString$0$(text);
    },
    valueToString$0: function() {
      return this.valueToString$1$parentConfiguration(null);
    },
    $asDiagnosticsProperty: function() {
      return [P.String];
    }
  };
  Y._NumProperty.prototype = {
    toJsonMap$0: function() {
      var json = this.super$DiagnosticsProperty$toJsonMap(),
        t1 = this.unit;
      if (t1 != null)
        json.$indexSet(0, "unit", t1);
      json.$indexSet(0, "numberToString", this.numberToString$0());
      return json;
    },
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var t1, _this = this;
      _this._maybeCacheValue$0();
      if (_this._value == null) {
        _this._maybeCacheValue$0();
        return J.toString$0$(_this._value);
      }
      t1 = _this.unit;
      return t1 != null ? H.S(_this.numberToString$0()) + t1 : _this.numberToString$0();
    },
    valueToString$0: function() {
      return this.valueToString$1$parentConfiguration(null);
    }
  };
  Y.DoubleProperty.prototype = {
    numberToString$0: function() {
      this._maybeCacheValue$0();
      var t1 = this._value;
      return t1 == null ? null : J.toStringAsFixed$1$n(t1, 1);
    },
    $as_NumProperty: function() {
      return [P.double];
    },
    $asDiagnosticsProperty: function() {
      return [P.double];
    }
  };
  Y.IntProperty.prototype = {
    numberToString$0: function() {
      this._maybeCacheValue$0();
      return J.toString$0$(this._value);
    },
    $as_NumProperty: function() {
      return [P.int];
    },
    $asDiagnosticsProperty: function() {
      return [P.int];
    }
  };
  Y.PercentProperty.prototype = {
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var t1, _this = this;
      _this._maybeCacheValue$0();
      if (_this._value == null) {
        _this._maybeCacheValue$0();
        return J.toString$0$(_this._value);
      }
      t1 = _this.unit;
      return t1 != null ? _this.numberToString$0() + " " + t1 : _this.numberToString$0();
    },
    valueToString$0: function() {
      return this.valueToString$1$parentConfiguration(null);
    },
    numberToString$0: function() {
      var _this = this;
      _this._maybeCacheValue$0();
      if (_this._value == null) {
        _this._maybeCacheValue$0();
        return J.toString$0$(_this._value);
      }
      _this._maybeCacheValue$0();
      return C.JSNumber_methods.toStringAsFixed$1(J.clamp$2$n(_this._value, 0, 1) * 100, 1) + "%";
    }
  };
  Y.FlagProperty.prototype = {
    toJsonMap$0: function() {
      var t1,
        json = this.super$DiagnosticsProperty$toJsonMap();
      json.$indexSet(0, "ifTrue", this.ifTrue);
      t1 = this.ifFalse;
      if (t1 != null)
        json.$indexSet(0, "ifFalse", t1);
      return json;
    },
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var t1, _this = this;
      _this._maybeCacheValue$0();
      if (J.$eq$(_this._value, true))
        return _this.ifTrue;
      else {
        _this._maybeCacheValue$0();
        if (J.$eq$(_this._value, false)) {
          t1 = _this.ifFalse;
          if (t1 != null)
            return t1;
        }
      }
      return _this.super$DiagnosticsProperty$valueToString(parentConfiguration);
    },
    valueToString$0: function() {
      return this.valueToString$1$parentConfiguration(null);
    },
    get$showName: function() {
      var t1, _this = this;
      _this._maybeCacheValue$0();
      if (_this._value != null) {
        _this._maybeCacheValue$0();
        J.$eq$(_this._value, true);
        _this._maybeCacheValue$0();
        t1 = J.$eq$(_this._value, false) && _this.ifFalse == null;
      } else
        t1 = true;
      if (t1)
        return true;
      return _this.showName;
    },
    get$level: function() {
      var _this = this;
      _this._maybeCacheValue$0();
      J.$eq$(_this._value, true);
      _this._maybeCacheValue$0();
      if (J.$eq$(_this._value, false))
        if (_this.ifFalse == null)
          return C.DiagnosticLevel_0;
      return Y.DiagnosticsProperty.prototype.get$level.call(_this);
    },
    $asDiagnosticsProperty: function() {
      return [P.bool];
    }
  };
  Y.IterableProperty.prototype = {
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var t1, _this = this;
      _this._maybeCacheValue$0();
      if (_this._value == null) {
        _this._maybeCacheValue$0();
        return J.toString$0$(_this._value);
      }
      _this._maybeCacheValue$0();
      if (J.get$isEmpty$asx(_this._value)) {
        t1 = _this.ifEmpty;
        return t1 == null ? "[]" : t1;
      }
      if (parentConfiguration != null && !parentConfiguration.lineBreakProperties) {
        _this._maybeCacheValue$0();
        return "[" + J.join$1$ax(_this._value, ", ") + "]";
      }
      _this._maybeCacheValue$0();
      t1 = _this._value;
      return J.join$1$ax(t1, _this.style === C.DiagnosticsTreeStyle_5 ? ", " : "\n");
    },
    valueToString$0: function() {
      return this.valueToString$1$parentConfiguration(null);
    },
    get$level: function() {
      var t1, _this = this;
      if (_this.ifEmpty == null) {
        _this._maybeCacheValue$0();
        if (_this._value != null) {
          _this._maybeCacheValue$0();
          t1 = J.get$isEmpty$asx(_this._value) && Y.DiagnosticsProperty.prototype.get$level.call(_this) !== C.DiagnosticLevel_0;
        } else
          t1 = false;
      } else
        t1 = false;
      if (t1)
        return C.DiagnosticLevel_1;
      return Y.DiagnosticsProperty.prototype.get$level.call(_this);
    },
    toJsonMap$0: function() {
      var _this = this,
        json = _this.super$DiagnosticsProperty$toJsonMap();
      _this._maybeCacheValue$0();
      if (_this._value != null) {
        _this._maybeCacheValue$0();
        json.$indexSet(0, "values", J.map$1$1$ax(_this._value, new Y.IterableProperty_toJsonMap_closure(_this), P.String).toList$0(0));
      }
      return json;
    },
    $asDiagnosticsProperty: function($T) {
      return [[P.Iterable, $T]];
    }
  };
  Y.IterableProperty_toJsonMap_closure.prototype = {
    call$1: function(value) {
      return J.toString$0$(H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this.$this, 0)));
    },
    $signature: function() {
      return {func: 1, ret: P.String, args: [H.getTypeArgumentByIndex(this.$this, 0)]};
    }
  };
  Y.EnumProperty.prototype = {
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var _this = this;
      _this._maybeCacheValue$0();
      if (_this._value == null) {
        _this._maybeCacheValue$0();
        return J.toString$0$(_this._value);
      }
      _this._maybeCacheValue$0();
      return Y.describeEnum(_this._value);
    },
    valueToString$0: function() {
      return this.valueToString$1$parentConfiguration(null);
    }
  };
  Y.ObjectFlagProperty.prototype = {
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var t1, _this = this;
      _this._maybeCacheValue$0();
      if (_this._value != null) {
        t1 = _this.ifPresent;
        if (t1 != null)
          return t1;
      } else {
        t1 = _this.ifNull;
        if (t1 != null)
          return t1;
      }
      return _this.super$DiagnosticsProperty$valueToString(parentConfiguration);
    },
    valueToString$0: function() {
      return this.valueToString$1$parentConfiguration(null);
    },
    get$showName: function() {
      var t1, _this = this;
      _this._maybeCacheValue$0();
      if (!(_this._value != null && _this.ifPresent == null)) {
        _this._maybeCacheValue$0();
        t1 = _this._value == null && _this.ifNull == null;
      } else
        t1 = true;
      if (t1)
        return true;
      return _this.showName;
    },
    get$level: function() {
      var _this = this;
      _this._maybeCacheValue$0();
      if (_this._value != null) {
        if (_this.ifPresent == null)
          return C.DiagnosticLevel_0;
      } else if (_this.ifNull == null)
        return C.DiagnosticLevel_0;
      return Y.DiagnosticsProperty.prototype.get$level.call(_this);
    },
    toJsonMap$0: function() {
      var json = this.super$DiagnosticsProperty$toJsonMap(),
        t1 = this.ifPresent;
      if (t1 != null)
        json.$indexSet(0, "ifPresent", t1);
      return json;
    }
  };
  Y.DiagnosticsProperty.prototype = {
    toJsonMap$0: function() {
      var _this = this,
        json = _this.super$DiagnosticsNode$toJsonMap(),
        t1 = _this.defaultValue,
        t2 = J.getInterceptor$(t1);
      if (!t2.$eq(t1, C.C__NoDefaultValue))
        json.$indexSet(0, "defaultValue", t2.toString$0(t1));
      t1 = _this.ifEmpty;
      if (t1 != null)
        json.$indexSet(0, "ifEmpty", t1);
      t1 = _this.ifNull;
      if (t1 != null)
        json.$indexSet(0, "ifNull", t1);
      t1 = _this.tooltip;
      if (t1 != null)
        json.$indexSet(0, "tooltip", t1);
      json.$indexSet(0, "missingIfNull", _this.missingIfNull);
      _this._maybeCacheValue$0();
      if (_this._exception != null) {
        _this._maybeCacheValue$0();
        json.$indexSet(0, "exception", J.toString$0$(_this._exception));
      }
      json.$indexSet(0, "propertyType", new H.TypeImpl(H.getRuntimeTypeArgument(_this, "DiagnosticsProperty", 0)).get$_typeName());
      json.$indexSet(0, "valueToString", _this.valueToString$0());
      json.$indexSet(0, "defaultLevel", Y.describeEnum(_this._defaultLevel));
      return json;
    },
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var v, t1;
      this._maybeCacheValue$0();
      v = this._value;
      t1 = J.getInterceptor$(v);
      return !!t1.$isDiagnosticableTree ? v.toStringShort$0() : t1.toString$0(v);
    },
    valueToString$0: function() {
      return this.valueToString$1$parentConfiguration(null);
    },
    toDescription$1$parentConfiguration: function(parentConfiguration) {
      var t2, result, _this = this,
        t1 = _this._description;
      if (t1 != null)
        return _this._addTooltip$1(t1);
      _this._maybeCacheValue$0();
      if (_this._exception != null) {
        _this._maybeCacheValue$0();
        return "EXCEPTION (" + J.get$runtimeType$(_this._exception).toString$0(0) + ")";
      }
      t1 = _this.ifNull;
      if (t1 != null) {
        _this._maybeCacheValue$0();
        t2 = _this._value == null;
      } else
        t2 = false;
      if (t2)
        return _this._addTooltip$1(t1);
      result = _this.valueToString$1$parentConfiguration(parentConfiguration);
      return _this._addTooltip$1(result.length === 0 && _this.ifEmpty != null ? _this.ifEmpty : result);
    },
    toDescription$0: function() {
      return this.toDescription$1$parentConfiguration(null);
    },
    _addTooltip$1: function(text) {
      var t1;
      H.assertHelper(text != null);
      t1 = this.tooltip;
      return t1 == null ? text : H.S(text) + " (" + t1 + ")";
    },
    get$value: function() {
      this._maybeCacheValue$0();
      return this._value;
    },
    _maybeCacheValue$0: function() {
      return;
    },
    get$level: function() {
      var t2, _this = this,
        t1 = _this._defaultLevel;
      if (t1 === C.DiagnosticLevel_0)
        return t1;
      _this._maybeCacheValue$0();
      if (_this._exception != null)
        return C.DiagnosticLevel_5;
      _this._maybeCacheValue$0();
      if (_this._value == null && _this.missingIfNull)
        return C.DiagnosticLevel_4;
      t2 = _this.defaultValue;
      if (!J.$eq$(t2, C.C__NoDefaultValue)) {
        _this._maybeCacheValue$0();
        t2 = J.$eq$(_this._value, t2);
      } else
        t2 = false;
      if (t2)
        return C.DiagnosticLevel_1;
      return t1;
    },
    getProperties$0: function() {
      return H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]);
    },
    getChildren$0: function() {
      return H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]);
    }
  };
  Y.DiagnosticableNode.prototype = {
    get$_builder: function() {
      var t1, _this = this;
      if (_this._cachedBuilder == null) {
        t1 = new Y.DiagnosticPropertiesBuilder(H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]), C.DiagnosticsTreeStyle_0);
        _this._cachedBuilder = t1;
        _this.value.debugFillProperties$1(t1);
      }
      return _this._cachedBuilder;
    },
    get$style: function() {
      var t1 = this.style;
      return t1 == null ? this.get$_builder().defaultDiagnosticsTreeStyle : t1;
    },
    get$emptyBodyDescription: function() {
      return this.get$_builder().emptyBodyDescription;
    },
    getProperties$0: function() {
      return this.get$_builder().properties;
    },
    getChildren$0: function() {
      return C.List_empty;
    },
    toDescription$1$parentConfiguration: function(parentConfiguration) {
      return this.value.toStringShort$0();
    },
    toDescription$0: function() {
      return this.toDescription$1$parentConfiguration(null);
    },
    get$value: function() {
      return this.value;
    }
  };
  Y._DiagnosticableTreeNode.prototype = {
    getChildren$0: function() {
      var t1 = this.value.debugDescribeChildren$0();
      return t1;
    },
    $asDiagnosticableNode: function() {
      return [Y.DiagnosticableTree];
    }
  };
  Y.DiagnosticPropertiesBuilder.prototype = {
    add$1: function(_, property) {
      C.JSArray_methods.add$1(this.properties, H.interceptedTypeCheck(property, "$isDiagnosticsNode"));
    }
  };
  Y.Diagnosticable.prototype = {
    toStringShort$0: function() {
      return this.get$runtimeType(this).toString$0(0) + "#" + Y.shortHash(this);
    },
    toString$0: function(_) {
      var t1 = {};
      t1.fullString = null;
      H.assertHelper(new Y.Diagnosticable_toString_closure(t1, this, C.DiagnosticLevel_2).call$0());
      t1 = t1.fullString;
      return t1 == null ? this.toStringShort$0() : t1;
    },
    toDiagnosticsNode$2$name$style: function($name, style) {
      return Y.DiagnosticableNode$($name, style, this, Y.Diagnosticable);
    },
    toDiagnosticsNode$1$style: function(style) {
      return this.toDiagnosticsNode$2$name$style(null, style);
    },
    toDiagnosticsNode$0: function() {
      return this.toDiagnosticsNode$2$name$style(null, null);
    },
    debugFillProperties$1: function(properties) {
    }
  };
  Y.Diagnosticable_toString_closure.prototype = {
    call$0: function() {
      this._box_0.fullString = this.$this.toDiagnosticsNode$1$style(C.DiagnosticsTreeStyle_5).toString$1$minLevel(0, this.minLevel);
      return true;
    },
    $signature: 0
  };
  Y.DiagnosticableTree.prototype = {
    toStringDeep$1$prefixLineOne: function(prefixLineOne) {
      return new Y._DiagnosticableTreeNode(this, null, true, true, null).toStringDeep$3$minLevel$prefixLineOne$prefixOtherLines(C.DiagnosticLevel_2, prefixLineOne, null);
    },
    toStringDeep$0: function() {
      return this.toStringDeep$1$prefixLineOne("");
    },
    toStringShort$0: function() {
      return this.get$runtimeType(this).toString$0(0) + "#" + Y.shortHash(this);
    },
    toDiagnosticsNode$2$name$style: function($name, style) {
      return new Y._DiagnosticableTreeNode(this, $name, true, true, style);
    },
    toDiagnosticsNode$1$style: function(style) {
      return this.toDiagnosticsNode$2$name$style(null, style);
    },
    toDiagnosticsNode$0: function() {
      return this.toDiagnosticsNode$2$name$style(null, null);
    },
    debugDescribeChildren$0: function() {
      return C.List_empty;
    }
  };
  Y.DiagnosticableTreeMixin.prototype = {
    toString$0: function(_) {
      return this.toDiagnosticsNode$1$style(C.DiagnosticsTreeStyle_5).toString$1$minLevel(0, C.DiagnosticLevel_2);
    },
    toStringShallow$2$joiner$minLevel: function(joiner, minLevel) {
      var t3,
        t1 = this.toStringShort$0() + joiner,
        t2 = H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]);
      this.debugFillProperties$1(new Y.DiagnosticPropertiesBuilder(t2, C.DiagnosticsTreeStyle_0));
      t3 = H.getTypeArgumentByIndex(t2, 0);
      t3 = t1 + new H.WhereIterable(t2, H.functionTypeCheck(new Y.DiagnosticableTreeMixin_toStringShallow_closure(minLevel), {func: 1, ret: P.bool, args: [t3]}), [t3]).join$1(0, joiner);
      return t3.charCodeAt(0) == 0 ? t3 : t3;
    },
    toStringDeep$3$minLevel$prefixLineOne$prefixOtherLines: function(minLevel, prefixLineOne, prefixOtherLines) {
      return this.toDiagnosticsNode$0().toStringDeep$3$minLevel$prefixLineOne$prefixOtherLines(minLevel, prefixLineOne, prefixOtherLines);
    },
    toStringShort$0: function() {
      return this.get$runtimeType(this).toString$0(0) + "#" + Y.shortHash(this);
    },
    toDiagnosticsNode$2$name$style: function($name, style) {
      return new Y._DiagnosticableTreeNode(this, $name, true, true, style);
    },
    toDiagnosticsNode$1$style: function(style) {
      return this.toDiagnosticsNode$2$name$style(null, style);
    },
    toDiagnosticsNode$0: function() {
      return this.toDiagnosticsNode$2$name$style(null, null);
    },
    debugDescribeChildren$0: function() {
      return C.List_empty;
    },
    debugFillProperties$1: function(properties) {
    }
  };
  Y.DiagnosticableTreeMixin_toStringShallow_closure.prototype = {
    call$1: function(n) {
      return H.interceptedTypeCheck(n, "$isDiagnosticsNode").get$level().index >= this.minLevel.index;
    },
    $signature: 18
  };
  F._IsolateConfiguration.prototype = {};
  F._spawn_closure.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, $async$temp1;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = $async$self._box_0;
              $async$goto = 2;
              return P._asyncAwait($async$self.configuration.apply$0(), $async$call$0);
            case 2:
              // returning from await.
              $async$temp1.result = $async$result;
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 25
  };
  F._spawn_closure0.prototype = {
    call$0: function() {
      this.configuration.get$resultPort().send$1(this._box_0.result);
    },
    $signature: 2
  };
  D.Key.prototype = {};
  D.LocalKey.prototype = {};
  D.ValueKey.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(this))))
        return false;
      return this.value === H.assertSubtype(other, "$isValueKey", this.$ti, "$asValueKey").value;
    },
    get$hashCode: function(_) {
      return P.hashValues(new H.TypeImpl(H.getRti(this)), this.value, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t1 = H.getTypeArgumentByIndex(this, 0),
        t2 = this.value,
        valueString = new H.TypeImpl(t1).$eq(0, C.Type_String_k8F) ? "<'" + t2.toString$0(0) + "'>" : "<" + t2.toString$0(0) + ">";
      if (new H.TypeImpl(H.getRti(this)).$eq(0, new H.TypeImpl([D.ValueKey, t1])))
        return "[" + valueString + "]";
      return "[" + new H.TypeImpl(t1).toString$0(0) + " " + valueString + "]";
    }
  };
  D._TypeLiteral.prototype = {};
  F.LicenseEntry.prototype = {};
  F.LicenseEntryWithLineBreaks.prototype = {};
  B.AbstractNode.prototype = {
    redepthChild$1: function(child) {
      var t1, t2;
      H.interceptedTypeCheck(child, "$isAbstractNode");
      H.assertHelper(J.$eq$(child.get$owner(), this.get$owner()));
      t1 = child._node$_depth;
      t2 = this._node$_depth;
      if (t1 <= t2) {
        child._node$_depth = t2 + 1;
        child.redepthChildren$0();
      }
    },
    redepthChildren$0: function() {
    },
    get$owner: function() {
      return this._node$_owner;
    },
    attach$1: function(owner) {
      H.assertHelper(owner != null);
      H.assertHelper(this._node$_owner == null);
      this._node$_owner = owner;
    },
    detach$0: function() {
      var _this = this;
      H.assertHelper(_this._node$_owner != null);
      _this._node$_owner = null;
      H.assertHelper(_this.get$parent() == null || _this._node$_owner != null === (_this.get$parent()._node$_owner != null));
    },
    get$parent: function() {
      return this._node$_parent;
    },
    adoptChild$1: function(child) {
      var t1, _this = this;
      H.assertHelper(child != null);
      H.assertHelper(child._node$_parent == null);
      H.assertHelper(new B.AbstractNode_adoptChild_closure(_this, child).call$0());
      child._node$_parent = _this;
      t1 = _this._node$_owner;
      if (t1 != null)
        child.attach$1(t1);
      _this.redepthChild$1(child);
    },
    dropChild$1: function(child) {
      H.interceptedTypeCheck(child, "$isAbstractNode");
      H.assertHelper(child != null);
      H.assertHelper(child._node$_parent === this);
      H.assertHelper(child._node$_owner != null === (this._node$_owner != null));
      child._node$_parent = null;
      if (this._node$_owner != null)
        child.detach$0();
    }
  };
  B.AbstractNode_adoptChild_closure.prototype = {
    call$0: function() {
      var node = this.$this;
      for (; node.get$parent() != null;)
        node = node.get$parent();
      H.assertHelper(node !== this.child);
      return true;
    },
    $signature: 0
  };
  R.ObserverList.prototype = {
    remove$1: function(_, item) {
      H.assertSubtypeOfRuntimeType(item, H.getTypeArgumentByIndex(this, 0));
      this._isDirty = true;
      return C.JSArray_methods.remove$1(this._list, item);
    },
    contains$1: function(_, element) {
      var t2, _this = this,
        t1 = _this._list;
      if (t1.length < 3)
        return C.JSArray_methods.contains$1(t1, element);
      if (_this._isDirty) {
        t2 = _this._set;
        if (t2 == null)
          _this.set$_set(P.HashSet_HashSet$from(t1, H.getTypeArgumentByIndex(_this, 0)));
        else {
          t2.clear$0(0);
          _this._set.addAll$1(0, t1);
        }
        _this._isDirty = false;
      }
      return _this._set.contains$1(0, element);
    },
    get$iterator: function(_) {
      var t1 = this._list;
      return new J.ArrayIterator(t1, t1.length, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    get$isEmpty: function(_) {
      return this._list.length === 0;
    },
    set$_set: function(_set) {
      this._set = H.assertSubtype(_set, "$isHashSet", this.$ti, "$asHashSet");
    }
  };
  T.TargetPlatform.prototype = {
    toString$0: function(_) {
      return this._platform$_name;
    }
  };
  T.defaultTargetPlatform_closure.prototype = {
    call$0: function() {
      if (P._Platform_environment()._collection$_map.containsKey$1("FLUTTER_TEST"))
        this._box_0.result = C.TargetPlatform_0;
      return true;
    },
    $signature: 0
  };
  D.debugPrintThrottled_closure.prototype = {
    call$1: function(line) {
      return D.debugWordWrap(H.stringTypeCheck(line), this.wrapWidth, "");
    },
    $signature: 115
  };
  D._WordWrapParseMode.prototype = {
    toString$0: function(_) {
      return this._print$_name;
    }
  };
  G.WriteBuffer.prototype = {
    _alignTo$1: function(alignment) {
      var t1, i, t2,
        mod = C.JSInt_methods.$mod(this._serialization$_buffer._typed_buffers$_length, alignment);
      if (mod !== 0)
        for (t1 = alignment - mod, i = 0; i < t1; ++i) {
          t2 = this._serialization$_buffer;
          t2.toString;
          t2._typed_buffers$_add$1(H.assertSubtypeOfRuntimeType(0, H.getRuntimeTypeArgument(t2, "_TypedDataBuffer", 0)));
        }
    },
    done$0: function() {
      var result,
        t1 = this._serialization$_buffer,
        t2 = t1._typed_buffers$_buffer,
        t3 = t2.buffer;
      t1 = t1._typed_buffers$_length;
      t2 = t2.BYTES_PER_ELEMENT;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3.toString;
      result = H.NativeByteData_NativeByteData$view(t3, 0, t1 * t2);
      this._serialization$_buffer = null;
      return result;
    }
  };
  G.ReadBuffer.prototype = {
    getUint8$0: function(_) {
      return this.data.getUint8(this._serialization$_position++);
    },
    getInt64$0: function(_) {
      C.NativeByteData_methods.getInt64$2(this.data, this._serialization$_position, $.$get$Endian_host());
    },
    getUint8List$1: function($length) {
      var t3, list, _this = this,
        t1 = _this.data,
        t2 = t1.buffer;
      t1 = t1.byteOffset;
      t3 = _this._serialization$_position;
      if (typeof t1 !== "number")
        return t1.$add();
      t2.toString;
      list = H.NativeUint8List_NativeUint8List$view(t2, t1 + t3, $length);
      t3 = _this._serialization$_position;
      if (typeof $length !== "number")
        return H.iae($length);
      _this._serialization$_position = t3 + $length;
      return list;
    },
    getInt64List$1: function($length) {
      var t1, t2, t3;
      this._alignTo$1(8);
      t1 = this.data;
      t2 = t1.buffer;
      t1 = t1.byteOffset;
      t3 = this._serialization$_position;
      if (typeof t1 !== "number")
        return t1.$add();
      (t2 && C.NativeByteBuffer_methods).asInt64List$2(t2, t1 + t3, $length);
    },
    _alignTo$1: function(alignment) {
      var t1 = this._serialization$_position,
        mod = C.JSInt_methods.$mod(t1, alignment);
      if (mod !== 0)
        this._serialization$_position = t1 + (alignment - mod);
    }
  };
  O.SynchronousFuture.prototype = {
    then$1$2$onError: function(f, onError, $E) {
      var result = H.functionTypeCheck(f, {func: 1, args: [H.getTypeArgumentByIndex(this, 0)]}).call$1(this._synchronous_future$_value);
      if (H.checkSubtype(result, "$isFuture", [$E], "$asFuture"))
        return result;
      return new O.SynchronousFuture(H.assertSubtypeOfRuntimeType(result, $E), [$E]);
    },
    then$1$1: function(f, $E) {
      return this.then$1$2$onError(f, null, $E);
    },
    whenComplete$1: function(action) {
      var result, e, stack, t1, exception, _this = this;
      H.functionTypeCheck(action, {func: 1});
      try {
        result = action.call$0();
        if (!!J.getInterceptor$(result).$isFuture) {
          t1 = result.then$1$1(new O.SynchronousFuture_whenComplete_closure(_this), H.getTypeArgumentByIndex(_this, 0));
          return t1;
        }
        return _this;
      } catch (exception) {
        e = H.unwrapException(exception);
        stack = H.getTraceFromException(exception);
        t1 = P.Future_Future$error(e, stack, H.getTypeArgumentByIndex(_this, 0));
        return t1;
      }
    },
    $isFuture: 1
  };
  O.SynchronousFuture_whenComplete_closure.prototype = {
    call$1: function(value) {
      return this.$this._synchronous_future$_value;
    },
    $signature: function() {
      return {func: 1, ret: H.getTypeArgumentByIndex(this.$this, 0), args: [,]};
    }
  };
  D.GestureDisposition.prototype = {
    toString$0: function(_) {
      return this._arena$_name;
    }
  };
  D.GestureArenaMember.prototype = {};
  D.GestureArenaEntry.prototype = {};
  D._GestureArena.prototype = {
    toString$0: function(_) {
      var t2, t3, _this = this,
        t1 = _this.members;
      if (t1.length === 0)
        t1 = "<empty>";
      else {
        t2 = P.String;
        t3 = H.getTypeArgumentByIndex(t1, 0);
        t2 = new H.MappedListIterable(t1, H.functionTypeCheck(new D._GestureArena_toString_closure(_this), {func: 1, ret: t2, args: [t3]}), [t3, t2]).join$1(0, ", ");
        t1 = t2;
      }
      if (_this.isOpen)
        t1 += " [open]";
      if (_this.isHeld)
        t1 += " [held]";
      if (_this.hasPendingSweep)
        t1 += " [hasPendingSweep]";
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  D._GestureArena_toString_closure.prototype = {
    call$1: function(member) {
      H.interceptedTypeCheck(member, "$isGestureArenaMember");
      if (member == this.$this.eagerWinner)
        return H.S(member) + " (eager winner)";
      return H.S(member);
    },
    $signature: 117
  };
  D.GestureArenaManager.prototype = {
    add$2: function(_, pointer, member) {
      var _this = this,
        state = _this._arenas.putIfAbsent$2(pointer, new D.GestureArenaManager_add_closure(_this, pointer));
      H.assertHelper(state.isOpen);
      C.JSArray_methods.add$1(state.members, member);
      _this._debugLogDiagnostic$2(pointer, "Adding: " + member.toString$0(0));
      return new D.GestureArenaEntry(_this, pointer, member);
    },
    close$1: function(pointer) {
      var state = this._arenas.$index(0, pointer);
      if (state == null)
        return;
      state.isOpen = false;
      this._debugLogDiagnostic$3(pointer, "Closing", state);
      this._tryToResolveArena$2(pointer, state);
    },
    sweep$1: function(pointer) {
      var i, _this = this,
        t1 = _this._arenas,
        state = t1.$index(0, pointer);
      if (state == null)
        return;
      H.assertHelper(!state.isOpen);
      if (state.isHeld) {
        state.hasPendingSweep = true;
        _this._debugLogDiagnostic$3(pointer, "Delaying sweep", state);
        return;
      }
      _this._debugLogDiagnostic$3(pointer, "Sweeping", state);
      t1.remove$1(0, pointer);
      t1 = state.members;
      if (t1.length !== 0) {
        _this._debugLogDiagnostic$2(pointer, "Winner: " + C.JSArray_methods.get$first(t1).toString$0(0));
        C.JSArray_methods.get$first(t1).acceptGesture$1(pointer);
        for (i = 1; i < t1.length; ++i)
          t1[i].rejectGesture$1(pointer);
      }
    },
    hold$1: function(pointer) {
      var state = this._arenas.$index(0, pointer);
      if (state == null)
        return;
      state.isHeld = true;
      this._debugLogDiagnostic$3(pointer, "Holding", state);
    },
    release$1: function(pointer) {
      var state = this._arenas.$index(0, pointer);
      if (state == null)
        return;
      state.isHeld = false;
      this._debugLogDiagnostic$3(pointer, "Releasing", state);
      if (state.hasPendingSweep)
        this.sweep$1(pointer);
    },
    _resolve$3: function(pointer, member, disposition) {
      var t1, t2, _this = this,
        state = _this._arenas.$index(0, pointer);
      if (state == null)
        return;
      t1 = disposition === C.GestureDisposition_0;
      _this._debugLogDiagnostic$2(pointer, (t1 ? "Accepting" : "Rejecting") + ": " + member.toString$0(0));
      t2 = state.members;
      H.assertHelper(C.JSArray_methods.contains$1(t2, member));
      if (disposition === C.GestureDisposition_1) {
        C.JSArray_methods.remove$1(t2, member);
        member.rejectGesture$1(pointer);
        if (!state.isOpen)
          _this._tryToResolveArena$2(pointer, state);
      } else {
        H.assertHelper(t1);
        if (state.isOpen) {
          if (state.eagerWinner == null)
            state.eagerWinner = member;
        } else {
          _this._debugLogDiagnostic$2(pointer, "Self-declared winner: " + member.toString$0(0));
          _this._resolveInFavorOf$3(pointer, state, member);
        }
      }
    },
    _tryToResolveArena$2: function(pointer, state) {
      var t2, _this = this,
        t1 = _this._arenas;
      H.assertHelper(J.$eq$(t1.$index(0, pointer), state));
      H.assertHelper(!state.isOpen);
      t2 = state.members.length;
      if (t2 === 1)
        P.scheduleMicrotask(new D.GestureArenaManager__tryToResolveArena_closure(_this, pointer, state));
      else if (t2 === 0) {
        t1.remove$1(0, pointer);
        _this._debugLogDiagnostic$2(pointer, "Arena empty.");
      } else {
        t1 = state.eagerWinner;
        if (t1 != null) {
          _this._debugLogDiagnostic$2(pointer, "Eager winner: " + t1.toString$0(0));
          _this._resolveInFavorOf$3(pointer, state, state.eagerWinner);
        }
      }
    },
    _resolveByDefault$2: function(pointer, state) {
      var members,
        t1 = this._arenas;
      if (!t1.containsKey$1(pointer))
        return;
      H.assertHelper(J.$eq$(t1.$index(0, pointer), state));
      H.assertHelper(!state.isOpen);
      members = state.members;
      H.assertHelper(members.length === 1);
      t1.remove$1(0, pointer);
      this._debugLogDiagnostic$2(pointer, "Default winner: " + C.JSArray_methods.get$first(members).toString$0(0));
      C.JSArray_methods.get$first(members).acceptGesture$1(pointer);
    },
    _resolveInFavorOf$3: function(pointer, state, member) {
      var t2, _i, rejectedMember,
        t1 = this._arenas;
      H.assertHelper(state === t1.$index(0, pointer));
      t2 = state.eagerWinner;
      H.assertHelper(t2 == null || t2 === member);
      H.assertHelper(!state.isOpen);
      t1.remove$1(0, pointer);
      for (t1 = state.members, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        rejectedMember = t1[_i];
        if (rejectedMember !== member)
          rejectedMember.rejectGesture$1(pointer);
      }
      member.acceptGesture$1(pointer);
    },
    _debugLogDiagnostic$3: function(pointer, message, state) {
      H.assertHelper(new D.GestureArenaManager__debugLogDiagnostic_closure(state, pointer, message).call$0());
      return true;
    },
    _debugLogDiagnostic$2: function(pointer, message) {
      return this._debugLogDiagnostic$3(pointer, message, null);
    }
  };
  D.GestureArenaManager_add_closure.prototype = {
    call$0: function() {
      this.$this._debugLogDiagnostic$2(this.pointer, "\u2605 Opening new gesture arena.");
      return new D._GestureArena(H.setRuntimeTypeInfo([], [D.GestureArenaMember]));
    },
    $signature: 128
  };
  D.GestureArenaManager__tryToResolveArena_closure.prototype = {
    call$0: function() {
      return this.$this._resolveByDefault$2(this.pointer, this.state);
    },
    $signature: 1
  };
  D.GestureArenaManager__debugLogDiagnostic_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  N.GestureBinding.prototype = {
    _handlePointerDataPacket$1: function(packet) {
      var t1 = packet.get$data();
      $.$get$window().toString;
      this.GestureBinding__pendingPointerEvents.addAll$1(0, G.PointerEventConverter_expand(t1, 1));
      if (this._lockCount <= 0)
        this._flushPointerEventQueue$0();
    },
    cancelPointer$1: function(pointer) {
      var t1, t2, t3, t4;
      H.intTypeCheck(pointer);
      t1 = this.GestureBinding__pendingPointerEvents;
      if (t1._head === t1._tail && this._lockCount <= 0)
        P.scheduleMicrotask(this.get$_flushPointerEventQueue());
      t2 = H.assertSubtypeOfRuntimeType(F.PointerCancelEvent$(0, 0, 0, 0, C.PointerDeviceKind_0, false, 0, pointer, C.Offset_0_0, 0, 1, 1, 0, 0, 0, 0, 0, 0, C.Duration_0), H.getTypeArgumentByIndex(t1, 0));
      t3 = t1._head;
      t4 = t1._table;
      t3 = (t3 - 1 & t4.length - 1) >>> 0;
      t1._head = t3;
      C.JSArray_methods.$indexSet(t4, t3, t2);
      if (t1._head === t1._tail)
        t1._grow$0();
      ++t1._modificationCount;
    },
    _flushPointerEventQueue$0: function() {
      H.assertHelper(this._lockCount <= 0);
      for (var t1 = this.GestureBinding__pendingPointerEvents; !t1.get$isEmpty(t1);)
        this._handlePointerEvent$1(t1.removeFirst$0());
    },
    _handlePointerEvent$1: function($event) {
      var t2, t3, t4, t5, t6, hitTestResult, _this = this, t1 = {};
      H.assertHelper(_this._lockCount <= 0);
      t1.hitTestResult = null;
      t2 = J.getInterceptor$($event);
      t3 = !!t2.$isPointerDownEvent;
      if (t3 || !!t2.$isPointerSignalEvent) {
        t4 = _this.GestureBinding__hitTests;
        t5 = $event.pointer;
        H.assertHelper(!t4.containsKey$1(t5));
        t6 = H.setRuntimeTypeInfo([], [O.HitTestEntry]);
        hitTestResult = t1.hitTestResult = new O.HitTestResult(t6);
        t6 = $event.position;
        H.assertHelper(_this.RendererBinding__pipelineOwner._rootNode != null);
        _this.RendererBinding__pipelineOwner._rootNode.hitTest$2$position(hitTestResult, t6);
        _this.super$GestureBinding$hitTest(hitTestResult, t6);
        if (t3)
          t4.$indexSet(0, t5, hitTestResult);
        H.assertHelper(new N.GestureBinding__handlePointerEvent_closure(t1, $event).call$0());
      } else if (!!t2.$isPointerUpEvent || !!t2.$isPointerCancelEvent)
        t1.hitTestResult = _this.GestureBinding__hitTests.remove$1(0, $event.pointer);
      else if (H.boolConversionCheck($event.down))
        t1.hitTestResult = _this.GestureBinding__hitTests.$index(0, $event.pointer);
      H.assertHelper(new N.GestureBinding__handlePointerEvent_closure0($event).call$0());
      t1 = t1.hitTestResult;
      if (t1 != null || !!t2.$isPointerHoverEvent || !!t2.$isPointerAddedEvent || !!t2.$isPointerRemovedEvent)
        _this.dispatchEvent$2($event, t1);
    },
    hitTest$2: function(result, position) {
      C.JSArray_methods.add$1(result._path, new O.HitTestEntry(this));
    },
    dispatchEvent$2: function($event, hitTestResult) {
      var exception, stack, entry, exception0, stack0, t1, t2, _i,
        _s15_ = "gesture library";
      H.assertHelper(this._lockCount <= 0);
      if (hitTestResult == null) {
        t1 = J.getInterceptor$($event);
        H.assertHelper(!!t1.$isPointerHoverEvent || !!t1.$isPointerAddedEvent || !!t1.$isPointerRemovedEvent);
        try {
          this.GestureBinding_pointerRouter.route$1($event);
        } catch (exception0) {
          exception = H.unwrapException(exception0);
          stack = H.getTraceFromException(exception0);
          U.FlutterError_reportError(N.FlutterErrorDetailsForPointerEventDispatcher$("while dispatching a non-hit-tested pointer event", $event, exception, null, new N.GestureBinding_dispatchEvent_closure($event), _s15_, stack));
        }
        return;
      }
      for (t1 = hitTestResult._path, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        entry = t1[_i];
        try {
          J.get$target$z(entry).handleEvent$2($event, entry);
        } catch (exception) {
          exception0 = H.unwrapException(exception);
          stack0 = H.getTraceFromException(exception);
          U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(new N.FlutterErrorDetailsForPointerEventDispatcher(exception0, stack0, _s15_, "while dispatching a pointer event", new N.GestureBinding_dispatchEvent_closure0($event, entry), false));
        }
      }
    },
    handleEvent$2: function($event, entry) {
      var t1, _this = this;
      _this.GestureBinding_pointerRouter.route$1($event);
      t1 = J.getInterceptor$($event);
      if (!!t1.$isPointerDownEvent)
        _this.GestureBinding_gestureArena.close$1($event.pointer);
      else if (!!t1.$isPointerUpEvent)
        _this.GestureBinding_gestureArena.sweep$1($event.pointer);
      else if (!!t1.$isPointerSignalEvent)
        _this.GestureBinding_pointerSignalResolver.resolve$1($event);
    }
  };
  N.GestureBinding__handlePointerEvent_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  N.GestureBinding__handlePointerEvent_closure0.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  N.GestureBinding_dispatchEvent_closure.prototype = {
    call$1: function(information) {
      information._contents += "Event:\n";
      information._contents += "  " + this.event.toString$0(0) + "\n";
    },
    $signature: 3
  };
  N.GestureBinding_dispatchEvent_closure0.prototype = {
    call$1: function(information) {
      var t1;
      information._contents += "Event:\n";
      t1 = information._contents += "  " + H.S(this.event) + "\n";
      information._contents = t1 + "Target:\n";
      t1 = this.entry;
      information._contents += "  " + t1.get$target(t1).toString$0(0);
    },
    $signature: 3
  };
  N.FlutterErrorDetailsForPointerEventDispatcher.prototype = {};
  G._PointerState.prototype = {
    toString$0: function(_) {
      return "_PointerState(pointer: " + H.S(this._converter$_pointer) + ", down: " + this._down + ", lastPosition: " + this.lastPosition.toString$0(0) + ")";
    }
  };
  G.PointerEventConverter__ensureStateForPointer_closure.prototype = {
    call$0: function() {
      return new G._PointerState(this.position);
    },
    $signature: 171
  };
  O.DragDownDetails.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(" + H.S(this.globalPosition) + ")";
    }
  };
  O.DragStartDetails.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(" + H.S(this.globalPosition) + ")";
    }
  };
  O.DragUpdateDetails.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(" + H.S(this.delta) + ")";
    }
  };
  O.DragEndDetails.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(" + this.velocity.toString$0(0) + ")";
    }
  };
  F.PointerEvent.prototype = {
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _this = this, _null = null,
        _s8_ = "obscured",
        _s11_ = "synthesized";
      _this.super$Diagnosticable$debugFillProperties(properties);
      t1 = P.Offset;
      t2 = Y.DiagnosticsProperty$("position", _this.position, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t2);
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("delta", _this.delta, C.Offset_0_0, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("timeStamp", _this.timeStamp, C.Duration_0, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Duration));
      C.JSArray_methods.add$1(t3, Y.IntProperty$("pointer", _this.pointer, C.C__NoDefaultValue, _null, C.DiagnosticLevel_2, _null));
      C.JSArray_methods.add$1(t3, new Y.EnumProperty(_null, _null, _null, _null, false, _this.kind, C.C__NoDefaultValue, C.DiagnosticLevel_2, "kind", true, true, C.DiagnosticsTreeStyle_5, [P.PointerDeviceKind]));
      C.JSArray_methods.add$1(t3, Y.IntProperty$("device", _this.device, 0, _null, C.DiagnosticLevel_2, _null));
      C.JSArray_methods.add$1(t3, Y.IntProperty$("buttons", _this.buttons, 0, _null, C.DiagnosticLevel_2, _null));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("down", _this.down, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.bool));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("pressure", _this.pressure, 1, _null, C.DiagnosticLevel_2, true, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("pressureMin", _this.pressureMin, 1, _null, C.DiagnosticLevel_2, true, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("pressureMax", _this.pressureMax, 1, _null, C.DiagnosticLevel_2, true, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("distance", _this.distance, 0, _null, C.DiagnosticLevel_2, true, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("distanceMin", 0, 0, _null, C.DiagnosticLevel_2, true, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("distanceMax", _this.distanceMax, 0, _null, C.DiagnosticLevel_2, true, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("size", _this.size, 0, _null, C.DiagnosticLevel_2, true, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("radiusMajor", _this.radiusMajor, 0, _null, C.DiagnosticLevel_2, true, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("radiusMinor", _this.radiusMinor, 0, _null, C.DiagnosticLevel_2, true, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("radiusMin", _this.radiusMin, 0, _null, C.DiagnosticLevel_2, true, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("radiusMax", _this.radiusMax, 0, _null, C.DiagnosticLevel_2, true, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("orientation", _this.orientation, 0, _null, C.DiagnosticLevel_2, true, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("tilt", _this.tilt, 0, _null, C.DiagnosticLevel_2, true, _null, _null));
      C.JSArray_methods.add$1(t3, Y.IntProperty$("platformData", _this.platformData, 0, _null, C.DiagnosticLevel_2, _null));
      C.JSArray_methods.add$1(t3, Y.FlagProperty$(_s8_, _null, _null, _s8_, C.DiagnosticLevel_2, false, _this.obscured));
      C.JSArray_methods.add$1(t3, Y.FlagProperty$(_s11_, _null, _null, _s11_, C.DiagnosticLevel_2, false, _this.synthesized));
    }
  };
  F.PointerHoverEvent.prototype = {};
  F.PointerEnterEvent.prototype = {};
  F.PointerExitEvent.prototype = {};
  F.PointerDownEvent.prototype = {};
  F.PointerMoveEvent.prototype = {};
  F.PointerUpEvent.prototype = {};
  F.PointerSignalEvent.prototype = {};
  F.PointerScrollEvent.prototype = {
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$PointerEvent$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("scrollDelta", this.scrollDelta, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Offset);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  F.PointerCancelEvent.prototype = {};
  O.HitTestEntry.prototype = {
    toString$0: function(_) {
      return this.get$target(this).toString$0(0);
    },
    get$target: function(receiver) {
      return this.target;
    }
  };
  O.HitTestResult.prototype = {
    toString$0: function(_) {
      var t1 = this._path;
      return "HitTestResult(" + (t1.length === 0 ? "<empty path>" : C.JSArray_methods.join$1(t1, ", ")) + ")";
    }
  };
  T.LongPressStartDetails.prototype = {};
  T.LongPressMoveUpdateDetails.prototype = {};
  T.LongPressEndDetails.prototype = {};
  T.LongPressGestureRecognizer.prototype = {
    didExceedDeadline$0: function() {
      var t1, _this = this;
      _this.resolve$1(C.GestureDisposition_0);
      _this._longPressAccepted = true;
      _this.super$PrimaryPointerGestureRecognizer$acceptGesture(_this.primaryPointer);
      t1 = _this.onLongPress;
      if (t1 != null)
        _this.invokeCallback$1$2("onLongPress", t1, -1);
    },
    handlePrimaryPointer$1: function($event) {
      var _this = this;
      if (!!$event.$isPointerUpEvent)
        if (_this._longPressAccepted)
          _this._longPressAccepted = false;
        else
          _this.resolve$1(C.GestureDisposition_1);
      else if (!!$event.$isPointerDownEvent || !!$event.$isPointerCancelEvent) {
        _this._longPressAccepted = false;
        _this._longPressOrigin = $event.position;
      } else
        !!$event.$isPointerMoveEvent;
    },
    acceptGesture$1: function(pointer) {
    },
    get$debugDescription: function() {
      return "long press";
    },
    set$onLongPress: function(onLongPress) {
      this.onLongPress = H.functionTypeCheck(onLongPress, {func: 1, ret: -1});
    },
    set$onLongPressStart: function(onLongPressStart) {
      this.onLongPressStart = H.functionTypeCheck(onLongPressStart, {func: 1, ret: -1, args: [T.LongPressStartDetails]});
    },
    set$onLongPressMoveUpdate: function(onLongPressMoveUpdate) {
      this.onLongPressMoveUpdate = H.functionTypeCheck(onLongPressMoveUpdate, {func: 1, ret: -1, args: [T.LongPressMoveUpdateDetails]});
    },
    set$onLongPressUp: function(onLongPressUp) {
      this.onLongPressUp = H.functionTypeCheck(onLongPressUp, {func: 1, ret: -1});
    },
    set$onLongPressEnd: function(onLongPressEnd) {
      this.onLongPressEnd = H.functionTypeCheck(onLongPressEnd, {func: 1, ret: -1, args: [T.LongPressEndDetails]});
    }
  };
  B._Vector.prototype = {
    $index: function(_, i) {
      var t1 = this._lsq_solver$_elements,
        t2 = i + this._lsq_solver$_offset;
      if (t2 < 0 || t2 >= t1.length)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    $indexSet: function(_, i, value) {
      var t1 = this._lsq_solver$_elements,
        t2 = i + this._lsq_solver$_offset;
      if (t2 < 0 || t2 >= t1.length)
        return H.ioore(t1, t2);
      t1[t2] = value;
    },
    $mul: function(_, a) {
      var t1, t2, t3, t4, result, i, t5, t6, t7;
      H.interceptedTypeCheck(a, "$is_Vector");
      for (t1 = this._lsq_solver$_length, t2 = this._lsq_solver$_elements, t3 = this._lsq_solver$_offset, t4 = t2.length, result = 0, i = 0; i < t1; ++i) {
        t5 = i + t3;
        if (t5 < 0 || t5 >= t4)
          return H.ioore(t2, t5);
        t5 = t2[t5];
        t6 = a._lsq_solver$_elements;
        t7 = i + a._lsq_solver$_offset;
        if (t7 < 0 || t7 >= t6.length)
          return H.ioore(t6, t7);
        result += t5 * t6[t7];
      }
      return result;
    }
  };
  B._Matrix.prototype = {
    getRow$1: function(row) {
      var t1 = this._columns;
      return new B._Vector(row * t1, t1, this._lsq_solver$_elements);
    }
  };
  B.PolynomialFit.prototype = {};
  B.LeastSquaresSolver.prototype = {
    solve$1: function(degree) {
      var t2, result, m, t3, t4, t5, t6, t7, t8, t9, h, t10, t11, i, t12, j, dot, t13, t14, norm, inverseNorm, wy, i0, yMean, sumSquaredError, sumSquaredTotal, err, term, v,
        t1 = this.x;
      if (degree > t1.length)
        return;
      t2 = degree + 1;
      result = new B.PolynomialFit(new Float64Array(t2));
      m = t1.length;
      t3 = t2 * m;
      t4 = new Float64Array(t3);
      for (t5 = t4.length, t6 = t1.length, t7 = this.w, t8 = t7.length, t9 = 0 * m, h = 0; h < m; ++h) {
        if (h >= t8)
          return H.ioore(t7, h);
        t10 = t7[h];
        t11 = t9 + h;
        if (t11 >= t5)
          return H.ioore(t4, t11);
        t4[t11] = t10;
        for (i = 1; i < t2; ++i) {
          t10 = (i - 1) * m + h;
          if (t10 < 0 || t10 >= t5)
            return H.ioore(t4, t10);
          t10 = t4[t10];
          if (h >= t6)
            return H.ioore(t1, h);
          t11 = t1[h];
          t12 = i * m + h;
          if (t12 >= t5)
            return H.ioore(t4, t12);
          t4[t12] = t10 * t11;
        }
      }
      t3 = new Float64Array(t3);
      t6 = new Float64Array(t2 * t2);
      for (t8 = t6.length, t9 = t3.length, j = 0; j < t2; ++j) {
        for (t10 = j * m, h = 0; h < m; ++h) {
          t11 = t10 + h;
          if (t11 >= t5)
            return H.ioore(t4, t11);
          t12 = t4[t11];
          if (t11 >= t9)
            return H.ioore(t3, t11);
          t3[t11] = t12;
        }
        for (i = 0; i < j; ++i) {
          t11 = i * m;
          dot = new B._Vector(t10, m, t3).$mul(0, new B._Vector(t11, m, t3));
          for (h = 0; h < m; ++h) {
            t12 = t10 + h;
            if (t12 >= t9)
              return H.ioore(t3, t12);
            t13 = t3[t12];
            t14 = t11 + h;
            if (t14 >= t9)
              return H.ioore(t3, t14);
            t3[t12] = t13 - dot * t3[t14];
          }
        }
        t11 = new B._Vector(t10, m, t3);
        norm = Math.sqrt(t11.$mul(0, t11));
        if (norm < 0.000001)
          return;
        inverseNorm = 1 / norm;
        for (h = 0; h < m; ++h) {
          t11 = t10 + h;
          if (t11 >= t9)
            return H.ioore(t3, t11);
          t3[t11] = t3[t11] * inverseNorm;
        }
        for (t11 = j * t2, i = 0; i < t2; ++i) {
          t12 = i < j ? 0 : new B._Vector(t10, m, t3).$mul(0, new B._Vector(i * m, m, t4));
          t13 = t11 + i;
          if (t13 >= t8)
            return H.ioore(t6, t13);
          t6[t13] = t12;
        }
      }
      t4 = new Float64Array(m);
      wy = new B._Vector(0, m, t4);
      for (t5 = this.y, t9 = t5.length, t10 = t7.length, t11 = t4.length, h = 0; h < m; ++h) {
        if (h >= t9)
          return H.ioore(t5, h);
        t12 = t5[h];
        if (h >= t10)
          return H.ioore(t7, h);
        t13 = t7[h];
        if (typeof t12 !== "number")
          return t12.$mul();
        if (h >= t11)
          return H.ioore(t4, h);
        t4[h] = t12 * t13;
      }
      for (i = t2 - 1, t4 = result.coefficients, t9 = t4.length, i0 = i; i0 >= 0; --i0) {
        t10 = new B._Vector(i0 * m, m, t3).$mul(0, wy);
        if (i0 >= t9)
          return H.ioore(t4, i0);
        t4[i0] = t10;
        for (t10 = i0 * t2, j = i; j > i0; --j) {
          t11 = t4[i0];
          t12 = t10 + j;
          if (t12 < 0 || t12 >= t8)
            return H.ioore(t6, t12);
          t12 = t6[t12];
          if (j >= t9)
            return H.ioore(t4, j);
          t4[i0] = t11 - t12 * t4[j];
        }
        t11 = t4[i0];
        t10 += i0;
        if (t10 < 0 || t10 >= t8)
          return H.ioore(t6, t10);
        t4[i0] = t11 / t6[t10];
      }
      for (t3 = t5.length, yMean = 0, h = 0; h < m; ++h) {
        if (h >= t3)
          return H.ioore(t5, h);
        t6 = t5[h];
        if (typeof t6 !== "number")
          return H.iae(t6);
        yMean += t6;
      }
      yMean /= m;
      for (t6 = t7.length, t8 = t1.length, sumSquaredError = 0, sumSquaredTotal = 0, h = 0; h < m; ++h) {
        if (h >= t3)
          return H.ioore(t5, h);
        t10 = t5[h];
        if (0 >= t9)
          return H.ioore(t4, 0);
        t11 = t4[0];
        if (typeof t10 !== "number")
          return t10.$sub();
        err = t10 - t11;
        for (term = 1, i = 1; i < t2; ++i) {
          if (h >= t8)
            return H.ioore(t1, h);
          term *= t1[h];
          if (i >= t9)
            return H.ioore(t4, i);
          err -= term * t4[i];
        }
        if (h >= t6)
          return H.ioore(t7, h);
        t11 = t7[h];
        t11 *= t11;
        sumSquaredError += t11 * err * err;
        v = t10 - yMean;
        sumSquaredTotal += t11 * v * v;
      }
      result.confidence = sumSquaredTotal <= 0.000001 ? 1 : 1 - sumSquaredError / sumSquaredTotal;
      return result;
    }
  };
  O._DragState.prototype = {
    toString$0: function(_) {
      return this._monodrag$_name;
    }
  };
  O.DragGestureRecognizer.prototype = {
    addAllowedPointer$1: function($event) {
      var t2, _this = this,
        t1 = $event.pointer;
      _this.startTrackingPointer$1(t1);
      t2 = new Array(20);
      t2.fixed$length = Array;
      _this._velocityTrackers.$indexSet(0, t1, new R.VelocityTracker(H.setRuntimeTypeInfo(t2, [R._PointAtTime])));
      t1 = _this._monodrag$_state;
      if (t1 === C._DragState_0) {
        _this._monodrag$_state = C._DragState_1;
        _this._initialPosition = $event.position;
        _this._pendingDragOffset = C.Offset_0_0;
        _this._lastPendingEventTimestamp = $event.timeStamp;
        if (_this.onDown != null)
          _this.invokeCallback$1$2("onDown", new O.DragGestureRecognizer_addAllowedPointer_closure(_this), -1);
      } else if (t1 === C._DragState_2)
        _this.resolve$1(C.GestureDisposition_0);
    },
    handleEvent$1: function($event) {
      var t1, tracker, delta, _this = this;
      H.interceptedTypeCheck($event, "$isPointerEvent");
      H.assertHelper(_this._monodrag$_state !== C._DragState_0);
      if (!H.boolConversionCheck($event.synthesized)) {
        t1 = J.getInterceptor$($event);
        t1 = !!t1.$isPointerDownEvent || !!t1.$isPointerMoveEvent;
      } else
        t1 = false;
      if (t1) {
        tracker = _this._velocityTrackers.$index(0, $event.pointer);
        H.assertHelper(tracker != null);
        tracker.addPosition$2($event.timeStamp, $event.position);
      }
      if ($event instanceof F.PointerMoveEvent) {
        delta = $event.delta;
        if (_this._monodrag$_state === C._DragState_2) {
          if (_this.onUpdate != null)
            _this.invokeCallback$1$2("onUpdate", new O.DragGestureRecognizer_handleEvent_closure(_this, $event, delta), -1);
        } else {
          _this._pendingDragOffset = _this._pendingDragOffset.$add(0, delta);
          _this._lastPendingEventTimestamp = $event.timeStamp;
          if (_this.get$_hasSufficientPendingDragDeltaToAccept())
            _this.resolve$1(C.GestureDisposition_0);
        }
      }
      _this.stopTrackingIfPointerNoLongerDown$1($event);
    },
    acceptGesture$1: function(pointer) {
      var delta, timestamp, t1, _this = this, _box_0 = {};
      if (_this._monodrag$_state !== C._DragState_2) {
        _this._monodrag$_state = C._DragState_2;
        delta = _this._pendingDragOffset;
        timestamp = _this._lastPendingEventTimestamp;
        _box_0.updateDelta = null;
        switch (_this.dragStartBehavior) {
          case C.DragStartBehavior_1:
            _this._initialPosition = _this._initialPosition.$add(0, delta);
            t1 = _box_0.updateDelta = C.Offset_0_0;
            break;
          case C.DragStartBehavior_0:
            t1 = _box_0.updateDelta = _this._getDeltaForDetails$1(delta);
            break;
          default:
            t1 = null;
        }
        _this._pendingDragOffset = C.Offset_0_0;
        _this._lastPendingEventTimestamp = null;
        if (_this.onStart != null)
          _this.invokeCallback$1$2("onStart", new O.DragGestureRecognizer_acceptGesture_closure(_this, timestamp), -1);
        if (!J.$eq$(t1, C.Offset_0_0) && _this.onUpdate != null)
          _this.invokeCallback$1$2("onUpdate", new O.DragGestureRecognizer_acceptGesture_closure0(_box_0, _this, timestamp), -1);
      }
    },
    rejectGesture$1: function(pointer) {
      this.stopTrackingPointer$1(pointer);
    },
    didStopTrackingLastPointer$1: function(pointer) {
      var tracker, estimate, velocity, _this = this,
        t1 = _this._monodrag$_state;
      if (t1 === C._DragState_1) {
        _this.resolve$1(C.GestureDisposition_1);
        _this._monodrag$_state = C._DragState_0;
        t1 = _this.onCancel;
        if (t1 != null)
          _this.invokeCallback$1$2("onCancel", t1, -1);
        return;
      }
      _this._monodrag$_state = C._DragState_0;
      if (t1 === C._DragState_2 && _this.onEnd != null) {
        tracker = _this._velocityTrackers.$index(0, pointer);
        H.assertHelper(tracker != null);
        estimate = tracker.getVelocityEstimate$0();
        if (estimate != null && _this._isFlingGesture$1(estimate)) {
          t1 = estimate.pixelsPerSecond;
          velocity = new R.Velocity(t1).clampMagnitude$2(50, 8000);
          _this.invokeCallback$1$3$debugReport("onEnd", new O.DragGestureRecognizer_didStopTrackingLastPointer_closure(_this, velocity), new O.DragGestureRecognizer_didStopTrackingLastPointer_closure0(estimate, velocity), -1);
        } else
          _this.invokeCallback$1$3$debugReport("onEnd", new O.DragGestureRecognizer_didStopTrackingLastPointer_closure1(_this), new O.DragGestureRecognizer_didStopTrackingLastPointer_closure2(estimate), -1);
      }
      _this._velocityTrackers.clear$0(0);
    },
    dispose$0: function() {
      this._velocityTrackers.clear$0(0);
      this.super$OneSequenceGestureRecognizer$dispose();
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$GestureRecognizer$debugFillProperties(properties);
      t1 = this.dragStartBehavior;
      C.JSArray_methods.add$1(properties.properties, new Y.EnumProperty(_null, _null, _null, _null, false, t1, C.C__NoDefaultValue, C.DiagnosticLevel_3, "start behavior", true, true, C.DiagnosticsTreeStyle_5, [S.DragStartBehavior]));
    },
    set$onDown: function(onDown) {
      this.onDown = H.functionTypeCheck(onDown, {func: 1, ret: -1, args: [O.DragDownDetails]});
    },
    set$onStart: function(onStart) {
      this.onStart = H.functionTypeCheck(onStart, {func: 1, ret: -1, args: [O.DragStartDetails]});
    },
    set$onUpdate: function(onUpdate) {
      this.onUpdate = H.functionTypeCheck(onUpdate, {func: 1, ret: -1, args: [O.DragUpdateDetails]});
    },
    set$onEnd: function(onEnd) {
      this.onEnd = H.functionTypeCheck(onEnd, {func: 1, ret: -1, args: [O.DragEndDetails]});
    },
    set$onCancel: function(onCancel) {
      this.onCancel = H.functionTypeCheck(onCancel, {func: 1, ret: -1});
    }
  };
  O.DragGestureRecognizer_addAllowedPointer_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._initialPosition;
      return t1.onDown.call$1(new O.DragDownDetails(t2));
    },
    $signature: 1
  };
  O.DragGestureRecognizer_handleEvent_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = this.event,
        t3 = this.delta;
      t2 = O.DragUpdateDetails$(t1._getDeltaForDetails$1(t3), t2.position, t1._getPrimaryValueFromOffset$1(t3), t2.timeStamp);
      return t1.onUpdate.call$1(t2);
    },
    $signature: 1
  };
  O.DragGestureRecognizer_acceptGesture_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._initialPosition;
      return t1.onStart.call$1(new O.DragStartDetails(t2));
    },
    $signature: 1
  };
  O.DragGestureRecognizer_acceptGesture_closure0.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = this._box_0,
        t3 = t2.updateDelta,
        t4 = t1._getPrimaryValueFromOffset$1(t3);
      t4 = O.DragUpdateDetails$(t3, t1._initialPosition.$add(0, t2.updateDelta), t4, this.timestamp);
      return t1.onUpdate.call$1(t4);
    },
    $signature: 1
  };
  O.DragGestureRecognizer_didStopTrackingLastPointer_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = this.velocity;
      t2 = O.DragEndDetails$(t1._getPrimaryValueFromOffset$1(t2.pixelsPerSecond), t2);
      return t1.onEnd.call$1(t2);
    },
    $signature: 1
  };
  O.DragGestureRecognizer_didStopTrackingLastPointer_closure0.prototype = {
    call$0: function() {
      return this.estimate.toString$0(0) + "; fling at " + this.velocity.toString$0(0) + ".";
    },
    $signature: 44
  };
  O.DragGestureRecognizer_didStopTrackingLastPointer_closure1.prototype = {
    call$0: function() {
      var t1 = O.DragEndDetails$(0, C.Velocity_Offset_0_0);
      return this.$this.onEnd.call$1(t1);
    },
    $signature: 1
  };
  O.DragGestureRecognizer_didStopTrackingLastPointer_closure2.prototype = {
    call$0: function() {
      var t1 = this.estimate;
      if (t1 == null)
        return "Could not estimate velocity.";
      return t1.toString$0(0) + "; judged to not be a fling.";
    },
    $signature: 44
  };
  O.VerticalDragGestureRecognizer.prototype = {
    _isFlingGesture$1: function(estimate) {
      var t1 = estimate.pixelsPerSecond._dy;
      if (typeof t1 !== "number")
        return t1.abs$0();
      if (Math.abs(t1) > 50) {
        t1 = estimate.offset._dy;
        if (typeof t1 !== "number")
          return t1.abs$0();
        t1 = Math.abs(t1) > 18;
      } else
        t1 = false;
      return t1;
    },
    get$_hasSufficientPendingDragDeltaToAccept: function() {
      var t1 = this._pendingDragOffset._dy;
      if (typeof t1 !== "number")
        return t1.abs$0();
      return Math.abs(t1) > 18;
    },
    _getDeltaForDetails$1: function(delta) {
      return new P.Offset(0, delta._dy);
    },
    _getPrimaryValueFromOffset$1: function(value) {
      return value._dy;
    },
    get$debugDescription: function() {
      return "vertical drag";
    }
  };
  O.HorizontalDragGestureRecognizer.prototype = {
    _isFlingGesture$1: function(estimate) {
      var t1 = estimate.pixelsPerSecond._dx;
      if (typeof t1 !== "number")
        return t1.abs$0();
      if (Math.abs(t1) > 50) {
        t1 = estimate.offset._dx;
        if (typeof t1 !== "number")
          return t1.abs$0();
        t1 = Math.abs(t1) > 18;
      } else
        t1 = false;
      return t1;
    },
    get$_hasSufficientPendingDragDeltaToAccept: function() {
      var t1 = this._pendingDragOffset._dx;
      if (typeof t1 !== "number")
        return t1.abs$0();
      return Math.abs(t1) > 18;
    },
    _getDeltaForDetails$1: function(delta) {
      return new P.Offset(delta._dx, 0);
    },
    _getPrimaryValueFromOffset$1: function(value) {
      return value._dx;
    },
    get$debugDescription: function() {
      return "horizontal drag";
    }
  };
  O.PanGestureRecognizer.prototype = {
    _isFlingGesture$1: function(estimate) {
      return estimate.pixelsPerSecond.get$distanceSquared() > 2500 && estimate.offset.get$distanceSquared() > 324;
    },
    get$_hasSufficientPendingDragDeltaToAccept: function() {
      return this._pendingDragOffset.get$distance() > 36;
    },
    _getDeltaForDetails$1: function(delta) {
      return delta;
    },
    _getPrimaryValueFromOffset$1: function(value) {
      return;
    },
    get$debugDescription: function() {
      return "pan";
    }
  };
  Y.MouseTrackerAnnotation.prototype = {};
  Y._TrackedAnnotation.prototype = {};
  Y.MouseTracker.prototype = {
    attachAnnotation$1: function(annotation) {
      this._trackedAnnotations.$indexSet(0, annotation, new Y._TrackedAnnotation(annotation, P.LinkedHashSet_LinkedHashSet$_empty(P.int)));
      this._scheduleMousePositionCheck$0();
    },
    detachAnnotation$1: function(annotation) {
      var t1;
      for (t1 = this._findAnnotation$1(annotation).activeDevices, t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0)); t1.moveNext$0();)
        annotation.onExit;
      this._trackedAnnotations.remove$1(0, annotation);
    },
    _scheduleMousePositionCheck$0: function() {
      var t2,
        t1 = $.SchedulerBinding__instance;
      t1.toString;
      t2 = H.functionTypeCheck(new Y.MouseTracker__scheduleMousePositionCheck_closure(this), {func: 1, ret: -1, args: [P.Duration]});
      C.JSArray_methods.add$1(t1.SchedulerBinding__postFrameCallbacks, t2);
      $.SchedulerBinding__instance.scheduleFrame$0();
    },
    _mouse_tracking$_handleEvent$1: function($event) {
      var deviceId, t1, _this = this;
      H.interceptedTypeCheck($event, "$isPointerEvent");
      if ($event.kind !== C.PointerDeviceKind_1)
        return;
      deviceId = $event.device;
      t1 = _this._trackedAnnotations;
      if (t1.get$isEmpty(t1)) {
        _this._lastMouseEvent.remove$1(0, deviceId);
        return;
      }
      t1 = J.getInterceptor$($event);
      if (!!t1.$isPointerRemovedEvent) {
        _this._lastMouseEvent.remove$1(0, deviceId);
        _this._scheduleMousePositionCheck$0();
      } else if (!!t1.$isPointerMoveEvent || !!t1.$isPointerHoverEvent || !!t1.$isPointerDownEvent) {
        t1 = _this._lastMouseEvent;
        if (!t1.containsKey$1(deviceId) || !J.$eq$(t1.$index(0, deviceId).position, $event.position))
          _this._scheduleMousePositionCheck$0();
        t1.$indexSet(0, deviceId, $event);
      }
    },
    _findAnnotation$1: function(annotation) {
      var trackedAnnotation = this._trackedAnnotations.$index(0, annotation);
      if (H.assertTest(trackedAnnotation != null))
        H.assertThrow("Unable to find annotation " + H.S(annotation) + " in tracked annotations. Check that attachAnnotation has been called for all annotated layers.");
      return trackedAnnotation;
    },
    collectMousePositions$0: function() {
      var t2, t3, t4, t5, hit, trackedAnnotation, t6, t7, t8, _this = this,
        exitAnnotation = new Y.MouseTracker_collectMousePositions_exitAnnotation(_this),
        t1 = _this._lastMouseEvent;
      if (!t1.get$isNotEmpty(t1)) {
        _this._trackedAnnotations.get$values().forEach$1(0, new Y.MouseTracker_collectMousePositions_exitAllDevices(exitAnnotation));
        return;
      }
      for (t2 = t1.get$keys(), t2 = t2.get$iterator(t2), t3 = _this._trackedAnnotations, t4 = _this.annotationFinder; t2.moveNext$0();) {
        t5 = t2.get$current();
        hit = t4.call$1(t1.$index(0, t5).position);
        if (hit == null) {
          for (t1 = t3.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
            exitAnnotation.call$2(t1.get$current(), t5);
          return;
        }
        trackedAnnotation = t3.$index(0, hit);
        if (H.assertTest(trackedAnnotation != null))
          H.assertThrow("Unable to find annotation " + hit.toString$0(0) + " in tracked annotations. Check that attachAnnotation has been called for all annotated layers.");
        t6 = trackedAnnotation.activeDevices;
        if (!t6.contains$1(0, t5))
          t6.add$1(0, t5);
        trackedAnnotation.annotation;
        for (t6 = t3.get$values(), t6 = t6.get$iterator(t6); t6.moveNext$0();) {
          t7 = t6.get$current();
          if (trackedAnnotation == t7)
            continue;
          t8 = t7.activeDevices;
          if (t8.contains$1(0, t5)) {
            t7.annotation;
            t8.remove$1(0, t5);
          }
        }
      }
    }
  };
  Y.MouseTracker__scheduleMousePositionCheck_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isDuration");
      return this.$this.collectMousePositions$0();
    },
    $signature: 13
  };
  Y.MouseTracker_collectMousePositions_exitAnnotation.prototype = {
    call$2: function(trackedAnnotation, deviceId) {
      trackedAnnotation.annotation;
    },
    $signature: 182
  };
  Y.MouseTracker_collectMousePositions_exitAllDevices.prototype = {
    call$1: function(trackedAnnotation) {
      var t1, deviceIds, t2;
      H.interceptedTypeCheck(trackedAnnotation, "$is_TrackedAnnotation");
      t1 = trackedAnnotation.activeDevices;
      if (t1._collection$_length !== 0) {
        deviceIds = t1._newSet$0();
        deviceIds.addAll$1(0, t1);
        for (t1 = deviceIds.get$iterator(deviceIds), t2 = this.exitAnnotation; t1.moveNext$0();)
          t2.call$2(trackedAnnotation, t1.get$current());
      }
    },
    $signature: 192
  };
  F._CountdownZoned.prototype = {
    _onTimeout$0: function() {
      this._timeout = true;
    }
  };
  F._TapTracker.prototype = {
    stopTrackingPointer$1: function(route) {
      H.functionTypeCheck(route, {func: 1, ret: -1, args: [F.PointerEvent]});
      if (this._isTrackingPointer) {
        this._isTrackingPointer = false;
        $.GestureBinding__instance.GestureBinding_pointerRouter.removeRoute$2(this.pointer, route);
      }
    },
    isWithinTolerance$2: function($event, tolerance) {
      return $event.position.$sub(0, this._multitap$_initialPosition).get$distance() <= tolerance;
    }
  };
  F.DoubleTapGestureRecognizer.prototype = {
    addAllowedPointer$1: function($event) {
      var t2, t3, tracker, _this = this,
        t1 = _this._firstTap;
      if (t1 != null)
        if (!t1.isWithinTolerance$2($event, 100))
          return;
        else if (!_this._firstTap._doubleTapMinTimeCountdown._timeout) {
          _this._reset$0();
          return _this.addAllowedPointer$1($event);
        }
      _this._stopDoubleTapTimer$0();
      t1 = $event.pointer;
      t2 = $.GestureBinding__instance.GestureBinding_gestureArena.add$2(0, t1, _this);
      t3 = new F._CountdownZoned();
      P.Timer_Timer(C.Duration_40000, t3.get$_onTimeout());
      tracker = new F._TapTracker(t1, t2, $event.position, t3);
      _this._trackers.$indexSet(0, t1, tracker);
      t3 = H.functionTypeCheck(_this.get$_handleEvent(), {func: 1, ret: -1, args: [F.PointerEvent]});
      if (!tracker._isTrackingPointer) {
        tracker._isTrackingPointer = true;
        $.GestureBinding__instance.GestureBinding_pointerRouter.addRoute$2(t1, t3);
      }
    },
    _handleEvent$1: function($event) {
      var t1, tracker, t2, t3, _this = this;
      H.interceptedTypeCheck($event, "$isPointerEvent");
      t1 = _this._trackers;
      tracker = t1.$index(0, $event.pointer);
      H.assertHelper(tracker != null);
      t2 = J.getInterceptor$($event);
      if (!!t2.$isPointerUpEvent) {
        t2 = _this._firstTap;
        if (t2 == null) {
          if (_this._doubleTapTimer == null)
            _this._doubleTapTimer = P.Timer_Timer(C.Duration_300000, _this.get$_reset());
          t2 = $.GestureBinding__instance.GestureBinding_gestureArena;
          t3 = tracker.pointer;
          t2.hold$1(t3);
          tracker.stopTrackingPointer$1(_this.get$_handleEvent());
          t1.remove$1(0, t3);
          _this._clearTrackers$0();
          _this._firstTap = tracker;
        } else {
          t2 = t2.entry;
          t2._arena._resolve$3(t2._pointer, t2._member, C.GestureDisposition_0);
          t2 = tracker.entry;
          t2._arena._resolve$3(t2._pointer, t2._member, C.GestureDisposition_0);
          tracker.stopTrackingPointer$1(_this.get$_handleEvent());
          t1.remove$1(0, tracker.pointer);
          t1 = _this.onDoubleTap;
          if (t1 != null)
            _this.invokeCallback$1$2("onDoubleTap", t1, -1);
          _this._reset$0();
        }
      } else if (!!t2.$isPointerMoveEvent) {
        if (!tracker.isWithinTolerance$2($event, 18))
          _this._reject$1(tracker);
      } else if (!!t2.$isPointerCancelEvent)
        _this._reject$1(tracker);
    },
    acceptGesture$1: function(pointer) {
    },
    rejectGesture$1: function(pointer) {
      var t1, _this = this,
        tracker = _this._trackers.$index(0, pointer);
      if (tracker == null) {
        t1 = _this._firstTap;
        t1 = t1 != null && t1.pointer == pointer;
      } else
        t1 = false;
      if (t1)
        tracker = _this._firstTap;
      if (tracker != null)
        _this._reject$1(tracker);
    },
    _reject$1: function(tracker) {
      var t1, t2, _this = this;
      H.interceptedTypeCheck(tracker, "$is_TapTracker");
      t1 = _this._trackers;
      t1.remove$1(0, tracker.pointer);
      t2 = tracker.entry;
      t2._arena._resolve$3(t2._pointer, t2._member, C.GestureDisposition_1);
      tracker.stopTrackingPointer$1(_this.get$_handleEvent());
      if (_this._firstTap != null)
        t1 = t1.get$isEmpty(t1) || tracker === _this._firstTap;
      else
        t1 = false;
      if (t1)
        _this._reset$0();
    },
    dispose$0: function() {
      this._reset$0();
      this.super$GestureRecognizer$dispose();
    },
    _reset$0: function() {
      var t1, _this = this;
      _this._stopDoubleTapTimer$0();
      t1 = _this._firstTap;
      if (t1 != null) {
        _this._firstTap = null;
        _this._reject$1(t1);
        $.GestureBinding__instance.GestureBinding_gestureArena.release$1(t1.pointer);
      }
      _this._clearTrackers$0();
    },
    _clearTrackers$0: function() {
      var t1 = this._trackers,
        t2 = t1.get$values();
      C.JSArray_methods.forEach$1(P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "Iterable", 0)), this.get$_reject());
      H.assertHelper(t1.get$isEmpty(t1));
    },
    _stopDoubleTapTimer$0: function() {
      var t1 = this._doubleTapTimer;
      if (t1 != null) {
        t1.cancel$0();
        this._doubleTapTimer = null;
      }
    },
    get$debugDescription: function() {
      return "double tap";
    },
    set$onDoubleTap: function(onDoubleTap) {
      this.onDoubleTap = H.functionTypeCheck(onDoubleTap, {func: 1, ret: -1});
    }
  };
  O.PointerRouter.prototype = {
    addRoute$2: function(pointer, route) {
      var routes;
      H.functionTypeCheck(route, {func: 1, ret: -1, args: [F.PointerEvent]});
      routes = this._routeMap.putIfAbsent$2(pointer, new O.PointerRouter_addRoute_closure());
      H.assertHelper(!routes.contains$1(0, route));
      routes.add$1(0, route);
    },
    removeRoute$2: function(pointer, route) {
      var t1, routes;
      H.functionTypeCheck(route, {func: 1, ret: -1, args: [F.PointerEvent]});
      t1 = this._routeMap;
      H.assertHelper(t1.containsKey$1(pointer));
      routes = t1.$index(0, pointer);
      H.assertHelper(routes.contains$1(0, route));
      routes.remove$1(0, route);
      if (routes._collection$_length === 0)
        t1.remove$1(0, pointer);
    },
    addGlobalRoute$1: function(route) {
      var t1;
      H.functionTypeCheck(route, {func: 1, ret: -1, args: [F.PointerEvent]});
      t1 = this._globalRoutes;
      H.assertHelper(!t1.contains$1(0, route));
      t1.add$1(0, route);
    },
    _dispatch$2: function($event, route) {
      var exception, stack, exception0;
      H.functionTypeCheck(route, {func: 1, ret: -1, args: [F.PointerEvent]});
      try {
        route.call$1($event);
      } catch (exception0) {
        exception = H.unwrapException(exception0);
        stack = H.getTraceFromException(exception0);
        U.FlutterError_reportError(new O.FlutterErrorDetailsForPointerRouter(exception, stack, "gesture library", "while routing a pointer event", new O.PointerRouter__dispatch_closure($event), false));
      }
    },
    route$1: function($event) {
      var t3, _i, route, _this = this,
        routes = _this._routeMap.$index(0, $event.pointer),
        t1 = _this._globalRoutes,
        t2 = {func: 1, ret: -1, args: [F.PointerEvent]},
        globalRoutes = P.List_List$from(t1, true, t2);
      if (routes != null)
        for (t2 = P.List_List$from(routes, true, t2), t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
          route = t2[_i];
          if (routes.contains$1(0, route))
            _this._dispatch$2($event, route);
        }
      for (t2 = globalRoutes.length, _i = 0; _i < globalRoutes.length; globalRoutes.length === t2 || (0, H.throwConcurrentModificationError)(globalRoutes), ++_i) {
        route = globalRoutes[_i];
        if (t1.contains$1(0, route))
          _this._dispatch$2($event, route);
      }
    }
  };
  O.PointerRouter_addRoute_closure.prototype = {
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet({func: 1, ret: -1, args: [F.PointerEvent]});
    },
    $signature: 59
  };
  O.PointerRouter__dispatch_closure.prototype = {
    call$1: function(information) {
      information._contents += "Event:\n";
      information._contents += "  " + this.event.toString$0(0);
    },
    $signature: 3
  };
  O.FlutterErrorDetailsForPointerRouter.prototype = {};
  G.PointerSignalResolver.prototype = {
    resolve$1: function($event) {
      return;
    }
  };
  S.DragStartBehavior.prototype = {
    toString$0: function(_) {
      return this._recognizer$_name;
    }
  };
  S.GestureRecognizer.prototype = {
    addPointer$1: function($event) {
      this.addAllowedPointer$1($event);
    },
    addAllowedPointer$1: function($event) {
    },
    dispose$0: function() {
    },
    invokeCallback$1$3$debugReport: function($name, callback, debugReport, $T) {
      var result, exception, stack, exception0;
      H.functionTypeCheck(callback, {func: 1, ret: $T});
      H.functionTypeCheck(debugReport, {func: 1, ret: P.String});
      H.assertHelper(callback != null);
      result = null;
      try {
        H.assertHelper(new S.GestureRecognizer_invokeCallback_closure(this, debugReport, $name).call$0());
        result = callback.call$0();
      } catch (exception0) {
        exception = H.unwrapException(exception0);
        stack = H.getTraceFromException(exception0);
        U.FlutterError_reportError(U.FlutterErrorDetails$("while handling a gesture", exception, new S.GestureRecognizer_invokeCallback_closure0(this, $name), "gesture", false, stack));
      }
      return result;
    },
    invokeCallback$1$2: function($name, callback, $T) {
      return this.invokeCallback$1$3$debugReport($name, callback, null, $T);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$DiagnosticableTreeMixin$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("debugOwner", this.debugOwner, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Object);
      C.JSArray_methods.add$1(properties.properties, t1);
    },
    $isDiagnosticable: 1,
    $isDiagnosticableTree: 1
  };
  S.GestureRecognizer_invokeCallback_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  S.GestureRecognizer_invokeCallback_closure0.prototype = {
    call$1: function(information) {
      var t1 = information._contents += "Handler: " + this.name + "\n";
      information._contents = t1 + "Recognizer:\n";
      information._contents += "  " + this.$this.toString$0(0) + "\n";
    },
    $signature: 3
  };
  S.OneSequenceGestureRecognizer.prototype = {
    acceptGesture$1: function(pointer) {
    },
    rejectGesture$1: function(pointer) {
    },
    resolve$1: function(disposition) {
      var _i, entry,
        t1 = this._recognizer$_entries,
        localEntries = P.List_List$from(t1.get$values(), true, D.GestureArenaEntry);
      t1.clear$0(0);
      for (t1 = localEntries.length, _i = 0; _i < localEntries.length; localEntries.length === t1 || (0, H.throwConcurrentModificationError)(localEntries), ++_i) {
        entry = localEntries[_i];
        entry._arena._resolve$3(entry._pointer, entry._member, disposition);
      }
    },
    dispose$0: function() {
      var t1, t2, t3, _this = this;
      _this.resolve$1(C.GestureDisposition_1);
      for (t1 = _this._trackedPointers, t2 = new P._HashSetIterator(t1, t1._computeElements$0(), [H.getTypeArgumentByIndex(t1, 0)]); t2.moveNext$0();) {
        t3 = t2._collection$_current;
        $.GestureBinding__instance.GestureBinding_pointerRouter.removeRoute$2(t3, _this.get$handleEvent());
      }
      t1.clear$0(0);
      t1 = _this._recognizer$_entries;
      H.assertHelper(t1.get$isEmpty(t1));
      _this.super$GestureRecognizer$dispose();
    },
    _addPointerToArena$1: function(pointer) {
      return $.GestureBinding__instance.GestureBinding_gestureArena.add$2(0, pointer, this);
    },
    startTrackingPointer$1: function(pointer) {
      var t1, _this = this;
      $.GestureBinding__instance.GestureBinding_pointerRouter.addRoute$2(pointer, _this.get$handleEvent());
      _this._trackedPointers.add$1(0, pointer);
      t1 = _this._recognizer$_entries;
      H.assertHelper(!t1.containsValue$1(pointer));
      t1.$indexSet(0, pointer, _this._addPointerToArena$1(pointer));
    },
    stopTrackingPointer$1: function(pointer) {
      var t1 = this._trackedPointers;
      if (t1.contains$1(0, pointer)) {
        $.GestureBinding__instance.GestureBinding_pointerRouter.removeRoute$2(pointer, this.get$handleEvent());
        t1.remove$1(0, pointer);
        if (t1._collection$_length === 0)
          this.didStopTrackingLastPointer$1(pointer);
      }
    },
    stopTrackingIfPointerNoLongerDown$1: function($event) {
      var t1 = J.getInterceptor$($event);
      if (!!t1.$isPointerUpEvent || !!t1.$isPointerCancelEvent)
        this.stopTrackingPointer$1($event.pointer);
    }
  };
  S.GestureRecognizerState.prototype = {
    toString$0: function(_) {
      return this._recognizer$_name;
    }
  };
  S.PrimaryPointerGestureRecognizer.prototype = {
    addAllowedPointer$1: function($event) {
      var _this = this,
        t1 = $event.pointer;
      _this.startTrackingPointer$1(t1);
      if (_this.state === C.GestureRecognizerState_0) {
        _this.state = C.GestureRecognizerState_1;
        _this.primaryPointer = t1;
        _this.initialPosition = $event.position;
        _this._timer = P.Timer_Timer(_this.deadline, _this.get$didExceedDeadline());
      }
    },
    handleEvent$1: function($event) {
      var isPreAcceptSlopPastTolerance, t1, isPostAcceptSlopPastTolerance, _this = this;
      H.interceptedTypeCheck($event, "$isPointerEvent");
      H.assertHelper(_this.state !== C.GestureRecognizerState_0);
      if (_this.state === C.GestureRecognizerState_1 && $event.pointer == _this.primaryPointer) {
        if (!_this._gestureAccepted)
          isPreAcceptSlopPastTolerance = $event.position.$sub(0, _this.initialPosition).get$distance() > 18;
        else
          isPreAcceptSlopPastTolerance = false;
        if (_this._gestureAccepted) {
          t1 = _this.postAcceptSlopTolerance;
          isPostAcceptSlopPastTolerance = t1 != null && $event.position.$sub(0, _this.initialPosition).get$distance() > t1;
        } else
          isPostAcceptSlopPastTolerance = false;
        if ($event instanceof F.PointerMoveEvent)
          t1 = isPreAcceptSlopPastTolerance || isPostAcceptSlopPastTolerance;
        else
          t1 = false;
        if (t1) {
          _this.resolve$1(C.GestureDisposition_1);
          _this.stopTrackingPointer$1(_this.primaryPointer);
        } else
          _this.handlePrimaryPointer$1($event);
      }
      _this.stopTrackingIfPointerNoLongerDown$1($event);
    },
    didExceedDeadline$0: function() {
      H.assertHelper(false);
    },
    acceptGesture$1: function(pointer) {
      this._gestureAccepted = true;
    },
    rejectGesture$1: function(pointer) {
      var _this = this;
      if (pointer == _this.primaryPointer && _this.state === C.GestureRecognizerState_1) {
        _this._stopTimer$0();
        _this.state = C.GestureRecognizerState_2;
      }
    },
    didStopTrackingLastPointer$1: function(pointer) {
      H.assertHelper(this.state !== C.GestureRecognizerState_0);
      this._stopTimer$0();
      this.state = C.GestureRecognizerState_0;
    },
    dispose$0: function() {
      this._stopTimer$0();
      this.super$OneSequenceGestureRecognizer$dispose();
    },
    _stopTimer$0: function() {
      var t1 = this._timer;
      if (t1 != null) {
        t1.cancel$0();
        this._timer = null;
      }
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$GestureRecognizer$debugFillProperties(properties);
      t1 = this.state;
      C.JSArray_methods.add$1(properties.properties, new Y.EnumProperty(_null, _null, _null, _null, false, t1, C.C__NoDefaultValue, C.DiagnosticLevel_3, "state", true, true, C.DiagnosticsTreeStyle_5, [S.GestureRecognizerState]));
    }
  };
  S._GestureRecognizer_GestureArenaMember_DiagnosticableTreeMixin.prototype = {};
  N.TapDownDetails.prototype = {};
  N.TapUpDetails.prototype = {};
  N.TapGestureRecognizer.prototype = {
    handlePrimaryPointer$1: function($event) {
      var _this = this;
      if (!!$event.$isPointerUpEvent) {
        _this._finalPosition = $event.position;
        if (_this._wonArenaForPrimaryPointer) {
          _this.resolve$1(C.GestureDisposition_0);
          _this._checkUp$0();
        }
      } else if (!!$event.$isPointerCancelEvent) {
        if (_this._sentTapDown && _this.onTapCancel != null)
          _this.invokeCallback$1$2("onTapCancel", _this.onTapCancel, -1);
        _this._tap$_reset$0();
      }
    },
    resolve$1: function(disposition) {
      var t1, _this = this;
      if (_this._wonArenaForPrimaryPointer && disposition === C.GestureDisposition_1) {
        H.assertHelper(_this._sentTapDown);
        t1 = _this.onTapCancel;
        if (t1 != null)
          _this.invokeCallback$1$2("spontaneous onTapCancel", t1, -1);
        _this._tap$_reset$0();
      }
      _this.super$OneSequenceGestureRecognizer$resolve(disposition);
    },
    didExceedDeadline$0: function() {
      this._checkDown$0();
    },
    acceptGesture$1: function(pointer) {
      var _this = this;
      _this.super$PrimaryPointerGestureRecognizer$acceptGesture(pointer);
      if (pointer == _this.primaryPointer) {
        _this._checkDown$0();
        _this._wonArenaForPrimaryPointer = true;
        _this._checkUp$0();
      }
    },
    rejectGesture$1: function(pointer) {
      var _this = this;
      _this.super$PrimaryPointerGestureRecognizer$rejectGesture(pointer);
      if (pointer == _this.primaryPointer) {
        H.assertHelper(_this.state !== C.GestureRecognizerState_1);
        if (_this._sentTapDown && _this.onTapCancel != null)
          _this.invokeCallback$1$2("forced onTapCancel", _this.onTapCancel, -1);
        _this._tap$_reset$0();
      }
    },
    _checkDown$0: function() {
      var _this = this;
      if (!_this._sentTapDown) {
        if (_this.onTapDown != null)
          _this.invokeCallback$1$2("onTapDown", new N.TapGestureRecognizer__checkDown_closure(_this), -1);
        _this._sentTapDown = true;
      }
    },
    _checkUp$0: function() {
      var t1, _this = this;
      if (_this._finalPosition != null) {
        t1 = _this.onTap;
        if (t1 != null)
          _this.invokeCallback$1$2("onTap", t1, -1);
        _this._tap$_reset$0();
      }
    },
    _tap$_reset$0: function() {
      this._wonArenaForPrimaryPointer = this._sentTapDown = false;
      this._finalPosition = null;
    },
    get$debugDescription: function() {
      return "tap";
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$PrimaryPointerGestureRecognizer$debugFillProperties(properties);
      t1 = Y.FlagProperty$("wonArenaForPrimaryPointer", _null, _null, "won arena", C.DiagnosticLevel_3, false, _this._wonArenaForPrimaryPointer);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("finalPosition", _this._finalPosition, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Offset));
      C.JSArray_methods.add$1(t2, Y.FlagProperty$("sentTapDown", _null, _null, "sent tap down", C.DiagnosticLevel_3, false, _this._sentTapDown));
    },
    set$onTapDown: function(onTapDown) {
      this.onTapDown = H.functionTypeCheck(onTapDown, {func: 1, ret: -1, args: [N.TapDownDetails]});
    },
    set$onTapUp: function(onTapUp) {
      this.onTapUp = H.functionTypeCheck(onTapUp, {func: 1, ret: -1, args: [N.TapUpDetails]});
    },
    set$onTap: function(onTap) {
      this.onTap = H.functionTypeCheck(onTap, {func: 1, ret: -1});
    },
    set$onTapCancel: function(onTapCancel) {
      this.onTapCancel = H.functionTypeCheck(onTapCancel, {func: 1, ret: -1});
    }
  };
  N.TapGestureRecognizer__checkDown_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1.initialPosition;
      t1.onTapDown.call$1(new N.TapDownDetails(t2));
    },
    $signature: 2
  };
  R.Velocity.prototype = {
    $sub: function(_, other) {
      return new R.Velocity(this.pixelsPerSecond.$sub(0, H.interceptedTypeCheck(other, "$isVelocity").pixelsPerSecond));
    },
    $add: function(_, other) {
      return new R.Velocity(this.pixelsPerSecond.$add(0, H.interceptedTypeCheck(other, "$isVelocity").pixelsPerSecond));
    },
    clampMagnitude$2: function(minValue, maxValue) {
      var valueSquared,
        t1 = maxValue >= minValue;
      H.assertHelper(t1);
      t1 = this.pixelsPerSecond;
      valueSquared = t1.get$distanceSquared();
      if (valueSquared > maxValue * maxValue)
        return new R.Velocity(t1.$div(0, t1.get$distance()).$mul(0, maxValue));
      if (valueSquared < minValue * minValue)
        return new R.Velocity(t1.$div(0, t1.get$distance()).$mul(0, minValue));
      return this;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof R.Velocity))
        return false;
      return this.pixelsPerSecond.$eq(0, other.pixelsPerSecond);
    },
    get$hashCode: function(_) {
      var t1 = this.pixelsPerSecond;
      return P.hashValues(t1._dx, t1._dy, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t1 = this.pixelsPerSecond;
      return "Velocity(" + J.toStringAsFixed$1$n(t1._dx, 1) + ", " + J.toStringAsFixed$1$n(t1._dy, 1) + ")";
    }
  };
  R.VelocityEstimate.prototype = {
    toString$0: function(_) {
      var _this = this,
        t1 = _this.pixelsPerSecond;
      return "VelocityEstimate(" + J.toStringAsFixed$1$n(t1._dx, 1) + ", " + J.toStringAsFixed$1$n(t1._dy, 1) + "; offset: " + _this.offset.toString$0(0) + ", duration: " + _this.duration.toString$0(0) + ", confidence: " + C.JSNumber_methods.toStringAsFixed$1(_this.confidence, 1) + ")";
    }
  };
  R._PointAtTime.prototype = {
    toString$0: function(_) {
      return "_PointAtTime(" + H.S(this.point) + " at " + H.S(this.time) + ")";
    }
  };
  R.VelocityTracker.prototype = {
    addPosition$2: function(time, position) {
      var t1 = ++this._velocity_tracker$_index;
      if (t1 === 20)
        t1 = this._velocity_tracker$_index = 0;
      C.JSArray_methods.$indexSet(this._samples, t1, new R._PointAtTime(time, position));
    },
    getVelocityEstimate$0: function() {
      var newestSample, t2, oldestSample, previousSample, sampleCount, sample, t3, t4, age, position, xFit, yFit, t5,
        t1 = [P.double],
        x = H.setRuntimeTypeInfo([], t1),
        y = H.setRuntimeTypeInfo([], t1),
        w = H.setRuntimeTypeInfo([], t1),
        time = H.setRuntimeTypeInfo([], t1),
        index = this._velocity_tracker$_index;
      t1 = this._samples;
      if (index >= 20)
        return H.ioore(t1, index);
      newestSample = t1[index];
      if (newestSample == null)
        return;
      t2 = newestSample.time;
      oldestSample = newestSample;
      previousSample = oldestSample;
      sampleCount = 0;
      do {
        if (index < 0 || index >= 20)
          return H.ioore(t1, index);
        sample = t1[index];
        if (sample == null)
          break;
        t3 = sample.time;
        t4 = t2._duration;
        t3 = t3._duration;
        age = C.JSInt_methods._tdivFast$1(t4 - t3, 1000);
        t3 = C.JSInt_methods._tdivFast$1(t3 - previousSample.time._duration, 1000);
        if (age > 100 || Math.abs(t3) > 40)
          break;
        position = sample.point;
        C.JSArray_methods.add$1(x, position._dx);
        C.JSArray_methods.add$1(y, position._dy);
        C.JSArray_methods.add$1(w, 1);
        C.JSArray_methods.add$1(time, -age);
        index = (index === 0 ? 20 : index) - 1;
        ++sampleCount;
        if (sampleCount < 20) {
          oldestSample = sample;
          previousSample = oldestSample;
          continue;
        } else {
          oldestSample = sample;
          break;
        }
      } while (true);
      if (sampleCount >= 3) {
        xFit = B.LeastSquaresSolver$(time, x, w).solve$1(2);
        if (xFit != null) {
          yFit = B.LeastSquaresSolver$(time, y, w).solve$1(2);
          if (yFit != null) {
            t1 = xFit.coefficients;
            if (1 >= t1.length)
              return H.ioore(t1, 1);
            t1 = t1[1];
            t3 = yFit.coefficients;
            if (1 >= t3.length)
              return H.ioore(t3, 1);
            t3 = t3[1];
            t4 = xFit.confidence;
            t5 = yFit.confidence;
            if (typeof t4 !== "number")
              return t4.$mul();
            if (typeof t5 !== "number")
              return H.iae(t5);
            return R.VelocityEstimate$(t4 * t5, new P.Duration(t2._duration - oldestSample.time._duration), newestSample.point.$sub(0, oldestSample.point), new P.Offset(t1 * 1000, t3 * 1000));
          }
        }
      }
      return R.VelocityEstimate$(1, new P.Duration(t2._duration - oldestSample.time._duration), newestSample.point.$sub(0, oldestSample.point), C.Offset_0_0);
    }
  };
  S.MaterialApp.prototype = {
    createState$0: function() {
      return new S._MaterialAppState(C._StateLifecycle_0);
    },
    onGenerateRoute$1: function(arg0) {
      return null.call$1(arg0);
    },
    onUnknownRoute$1: function(arg0) {
      return null.call$1(arg0);
    },
    builder$2: function(arg0, arg1) {
      return null.call$2(arg0, arg1);
    }
  };
  S._MaterialScrollBehavior.prototype = {};
  S._MaterialAppState.prototype = {
    initState$0: function() {
      var _this = this;
      _this.super$State$initState();
      _this._heroController = new T.HeroController(_this.get$_createRectTween(), P.LinkedHashMap_LinkedHashMap$_empty(P.Object, T._HeroFlight));
      _this._updateNavigator$0();
    },
    didUpdateWidget$1: function(oldWidget) {
      H.interceptedTypeCheck(oldWidget, "$isMaterialApp");
      this.super$State$didUpdateWidget(oldWidget);
      this._widget.toString;
      oldWidget.toString;
      this._updateNavigator$0();
    },
    _updateNavigator$0: function() {
      var t1 = this._widget;
      t1.toString;
      t1 = P.List_List$from(C.List_empty1, true, K.NavigatorObserver);
      C.JSArray_methods.add$1(t1, this._heroController);
      this.set$_navigatorObservers(t1);
    },
    _createRectTween$2: function(begin, end) {
      return new D.MaterialRectArcTween(begin, end);
    },
    get$_localizationsDelegates: function() {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var $async$goto = 0, $async$handler = 1, $async$currentError;
        return function $async$get$_localizationsDelegates($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$self._widget.toString;
                $async$goto = 2;
                return C.C__MaterialLocalizationsDelegate;
              case 2:
                // after yield
                $async$goto = 3;
                return C.C__CupertinoLocalizationsDelegate;
              case 3:
                // after yield
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, [L.LocalizationsDelegate,,]);
    },
    build$1: function(context) {
      var t6, _this = this, _null = null, t1 = {},
        t2 = _this._widget,
        t3 = _this._navigatorObservers,
        t4 = t2.home,
        t5 = t2.title;
      t2 = t2.theme;
      t2 = t2.primaryColor;
      if (t2 == null)
        t2 = C.MaterialColor_Map_JNwaj_4280391411;
      t6 = _this.get$_localizationsDelegates();
      _this._widget.toString;
      t1.result = new S.WidgetsApp(_null, _null, new S._MaterialAppState_build_closure(), t4, C.Map_empty, _null, _null, t3, new S._MaterialAppState_build_closure0(_this), t5, _null, C.TextStyle_8aB, t2, _null, t6, _null, _null, C.List_Locale_en_US, false, false, false, false, new S._MaterialAppState_build_closure1(), true, new N.GlobalObjectKey(_this, [[N.State, N.StatefulWidget]]));
      H.assertHelper(new S._MaterialAppState_build_closure2(t1, _this).call$0());
      return new K.ScrollConfiguration(new S._MaterialScrollBehavior(), t1.result, _null);
    },
    set$_navigatorObservers: function(_navigatorObservers) {
      this._navigatorObservers = H.assertSubtype(_navigatorObservers, "$isList", [K.NavigatorObserver], "$asList");
    },
    $asState: function() {
      return [S.MaterialApp];
    }
  };
  S._MaterialAppState_build_closure.prototype = {
    call$1$2: function(settings, builder, $T) {
      var t1, t2, t3, t4, t5, t6, t7, t8;
      H.interceptedTypeCheck(settings, "$isRouteSettings");
      H.functionTypeCheck(builder, {func: 1, ret: N.Widget, args: [N.BuildContext]});
      t1 = H.setRuntimeTypeInfo([], [{func: 1, ret: [P.Future, P.bool]}]);
      t2 = $.Zone__current;
      t3 = [$T];
      t4 = [$T];
      t5 = S.ProxyAnimation$(C.C__AlwaysDismissedAnimation);
      t6 = H.setRuntimeTypeInfo([], [X.OverlayEntry]);
      t7 = $.Zone__current;
      t8 = settings == null ? C.RouteSettings_null_false_null : settings;
      return new V.MaterialPageRoute(builder, false, t1, new N.LabeledGlobalKey(null, [[T._ModalScopeState, $T]]), new N.LabeledGlobalKey(null, [[N.State, N.StatefulWidget]]), new S.PageStorageBucket(), null, new P._AsyncCompleter(new P._Future(t2, t3), t4), t5, t6, t8, new P._AsyncCompleter(new P._Future(t7, t3), t4), [$T]);
    },
    call$2: function(settings, builder) {
      return this.call$1$2(settings, builder, null);
    },
    $signature: 61
  };
  S._MaterialAppState_build_closure0.prototype = {
    call$2: function(context, child) {
      var t1, platformBrightness, theme;
      H.interceptedTypeCheck(context, "$isBuildContext");
      H.interceptedTypeCheck(child, "$isWidget");
      t1 = F.MediaQuery_of(context, true);
      platformBrightness = t1 == null ? null : t1.platformBrightness;
      if ((platformBrightness == null ? C.Brightness_1 : platformBrightness) === C.Brightness_0)
        this.$this._widget.toString;
      theme = this.$this._widget.theme;
      this.$this._widget.toString;
      return new K.AnimatedTheme(theme, true, child, C.C__Linear, C.Duration_200000, null);
    },
    $signature: 62
  };
  S._MaterialAppState_build_closure1.prototype = {
    call$2: function(context, onPressed) {
      H.interceptedTypeCheck(context, "$isBuildContext");
      return E.FloatingActionButton$(C.Icon_INY, true, H.functionTypeCheck(onPressed, {func: 1, ret: -1}), null);
    },
    $signature: 63
  };
  S._MaterialAppState_build_closure2.prototype = {
    call$0: function() {
      this.$this._widget.toString;
      return true;
    },
    $signature: 0
  };
  E._ToolbarContainerLayout.prototype = {
    getConstraintsForChild$1: function(constraints) {
      return constraints.tighten$1$height(56);
    },
    getSize$1: function(constraints) {
      return new P.Size(constraints.maxWidth, 56);
    },
    getPositionForChild$2: function(size, childSize) {
      var t1 = size._dy,
        t2 = childSize._dy;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return new P.Offset(0, t1 - t2);
    },
    shouldRelayout$1: function(oldDelegate) {
      H.interceptedTypeCheck(oldDelegate, "$is_ToolbarContainerLayout");
      return false;
    }
  };
  E.AppBar.prototype = {
    _getEffectiveCenterTitle$1: function(themeData) {
      var t1 = themeData.platform;
      H.assertHelper(t1 != null);
      switch (t1) {
        case C.TargetPlatform_0:
        case C.TargetPlatform_1:
          return false;
        case C.TargetPlatform_2:
          return true;
      }
      return;
    },
    createState$0: function() {
      return new E._AppBarState(C._StateLifecycle_0);
    },
    $isPreferredSizeWidget: 1
  };
  E._AppBarState.prototype = {
    _handleDrawerButton$0: function() {
      var t1 = M.Scaffold_of(this._element, false),
        t2 = t1._endDrawerKey;
      if (t2.get$currentState() != null && t1._endDrawerOpened)
        t2.get$currentState().close$0();
      t1 = t1._drawerKey.get$currentState();
      if (t1 != null)
        t1.open$0();
    },
    _handleDrawerButtonEnd$0: function() {
      var t1 = M.Scaffold_of(this._element, false),
        t2 = t1._drawerKey;
      if (t2.get$currentState() != null && t1._drawerOpened)
        t2.get$currentState().close$0();
      t1 = t1._endDrawerKey.get$currentState();
      if (t1 != null)
        t1.open$0();
    },
    build$1: function(context) {
      var themeData, appBarTheme, scaffold, parentRoute, t1, t2, t3, overallIconTheme, actionsIconTheme, t4, t5, centerStyle, sideStyle, leading, title, namesRoute, actions, appBar, brightness, overlayStyle, _this = this, _null = null,
        _s20_ = "Open navigation menu";
      _this._widget.toString;
      E.debugCheckHasMediaQuery(context);
      E.debugCheckHasMaterialLocalizations(context);
      themeData = K.Theme_of(context);
      appBarTheme = K.Theme_of(context).appBarTheme;
      scaffold = M.Scaffold_of(context, true);
      parentRoute = T.ModalRoute_of(context, P.Object);
      t1 = scaffold == null;
      if (t1)
        t2 = _null;
      else {
        scaffold._widget.toString;
        t2 = false;
      }
      if (t1)
        t1 = _null;
      else {
        scaffold._widget.toString;
        t1 = false;
      }
      if (parentRoute == null)
        t3 = _null;
      else
        t3 = !parentRoute.get$isFirst() || parentRoute.get$willHandlePopInternally();
      _this._widget.toString;
      overallIconTheme = appBarTheme.iconTheme;
      if (overallIconTheme == null)
        overallIconTheme = themeData.primaryIconTheme;
      actionsIconTheme = appBarTheme.actionsIconTheme;
      if (actionsIconTheme == null)
        actionsIconTheme = overallIconTheme;
      t4 = appBarTheme.textTheme;
      t5 = t4 == null ? _null : t4.title;
      centerStyle = t5;
      if (centerStyle == null)
        centerStyle = themeData.primaryTextTheme.title;
      t4 = t4 == null ? _null : t4.body1;
      sideStyle = t4;
      if (sideStyle == null)
        sideStyle = themeData.primaryTextTheme.body1;
      if (t2 === true) {
        L.Localizations_of(context, C.Type_MaterialLocalizations_flR, U.MaterialLocalizations).toString;
        leading = B.IconButton$(_null, C.Icon_0, _this.get$_handleDrawerButton(), _s20_);
      } else if (t3 === true)
        leading = C.BackButton_null;
      else
        leading = _null;
      if (leading != null)
        leading = T.ConstrainedBox$(leading, C.BoxConstraints_EcO);
      title = _this._widget.title;
      switch (T.defaultTargetPlatform()) {
        case C.TargetPlatform_0:
        case C.TargetPlatform_1:
          namesRoute = true;
          break;
        case C.TargetPlatform_2:
          namesRoute = _null;
          break;
        default:
          namesRoute = _null;
      }
      title = L.DefaultTextStyle$(T.Semantics$(_null, title, false, _null, false, true, _null, namesRoute, _null, _null, _null), _null, C.TextOverflow_2, false, centerStyle, _null);
      _this._widget.toString;
      if (t1 === true) {
        L.Localizations_of(context, C.Type_MaterialLocalizations_flR, U.MaterialLocalizations).toString;
        actions = B.IconButton$(_null, C.Icon_0, _this.get$_handleDrawerButtonEnd(), _s20_);
      } else
        actions = _null;
      if (actions != null)
        actions = Y.IconTheme_merge(actions, actionsIconTheme);
      t1 = _this._widget._getEffectiveCenterTitle$1(themeData);
      _this._widget.toString;
      t1 = T.CustomSingleChildLayout$(Y.IconTheme_merge(L.DefaultTextStyle$(new E.NavigationToolbar(leading, title, actions, t1, 16, _null), _null, C.TextOverflow_0, true, sideStyle, _null), overallIconTheme), C.C__ToolbarContainerLayout);
      appBar = Q.SafeArea$(new T.ClipRect(t1, _null), true);
      appBar = T.Align$(C.Alignment_0_m1, appBar, _null, _null, _null);
      brightness = themeData.primaryColorBrightness;
      overlayStyle = brightness === C.Brightness_0 ? C.SystemUiOverlayStyle_4EL : C.SystemUiOverlayStyle_yjH;
      t1 = appBarTheme.color;
      if (t1 == null)
        t1 = themeData.primaryColor;
      t2 = appBarTheme.elevation;
      if (t2 == null)
        t2 = 4;
      return T.Semantics$(_null, new X.AnnotatedRegion(overlayStyle, M.Material$(C.Duration_200000, T.Semantics$(_null, appBar, false, _null, true, _null, _null, _null, _null, _null, _null), C.Clip_0, t1, t2, _null, _null, _null, C.MaterialType_0), _null, [X.SystemUiOverlayStyle]), true, _null, false, _null, _null, _null, _null, _null, _null);
    },
    $asState: function() {
      return [E.AppBar];
    }
  };
  V.AppBarTheme.prototype = {
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.brightness, _this.color, _this.elevation, _this.iconTheme, _this.actionsIconTheme, _this.textTheme, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isAppBarTheme");
      t1 = J.$eq$(other.color, _this.color) && other.elevation == _this.elevation && J.$eq$(other.iconTheme, _this.iconTheme) && J.$eq$(other.actionsIconTheme, _this.actionsIconTheme) && J.$eq$(other.textTheme, _this.textTheme);
      return t1;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("brightness", _this.brightness, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Brightness);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("color", _this.color, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Color));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("elevation", _this.elevation, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.double));
      t1 = T.IconThemeData;
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("iconTheme", _this.iconTheme, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("actionsIconTheme", _this.actionsIconTheme, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("textTheme", _this.textTheme, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, R.TextTheme));
    }
  };
  D.MaterialPointArcTween.prototype = {
    _initialize$0: function() {
      var delta, t1, deltaX, deltaY, distanceFromAtoB, t2, t3, c, t4, t5, _this = this;
      H.assertHelper(_this.begin != null);
      H.assertHelper(_this.end != null);
      delta = J.$sub$n(_this.end, _this.begin);
      t1 = delta._dx;
      if (typeof t1 !== "number")
        return t1.abs$0();
      deltaX = Math.abs(t1);
      t1 = delta._dy;
      if (typeof t1 !== "number")
        return t1.abs$0();
      deltaY = Math.abs(t1);
      distanceFromAtoB = delta.get$distance();
      t1 = _this.end;
      t2 = t1._dx;
      t3 = _this.begin;
      c = new P.Offset(t2, t3._dy);
      t2 = new D.MaterialPointArcTween__initialize_sweepAngle(_this, distanceFromAtoB);
      if (deltaX > 2 && deltaY > 2) {
        t4 = distanceFromAtoB * distanceFromAtoB;
        if (deltaX < deltaY) {
          t1 = t4 / c.$sub(0, t3).get$distance() / 2;
          _this._arc$_radius = t1;
          t3 = _this.end._dx;
          t4 = _this.begin._dx;
          if (typeof t4 !== "number")
            return t4.$sub();
          if (typeof t3 !== "number")
            return H.iae(t3);
          t4 = J.get$sign$in(t4 - t3);
          t5 = _this.end;
          _this._center = new P.Offset(t3 + t1 * t4, t5._dy);
          t1 = _this.begin._dx;
          t5 = t5._dx;
          if (typeof t1 !== "number")
            return t1.$lt();
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (t1 < t5) {
            t1 = t2.call$0();
            t2 = _this.begin._dy;
            t3 = _this.end._dy;
            if (typeof t2 !== "number")
              return t2.$sub();
            if (typeof t3 !== "number")
              return H.iae(t3);
            _this._beginAngle = H.doubleTypeCheck(J.$mul$ns(t1, J.get$sign$in(t2 - t3)));
            _this._endAngle = 0;
          } else {
            t1 = t2.call$0();
            t2 = _this.end._dy;
            t3 = _this.begin._dy;
            if (typeof t2 !== "number")
              return t2.$sub();
            if (typeof t3 !== "number")
              return H.iae(t3);
            _this._beginAngle = 3.141592653589793 + J.$mul$ns(t1, J.get$sign$in(t2 - t3));
            _this._endAngle = 3.141592653589793;
          }
        } else {
          _this._arc$_radius = t4 / c.$sub(0, t1).get$distance() / 2;
          t1 = _this.begin;
          t3 = t1._dx;
          t1 = t1._dy;
          t4 = _this.end._dy;
          if (typeof t4 !== "number")
            return t4.$sub();
          if (typeof t1 !== "number")
            return H.iae(t1);
          t4 = J.get$sign$in(t4 - t1);
          t5 = _this._arc$_radius;
          if (typeof t5 !== "number")
            return H.iae(t5);
          _this._center = new P.Offset(t3, t1 + t4 * t5);
          t1 = _this.begin._dy;
          t3 = _this.end._dy;
          if (typeof t1 !== "number")
            return t1.$lt();
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (t1 < t3) {
            _this._beginAngle = -1.5707963267948966;
            t1 = t2.call$0();
            t2 = _this.end._dx;
            t3 = _this.begin._dx;
            if (typeof t2 !== "number")
              return t2.$sub();
            if (typeof t3 !== "number")
              return H.iae(t3);
            t3 = J.$mul$ns(t1, J.get$sign$in(t2 - t3));
            if (typeof t3 !== "number")
              return H.iae(t3);
            _this._endAngle = -1.5707963267948966 + t3;
          } else {
            _this._beginAngle = 1.5707963267948966;
            t1 = t2.call$0();
            t2 = _this.begin._dx;
            t3 = _this.end._dx;
            if (typeof t2 !== "number")
              return t2.$sub();
            if (typeof t3 !== "number")
              return H.iae(t3);
            t3 = J.$mul$ns(t1, J.get$sign$in(t2 - t3));
            if (typeof t3 !== "number")
              return H.iae(t3);
            _this._endAngle = 1.5707963267948966 + t3;
          }
        }
        H.assertHelper(_this._beginAngle != null);
        H.assertHelper(_this._endAngle != null);
      } else
        _this._endAngle = _this._beginAngle = null;
      _this._arc$_dirty = false;
    },
    get$center: function() {
      var _this = this;
      if (_this.begin == null || _this.end == null)
        return;
      if (_this._arc$_dirty)
        _this._initialize$0();
      return _this._center;
    },
    get$radius: function() {
      var _this = this;
      if (_this.begin == null || _this.end == null)
        return;
      if (_this._arc$_dirty)
        _this._initialize$0();
      return _this._arc$_radius;
    },
    get$beginAngle: function() {
      var _this = this;
      if (_this.begin == null || _this.end == null)
        return;
      if (_this._arc$_dirty)
        _this._initialize$0();
      return _this._beginAngle;
    },
    get$endAngle: function() {
      var _this = this;
      if (_this.begin == null || _this.end == null)
        return;
      if (_this._arc$_dirty)
        _this._initialize$0();
      return _this._beginAngle;
    },
    set$begin: function(value) {
      H.interceptedTypeCheck(value, "$isOffset");
      if (!J.$eq$(value, this.begin)) {
        this.begin = value;
        this._arc$_dirty = true;
      }
    },
    set$end: function(value) {
      H.interceptedTypeCheck(value, "$isOffset");
      if (!J.$eq$(value, this.end)) {
        this.end = value;
        this._arc$_dirty = true;
      }
    },
    lerp$1: function(t) {
      var t1, angle, t2, t3, t4, _this = this;
      if (_this._arc$_dirty)
        _this._initialize$0();
      if (t === 0)
        return _this.begin;
      if (t === 1)
        return _this.end;
      t1 = _this._beginAngle;
      if (t1 == null || _this._endAngle == null)
        return P.Offset_lerp(_this.begin, _this.end, t);
      angle = P.lerpDouble(t1, _this._endAngle, t);
      t1 = Math.cos(H.checkNum(angle));
      t2 = _this._arc$_radius;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = Math.sin(H.checkNum(angle));
      t4 = _this._arc$_radius;
      if (typeof t4 !== "number")
        return H.iae(t4);
      return _this._center.$add(0, new P.Offset(t1 * t2, t3 * t4));
    },
    toString$0: function(_) {
      var _this = this;
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(" + H.S(_this.begin) + " \u2192 " + H.S(_this.end) + "; center=" + H.S(_this.get$center()) + ", radius=" + H.S(_this.get$radius()) + ", beginAngle=" + H.S(_this.get$beginAngle()) + ", endAngle=" + H.S(_this.get$endAngle()) + ")";
    },
    $asAnimatable: function() {
      return [P.Offset];
    },
    $asTween: function() {
      return [P.Offset];
    }
  };
  D.MaterialPointArcTween__initialize_sweepAngle.prototype = {
    call$0: function() {
      var t1 = this.$this._arc$_radius;
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 2 * Math.asin(this.distanceFromAtoB / (2 * t1));
    },
    $signature: 46
  };
  D._CornerId.prototype = {
    toString$0: function(_) {
      return this._arc$_name;
    }
  };
  D._Diagonal.prototype = {};
  D.MaterialRectArcTween.prototype = {
    _initialize$0: function() {
      var diagonal, t1, t2, _this = this;
      H.assertHelper(_this.begin != null);
      H.assertHelper(_this.end != null);
      diagonal = D._maxBy(C.List_yvP, new D.MaterialRectArcTween__initialize_closure(_this, J.$sub$n(_this.end.get$center(), _this.begin.get$center())), D._Diagonal);
      t1 = _this.begin;
      t2 = diagonal.beginId;
      _this._beginArc = new D.MaterialPointArcTween(_this._cornerFor$2(t1, t2), _this._cornerFor$2(_this.end, t2));
      t2 = _this.begin;
      t1 = diagonal.endId;
      _this._endArc = new D.MaterialPointArcTween(_this._cornerFor$2(t2, t1), _this._cornerFor$2(_this.end, t1));
      _this._arc$_dirty = false;
    },
    _cornerFor$2: function(rect, id) {
      switch (id) {
        case C._CornerId_0:
          return new P.Offset(rect.left, rect.top);
        case C._CornerId_1:
          return new P.Offset(rect.right, rect.top);
        case C._CornerId_2:
          return new P.Offset(rect.left, rect.bottom);
        case C._CornerId_3:
          return new P.Offset(rect.right, rect.bottom);
      }
      return C.Offset_0_0;
    },
    get$beginArc: function() {
      var _this = this;
      if (_this.begin == null)
        return;
      if (_this._arc$_dirty)
        _this._initialize$0();
      return _this._beginArc;
    },
    get$endArc: function() {
      var _this = this;
      if (_this.end == null)
        return;
      if (_this._arc$_dirty)
        _this._initialize$0();
      return _this._endArc;
    },
    set$begin: function(value) {
      H.interceptedTypeCheck(value, "$isRect");
      if (!J.$eq$(value, this.begin)) {
        this.begin = value;
        this._arc$_dirty = true;
      }
    },
    set$end: function(value) {
      H.interceptedTypeCheck(value, "$isRect");
      if (!J.$eq$(value, this.end)) {
        this.end = value;
        this._arc$_dirty = true;
      }
    },
    lerp$1: function(t) {
      var _this = this;
      if (_this._arc$_dirty)
        _this._initialize$0();
      if (t === 0)
        return _this.begin;
      if (t === 1)
        return _this.end;
      return P.Rect$fromPoints(_this._beginArc.lerp$1(t), _this._endArc.lerp$1(t));
    },
    toString$0: function(_) {
      var _this = this;
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(" + H.S(_this.begin) + " \u2192 " + H.S(_this.end) + "; beginArc=" + H.S(_this.get$beginArc()) + ", endArc=" + H.S(_this.get$endArc()) + ")";
    }
  };
  D.MaterialRectArcTween__initialize_closure.prototype = {
    call$1: function(d) {
      var t1, t2, delta, $length, t3, t4;
      H.interceptedTypeCheck(d, "$is_Diagonal");
      t1 = this.$this;
      t2 = this.centersVector;
      delta = t1._cornerFor$2(t1.begin, d.endId).$sub(0, t1._cornerFor$2(t1.begin, d.beginId));
      $length = delta.get$distance();
      t1 = t2._dx;
      t3 = delta._dx;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t2 = t2._dy;
      t4 = delta._dy;
      if (typeof t2 !== "number")
        return t2.$mul();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return t1 * t3 / $length + t2 * t4 / $length;
    },
    $signature: 65
  };
  R.BackButtonIcon.prototype = {
    build$1: function(context) {
      return L.Icon$(R.BackButtonIcon__getIconData(K.Theme_of(context).platform));
    }
  };
  R.BackButton.prototype = {
    build$1: function(context) {
      E.debugCheckHasMaterialLocalizations(context);
      L.Localizations_of(context, C.Type_MaterialLocalizations_flR, U.MaterialLocalizations).toString;
      return B.IconButton$(null, C.BackButtonIcon_null, new R.BackButton_build_closure(context), "Back");
    }
  };
  R.BackButton_build_closure.prototype = {
    call$0: function() {
      K.Navigator_maybePop(this.context, P.Object);
    },
    $signature: 2
  };
  D.BottomAppBarTheme.prototype = {
    get$hashCode: function(_) {
      return P.hashValues(this.color, this.elevation, this.shape, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isBottomAppBarTheme");
      return J.$eq$(other.color, _this.color) && other.elevation == _this.elevation && true;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("color", _this.color, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Color);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("elevation", _this.elevation, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.double));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("shape", _this.shape, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, V.NotchedShape));
    }
  };
  Z.RawMaterialButton.prototype = {
    createState$0: function() {
      return new Z._RawMaterialButtonState(C._StateLifecycle_0);
    },
    onHighlightChanged$1: function(arg0) {
      return null.call$1(arg0);
    },
    get$onHighlightChanged: function() {
      return null;
    },
    get$highlightColor: function() {
      return null;
    },
    get$splashColor: function() {
      return null;
    },
    get$child: function() {
      return this.child;
    }
  };
  Z._RawMaterialButtonState.prototype = {
    _handleHighlightChanged$1: function(value) {
      if (this._highlight !== value)
        this.setState$1(new Z._RawMaterialButtonState__handleHighlightChanged_closure(this, value));
    },
    didUpdateWidget$1: function(oldWidget) {
      var _this = this;
      _this.super$State$didUpdateWidget(H.interceptedTypeCheck(oldWidget, "$isRawMaterialButton"));
      if (_this._highlight && _this._widget.onPressed == null) {
        _this._highlight = false;
        _this._widget.toString;
      }
    },
    build$1: function(context) {
      var elevation, t3, t4, t5, t6, t7, t8, result, minSize, _this = this, _null = null,
        t1 = _this._widget,
        t2 = t1.onPressed;
      if (t2 != null)
        elevation = _this._highlight ? t1.highlightElevation : t1.elevation;
      else
        elevation = t1.disabledElevation;
      t3 = t1.constraints;
      t4 = t1.textStyle;
      t5 = t1.shape;
      t6 = t1.fillColor;
      t7 = t6 == null ? C.MaterialType_4 : C.MaterialType_3;
      t8 = t1.clipBehavior;
      result = T.ConstrainedBox$(M.Material$(C.Duration_200000, new R.InkWell(Y.IconTheme_merge(M.Container$(_null, new T.Center(C.Alignment_0_0, 1, 1, t1.child, _null), _null, _null, _null, C.EdgeInsets_0_0_0_0, _null), new T.IconThemeData(t4.color, _null, _null)), t2, _null, _null, _null, _null, _this.get$_handleHighlightChanged(), true, C.BoxShape_0, _null, _null, t5, _null, _null, _null, true, false, _null), t8, t6, elevation, _null, t5, t4, t7), t3);
      t1 = _this._widget;
      switch (t1.materialTapTargetSize) {
        case C.MaterialTapTargetSize_0:
          minSize = C.Size_48_48;
          break;
        case C.MaterialTapTargetSize_1:
          minSize = C.Size_0_0;
          break;
        default:
          minSize = _null;
      }
      return T.Semantics$(true, new Z._InputPadding(minSize, result, _null), true, t1.onPressed != null, false, _null, _null, _null, _null, _null, _null);
    },
    $asState: function() {
      return [Z.RawMaterialButton];
    }
  };
  Z._RawMaterialButtonState__handleHighlightChanged_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._highlight = this.value;
      t1._widget.toString;
    },
    $signature: 2
  };
  Z._InputPadding.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new Z._RenderInputPadding(this.minSize, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$is_RenderInputPadding").set$minSize(this.minSize);
    }
  };
  Z._RenderInputPadding.prototype = {
    set$minSize: function(value) {
      if (J.$eq$(this._minSize, value))
        return;
      this._minSize = value;
      this.markNeedsLayout$0();
    },
    performLayout$0: function() {
      var t2, height, width, _this = this,
        t1 = _this.RenderObjectWithChildMixin__child;
      if (t1 != null) {
        t1.layout$2$parentUsesSize(K.RenderObject.prototype.get$constraints.call(_this), true);
        t1 = _this.RenderObjectWithChildMixin__child.get$size()._dx;
        t2 = _this._minSize._dx;
        height = Math.max(H.checkNum(t1), H.checkNum(t2));
        t2 = _this.RenderObjectWithChildMixin__child.get$size()._dy;
        t1 = _this._minSize._dy;
        width = Math.max(H.checkNum(t2), H.checkNum(t1));
        _this.set$size(K.RenderObject.prototype.get$constraints.call(_this).constrain$1(new P.Size(height, width)));
        H.interceptedTypeCheck(_this.RenderObjectWithChildMixin__child.parentData, "$isBoxParentData").offset = C.Alignment_0_0.alongOffset$1(H.interceptedTypeCheck(_this.get$size().$sub(0, _this.RenderObjectWithChildMixin__child.get$size()), "$isOffset"));
      } else
        _this.set$size(C.Size_0_0);
    },
    hitTest$2$position: function(result, position) {
      var t1;
      if (!this.super$RenderBox$hitTest(result, position)) {
        t1 = this.RenderObjectWithChildMixin__child;
        t1 = t1.hitTest$2$position(result, t1.get$size().center$1(C.Offset_0_0));
      } else
        t1 = true;
      return t1;
    }
  };
  M.ButtonTextTheme.prototype = {
    toString$0: function(_) {
      return this._button_theme$_name;
    }
  };
  M.ButtonBarLayoutBehavior.prototype = {
    toString$0: function(_) {
      return this._button_theme$_name;
    }
  };
  M.ButtonThemeData.prototype = {
    get$padding: function() {
      var t1 = this._button_theme$_padding;
      if (t1 != null)
        return t1;
      switch (this.textTheme) {
        case C.ButtonTextTheme_0:
        case C.ButtonTextTheme_1:
          return C.EdgeInsets_16_0_16_0;
        case C.ButtonTextTheme_2:
          return C.EdgeInsets_24_0_24_0;
      }
      H.assertHelper(false);
      return C.EdgeInsets_0_0_0_0;
    },
    get$shape: function() {
      var t1 = this._button_theme$_shape;
      if (t1 != null)
        return t1;
      switch (this.textTheme) {
        case C.ButtonTextTheme_0:
        case C.ButtonTextTheme_1:
          return C.RoundedRectangleBorder_yx30;
        case C.ButtonTextTheme_2:
          return C.RoundedRectangleBorder_yx31;
      }
      return C.RoundedRectangleBorder_yx3;
    },
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isButtonThemeData");
      if (_this.textTheme === other.textTheme)
        if (_this.minWidth === other.minWidth)
          if (_this.height === other.height)
            if (J.$eq$(_this.get$padding(), other.get$padding()))
              if (J.$eq$(_this.get$shape(), other.get$shape()))
                if (J.$eq$(_this._buttonColor, other._buttonColor))
                  t1 = J.$eq$(_this.colorScheme, other.colorScheme) && _this._materialTapTargetSize == other._materialTapTargetSize;
                else
                  t1 = false;
              else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.textTheme, _this.minWidth, _this.height, _this.get$padding(), _this.get$shape(), false, _this._buttonColor, _this._disabledColor, _this._highlightColor, _this._splashColor, _this.colorScheme, _this._materialTapTargetSize, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      t1 = properties.properties;
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.textTheme, C.ButtonTextTheme_0, C.DiagnosticLevel_3, "textTheme", true, true, C.DiagnosticsTreeStyle_5, [M.ButtonTextTheme]));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("minWidth", _this.minWidth, 88, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("height", _this.height, 36, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("padding", _this.get$padding(), C.ButtonThemeData_2Vk.get$padding(), _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, V.EdgeInsetsGeometry));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("shape", _this.get$shape(), C.ButtonThemeData_2Vk.get$shape(), _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, Y.ShapeBorder));
      C.JSArray_methods.add$1(t1, Y.FlagProperty$("alignedDropdown", false, _null, "dropdown width matches button", C.DiagnosticLevel_3, false, false));
      t2 = P.Color;
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("buttonColor", _this._buttonColor, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t2));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("disabledColor", _this._disabledColor, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t2));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("highlightColor", _this._highlightColor, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t2));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("splashColor", _this._splashColor, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t2));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("colorScheme", _this.colorScheme, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, A.ColorScheme));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("materialTapTargetSize", _this._materialTapTargetSize, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, X.MaterialTapTargetSize));
    }
  };
  A.CardTheme.prototype = {
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.clipBehavior, _this.color, _this.elevation, _this.margin, _this.shape, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isCardTheme");
      t1 = J.$eq$(other.color, _this.color) && other.elevation == _this.elevation && J.$eq$(other.margin, _this.margin) && J.$eq$(other.shape, _this.shape);
      return t1;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("clipBehavior", _this.clipBehavior, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Clip);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("color", _this.color, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Color));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("elevation", _this.elevation, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.double));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("margin", _this.margin, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, V.EdgeInsetsGeometry));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("shape", _this.shape, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, Y.ShapeBorder));
    }
  };
  K.ChipThemeData.prototype = {
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.backgroundColor, _this.deleteIconColor, _this.disabledColor, _this.selectedColor, _this.secondarySelectedColor, _this.shadowColor, _this.selectedShadowColor, _this.labelPadding, _this.padding, _this.shape, _this.labelStyle, _this.secondaryLabelStyle, _this.brightness, _this.elevation, _this.pressElevation, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isChipThemeData");
      return J.$eq$(other.backgroundColor, _this.backgroundColor) && J.$eq$(other.deleteIconColor, _this.deleteIconColor) && J.$eq$(other.disabledColor, _this.disabledColor) && J.$eq$(other.selectedColor, _this.selectedColor) && J.$eq$(other.secondarySelectedColor, _this.secondarySelectedColor) && J.$eq$(other.shadowColor, _this.shadowColor) && J.$eq$(other.selectedShadowColor, _this.selectedShadowColor) && J.$eq$(other.labelPadding, _this.labelPadding) && J.$eq$(other.padding, _this.padding) && J.$eq$(other.shape, _this.shape) && J.$eq$(other.labelStyle, _this.labelStyle) && J.$eq$(other.secondaryLabelStyle, _this.secondaryLabelStyle) && other.brightness == _this.brightness && other.elevation == _this.elevation && other.pressElevation == _this.pressElevation;
    },
    debugFillProperties$1: function(properties) {
      var defaultTheme, defaultData, t1, t2, t3, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      defaultTheme = X.ThemeData_ThemeData(C.Brightness_1, _null, _null, _null, _null);
      defaultData = K.ChipThemeData_ChipThemeData$fromDefaults(defaultTheme.brightness, defaultTheme.textTheme.body2, defaultTheme.primaryColor);
      t1 = P.Color;
      t2 = Y.DiagnosticsProperty$("backgroundColor", _this.backgroundColor, defaultData.backgroundColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t2);
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("deleteIconColor", _this.deleteIconColor, defaultData.deleteIconColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("disabledColor", _this.disabledColor, defaultData.disabledColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("selectedColor", _this.selectedColor, defaultData.selectedColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("secondarySelectedColor", _this.secondarySelectedColor, defaultData.secondarySelectedColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("shadowColor", _this.shadowColor, defaultData.shadowColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("selectedShadowColor", _this.selectedShadowColor, defaultData.selectedShadowColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      t1 = V.EdgeInsetsGeometry;
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("labelPadding", _this.labelPadding, defaultData.labelPadding, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("padding", _this.padding, defaultData.padding, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("shape", _this.shape, defaultData.shape, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, Y.ShapeBorder));
      t1 = A.TextStyle0;
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("labelStyle", _this.labelStyle, defaultData.labelStyle, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("secondaryLabelStyle", _this.secondaryLabelStyle, defaultData.secondaryLabelStyle, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, new Y.EnumProperty(_null, _null, _null, _null, false, _this.brightness, defaultData.brightness, C.DiagnosticLevel_3, "brightness", true, true, C.DiagnosticsTreeStyle_5, [P.Brightness]));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("elevation", _this.elevation, defaultData.elevation, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("pressElevation", _this.pressElevation, defaultData.pressElevation, _null, C.DiagnosticLevel_3, true, _null, _null));
    }
  };
  A.ColorScheme.prototype = {
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isColorScheme");
      return J.$eq$(other.primary, _this.primary) && J.$eq$(other.primaryVariant, _this.primaryVariant) && J.$eq$(other.secondary, _this.secondary) && J.$eq$(other.secondaryVariant, _this.secondaryVariant) && J.$eq$(other.surface, _this.surface) && J.$eq$(other.background, _this.background) && J.$eq$(other.error, _this.error) && J.$eq$(other.onPrimary, _this.onPrimary) && J.$eq$(other.onSecondary, _this.onSecondary) && J.$eq$(other.onSurface, _this.onSurface) && J.$eq$(other.onBackground, _this.onBackground) && J.$eq$(other.onError, _this.onError) && other.brightness === _this.brightness;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.primary, _this.primaryVariant, _this.secondary, _this.secondaryVariant, _this.surface, _this.background, _this.error, _this.onPrimary, _this.onSecondary, _this.onSurface, _this.onBackground, _this.onError, _this.brightness, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      t1 = P.Color;
      t2 = Y.DiagnosticsProperty$("primary", _this.primary, C.Color_4284612846, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t2);
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("primaryVariant", _this.primaryVariant, C.Color_4281794739, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("secondary", _this.secondary, C.Color_4278442694, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("secondaryVariant", _this.secondaryVariant, C.Color_4278290310, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("surface", _this.surface, C.Color_4294967295, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("background", _this.background, C.Color_4294967295, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("error", _this.error, C.Color_4289724448, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("onPrimary", _this.onPrimary, C.Color_4294967295, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("onSecondary", _this.onSecondary, C.Color_4278190080, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("onSurface", _this.onSurface, C.Color_4278190080, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("onBackground", _this.onBackground, C.Color_4278190080, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("onError", _this.onError, C.Color_4294967295, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("brightness", _this.brightness, C.Brightness_1, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Brightness));
    }
  };
  E.MaterialColor.prototype = {
    $asColorSwatch: function() {
      return [P.int];
    }
  };
  E.debugCheckHasMaterial_closure.prototype = {
    call$0: function() {
      var message, t2, ancestors, _i,
        _s26_ = "No Material widget found.\n",
        t1 = this.context;
      if (!t1.get$widget().$isMaterial && t1.ancestorWidgetOfExactType$1(C.Type_Material_2bi) == null) {
        message = new P.StringBuffer("");
        message._contents = _s26_;
        t2 = _s26_ + (new H.TypeImpl(H.getRti(t1.get$widget())).toString$0(0) + " widgets require a Material widget ancestor.\n");
        message._contents = t2;
        t2 += 'In material design, most widgets are conceptually "printed" on a sheet of material. In Flutter\'s material library, that material is represented by the Material widget. It is the Material widget that renders ink splashes, for instance. Because of this, many material library widgets require that there be a Material widget in the tree above them.\n';
        message._contents = t2;
        t2 += "To introduce a Material widget, you can either directly include one, or use a widget that contains Material itself, such as a Card, Dialog, Drawer, or Scaffold.\n";
        message._contents = t2;
        t2 += "The specific widget that could not find a Material ancestor was:\n";
        message._contents = t2;
        t2 = message._contents = t2 + ("  " + t1.get$widget().toString$0(0) + "\n");
        ancestors = H.setRuntimeTypeInfo([], [N.Widget]);
        t1.visitAncestorElements$1(new E.debugCheckHasMaterial__closure(ancestors));
        t1 = ancestors.length;
        if (t1 !== 0) {
          message._contents = t2 + "The ancestors of this widget were:";
          for (_i = 0; _i < ancestors.length; ancestors.length === t1 || (0, H.throwConcurrentModificationError)(ancestors), ++_i)
            message._contents += "\n  " + ancestors[_i].toString$0(0);
        } else
          message._contents = t2 + 'This widget is the root of the tree, so it has no ancestors, let alone a "Material" ancestor.\n';
        throw H.wrapException(U.FlutterError$(message.toString$0(0)));
      }
      return true;
    },
    $signature: 0
  };
  E.debugCheckHasMaterial__closure.prototype = {
    call$1: function(element) {
      C.JSArray_methods.add$1(this.ancestors, element.get$widget());
      return true;
    },
    $signature: 22
  };
  E.debugCheckHasMaterialLocalizations_closure.prototype = {
    call$0: function() {
      var message, t2, ancestors, _i,
        _s32_ = "No MaterialLocalizations found.\n",
        t1 = this.context;
      if (L.Localizations_of(t1, C.Type_MaterialLocalizations_flR, U.MaterialLocalizations) == null) {
        message = new P.StringBuffer("");
        message._contents = _s32_;
        t2 = _s32_ + (new H.TypeImpl(H.getRti(t1.get$widget())).toString$0(0) + " widgets require MaterialLocalizations to be provided by a Localizations widget ancestor.\n");
        message._contents = t2;
        t2 += "Localizations are used to generate many different messages, labels,and abbreviations which are used by the material library. \n";
        message._contents = t2;
        t2 += "To introduce a MaterialLocalizations, either use a  MaterialApp at the root of your application to include them automatically, or add a Localization widget with a MaterialLocalizations delegate.\n";
        message._contents = t2;
        t2 += "The specific widget that could not find a MaterialLocalizations ancestor was:\n";
        message._contents = t2;
        t2 = message._contents = t2 + ("  " + t1.get$widget().toString$0(0) + "\n");
        ancestors = H.setRuntimeTypeInfo([], [N.Widget]);
        t1.visitAncestorElements$1(new E.debugCheckHasMaterialLocalizations__closure(ancestors));
        t1 = ancestors.length;
        if (t1 !== 0) {
          message._contents = t2 + "The ancestors of this widget were:";
          for (_i = 0; _i < ancestors.length; ancestors.length === t1 || (0, H.throwConcurrentModificationError)(ancestors), ++_i)
            message._contents += "\n  " + ancestors[_i].toString$0(0);
        } else
          message._contents = t2 + 'This widget is the root of the tree, so it has no ancestors, let alone a "Localizations" ancestor.\n';
        throw H.wrapException(U.FlutterError$(message.toString$0(0)));
      }
      return true;
    },
    $signature: 0
  };
  E.debugCheckHasMaterialLocalizations__closure.prototype = {
    call$1: function(element) {
      C.JSArray_methods.add$1(this.ancestors, element.get$widget());
      return true;
    },
    $signature: 22
  };
  Y.DialogTheme.prototype = {
    get$hashCode: function(_) {
      return J.get$hashCode$(this.shape);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isDialogTheme");
      return J.$eq$(other.backgroundColor, _this.backgroundColor) && other.elevation == _this.elevation && J.$eq$(other.shape, _this.shape) && J.$eq$(other.titleTextStyle, _this.titleTextStyle) && J.$eq$(other.contentTextStyle, _this.contentTextStyle);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("backgroundColor", _this.backgroundColor, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Color);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("shape", _this.shape, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, Y.ShapeBorder));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("elevation", _this.elevation, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.double));
      t1 = A.TextStyle0;
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("titleTextStyle", _this.titleTextStyle, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("contentTextStyle", _this.contentTextStyle, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
    }
  };
  Z.DrawerController.prototype = {};
  Z.DrawerControllerState.prototype = {$isTickerProvider: 1,
    $asState: function() {
      return [Z.DrawerController];
    }
  };
  Z._DrawerControllerState_State_SingleTickerProviderStateMixin.prototype = {};
  Z.FlexibleSpaceBarSettings.prototype = {
    updateShouldNotify$1: function(oldWidget) {
      var _this = this;
      H.interceptedTypeCheck(oldWidget, "$isFlexibleSpaceBarSettings");
      return _this.toolbarOpacity !== oldWidget.toolbarOpacity || _this.minExtent !== oldWidget.minExtent || _this.maxExtent !== oldWidget.maxExtent || _this.currentExtent !== oldWidget.currentExtent;
    }
  };
  E._DefaultHeroTag.prototype = {
    toString$0: function(_) {
      return "<default FloatingActionButton tag>";
    }
  };
  E.FloatingActionButton.prototype = {
    build$1: function(context) {
      var t1, foregroundColor, elevation, disabledElevation, highlightElevation, materialTapTargetSize, textStyle, shape, result, _this = this, _null = null,
        theme = K.Theme_of(context),
        floatingActionButtonTheme = theme.floatingActionButtonTheme,
        backgroundColor = floatingActionButtonTheme.backgroundColor;
      if (backgroundColor == null)
        backgroundColor = theme.colorScheme.secondary;
      t1 = floatingActionButtonTheme.foregroundColor;
      foregroundColor = t1 == null ? theme.accentIconTheme.color : t1;
      if (foregroundColor == null)
        foregroundColor = theme.colorScheme.onSecondary;
      elevation = floatingActionButtonTheme.elevation;
      if (elevation == null)
        elevation = 6;
      disabledElevation = floatingActionButtonTheme.disabledElevation;
      if (disabledElevation == null)
        disabledElevation = elevation;
      highlightElevation = floatingActionButtonTheme.highlightElevation;
      if (highlightElevation == null)
        highlightElevation = 12;
      materialTapTargetSize = theme.materialTapTargetSize;
      textStyle = theme.accentTextTheme.button.copyWith$2$color$letterSpacing(foregroundColor, 1.2);
      shape = floatingActionButtonTheme.shape;
      if (shape == null)
        shape = C.CircleBorder_61T;
      result = Y.IconTheme_merge(_this.child, new T.IconThemeData(foregroundColor, _null, _null));
      result = new Z.RawMaterialButton(_this.onPressed, textStyle, backgroundColor, elevation, highlightElevation, disabledElevation, _this._sizeConstraints, shape, result, materialTapTargetSize, C.Clip_0, _null);
      t1 = _this.tooltip;
      if (t1 != null)
        result = new T.MergeSemantics(S.Tooltip$(result, t1), _null);
      return new T.Hero(C.C__DefaultHeroTag, result, _null);
    }
  };
  A.FloatingActionButtonLocation.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    }
  };
  A._EndFloatFloatingActionButtonLocation.prototype = {
    getOffset$1: function(scaffoldGeometry) {
      var fabY,
        fabX = A._endOffset(scaffoldGeometry),
        contentBottom = scaffoldGeometry.contentBottom,
        bottomSheetHeight = scaffoldGeometry.bottomSheetSize._dy,
        fabHeight = scaffoldGeometry.floatingActionButtonSize._dy,
        snackBarHeight = scaffoldGeometry.snackBarSize._dy;
      if (typeof fabHeight !== "number")
        return H.iae(fabHeight);
      fabY = contentBottom - fabHeight - 16;
      if (typeof snackBarHeight !== "number")
        return snackBarHeight.$gt();
      if (snackBarHeight > 0)
        fabY = Math.min(fabY, contentBottom - snackBarHeight - fabHeight - 16);
      if (typeof bottomSheetHeight !== "number")
        return bottomSheetHeight.$gt();
      return new P.Offset(fabX, bottomSheetHeight > 0 ? Math.min(fabY, contentBottom - bottomSheetHeight - fabHeight / 2) : fabY);
    },
    toString$0: function(_) {
      return "FloatingActionButtonLocation.endFloat";
    }
  };
  A.FloatingActionButtonAnimator.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    }
  };
  A._ScalingFabMotionAnimator.prototype = {
    getOffset$3$begin$end$progress: function(begin, end, progress) {
      if (typeof progress !== "number")
        return progress.$lt();
      if (progress < 0.5)
        return begin;
      else
        return end;
    }
  };
  A._AnimationSwap.prototype = {
    get$value: function() {
      var _this = this,
        t1 = _this.parent._animation_controller$_value;
      if (typeof t1 !== "number")
        return t1.$lt();
      return t1 < _this.swapThreshold ? _this.first.get$value() : _this.next.get$value();
    }
  };
  S.FloatingActionButtonThemeData.prototype = {
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.backgroundColor, _this.foregroundColor, _this.elevation, _this.disabledElevation, _this.highlightElevation, _this.shape, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isFloatingActionButtonThemeData");
      return J.$eq$(other.backgroundColor, _this.backgroundColor) && J.$eq$(other.foregroundColor, _this.foregroundColor) && other.elevation == _this.elevation && other.disabledElevation == _this.disabledElevation && other.highlightElevation == _this.highlightElevation && J.$eq$(other.shape, _this.shape);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      t1 = P.Color;
      t2 = Y.DiagnosticsProperty$("backgroundColor", _this.backgroundColor, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t2);
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("foregroundColor", _this.foregroundColor, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      t1 = P.double;
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("elevation", _this.elevation, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("disabledElevation", _this.disabledElevation, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("highlightElevation", _this.highlightElevation, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("shape", _this.shape, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, Y.ShapeBorder));
    }
  };
  B.IconButton.prototype = {
    build$1: function(context) {
      var result, t1, t2, t3, t4, t5, _this = this, _null = null;
      E.debugCheckHasMaterial(context);
      result = S.Tooltip$(T.Semantics$(true, T.ConstrainedBox$(T.Padding$(new T.SizedBox(24, 24, T.Align$(C.Alignment_0_0, Y.IconTheme_merge(_this.icon, new T.IconThemeData(_this.color, _null, 24)), _null, _null, _null), _null), C.EdgeInsets_8_8_8_8), C.BoxConstraints_mlX), false, true, false, _null, _null, _null, _null, _null, _null), _this.tooltip);
      t1 = K.Theme_of(context).highlightColor;
      t2 = K.Theme_of(context).splashColor;
      t3 = C.EdgeInsets_8_8_8_8.get$horizontal();
      t4 = C.EdgeInsets_8_8_8_8.get$_top();
      t5 = C.EdgeInsets_8_8_8_8.get$_bottom();
      if (typeof t4 !== "number")
        return t4.$add();
      if (typeof t5 !== "number")
        return H.iae(t5);
      return R.InkResponse$(_null, result, false, _null, true, false, t1, C.BoxShape_1, _null, _null, _null, _null, _this.onPressed, _null, _null, Math.max(35, (24 + Math.min(t3, t4 + t5)) * 0.7), t2, _null);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("icon", _this.icon, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_5, _null, N.Widget);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.ObjectFlagProperty$("onPressed", _this.onPressed, "disabled", {func: 1, ret: -1}));
      C.JSArray_methods.add$1(t2, Y.StringProperty$("tooltip", _this.tooltip, _null, false, true));
    }
  };
  Y.InkHighlight.prototype = {
    _handleAlphaStatusChanged$1: function($status) {
      if (H.interceptedTypeCheck($status, "$isAnimationStatus") === C.AnimationStatus_0 && !this._ink_highlight$_active) {
        this._ink_highlight$_alphaController.dispose$0();
        this.super$InkFeature$dispose();
      }
    },
    dispose$0: function() {
      this._ink_highlight$_alphaController.dispose$0();
      this.super$InkFeature$dispose();
    },
    _paintHighlight$3: function(canvas, rect, paint) {
      var t1, _this = this;
      canvas.save$0();
      t1 = _this._customBorder;
      if (t1 != null)
        canvas.clipPath$1(t1.getOuterPath$2$textDirection(rect, _this._ink_highlight$_textDirection));
      switch (_this._shape) {
        case C.BoxShape_1:
          canvas.drawCircle$3(rect.get$center(), 35, paint);
          break;
        case C.BoxShape_0:
          t1 = _this._borderRadius;
          if (!t1.$eq(0, C.BorderRadius_tLn))
            canvas.drawRRect$2(P.RRect$fromRectAndCorners(rect, t1.bottomLeft, t1.bottomRight, t1.topLeft, t1.topRight), paint);
          else
            canvas.drawRect$2(rect, paint);
          break;
      }
      canvas.restore$0();
    },
    paintFeature$2: function(canvas, transform) {
      var originOffset, rect, _this = this,
        paint = new P.Paint(new DataView(new ArrayBuffer(75))),
        t1 = _this._ink_well$_color,
        t2 = _this._ink_highlight$_alpha;
      t2 = t2._evaluatable.transform$1(H.assertSubtype(t2.parent, "$isAnimation", [P.double], "$asAnimation").get$value());
      t1.toString;
      H.intTypeCheck(t2);
      t1 = t1.value;
      paint.set$color(P.Color$fromARGB(t2, (16711680 & t1) >>> 16, (65280 & t1) >>> 8, (255 & t1) >>> 0));
      originOffset = T.MatrixUtils_getAsTranslation(transform);
      t1 = _this.referenceBox.get$size();
      t2 = t1._dx;
      t1 = t1._dy;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (typeof t1 !== "number")
        return H.iae(t1);
      rect = new P.Rect(0, 0, 0 + t2, 0 + t1);
      if (originOffset == null) {
        canvas.save$0();
        canvas.transform$1(transform._m4storage);
        _this._paintHighlight$3(canvas, rect, paint);
        canvas.restore$0();
      } else
        _this._paintHighlight$3(canvas, rect.shift$1(originOffset), paint);
    },
    set$_ink_highlight$_alpha: function(_alpha) {
      this._ink_highlight$_alpha = H.assertSubtype(_alpha, "$isAnimation", [P.int], "$asAnimation");
    }
  };
  U._getClipCallback_closure.prototype = {
    call$0: function() {
      var t1 = this.referenceBox.get$size(),
        t2 = t1._dx;
      t1 = t1._dy;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return new P.Rect(0, 0, 0 + t2, 0 + t1);
    },
    $signature: 68
  };
  U._InkSplashFactory.prototype = {};
  U.InkSplash.prototype = {
    confirm$0: function() {
      var duration = C.JSDouble_methods.floor$0(this._targetRadius / 1),
        t1 = this._radiusController;
      t1.duration = P.Duration$(0, duration, 0);
      t1.forward$0();
      this._alphaController.forward$0();
    },
    _ink_splash$_handleAlphaStatusChanged$1: function($status) {
      if (H.interceptedTypeCheck($status, "$isAnimationStatus") === C.AnimationStatus_3)
        this.dispose$0();
    },
    dispose$0: function() {
      var _this = this;
      _this._radiusController.dispose$0();
      _this._alphaController.dispose$0();
      _this._alphaController = null;
      _this.super$InkFeature$dispose();
    },
    paintFeature$2: function(canvas, transform) {
      var center, originOffset, rect, _this = this,
        paint = new P.Paint(new DataView(new ArrayBuffer(75))),
        t1 = _this._ink_well$_color,
        t2 = _this._ink_splash$_alpha,
        t3 = [P.double];
      t2 = t2._evaluatable.transform$1(H.assertSubtype(t2.parent, "$isAnimation", t3, "$asAnimation").get$value());
      t1.toString;
      H.intTypeCheck(t2);
      t1 = t1.value;
      paint.set$color(P.Color$fromARGB(t2, (16711680 & t1) >>> 16, (65280 & t1) >>> 8, (255 & t1) >>> 0));
      center = _this._ink_splash$_position;
      if (_this._repositionToReferenceBox)
        center = P.Offset_lerp(center, _this.referenceBox.get$size().center$1(C.Offset_0_0), _this._radiusController._animation_controller$_value);
      originOffset = T.MatrixUtils_getAsTranslation(transform);
      canvas.save$0();
      if (originOffset == null)
        canvas.transform$1(transform._m4storage);
      else
        canvas.translate$2(originOffset._dx, originOffset._dy);
      t1 = _this._clipCallback;
      if (t1 != null) {
        rect = t1.call$0();
        t1 = _this._ink_splash$_customBorder;
        if (t1 != null)
          canvas.clipPath$1(t1.getOuterPath$2$textDirection(rect, _this._ink_splash$_textDirection));
        else {
          t1 = _this._ink_splash$_borderRadius;
          if (!t1.$eq(0, C.BorderRadius_tLn))
            canvas.clipRRect$1(P.RRect$fromRectAndCorners(rect, t1.bottomLeft, t1.bottomRight, t1.topLeft, t1.topRight));
          else
            canvas.clipRect$1(rect);
        }
      }
      t1 = _this._radius;
      canvas.drawCircle$3(center, t1._evaluatable.transform$1(H.assertSubtype(t1.parent, "$isAnimation", t3, "$asAnimation").get$value()), paint);
      canvas.restore$0();
    },
    set$_radius: function(_radius) {
      this._radius = H.assertSubtype(_radius, "$isAnimation", [P.double], "$asAnimation");
    },
    set$_ink_splash$_alpha: function(_alpha) {
      this._ink_splash$_alpha = H.assertSubtype(_alpha, "$isAnimation", [P.int], "$asAnimation");
    }
  };
  R.InteractiveInkFeature.prototype = {
    set$color: function(value) {
      if (J.$eq$(value, this._ink_well$_color))
        return;
      this._ink_well$_color = value;
      this._material$_controller.markNeedsPaint$0();
    }
  };
  R.InteractiveInkFeatureFactory.prototype = {};
  R.InkResponse.prototype = {
    getRectCallback$1: function(referenceBox) {
      return;
    },
    debugCheckContext$1: function(context) {
      E.debugCheckHasMaterial(context);
      E.debugCheckHasDirectionality(context);
      return true;
    },
    createState$0: function() {
      return new R._InkResponseState(null, C._StateLifecycle_0, [R.InkResponse]);
    },
    debugFillProperties$1: function(properties) {
      var t1, gestures, t2, t3, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      t1 = P.String;
      gestures = H.setRuntimeTypeInfo([], [t1]);
      if (_this.onTap != null)
        C.JSArray_methods.add$1(gestures, "tap");
      t1 = Y.IterableProperty$("gestures", gestures, C.C__NoDefaultValue, "<none>", C.DiagnosticLevel_3, C.DiagnosticsTreeStyle_5, t1);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      t1 = _this.containedInkWell;
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("containedInkWell", t1, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_1, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.bool));
      t3 = _this.highlightShape;
      t1 = t1 ? "clipped to " : "";
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("highlightShape", t3, C.C__NoDefaultValue, t1 + t3.toString$0(0), _null, _null, C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_5, _null, F.BoxShape));
    },
    onTap$0: function() {
      return this.onTap.call$0();
    },
    onHighlightChanged$1: function(arg0) {
      return this.onHighlightChanged.call$1(arg0);
    },
    get$child: function() {
      return this.child;
    },
    get$onTap: function() {
      return this.onTap;
    },
    get$onTapDown: function() {
      return this.onTapDown;
    },
    get$onTapCancel: function() {
      return this.onTapCancel;
    },
    get$onDoubleTap: function() {
      return this.onDoubleTap;
    },
    get$onLongPress: function() {
      return this.onLongPress;
    },
    get$onHighlightChanged: function() {
      return this.onHighlightChanged;
    },
    get$containedInkWell: function() {
      return this.containedInkWell;
    },
    get$highlightShape: function() {
      return this.highlightShape;
    },
    get$radius: function() {
      return this.radius;
    },
    get$borderRadius: function() {
      return this.borderRadius;
    },
    get$customBorder: function() {
      return this.customBorder;
    },
    get$highlightColor: function() {
      return this.highlightColor;
    },
    get$splashColor: function() {
      return this.splashColor;
    },
    get$splashFactory: function() {
      return this.splashFactory;
    },
    get$enableFeedback: function() {
      return this.enableFeedback;
    },
    get$excludeFromSemantics: function() {
      return this.excludeFromSemantics;
    }
  };
  R._InkResponseState.prototype = {
    get$wantKeepAlive: function() {
      if (this._lastHighlight == null) {
        var t1 = this._splashes;
        t1 = t1 != null && t1._collection$_length !== 0;
      } else
        t1 = true;
      return t1;
    },
    updateHighlight$1: function(value) {
      var referenceBox, result, t3, t4, t5, t6, _this = this,
        t1 = _this._lastHighlight,
        t2 = t1 == null;
      if (value === (!t2 && t1._ink_highlight$_active))
        return;
      if (value)
        if (t2) {
          referenceBox = H.interceptedTypeCheck(_this._element.get$renderObject(), "$isRenderBox");
          result = H.interceptedTypeCheck(_this._element.ancestorRenderObjectOfType$1(C.C_TypeMatcher0), "$is_RenderInkFeatures");
          t1 = _this._widget.get$highlightColor();
          if (t1 == null)
            t1 = K.Theme_of(_this._element).highlightColor;
          t2 = _this._widget.get$highlightShape();
          t3 = _this._widget.get$borderRadius();
          t4 = _this._widget.get$customBorder();
          t5 = _this._widget.getRectCallback$1(referenceBox);
          t6 = T.Directionality_of(_this._element);
          if (t3 == null)
            t3 = C.BorderRadius_tLn;
          t6 = new Y.InkHighlight(t2, t3, t4, t5, t6, t1, result, referenceBox, _this.get$_handleInkHighlightRemoval());
          t5 = G.AnimationController$(null, C.Duration_200000, 0, 1, null, result.vsync);
          t4 = H.functionTypeCheck(result.get$markNeedsPaint(), {func: 1, ret: -1});
          t5.didRegisterListener$0();
          t3 = t5.AnimationLocalListenersMixin__listeners;
          H.assertSubtypeOfRuntimeType(t4, H.getTypeArgumentByIndex(t3, 0));
          t3._isDirty = true;
          C.JSArray_methods.add$1(t3._list, t4);
          t5.addStatusListener$1(t6.get$_handleAlphaStatusChanged());
          t5.forward$0();
          t6._ink_highlight$_alphaController = t5;
          t6.set$_ink_highlight$_alpha(t5.drive$1$1(new R.IntTween(0, (4278190080 & t1.value) >>> 24), P.int));
          result.addInkFeature$1(t6);
          _this._lastHighlight = t6;
          _this.updateKeepAlive$0();
        } else {
          t1._ink_highlight$_active = true;
          t1._ink_highlight$_alphaController.forward$0();
        }
      else {
        t1._ink_highlight$_active = false;
        t1._ink_highlight$_alphaController.reverse$0();
      }
      t1 = _this._lastHighlight;
      H.assertHelper(value === (t1 != null && t1._ink_highlight$_active));
      if (_this._widget.get$onHighlightChanged() != null)
        _this._widget.onHighlightChanged$1(value);
    },
    _handleInkHighlightRemoval$0: function() {
      H.assertHelper(this._lastHighlight != null);
      this._lastHighlight = null;
      this.updateKeepAlive$0();
    },
    _createInkFeature$1: function(details) {
      var rectCallback, borderRadius, customBorder, t2, t3, t4, t5, t6, t7, splash, _this = this, _null = null, t1 = {},
        result = H.interceptedTypeCheck(_this._element.ancestorRenderObjectOfType$1(C.C_TypeMatcher0), "$is_RenderInkFeatures"),
        referenceBox = H.interceptedTypeCheck(_this._element.get$renderObject(), "$isRenderBox"),
        position = referenceBox.globalToLocal$1(details.globalPosition),
        color = _this._widget.get$splashColor();
      if (color == null)
        color = K.Theme_of(_this._element).splashColor;
      rectCallback = _this._widget.get$containedInkWell() ? _this._widget.getRectCallback$1(referenceBox) : _null;
      borderRadius = _this._widget.get$borderRadius();
      customBorder = _this._widget.get$customBorder();
      t1.splash = null;
      _this._widget.get$splashFactory();
      K.Theme_of(_this._element).splashFactory;
      t2 = _this._widget.get$containedInkWell();
      t3 = _this._widget.get$radius();
      t4 = T.Directionality_of(_this._element);
      t5 = {func: 1, ret: -1};
      t6 = H.functionTypeCheck(new R._InkResponseState__createInkFeature_onRemoved(t1, _this), t5);
      t7 = borderRadius == null ? C.BorderRadius_tLn : borderRadius;
      if (t3 == null)
        t3 = U._getTargetRadius(referenceBox, t2, rectCallback, position);
      splash = new U.InkSplash(position, t7, customBorder, t3, U._getClipCallback(referenceBox, t2, rectCallback), !t2, t4, color, result, referenceBox, t6);
      t6 = result.vsync;
      t4 = G.AnimationController$(_null, C.Duration_1000000, 0, 1, _null, t6);
      t5 = H.functionTypeCheck(result.get$markNeedsPaint(), t5);
      t4.didRegisterListener$0();
      t2 = t4.AnimationLocalListenersMixin__listeners;
      H.assertSubtypeOfRuntimeType(t5, H.getTypeArgumentByIndex(t2, 0));
      t2._isDirty = true;
      C.JSArray_methods.add$1(t2._list, t5);
      t4.forward$0();
      splash._radiusController = t4;
      t2 = P.double;
      splash.set$_radius(t4.drive$1$1(new R.Tween(0, t3, [t2]), t2));
      t6 = G.AnimationController$(_null, C.Duration_200000, 0, 1, _null, t6);
      t6.didRegisterListener$0();
      t2 = t6.AnimationLocalListenersMixin__listeners;
      H.assertSubtypeOfRuntimeType(t5, H.getTypeArgumentByIndex(t2, 0));
      t2._isDirty = true;
      C.JSArray_methods.add$1(t2._list, t5);
      t6.addStatusListener$1(splash.get$_ink_splash$_handleAlphaStatusChanged());
      splash._alphaController = t6;
      splash.set$_ink_splash$_alpha(t6.drive$1$1(new R.IntTween((4278190080 & color.value) >>> 24, 0), P.int));
      result.addInkFeature$1(splash);
      return t1.splash = splash;
    },
    _handleTapDown$1: function(details) {
      var _this = this,
        splash = _this._createInkFeature$1(details);
      if (_this._splashes == null)
        _this.set$_splashes(P.HashSet_HashSet(R.InteractiveInkFeature));
      _this._splashes.add$1(0, splash);
      _this._currentSplash = splash;
      _this._widget.get$onTapDown();
      _this.updateKeepAlive$0();
      _this.updateHighlight$1(true);
    },
    _handleTapCancel$0: function() {
      var _this = this,
        t1 = _this._currentSplash;
      if (t1 != null) {
        t1 = t1._alphaController;
        if (t1 != null)
          t1.forward$0();
      }
      _this._currentSplash = null;
      _this._widget.get$onTapCancel();
      _this.updateHighlight$1(false);
    },
    deactivate$0: function() {
      var _this = this,
        t1 = _this._splashes;
      if (t1 != null) {
        _this.set$_splashes(null);
        for (t1 = new P._HashSetIterator(t1, t1._computeElements$0(), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
          t1._collection$_current.dispose$0();
        _this._currentSplash = null;
      }
      H.assertHelper(_this._currentSplash == null);
      t1 = _this._lastHighlight;
      if (t1 != null) {
        t1._ink_highlight$_alphaController.dispose$0();
        t1.super$InkFeature$dispose();
      }
      _this._lastHighlight = null;
      _this.super$__InkResponseState_State_AutomaticKeepAliveClientMixin$deactivate();
    },
    build$1: function(context) {
      var themeData, t1, t2, enabled, t3, _this = this, _null = null;
      _this._widget.debugCheckContext$1(context);
      _this.super$AutomaticKeepAliveClientMixin$build(context);
      themeData = K.Theme_of(context);
      t1 = _this._lastHighlight;
      if (t1 != null) {
        t2 = _this._widget.get$highlightColor();
        t1.set$color(t2 == null ? themeData.highlightColor : t2);
      }
      t1 = _this._currentSplash;
      if (t1 != null) {
        t2 = _this._widget.get$splashColor();
        t1.set$color(t2 == null ? themeData.splashColor : t2);
      }
      if (_this._widget.get$onTap() == null) {
        _this._widget.get$onDoubleTap();
        _this._widget.get$onLongPress();
        enabled = false;
      } else
        enabled = true;
      t1 = enabled ? _this.get$_handleTapDown() : _null;
      t2 = enabled ? new R._InkResponseState_build_closure(_this, context) : _null;
      t3 = enabled ? _this.get$_handleTapCancel() : _null;
      _this._widget.get$onDoubleTap();
      _this._widget.get$onLongPress();
      return D.GestureDetector$(C.HitTestBehavior_1, _this._widget.get$child(), C.DragStartBehavior_1, _this._widget.get$excludeFromSemantics(), _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, t2, t3, t1, _null, _null);
    },
    set$_splashes: function(_splashes) {
      this._splashes = H.assertSubtype(_splashes, "$isSet", [R.InteractiveInkFeature], "$asSet");
    }
  };
  R._InkResponseState__createInkFeature_onRemoved.prototype = {
    call$0: function() {
      var t3,
        t1 = this.$this,
        t2 = t1._splashes;
      if (t2 != null) {
        t3 = this._box_0;
        H.assertHelper(t2.contains$1(0, t3.splash));
        t1._splashes.remove$1(0, t3.splash);
        if (t1._currentSplash == t3.splash)
          t1._currentSplash = null;
        t1.updateKeepAlive$0();
      }
    },
    $signature: 1
  };
  R._InkResponseState_build_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._currentSplash;
      if (t2 != null)
        t2.confirm$0();
      t1._currentSplash = null;
      t1.updateHighlight$1(false);
      if (t1._widget.get$onTap() != null) {
        t1._widget.get$enableFeedback();
        M.Feedback_forTap(this.context);
        t1._widget.onTap$0();
      }
      return;
    },
    $signature: 1
  };
  R.InkWell.prototype = {};
  R.__InkResponseState_State_AutomaticKeepAliveClientMixin.prototype = {
    initState$0: function() {
      this.super$State$initState();
      if (this.get$wantKeepAlive())
        this._ensureKeepAlive$0();
    },
    deactivate$0: function() {
      var t1 = this.AutomaticKeepAliveClientMixin__keepAliveHandle;
      if (t1 != null) {
        t1.notifyListeners$0();
        this.AutomaticKeepAliveClientMixin__keepAliveHandle = null;
      }
      this.super$State$deactivate();
    }
  };
  F.InputBorder.prototype = {};
  L.InputDecorationTheme.prototype = {
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _null = null;
      this.super$Diagnosticable$debugFillProperties(properties);
      t1 = A.TextStyle0;
      t2 = Y.DiagnosticsProperty$("labelStyle", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t2);
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("helperStyle", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("hintStyle", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("errorStyle", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("errorMaxLines", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.int));
      t2 = P.bool;
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("hasFloatingPlaceholder", true, true, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t2));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("isDense", false, false, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t2));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("contentPadding", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, V.EdgeInsetsGeometry));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("isCollapsed", false, false, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t2));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("prefixStyle", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("suffixStyle", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("counterStyle", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("filled", false, false, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t2));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("fillColor", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Color));
      t1 = F.InputBorder;
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("errorBorder", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("focusedBorder", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("focusedErrorBorder", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("disabledBorder", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("enabledBorder", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("border", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("alignLabelWithHint", false, false, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t2));
    }
  };
  M.MaterialType.prototype = {
    toString$0: function(_) {
      return this._material$_name;
    }
  };
  M.Material.prototype = {
    createState$0: function() {
      return new M._MaterialState(new N.LabeledGlobalKey("ink renderer", [[N.State, N.StatefulWidget]]), null, C._StateLifecycle_0);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      t1 = properties.properties;
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.type, C.C__NoDefaultValue, C.DiagnosticLevel_3, "type", true, true, C.DiagnosticsTreeStyle_5, [M.MaterialType]));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("elevation", _this.elevation, 0, _null, C.DiagnosticLevel_3, true, _null, _null));
      t2 = P.Color;
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("color", _this.color, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t2));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("shadowColor", C.Color_4278190080, C.Color_4278190080, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t2));
      t2 = _this.textStyle;
      if (t2 != null)
        t2.debugFillProperties$2$prefix(properties, "textStyle.");
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("shape", _this.shape, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, Y.ShapeBorder));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("borderOnForeground", true, true, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.bool));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("borderRadius", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.BorderRadiusGeometry));
    },
    get$child: function() {
      return this.child;
    },
    get$borderRadius: function() {
      return null;
    }
  };
  M._MaterialState.prototype = {
    _getBackgroundColor$1: function(context) {
      var t1 = this._widget,
        t2 = t1.color;
      if (t2 != null)
        return t2;
      switch (t1.type) {
        case C.MaterialType_0:
          return K.Theme_of(context).canvasColor;
        case C.MaterialType_1:
          return K.Theme_of(context).cardColor;
        default:
          return;
      }
    },
    build$1: function(context) {
      var t1, contents, t2, t3, t4, shape, _this = this,
        backgroundColor = _this._getBackgroundColor$1(context);
      if (H.assertTest(backgroundColor != null || _this._widget.type === C.MaterialType_4))
        H.assertThrow("If Material type is not MaterialType.transparency, a color must either be passed in through the `color` property, or be defined in the theme (ex. canvasColor != null if type is set to MaterialType.canvas)");
      t1 = _this._widget;
      contents = t1.child;
      t1 = t1.textStyle;
      if (t1 == null)
        t1 = K.Theme_of(context).textTheme.body1;
      t2 = _this._widget;
      contents = new G.AnimatedDefaultTextStyle(contents, t1, C.C__Linear, t2.animationDuration, null);
      t1 = t2;
      contents = U.NotificationListener$(new M._InkFeatures(backgroundColor, _this, contents, _this._inkFeatureRenderer), new M._MaterialState_build_closure(_this), U.LayoutChangedNotification);
      if (t1.type === C.MaterialType_0)
        if (t1.shape == null) {
          t1.toString;
          t2 = true;
        } else
          t2 = false;
      else
        t2 = false;
      if (t2) {
        t2 = t1.animationDuration;
        t3 = t1.clipBehavior;
        t4 = t1.elevation;
        t1.toString;
        return new G.AnimatedPhysicalModel(contents, C.BoxShape_0, t3, C.BorderRadius_tLn, t4, backgroundColor, false, C.Color_4278190080, C.Cubic_ifx, t2, null);
      }
      shape = _this._getShape$0();
      t1 = _this._widget;
      if (t1.type === C.MaterialType_4)
        return M._MaterialState__transparentInterior(t1.clipBehavior, contents, context, shape);
      t2 = t1.animationDuration;
      return new M._MaterialInterior(contents, shape, true, t1.clipBehavior, t1.elevation, backgroundColor, C.Color_4278190080, C.Cubic_ifx, t2, null);
    },
    _getShape$0: function() {
      var t1 = this._widget,
        t2 = t1.shape;
      if (t2 != null)
        return t2;
      t1 = t1.type;
      switch (t1) {
        case C.MaterialType_0:
        case C.MaterialType_4:
          return C.RoundedRectangleBorder_yx3;
        case C.MaterialType_1:
        case C.MaterialType_3:
          t1 = $.$get$kMaterialEdges().$index(0, t1);
          return X.RoundedRectangleBorder$(t1, C.BorderSide_m7u);
        case C.MaterialType_2:
          return C.CircleBorder_61T;
      }
      return C.RoundedRectangleBorder_yx3;
    },
    $isTickerProvider: 1,
    $asState: function() {
      return [M.Material];
    },
    $asTickerProviderStateMixin: function() {
      return [M.Material];
    }
  };
  M._MaterialState_build_closure.prototype = {
    call$1: function(notification) {
      var renderer, t1;
      H.interceptedTypeCheck(notification, "$isLayoutChangedNotification");
      renderer = H.interceptedTypeCheck($.GlobalKey__registry.$index(0, this.$this._inkFeatureRenderer).get$renderObject(), "$is_RenderInkFeatures");
      t1 = renderer._inkFeatures;
      if (t1 != null && t1.length !== 0)
        renderer.markNeedsPaint$0();
      return true;
    },
    $signature: 70
  };
  M._RenderInkFeatures.prototype = {
    addInkFeature$1: function(feature) {
      var t1, _this = this;
      H.assertHelper(!feature._debugDisposed);
      H.assertHelper(feature._material$_controller === _this);
      if (_this._inkFeatures == null)
        _this.set$_inkFeatures(H.setRuntimeTypeInfo([], [M.InkFeature]));
      t1 = _this._inkFeatures;
      H.assertHelper(!(t1 && C.JSArray_methods).contains$1(t1, feature));
      t1 = _this._inkFeatures;
      (t1 && C.JSArray_methods).add$1(t1, feature);
      _this.markNeedsPaint$0();
    },
    hitTestSelf$1: function(position) {
      return true;
    },
    paint$2: function(context, offset) {
      var canvas, t2, _i, _this = this,
        t1 = _this._inkFeatures;
      if (t1 != null && t1.length !== 0) {
        canvas = context.get$canvas();
        canvas.save$0();
        canvas.translate$2(offset._dx, offset._dy);
        t1 = _this.get$size();
        t2 = t1._dx;
        t1 = t1._dy;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (typeof t1 !== "number")
          return H.iae(t1);
        canvas.clipRect$1(new P.Rect(0, 0, 0 + t2, 0 + t1));
        for (t1 = _this._inkFeatures, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          t1[_i]._paint$1(canvas);
        canvas.restore$0();
      }
      _this.super$RenderProxyBoxMixin$paint(context, offset);
    },
    set$_inkFeatures: function(_inkFeatures) {
      this._inkFeatures = H.assertSubtype(_inkFeatures, "$isList", [M.InkFeature], "$asList");
    },
    $isMaterialInkController: 1
  };
  M._InkFeatures.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new M._RenderInkFeatures(this.vsync, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.assertHelper(this.vsync === H.interceptedTypeCheck(renderObject, "$is_RenderInkFeatures").vsync);
    }
  };
  M.InkFeature.prototype = {
    dispose$0: function() {
      var t1, t2, _this = this;
      H.assertHelper(!_this._debugDisposed);
      H.assertHelper(new M.InkFeature_dispose_closure(_this).call$0());
      t1 = _this._material$_controller;
      H.assertHelper(t1._inkFeatures != null);
      t2 = t1._inkFeatures;
      (t2 && C.JSArray_methods).remove$1(t2, _this);
      t1.markNeedsPaint$0();
      _this.onRemoved.call$0();
    },
    _paint$1: function(canvas) {
      var descendants, t1, transform, index, t2, _this = this,
        node = _this.referenceBox;
      H.assertHelper(node._node$_owner != null);
      H.assertHelper(!_this._debugDisposed);
      descendants = H.setRuntimeTypeInfo([node], [K.RenderObject]);
      for (t1 = _this._material$_controller; node != t1;) {
        node = H.interceptedTypeCheck(node._node$_parent, "$isRenderObject");
        H.assertHelper(node != null);
        C.JSArray_methods.add$1(descendants, node);
      }
      transform = new E.Matrix4(new Float64Array(16));
      transform.setIdentity$0();
      H.assertHelper(descendants.length >= 2);
      for (index = descendants.length - 1; index > 0;) {
        t1 = descendants.length;
        if (index >= t1)
          return H.ioore(descendants, index);
        t2 = descendants[index];
        --index;
        if (index >= t1)
          return H.ioore(descendants, index);
        t2.applyPaintTransform$2(descendants[index], transform);
      }
      _this.paintFeature$2(canvas, transform);
    },
    toString$0: function(_) {
      return this.get$runtimeType(this).toString$0(0) + "#" + Y.shortHash(this);
    }
  };
  M.InkFeature_dispose_closure.prototype = {
    call$0: function() {
      return this.$this._debugDisposed = true;
    },
    $signature: 0
  };
  M.ShapeBorderTween.prototype = {
    lerp$1: function(t) {
      return Y.ShapeBorder_lerp(this.begin, this.end, t);
    },
    $asAnimatable: function() {
      return [Y.ShapeBorder];
    },
    $asTween: function() {
      return [Y.ShapeBorder];
    }
  };
  M._MaterialInterior.prototype = {
    createState$0: function() {
      return new M._MaterialInteriorState(null, C._StateLifecycle_0);
    },
    debugFillProperties$1: function(description) {
      var t1, t2, _this = this, _null = null;
      _this.super$ImplicitlyAnimatedWidget$debugFillProperties(description);
      t1 = Y.DiagnosticsProperty$("shape", _this.shape, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, Y.ShapeBorder);
      t2 = description.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("elevation", _this.elevation, C.C__NoDefaultValue, _null, C.DiagnosticLevel_3, true, _null, _null));
      t1 = P.Color;
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("color", _this.color, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("shadowColor", _this.shadowColor, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
    },
    get$child: function() {
      return this.child;
    }
  };
  M._MaterialInteriorState.prototype = {
    forEachTween$1: function(visitor) {
      var _this = this;
      H.functionTypeCheck(visitor, {func: 1, ret: [R.Tween,,], args: [[R.Tween,,],, {func: 1, ret: [R.Tween,,], args: [,]}]});
      _this.set$_material$_elevation(H.assertSubtype(visitor.call$3(_this._material$_elevation, _this._widget.elevation, new M._MaterialInteriorState_forEachTween_closure()), "$isTween", [P.double], "$asTween"));
      _this._shadowColor = H.interceptedTypeCheck(visitor.call$3(_this._shadowColor, _this._widget.shadowColor, new M._MaterialInteriorState_forEachTween_closure0()), "$isColorTween");
      _this._border = H.interceptedTypeCheck(visitor.call$3(_this._border, _this._widget.shape, new M._MaterialInteriorState_forEachTween_closure1()), "$isShapeBorderTween");
    },
    build$1: function(context) {
      var t3, shape, t4, t5, t6, t7, t8, _this = this,
        t1 = _this._border,
        t2 = _this._animation;
      t1.toString;
      t3 = [P.double];
      shape = t1.transform$1(H.assertSubtype(t2, "$isAnimation", t3, "$asAnimation").get$value());
      t2 = _this._widget;
      t1 = t2.child;
      t2.borderOnForeground;
      t2 = T.Directionality_of(context);
      t4 = _this._widget.clipBehavior;
      t5 = _this._material$_elevation;
      t6 = _this._animation;
      t5.toString;
      t6 = t5.transform$1(H.assertSubtype(t6, "$isAnimation", t3, "$asAnimation").get$value());
      t5 = _this._widget.color;
      t7 = _this._shadowColor;
      t8 = _this._animation;
      t7.toString;
      return new T.PhysicalShape(new E.ShapeBorderClipper(shape, t2), t4, t6, t5, t7.transform$1(H.assertSubtype(t8, "$isAnimation", t3, "$asAnimation").get$value()), new M._ShapeBorderPaint(t1, shape, true, null), null);
    },
    set$_material$_elevation: function(_elevation) {
      this._material$_elevation = H.assertSubtype(_elevation, "$isTween", [P.double], "$asTween");
    },
    $asState: function() {
      return [M._MaterialInterior];
    },
    $asImplicitlyAnimatedWidgetState: function() {
      return [M._MaterialInterior];
    }
  };
  M._MaterialInteriorState_forEachTween_closure.prototype = {
    call$1: function(value) {
      return new R.Tween(H.doubleTypeCheck(value), null, [P.double]);
    },
    $signature: 55
  };
  M._MaterialInteriorState_forEachTween_closure0.prototype = {
    call$1: function(value) {
      return new R.ColorTween(H.interceptedTypeCheck(value, "$isColor"), null);
    },
    $signature: 31
  };
  M._MaterialInteriorState_forEachTween_closure1.prototype = {
    call$1: function(value) {
      return new M.ShapeBorderTween(H.interceptedTypeCheck(value, "$isShapeBorder"), null);
    },
    $signature: 73
  };
  M._ShapeBorderPaint.prototype = {
    build$1: function(context) {
      var t1 = T.Directionality_of(context);
      return T.CustomPaint$(this.child, new M._ShapeBorderPainter(this.shape, t1), null);
    }
  };
  M._ShapeBorderPainter.prototype = {
    paint$2: function(canvas, size) {
      var t1 = size._dx,
        t2 = size._dy;
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (typeof t2 !== "number")
        return H.iae(t2);
      this.border.paint$3$textDirection(canvas, new P.Rect(0, 0, 0 + t1, 0 + t2), this.textDirection);
    },
    shouldRepaint$1: function(oldDelegate) {
      return !J.$eq$(H.interceptedTypeCheck(oldDelegate, "$is_ShapeBorderPainter").border, this.border);
    }
  };
  M.__MaterialState_State_TickerProviderStateMixin_dispose_closure.prototype = {
    call$0: function() {
      var t3,
        t1 = this.$this,
        t2 = t1.TickerProviderStateMixin__tickers;
      if (t2 != null)
        for (t2 = P._LinkedHashSetIterator$(t2, t2._collection$_modifications, H.getTypeArgumentByIndex(t2, 0)); t2.moveNext$0();) {
          t3 = t2._collection$_current;
          if (t3._future != null)
            throw H.wrapException(U.FlutterError$(t1.toString$0(0) + " was disposed with an active Ticker.\n" + H.getRuntimeType(t1).toString$0(0) + " created a Ticker via its TickerProviderStateMixin, but at the time dispose() was called on the mixin, that Ticker was still active. All Tickers must be disposed before calling super.dispose(). Tickers used by AnimationControllers should be disposed by calling dispose() on the AnimationController itself. Otherwise, the ticker will leak.\nThe offending ticker was: " + J.toString$1$debugIncludeStack$(t3, true)));
        }
      return true;
    },
    $signature: 0
  };
  M.__MaterialState_State_TickerProviderStateMixin.prototype = {
    dispose$0: function() {
      H.assertHelper(new M.__MaterialState_State_TickerProviderStateMixin_dispose_closure(this).call$0());
      this.super$State$dispose();
    },
    didChangeDependencies$0: function() {
      var muted = !U.TickerMode_of(this._element),
        t1 = this.TickerProviderStateMixin__tickers;
      if (t1 != null)
        for (t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0)); t1.moveNext$0();)
          t1._collection$_current.set$muted(muted);
      this.super$State$didChangeDependencies();
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$State$debugFillProperties(properties);
      t1 = this.TickerProviderStateMixin__tickers;
      if (t1 != null) {
        t2 = "tracking " + t1._collection$_length + " ticker";
        t2 += this.TickerProviderStateMixin__tickers._collection$_length === 1 ? "" : "s";
      } else
        t2 = _null;
      t2 = Y.DiagnosticsProperty$("tickers", t1, _null, t2, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, [P.Set, M.Ticker]);
      C.JSArray_methods.add$1(properties.properties, t2);
    },
    set$_tickers: function(_tickers) {
      this.TickerProviderStateMixin__tickers = H.assertSubtype(_tickers, "$isSet", [M.Ticker], "$asSet");
    }
  };
  U.MaterialLocalizations.prototype = {};
  U._MaterialLocalizationsDelegate.prototype = {
    isSupported$1: function(locale) {
      return P.Locale__replaceDeprecatedLanguageSubtag(locale._languageCode) === "en";
    },
    load$1: function(locale) {
      return new O.SynchronousFuture(C.C_DefaultMaterialLocalizations, [U.MaterialLocalizations]);
    },
    shouldReload$1: function(old) {
      H.interceptedTypeCheck(old, "$is_MaterialLocalizationsDelegate");
      return false;
    },
    toString$0: function(_) {
      return "DefaultMaterialLocalizations.delegate(en_US)";
    },
    $asLocalizationsDelegate: function() {
      return [U.MaterialLocalizations];
    }
  };
  U.DefaultMaterialLocalizations.prototype = {$isMaterialLocalizations: 1};
  V.MaterialPageRoute.prototype = {
    buildPage$3: function(context, animation, secondaryAnimation) {
      var result, _null = null,
        t1 = [P.double];
      H.assertSubtype(animation, "$isAnimation", t1, "$asAnimation");
      H.assertSubtype(secondaryAnimation, "$isAnimation", t1, "$asAnimation");
      result = this.builder.call$1(context);
      H.assertHelper(new V.MaterialPageRoute_buildPage_closure(this, result).call$0());
      return T.Semantics$(_null, result, false, _null, true, _null, _null, _null, _null, true, _null);
    }
  };
  V.MaterialPageRoute_buildPage_closure.prototype = {
    call$0: function() {
      if (this.result == null)
        throw H.wrapException(U.FlutterError$('The builder for route "' + H.S(this.$this.settings.name) + '" returned null.\nRoute builders must never return null.'));
      return true;
    },
    $signature: 0
  };
  K._FadeUpwardsPageTransition.prototype = {
    build$1: function(context) {
      return K.SlideTransition$(K.FadeTransition$(this.child, this._opacityAnimation), this._positionAnimation, null, true);
    }
  };
  K.PageTransitionsBuilder.prototype = {};
  K.FadeUpwardsPageTransitionsBuilder.prototype = {
    buildTransitions$1$5: function(route, context, animation, secondaryAnimation, child, $T) {
      var t1, t2, t3;
      H.assertSubtype(route, "$isPageRoute", [$T], "$asPageRoute");
      t1 = P.double;
      t2 = [t1];
      H.assertSubtype(animation, "$isAnimation", t2, "$asAnimation");
      H.assertSubtype(secondaryAnimation, "$isAnimation", t2, "$asAnimation");
      t2 = $.$get$_FadeUpwardsPageTransition__bottomUpTween();
      t3 = $.$get$_FadeUpwardsPageTransition__fastOutSlowInTween();
      t2.toString;
      return new K._FadeUpwardsPageTransition(animation.drive$1$1(new R._ChainedEvaluation(H.assertSubtype(t3, "$isAnimatable", [t1], "$asAnimatable"), t2, [H.getRuntimeTypeArgument(t2, "Animatable", 0)]), P.Offset), animation.drive$1$1($.$get$_FadeUpwardsPageTransition__easeInTween(), t1), child, null);
    }
  };
  K.CupertinoPageTransitionsBuilder.prototype = {
    buildTransitions$1$5: function(route, context, animation, secondaryAnimation, child, $T) {
      var t1 = [P.double];
      return D.CupertinoPageRoute_buildPageTransitions(H.assertSubtype(route, "$isPageRoute", [$T], "$asPageRoute"), context, H.assertSubtype(animation, "$isAnimation", t1, "$asAnimation"), H.assertSubtype(secondaryAnimation, "$isAnimation", t1, "$asAnimation"), child, $T);
    }
  };
  K.PageTransitionsTheme.prototype = {
    get$builders: function() {
      return C.Map_leqom;
    },
    _all$1: function(builders) {
      var t1 = K.PageTransitionsBuilder,
        t2 = H.getTypeArgumentByIndex(C.List_U0W, 0);
      return new H.MappedListIterable(C.List_U0W, H.functionTypeCheck(new K.PageTransitionsTheme__all_closure(H.assertSubtype(builders, "$isMap", [T.TargetPlatform, t1], "$asMap")), {func: 1, ret: t1, args: [t2]}), [t2, t1]).toList$0(0);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isPageTransitionsTheme");
      if (_this.get$builders() === other.get$builders())
        return true;
      return S.listEquals(_this._all$1(_this.get$builders()), _this._all$1(other.get$builders()), K.PageTransitionsBuilder);
    },
    get$hashCode: function(_) {
      return P.hashList(this._all$1(this.get$builders()));
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Diagnosticable$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("builders", this.get$builders(), C.Map_leqom, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, [P.Map, T.TargetPlatform, K.PageTransitionsBuilder]);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  K.PageTransitionsTheme__all_closure.prototype = {
    call$1: function(platform) {
      return this.builders.$index(0, H.interceptedTypeCheck(platform, "$isTargetPlatform"));
    },
    $signature: 74
  };
  M._ScaffoldSlot.prototype = {
    toString$0: function(_) {
      return this._scaffold$_name;
    }
  };
  M.ScaffoldPrelayoutGeometry.prototype = {};
  M.ScaffoldGeometry.prototype = {};
  M._ScaffoldGeometryNotifier.prototype = {
    _updateWith$3$bottomNavigationBarTop$floatingActionButtonArea$floatingActionButtonScale: function(bottomNavigationBarTop, floatingActionButtonArea, floatingActionButtonScale) {
      var t1, t2, _this = this;
      _this.floatingActionButtonScale = floatingActionButtonScale == null ? _this.floatingActionButtonScale : floatingActionButtonScale;
      t1 = _this.geometry;
      t2 = bottomNavigationBarTop == null ? t1.bottomNavigationBarTop : bottomNavigationBarTop;
      _this.geometry = new M.ScaffoldGeometry(t2, floatingActionButtonArea == null ? t1.floatingActionButtonArea : floatingActionButtonArea);
      _this.notifyListeners$0();
    },
    _updateWith$1$floatingActionButtonScale: function(floatingActionButtonScale) {
      return this._updateWith$3$bottomNavigationBarTop$floatingActionButtonArea$floatingActionButtonScale(null, null, floatingActionButtonScale);
    },
    _updateWith$2$bottomNavigationBarTop$floatingActionButtonArea: function(bottomNavigationBarTop, floatingActionButtonArea) {
      return this._updateWith$3$bottomNavigationBarTop$floatingActionButtonArea$floatingActionButtonScale(bottomNavigationBarTop, floatingActionButtonArea, null);
    }
  };
  M._BodyBoxConstraints.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!this.super$BoxConstraints$$eq(0, other))
        return false;
      return this.bottomWidgetsHeight === H.interceptedTypeCheck(other, "$is_BodyBoxConstraints").bottomWidgetsHeight;
    },
    get$hashCode: function(_) {
      return P.hashValues(S.BoxConstraints.prototype.get$hashCode.call(this, this), this.bottomWidgetsHeight, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    }
  };
  M._ScaffoldLayout.prototype = {
    performLayout$1: function(size) {
      var contentTop, bottomNavigationBarHeight, bottomWidgetsHeight, bottomNavigationBarTop, persistentFooterHeight, t3, t4, contentBottom, bodyMaxHeight, snackBarSize, bottomSheetSize, fabSize, currentGeometry, currentFabOffset, fabOffset, t5, floatingActionButtonRect, snackBarYOffsetBase, _this = this,
        t1 = size._dx,
        t2 = size._dy,
        looseConstraints = new S.BoxConstraints(0, t1, 0, t2),
        fullWidthConstraints = looseConstraints.tighten$1$width(t1);
      if (_this._idToChild.$index(0, C._ScaffoldSlot_1) != null) {
        contentTop = _this.layoutChild$2(C._ScaffoldSlot_1, fullWidthConstraints)._dy;
        _this.positionChild$2(C._ScaffoldSlot_1, C.Offset_0_0);
      } else
        contentTop = 0;
      if (_this._idToChild.$index(0, C._ScaffoldSlot_6) != null) {
        bottomNavigationBarHeight = _this.layoutChild$2(C._ScaffoldSlot_6, fullWidthConstraints)._dy;
        if (typeof bottomNavigationBarHeight !== "number")
          return H.iae(bottomNavigationBarHeight);
        bottomWidgetsHeight = 0 + bottomNavigationBarHeight;
        if (typeof t2 !== "number")
          return t2.$sub();
        bottomNavigationBarTop = Math.max(0, t2 - bottomWidgetsHeight);
        _this.positionChild$2(C._ScaffoldSlot_6, new P.Offset(0, bottomNavigationBarTop));
      } else {
        bottomWidgetsHeight = 0;
        bottomNavigationBarTop = null;
      }
      if (_this._idToChild.$index(0, C._ScaffoldSlot_5) != null) {
        if (typeof t2 !== "number")
          return t2.$sub();
        if (typeof contentTop !== "number")
          return H.iae(contentTop);
        persistentFooterHeight = _this.layoutChild$2(C._ScaffoldSlot_5, new S.BoxConstraints(0, fullWidthConstraints.maxWidth, 0, Math.max(0, t2 - bottomWidgetsHeight - contentTop)))._dy;
        if (typeof persistentFooterHeight !== "number")
          return H.iae(persistentFooterHeight);
        bottomWidgetsHeight += persistentFooterHeight;
        _this.positionChild$2(C._ScaffoldSlot_5, new P.Offset(0, Math.max(0, t2 - bottomWidgetsHeight)));
      }
      t3 = _this.minInsets;
      t4 = Math.max(H.checkNum(t3.bottom), bottomWidgetsHeight);
      if (typeof t2 !== "number")
        return t2.$sub();
      contentBottom = Math.max(0, t2 - t4);
      if (_this._idToChild.$index(0, C._ScaffoldSlot_0) != null) {
        if (typeof contentTop !== "number")
          return H.iae(contentTop);
        bodyMaxHeight = Math.max(0, contentBottom - contentTop);
        _this.layoutChild$2(C._ScaffoldSlot_0, new M._BodyBoxConstraints(0, 0, fullWidthConstraints.maxWidth, 0, bodyMaxHeight));
        _this.positionChild$2(C._ScaffoldSlot_0, new P.Offset(0, contentTop));
      }
      if (_this._idToChild.$index(0, C._ScaffoldSlot_2) != null) {
        _this.layoutChild$2(C._ScaffoldSlot_2, new S.BoxConstraints(0, fullWidthConstraints.maxWidth, 0, contentBottom));
        _this.positionChild$2(C._ScaffoldSlot_2, C.Offset_0_0);
      }
      snackBarSize = _this._idToChild.$index(0, C._ScaffoldSlot_4) != null && !_this.isSnackBarFloating ? _this.layoutChild$2(C._ScaffoldSlot_4, fullWidthConstraints) : C.Size_0_0;
      if (_this._idToChild.$index(0, C._ScaffoldSlot_3) != null) {
        if (typeof contentTop !== "number")
          return H.iae(contentTop);
        bottomSheetSize = _this.layoutChild$2(C._ScaffoldSlot_3, new S.BoxConstraints(0, fullWidthConstraints.maxWidth, 0, Math.max(0, contentBottom - contentTop)));
        t2 = bottomSheetSize._dx;
        if (typeof t1 !== "number")
          return t1.$sub();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t4 = bottomSheetSize._dy;
        if (typeof t4 !== "number")
          return H.iae(t4);
        _this.positionChild$2(C._ScaffoldSlot_3, new P.Offset((t1 - t2) / 2, contentBottom - t4));
      } else
        bottomSheetSize = C.Size_0_0;
      if (_this._idToChild.$index(0, C._ScaffoldSlot_7) != null) {
        fabSize = _this.layoutChild$2(C._ScaffoldSlot_7, looseConstraints);
        currentGeometry = new M.ScaffoldPrelayoutGeometry(fabSize, bottomSheetSize, contentBottom, t3, size, snackBarSize, _this.textDirection);
        currentFabOffset = _this.currentFloatingActionButtonLocation.getOffset$1(currentGeometry);
        fabOffset = _this.floatingActionButtonMotionAnimator.getOffset$3$begin$end$progress(_this.previousFloatingActionButtonLocation.getOffset$1(currentGeometry), currentFabOffset, _this.floatingActionButtonMoveAnimationProgress);
        _this.positionChild$2(C._ScaffoldSlot_7, fabOffset);
        t1 = fabOffset._dx;
        t2 = fabOffset._dy;
        t4 = fabSize._dx;
        t5 = fabSize._dy;
        if (typeof t1 !== "number")
          return t1.$add();
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (typeof t2 !== "number")
          return t2.$add();
        if (typeof t5 !== "number")
          return H.iae(t5);
        floatingActionButtonRect = new P.Rect(t1, t2, t1 + t4, t2 + t5);
      } else
        floatingActionButtonRect = null;
      if (_this._idToChild.$index(0, C._ScaffoldSlot_4) != null) {
        if (J.$eq$(snackBarSize, C.Size_0_0))
          snackBarSize = _this.layoutChild$2(C._ScaffoldSlot_4, fullWidthConstraints);
        snackBarYOffsetBase = floatingActionButtonRect != null && _this.isSnackBarFloating ? floatingActionButtonRect.top : contentBottom;
        t1 = snackBarSize._dy;
        if (typeof snackBarYOffsetBase !== "number")
          return snackBarYOffsetBase.$sub();
        if (typeof t1 !== "number")
          return H.iae(t1);
        _this.positionChild$2(C._ScaffoldSlot_4, new P.Offset(0, snackBarYOffsetBase - t1));
      }
      if (_this._idToChild.$index(0, C._ScaffoldSlot_10) != null) {
        _this.layoutChild$2(C._ScaffoldSlot_10, fullWidthConstraints.tighten$1$height(t3.top));
        _this.positionChild$2(C._ScaffoldSlot_10, C.Offset_0_0);
      }
      if (_this._idToChild.$index(0, C._ScaffoldSlot_8) != null) {
        _this.layoutChild$2(C._ScaffoldSlot_8, S.BoxConstraints$tight(size));
        _this.positionChild$2(C._ScaffoldSlot_8, C.Offset_0_0);
      }
      if (_this._idToChild.$index(0, C._ScaffoldSlot_9) != null) {
        _this.layoutChild$2(C._ScaffoldSlot_9, S.BoxConstraints$tight(size));
        _this.positionChild$2(C._ScaffoldSlot_9, C.Offset_0_0);
      }
      _this.geometryNotifier._updateWith$2$bottomNavigationBarTop$floatingActionButtonArea(bottomNavigationBarTop, floatingActionButtonRect);
    },
    shouldRelayout$1: function(oldDelegate) {
      var _this = this;
      H.interceptedTypeCheck(oldDelegate, "$is_ScaffoldLayout");
      return !oldDelegate.minInsets.$eq(0, _this.minInsets) || oldDelegate.textDirection != _this.textDirection || oldDelegate.floatingActionButtonMoveAnimationProgress != _this.floatingActionButtonMoveAnimationProgress || oldDelegate.previousFloatingActionButtonLocation != _this.previousFloatingActionButtonLocation || oldDelegate.currentFloatingActionButtonLocation != _this.currentFloatingActionButtonLocation;
    }
  };
  M._FloatingActionButtonTransition.prototype = {
    createState$0: function() {
      return new M._FloatingActionButtonTransitionState(null, C._StateLifecycle_0);
    },
    get$child: function() {
      return this.child;
    }
  };
  M._FloatingActionButtonTransitionState.prototype = {
    initState$0: function() {
      var t1, _this = this;
      _this.super$State$initState();
      t1 = G.AnimationController$(null, C.Duration_200000, 0, 1, null, _this);
      t1.addStatusListener$1(_this.get$_handlePreviousAnimationStatusChanged());
      _this._previousController = t1;
      _this._updateAnimations$0();
      _this._widget.currentController.set$value(1);
    },
    dispose$0: function() {
      this._previousController.dispose$0();
      this.super$__FloatingActionButtonTransitionState_State_TickerProviderStateMixin$dispose();
    },
    didUpdateWidget$1: function(oldWidget) {
      var t1, t2, t3, t4, currentValue, _this = this;
      H.interceptedTypeCheck(oldWidget, "$is_FloatingActionButtonTransition");
      _this.super$State$didUpdateWidget(oldWidget);
      t1 = oldWidget.child;
      t2 = _this._widget.child;
      t2 = J.$eq$(t1.key, t2.key);
      if (t2)
        return;
      t2 = oldWidget.fabMotionAnimator;
      t3 = _this._widget;
      if (t2 != t3.fabMotionAnimator || oldWidget.fabMoveAnimation != t3.fabMoveAnimation)
        _this._updateAnimations$0();
      t2 = _this._previousController;
      if (t2._status === C.AnimationStatus_0) {
        t3 = _this._widget;
        t4 = t3.currentController;
        currentValue = t4._animation_controller$_value;
        if (currentValue === 0 || false) {
          _this._previousChild = null;
          t3.child;
          t4.forward$0();
        } else {
          _this._previousChild = t1;
          t2.set$value(currentValue);
          t2.reverse$0();
          _this._widget.currentController.set$value(0);
        }
      }
    },
    _updateAnimations$0: function() {
      var t6, t7, t8, t9, t10, moveScaleAnimation, t11, moveRotationAnimation, _this = this, _null = null,
        previousExitScaleAnimation = S.CurvedAnimation$(C.Cubic_JUR, _this._previousController, _null),
        t1 = P.double,
        t2 = [t1],
        t3 = H.assertSubtype(S.CurvedAnimation$(C.Cubic_JUR, _this._previousController, _null), "$isAnimation", t2, "$asAnimation"),
        currentEntranceScaleAnimation = S.CurvedAnimation$(C.Cubic_JUR, _this._widget.currentController, _null),
        currentEntranceRotationAnimation = _this._widget.currentController.drive$1$1($.$get$_FloatingActionButtonTransitionState__entranceTurnTween(), t1),
        t4 = _this._widget,
        t5 = t4.fabMotionAnimator;
      t4 = t4.fabMoveAnimation;
      t5.toString;
      H.assertSubtype(t4, "$isAnimation", t2, "$asAnimation");
      t5 = {func: 1, ret: -1, args: [X.AnimationStatus]};
      t6 = [t5];
      t5 = [t5];
      t7 = {func: 1, ret: -1};
      t8 = [t7];
      t9 = [t7];
      t10 = [t1];
      moveScaleAnimation = new A._AnimationSwap(t4, 0.5, new S.ReverseAnimation(t4.drive$1$1(new R.CurveTween(new Z.FlippedCurve(C.Interval_E4y)), t1), new R.ObserverList(H.setRuntimeTypeInfo([], t6), t5), 0), t4.drive$1$1(new R.CurveTween(C.Interval_E4y), t1), new R.ObserverList(H.setRuntimeTypeInfo([], t6), t5), new R.ObserverList(H.setRuntimeTypeInfo([], t8), t9), 0, t10);
      t4 = _this._widget;
      t11 = t4.fabMotionAnimator;
      t4 = t4.fabMoveAnimation;
      t11.toString;
      H.assertSubtype(t4, "$isAnimation", t2, "$asAnimation");
      moveRotationAnimation = new A._AnimationSwap(t4, 0.5, t4.drive$1$1($.$get$_ScalingFabMotionAnimator__rotationTween(), t1), new S.ReverseAnimation(t4.drive$1$1($.$get$_ScalingFabMotionAnimator__thresholdCenterTween(), t1), new R.ObserverList(H.setRuntimeTypeInfo([], t6), t5), 0), new R.ObserverList(H.setRuntimeTypeInfo([], t6), t5), new R.ObserverList(H.setRuntimeTypeInfo([], t8), t9), 0, t10);
      t10 = [t1];
      _this.set$_previousScaleAnimation(new S.AnimationMin(moveScaleAnimation, previousExitScaleAnimation, new R.ObserverList(H.setRuntimeTypeInfo([], t6), t5), new R.ObserverList(H.setRuntimeTypeInfo([], t8), t9), 0, t10));
      _this.set$_currentScaleAnimation(new S.AnimationMin(moveScaleAnimation, currentEntranceScaleAnimation, new R.ObserverList(H.setRuntimeTypeInfo([], t6), t5), new R.ObserverList(H.setRuntimeTypeInfo([], t8), t9), 0, t10));
      _this.set$_extendedCurrentScaleAnimation(_this._currentScaleAnimation.drive$1$1(new R.CurveTween(C.Interval_75R), t1));
      _this.set$_previousRotationAnimation(S.TrainHoppingAnimation$(new R._AnimatedEvaluation(t3, new R.Tween(1, 1, [t1]), [t1]), moveRotationAnimation, _null));
      _this.set$_currentRotationAnimation(S.TrainHoppingAnimation$(currentEntranceRotationAnimation, moveRotationAnimation, _null));
      t1 = _this._currentScaleAnimation;
      t1.toString;
      t7 = H.functionTypeCheck(_this.get$_onProgressChanged(), t7);
      t1.didRegisterListener$0();
      t1 = t1.AnimationLocalListenersMixin__listeners;
      H.assertSubtypeOfRuntimeType(t7, H.getTypeArgumentByIndex(t1, 0));
      t1._isDirty = true;
      C.JSArray_methods.add$1(t1._list, t7);
      t1 = _this._previousScaleAnimation;
      t1.didRegisterListener$0();
      t1 = t1.AnimationLocalListenersMixin__listeners;
      H.assertSubtypeOfRuntimeType(t7, H.getTypeArgumentByIndex(t1, 0));
      t1._isDirty = true;
      C.JSArray_methods.add$1(t1._list, t7);
    },
    _handlePreviousAnimationStatusChanged$1: function($status) {
      this.setState$1(new M._FloatingActionButtonTransitionState__handlePreviousAnimationStatusChanged_closure(this, H.interceptedTypeCheck($status, "$isAnimationStatus")));
    },
    _isExtendedFloatingActionButton$1: function(widget) {
      if (!(widget instanceof E.FloatingActionButton))
        return false;
      return false;
    },
    build$1: function(context) {
      var t1, t2, _this = this,
        children = H.setRuntimeTypeInfo([], [N.Widget]);
      if (_this._previousController._status !== C.AnimationStatus_0) {
        _this._isExtendedFloatingActionButton$1(_this._previousChild);
        t1 = _this._previousScaleAnimation;
        t2 = _this._previousRotationAnimation;
        C.JSArray_methods.add$1(children, K.ScaleTransition$(K.RotationTransition$(_this._previousChild, t2), t1));
      }
      _this._isExtendedFloatingActionButton$1(_this._widget.child);
      t1 = _this._currentScaleAnimation;
      t2 = _this._currentRotationAnimation;
      C.JSArray_methods.add$1(children, K.ScaleTransition$(K.RotationTransition$(_this._widget.child, t2), t1));
      return T.Stack$(C.Alignment_1_0, children, C.StackFit_0);
    },
    _onProgressChanged$0: function() {
      var t3,
        t1 = this._previousScaleAnimation,
        t2 = t1.first.get$value();
      t1 = t1.next.get$value();
      t1 = Math.min(H.checkNum(t2), H.checkNum(t1));
      t2 = this._currentScaleAnimation;
      t3 = t2.first.get$value();
      t2 = t2.next.get$value();
      t2 = Math.max(t1, Math.min(H.checkNum(t3), H.checkNum(t2)));
      this._widget.geometryNotifier._updateWith$1$floatingActionButtonScale(t2);
    },
    set$_previousScaleAnimation: function(_previousScaleAnimation) {
      this._previousScaleAnimation = H.assertSubtype(_previousScaleAnimation, "$isAnimation", [P.double], "$asAnimation");
    },
    set$_previousRotationAnimation: function(_previousRotationAnimation) {
      this._previousRotationAnimation = H.assertSubtype(_previousRotationAnimation, "$isAnimation", [P.double], "$asAnimation");
    },
    set$_currentScaleAnimation: function(_currentScaleAnimation) {
      this._currentScaleAnimation = H.assertSubtype(_currentScaleAnimation, "$isAnimation", [P.double], "$asAnimation");
    },
    set$_extendedCurrentScaleAnimation: function(_extendedCurrentScaleAnimation) {
      this._extendedCurrentScaleAnimation = H.assertSubtype(_extendedCurrentScaleAnimation, "$isAnimation", [P.double], "$asAnimation");
    },
    set$_currentRotationAnimation: function(_currentRotationAnimation) {
      this._currentRotationAnimation = H.assertSubtype(_currentRotationAnimation, "$isAnimation", [P.double], "$asAnimation");
    },
    $isTickerProvider: 1,
    $asState: function() {
      return [M._FloatingActionButtonTransition];
    },
    $asTickerProviderStateMixin: function() {
      return [M._FloatingActionButtonTransition];
    }
  };
  M._FloatingActionButtonTransitionState__handlePreviousAnimationStatusChanged_closure.prototype = {
    call$0: function() {
      if (this.status === C.AnimationStatus_0) {
        var t1 = this.$this;
        H.assertHelper(t1._widget.currentController._status === C.AnimationStatus_0);
        t1._widget.currentController.forward$0();
      }
    },
    $signature: 2
  };
  M.Scaffold.prototype = {
    createState$0: function() {
      var t1 = [Z.DrawerControllerState],
        t2 = {func: 1, ret: -1};
      return new M.ScaffoldState(new N.LabeledGlobalKey(null, t1), new N.LabeledGlobalKey(null, t1), P.ListQueue$([M.ScaffoldFeatureController, N.SnackBar, N.SnackBarClosedReason]), H.setRuntimeTypeInfo([], [M._StandardBottomSheet]), new F.ScrollController(H.setRuntimeTypeInfo([], [A.ScrollPosition]), new R.ObserverList(H.setRuntimeTypeInfo([], [t2]), [t2])), C.Color_4278190080, null, C._StateLifecycle_0);
    }
  };
  M.ScaffoldState.prototype = {
    _maybeBuildPersistentBottomSheet$0: function() {
      this._widget.toString;
    },
    _handleStatusBarTap$0: function() {
    },
    get$_resizeToAvoidBottomInset: function() {
      this._widget.toString;
      return true;
    },
    initState$0: function() {
      var t1, _this = this;
      _this.super$State$initState();
      t1 = {func: 1, ret: -1};
      _this._geometryNotifier = new M._ScaffoldGeometryNotifier(C.ScaffoldGeometry_null_null, new R.ObserverList(H.setRuntimeTypeInfo([], [t1]), [t1]));
      _this._widget.toString;
      _this._floatingActionButtonLocation = C.C__EndFloatFloatingActionButtonLocation;
      _this._floatingActionButtonAnimator = C.C__ScalingFabMotionAnimator;
      _this._previousFloatingActionButtonLocation = C.C__EndFloatFloatingActionButtonLocation;
      _this._floatingActionButtonMoveController = G.AnimationController$(null, new P.Duration(400000), 0, 1, 1, _this);
      _this._floatingActionButtonVisibilityController = G.AnimationController$(null, C.Duration_200000, 0, 1, null, _this);
    },
    didUpdateWidget$1: function(oldWidget) {
      H.interceptedTypeCheck(oldWidget, "$isScaffold");
      this._widget.toString;
      oldWidget.toString;
      this.super$State$didUpdateWidget(oldWidget);
    },
    didChangeDependencies$0: function() {
      var _this = this,
        mediaQuery = F.MediaQuery_of(_this._element, false);
      _this._accessibleNavigation = mediaQuery.accessibleNavigation;
      _this._maybeBuildPersistentBottomSheet$0();
      _this.super$_ScaffoldState_State_TickerProviderStateMixin$didChangeDependencies();
    },
    dispose$0: function() {
      var t2, _i, _this = this,
        t1 = _this._snackBarTimer;
      if (t1 != null)
        t1.cancel$0();
      _this._snackBarTimer = null;
      t1 = _this._geometryNotifier;
      t1._debugAssertNotDisposed$0();
      t1.set$_change_notifier$_listeners(null);
      for (t1 = _this._dismissedBottomSheets, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        t1[_i].animationController.dispose$0();
      t1 = _this._currentBottomSheet;
      if (t1 != null)
        t1._scaffold$_widget.animationController.dispose$0();
      _this._floatingActionButtonMoveController.dispose$0();
      _this._floatingActionButtonVisibilityController.dispose$0();
      _this.super$_ScaffoldState_State_TickerProviderStateMixin$dispose();
    },
    _addIfNonNull$8$removeBottomInset$removeBottomPadding$removeLeftPadding$removeRightPadding$removeTopPadding: function(children, child, childId, removeBottomInset, removeBottomPadding, removeLeftPadding, removeRightPadding, removeTopPadding) {
      var data;
      H.assertSubtype(children, "$isList", [T.LayoutId], "$asList");
      data = F.MediaQuery_of(this._element, false).removePadding$4$removeBottom$removeLeft$removeRight$removeTop(removeBottomPadding, removeLeftPadding, removeRightPadding, removeTopPadding);
      if (removeBottomInset)
        data = data.removeViewInsets$1$removeBottom(true);
      if (child != null)
        C.JSArray_methods.add$1(children, T.LayoutId$(F.MediaQuery$(child, data, null), childId));
    },
    _addIfNonNull$7$removeBottomPadding$removeLeftPadding$removeRightPadding$removeTopPadding: function(children, child, childId, removeBottomPadding, removeLeftPadding, removeRightPadding, removeTopPadding) {
      return this._addIfNonNull$8$removeBottomInset$removeBottomPadding$removeLeftPadding$removeRightPadding$removeTopPadding(children, child, childId, false, removeBottomPadding, removeLeftPadding, removeRightPadding, removeTopPadding);
    },
    _buildEndDrawer$2: function(children, textDirection) {
      H.assertSubtype(children, "$isList", [T.LayoutId], "$asList");
      this._widget.toString;
    },
    _buildDrawer$2: function(children, textDirection) {
      H.assertSubtype(children, "$isList", [T.LayoutId], "$asList");
      this._widget.toString;
    },
    build$1: function(context) {
      var mediaQuery, themeData, textDirection, t1, route, t2, children, t3, topPadding, bottomSheets, stack, minInsets, _this = this, _null = null, _box_0 = {};
      E.debugCheckHasMediaQuery(context);
      E.debugCheckHasDirectionality(context);
      mediaQuery = F.MediaQuery_of(context, false);
      themeData = K.Theme_of(context);
      textDirection = T.Directionality_of(context);
      _this._accessibleNavigation = mediaQuery.accessibleNavigation;
      t1 = _this._snackBars;
      if (!t1.get$isEmpty(t1)) {
        route = T.ModalRoute_of(context, P.Object);
        if (route == null || route.get$isCurrent())
          _null.get$isCompleted();
        else {
          t2 = _this._snackBarTimer;
          if (t2 != null)
            t2.cancel$0();
          _this._snackBarTimer = null;
        }
      }
      children = H.setRuntimeTypeInfo([], [T.LayoutId]);
      t2 = _this._widget;
      t3 = t2.body;
      t2.appBar;
      _this.get$_resizeToAvoidBottomInset();
      _this._addIfNonNull$8$removeBottomInset$removeBottomPadding$removeLeftPadding$removeRightPadding$removeTopPadding(children, t3, C._ScaffoldSlot_0, true, false, false, false, true);
      if (_this._showBodyScrim)
        _this._addIfNonNull$7$removeBottomPadding$removeLeftPadding$removeRightPadding$removeTopPadding(children, X.ModalBarrier$(true, _this._bodyScrimColor, false, _null), C._ScaffoldSlot_2, true, true, true, true);
      t2 = _this._widget;
      t3 = t2.appBar;
      t2.toString;
      topPadding = mediaQuery.padding.top;
      t2 = t3.preferredSize._dy;
      if (typeof t2 !== "number")
        return t2.$add();
      if (typeof topPadding !== "number")
        return H.iae(topPadding);
      t2 = _this._appBarMaxHeight = t2 + topPadding;
      H.assertHelper(t2 >= 0 && isFinite(t2));
      t2 = _this._appBarMaxHeight;
      t3 = _this._widget.appBar;
      H.assertHelper(t2 != null);
      _this._addIfNonNull$7$removeBottomPadding$removeLeftPadding$removeRightPadding$removeTopPadding(children, T.ConstrainedBox$(new Z.FlexibleSpaceBarSettings(1, t2, t2, t2, t3, _null), new S.BoxConstraints(0, 1 / 0, 0, t2)), C._ScaffoldSlot_1, true, false, false, false);
      _box_0.isSnackBarFloating = false;
      if (!t1.get$isEmpty(t1)) {
        t1.get$first(t1)._scaffold$_widget.get$behavior();
        _box_0.isSnackBarFloating = false;
        t1 = t1.get$first(t1)._scaffold$_widget;
        _this._widget.toString;
        _this._addIfNonNull$7$removeBottomPadding$removeLeftPadding$removeRightPadding$removeTopPadding(children, t1, C._ScaffoldSlot_4, false, false, false, true);
      }
      _this._widget.toString;
      if (_this._currentBottomSheet != null || _this._dismissedBottomSheets.length !== 0) {
        bottomSheets = H.setRuntimeTypeInfo([], [N.Widget]);
        t1 = _this._dismissedBottomSheets;
        if (t1.length !== 0)
          C.JSArray_methods.addAll$1(bottomSheets, t1);
        t1 = _this._currentBottomSheet;
        if (t1 != null)
          C.JSArray_methods.add$1(bottomSheets, t1._scaffold$_widget);
        stack = T.Stack$(C.Alignment_0_1, bottomSheets, C.StackFit_0);
        _this.get$_resizeToAvoidBottomInset();
        _this._addIfNonNull$7$removeBottomPadding$removeLeftPadding$removeRightPadding$removeTopPadding(children, stack, C._ScaffoldSlot_3, true, false, false, true);
      }
      _this._addIfNonNull$7$removeBottomPadding$removeLeftPadding$removeRightPadding$removeTopPadding(children, new M._FloatingActionButtonTransition(_this._widget.floatingActionButton, _this._floatingActionButtonMoveController, _this._floatingActionButtonAnimator, _this._geometryNotifier, _this._floatingActionButtonVisibilityController, _null), C._ScaffoldSlot_7, true, true, true, true);
      switch (themeData.platform) {
        case C.TargetPlatform_2:
          _this._addIfNonNull$7$removeBottomPadding$removeLeftPadding$removeRightPadding$removeTopPadding(children, D.GestureDetector$(C.HitTestBehavior_1, _null, C.DragStartBehavior_1, true, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _this.get$_handleStatusBarTap(), _null, _null, _null, _null), C._ScaffoldSlot_10, true, false, false, true);
          break;
        case C.TargetPlatform_0:
        case C.TargetPlatform_1:
          break;
      }
      if (_this._endDrawerOpened) {
        _this._buildDrawer$2(children, textDirection);
        _this._buildEndDrawer$2(children, textDirection);
      } else {
        _this._buildEndDrawer$2(children, textDirection);
        _this._buildDrawer$2(children, textDirection);
      }
      t1 = mediaQuery.padding;
      _this.get$_resizeToAvoidBottomInset();
      t2 = mediaQuery.viewInsets;
      minInsets = t1.copyWith$1$bottom(t2.bottom);
      t1 = minInsets.bottom;
      if (typeof t1 !== "number")
        return t1.$gt();
      if (!(t1 > 0))
        _this._widget.toString;
      _this._widget.toString;
      t1 = themeData.scaffoldBackgroundColor;
      return new M._ScaffoldScope(false, new E.PrimaryScrollController(_this._primaryScrollController, M.Material$(C.Duration_200000, K.AnimatedBuilder$(_this._floatingActionButtonMoveController, new M.ScaffoldState_build_closure(_box_0, _this, children, false, minInsets, textDirection), _null), C.Clip_0, t1, 0, _null, _null, _null, C.MaterialType_0), _null), _null);
    },
    $isTickerProvider: 1,
    $asState: function() {
      return [M.Scaffold];
    },
    $asTickerProviderStateMixin: function() {
      return [M.Scaffold];
    }
  };
  M.ScaffoldState_build_closure.prototype = {
    call$2: function(context, child) {
      var t1, t2, t3, t4, _this = this;
      H.interceptedTypeCheck(context, "$isBuildContext");
      H.interceptedTypeCheck(child, "$isWidget");
      t1 = _this.$this;
      t2 = t1._floatingActionButtonLocation;
      t3 = t1._floatingActionButtonMoveController._animation_controller$_value;
      t4 = t1._floatingActionButtonAnimator;
      return T.CustomMultiChildLayout$(_this.children, new M._ScaffoldLayout(_this._extendBody, _this.minInsets, _this.textDirection, t1._geometryNotifier, t1._previousFloatingActionButtonLocation, t2, t3, t4, _this._box_0.isSnackBarFloating));
    },
    $signature: 75
  };
  M.ScaffoldFeatureController.prototype = {};
  M._StandardBottomSheet.prototype = {};
  M._ScaffoldScope.prototype = {
    updateShouldNotify$1: function(oldWidget) {
      return this.hasDrawer !== H.interceptedTypeCheck(oldWidget, "$is_ScaffoldScope").hasDrawer;
    }
  };
  M._ScaffoldState_State_TickerProviderStateMixin_dispose_closure.prototype = {
    call$0: function() {
      var t3,
        t1 = this.$this,
        t2 = t1.TickerProviderStateMixin__tickers;
      if (t2 != null)
        for (t2 = P._LinkedHashSetIterator$(t2, t2._collection$_modifications, H.getTypeArgumentByIndex(t2, 0)); t2.moveNext$0();) {
          t3 = t2._collection$_current;
          if (t3._future != null)
            throw H.wrapException(U.FlutterError$(t1.toString$0(0) + " was disposed with an active Ticker.\n" + H.getRuntimeType(t1).toString$0(0) + " created a Ticker via its TickerProviderStateMixin, but at the time dispose() was called on the mixin, that Ticker was still active. All Tickers must be disposed before calling super.dispose(). Tickers used by AnimationControllers should be disposed by calling dispose() on the AnimationController itself. Otherwise, the ticker will leak.\nThe offending ticker was: " + J.toString$1$debugIncludeStack$(t3, true)));
        }
      return true;
    },
    $signature: 0
  };
  M.__FloatingActionButtonTransitionState_State_TickerProviderStateMixin_dispose_closure.prototype = {
    call$0: function() {
      var t3,
        t1 = this.$this,
        t2 = t1.TickerProviderStateMixin__tickers;
      if (t2 != null)
        for (t2 = P._LinkedHashSetIterator$(t2, t2._collection$_modifications, H.getTypeArgumentByIndex(t2, 0)); t2.moveNext$0();) {
          t3 = t2._collection$_current;
          if (t3._future != null)
            throw H.wrapException(U.FlutterError$(t1.toString$0(0) + " was disposed with an active Ticker.\n" + H.getRuntimeType(t1).toString$0(0) + " created a Ticker via its TickerProviderStateMixin, but at the time dispose() was called on the mixin, that Ticker was still active. All Tickers must be disposed before calling super.dispose(). Tickers used by AnimationControllers should be disposed by calling dispose() on the AnimationController itself. Otherwise, the ticker will leak.\nThe offending ticker was: " + J.toString$1$debugIncludeStack$(t3, true)));
        }
      return true;
    },
    $signature: 0
  };
  M._ScaffoldState_State_TickerProviderStateMixin.prototype = {
    dispose$0: function() {
      H.assertHelper(new M._ScaffoldState_State_TickerProviderStateMixin_dispose_closure(this).call$0());
      this.super$State$dispose();
    },
    didChangeDependencies$0: function() {
      var muted = !U.TickerMode_of(this._element),
        t1 = this.TickerProviderStateMixin__tickers;
      if (t1 != null)
        for (t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0)); t1.moveNext$0();)
          t1._collection$_current.set$muted(muted);
      this.super$State$didChangeDependencies();
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$State$debugFillProperties(properties);
      t1 = this.TickerProviderStateMixin__tickers;
      if (t1 != null) {
        t2 = "tracking " + t1._collection$_length + " ticker";
        t2 += this.TickerProviderStateMixin__tickers._collection$_length === 1 ? "" : "s";
      } else
        t2 = _null;
      t2 = Y.DiagnosticsProperty$("tickers", t1, _null, t2, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, [P.Set, M.Ticker]);
      C.JSArray_methods.add$1(properties.properties, t2);
    },
    set$_tickers: function(_tickers) {
      this.TickerProviderStateMixin__tickers = H.assertSubtype(_tickers, "$isSet", [M.Ticker], "$asSet");
    }
  };
  M.__FloatingActionButtonTransitionState_State_TickerProviderStateMixin.prototype = {
    dispose$0: function() {
      H.assertHelper(new M.__FloatingActionButtonTransitionState_State_TickerProviderStateMixin_dispose_closure(this).call$0());
      this.super$State$dispose();
    },
    didChangeDependencies$0: function() {
      var muted = !U.TickerMode_of(this._element),
        t1 = this.TickerProviderStateMixin__tickers;
      if (t1 != null)
        for (t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0)); t1.moveNext$0();)
          t1._collection$_current.set$muted(muted);
      this.super$State$didChangeDependencies();
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$State$debugFillProperties(properties);
      t1 = this.TickerProviderStateMixin__tickers;
      if (t1 != null) {
        t2 = "tracking " + t1._collection$_length + " ticker";
        t2 += this.TickerProviderStateMixin__tickers._collection$_length === 1 ? "" : "s";
      } else
        t2 = _null;
      t2 = Y.DiagnosticsProperty$("tickers", t1, _null, t2, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, [P.Set, M.Ticker]);
      C.JSArray_methods.add$1(properties.properties, t2);
    },
    set$_tickers: function(_tickers) {
      this.TickerProviderStateMixin__tickers = H.assertSubtype(_tickers, "$isSet", [M.Ticker], "$asSet");
    }
  };
  Q.ShowValueIndicator.prototype = {
    toString$0: function(_) {
      return this._slider_theme$_name;
    }
  };
  Q.SliderThemeData.prototype = {
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.trackHeight, _this.activeTrackColor, _this.inactiveTrackColor, _this.disabledActiveTrackColor, _this.disabledInactiveTrackColor, _this.activeTickMarkColor, _this.inactiveTickMarkColor, _this.disabledActiveTickMarkColor, _this.disabledInactiveTickMarkColor, _this.thumbColor, _this.disabledThumbColor, _this.overlayColor, _this.valueIndicatorColor, _this.trackShape, _this.tickMarkShape, _this.thumbShape, _this.overlayShape, _this.valueIndicatorShape, _this.showValueIndicator, _this.valueIndicatorTextStyle);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isSliderThemeData");
      return other.trackHeight == _this.trackHeight && J.$eq$(other.activeTrackColor, _this.activeTrackColor) && J.$eq$(other.inactiveTrackColor, _this.inactiveTrackColor) && J.$eq$(other.disabledActiveTrackColor, _this.disabledActiveTrackColor) && J.$eq$(other.disabledInactiveTrackColor, _this.disabledInactiveTrackColor) && J.$eq$(other.activeTickMarkColor, _this.activeTickMarkColor) && J.$eq$(other.inactiveTickMarkColor, _this.inactiveTickMarkColor) && J.$eq$(other.disabledActiveTickMarkColor, _this.disabledActiveTickMarkColor) && J.$eq$(other.disabledInactiveTickMarkColor, _this.disabledInactiveTickMarkColor) && J.$eq$(other.thumbColor, _this.thumbColor) && J.$eq$(other.disabledThumbColor, _this.disabledThumbColor) && J.$eq$(other.overlayColor, _this.overlayColor) && J.$eq$(other.valueIndicatorColor, _this.valueIndicatorColor) && other.trackShape == _this.trackShape && other.tickMarkShape == _this.tickMarkShape && other.thumbShape == _this.thumbShape && other.overlayShape == _this.overlayShape && other.valueIndicatorShape == _this.valueIndicatorShape && other.showValueIndicator == _this.showValueIndicator && J.$eq$(other.valueIndicatorTextStyle, _this.valueIndicatorTextStyle);
    },
    debugFillProperties$1: function(properties) {
      var defaultTheme, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, defaultData, _this = this, _null = null,
        _s16_ = "activeTrackColor";
      _this.super$Diagnosticable$debugFillProperties(properties);
      defaultTheme = X.ThemeData_ThemeData(C.Brightness_1, _null, _null, _null, _null);
      t1 = defaultTheme.primaryColor;
      t2 = defaultTheme.primaryColorDark;
      t3 = defaultTheme.primaryColorLight;
      t4 = defaultTheme.accentTextTheme.body2;
      H.assertHelper(t1 != null);
      H.assertHelper(t2 != null);
      H.assertHelper(t3 != null);
      H.assertHelper(t4 != null);
      t1 = t1.value;
      t5 = (16711680 & t1) >>> 16;
      t6 = (65280 & t1) >>> 8;
      t1 = (255 & t1) >>> 0;
      t7 = P.Color$fromARGB(255, t5, t6, t1);
      t8 = P.Color$fromARGB(61, t5, t6, t1);
      t2 = t2.value;
      t9 = (16711680 & t2) >>> 16;
      t10 = (65280 & t2) >>> 8;
      t2 = (255 & t2) >>> 0;
      t11 = P.Color$fromARGB(82, t9, t10, t2);
      t12 = P.Color$fromARGB(31, t9, t10, t2);
      t3 = t3.value;
      t13 = (16711680 & t3) >>> 16;
      t14 = (65280 & t3) >>> 8;
      t3 = (255 & t3) >>> 0;
      t15 = P.Color$fromARGB(138, t13, t14, t3);
      t16 = P.Color$fromARGB(138, t5, t6, t1);
      t3 = P.Color$fromARGB(31, t13, t14, t3);
      t14 = P.Color$fromARGB(31, t9, t10, t2);
      t13 = P.Color$fromARGB(255, t5, t6, t1);
      defaultData = Q.SliderThemeData$(t15, t7, t3, t11, t14, t12, P.Color$fromARGB(82, t9, t10, t2), t16, t8, P.Color$fromARGB(31, t5, t6, t1), C.C_RoundSliderOverlayShape, C.ShowValueIndicator_0, t13, C.C_RoundSliderThumbShape, C.C_RoundSliderTickMarkShape, 2, C.C_RoundedRectSliderTrackShape, P.Color$fromARGB(255, t5, t6, t1), C.C_PaddleSliderValueIndicatorShape, t4);
      t4 = _this.activeTrackColor;
      t1 = defaultData.activeTrackColor;
      t6 = P.Color;
      t5 = Y.DiagnosticsProperty$(_s16_, t4, t1, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t6);
      t13 = properties.properties;
      C.JSArray_methods.add$1(t13, t5);
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$(_s16_, t4, t1, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t6));
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("inactiveTrackColor", _this.inactiveTrackColor, defaultData.inactiveTrackColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t6));
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("disabledActiveTrackColor", _this.disabledActiveTrackColor, defaultData.disabledActiveTrackColor, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, t6));
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("disabledInactiveTrackColor", _this.disabledInactiveTrackColor, defaultData.disabledInactiveTrackColor, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, t6));
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("activeTickMarkColor", _this.activeTickMarkColor, defaultData.activeTickMarkColor, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, t6));
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("inactiveTickMarkColor", _this.inactiveTickMarkColor, defaultData.inactiveTickMarkColor, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, t6));
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("disabledActiveTickMarkColor", _this.disabledActiveTickMarkColor, defaultData.disabledActiveTickMarkColor, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, t6));
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("disabledInactiveTickMarkColor", _this.disabledInactiveTickMarkColor, defaultData.disabledInactiveTickMarkColor, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, t6));
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("thumbColor", _this.thumbColor, defaultData.thumbColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t6));
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("disabledThumbColor", _this.disabledThumbColor, defaultData.disabledThumbColor, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, t6));
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("overlayColor", _this.overlayColor, defaultData.overlayColor, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, t6));
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("valueIndicatorColor", _this.valueIndicatorColor, defaultData.valueIndicatorColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t6));
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("trackShape", _this.trackShape, defaultData.trackShape, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, Q.SliderTrackShape));
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("tickMarkShape", _this.tickMarkShape, defaultData.tickMarkShape, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, Q.SliderTickMarkShape));
      t6 = Q.SliderComponentShape;
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("thumbShape", _this.thumbShape, defaultData.thumbShape, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, t6));
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("overlayShape", _this.overlayShape, defaultData.overlayShape, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, t6));
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("valueIndicatorShape", _this.valueIndicatorShape, defaultData.valueIndicatorShape, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, t6));
      C.JSArray_methods.add$1(t13, new Y.EnumProperty(_null, _null, _null, _null, false, _this.showValueIndicator, defaultData.showValueIndicator, C.DiagnosticLevel_3, "showValueIndicator", true, true, C.DiagnosticsTreeStyle_5, [Q.ShowValueIndicator]));
      C.JSArray_methods.add$1(t13, Y.DiagnosticsProperty$("valueIndicatorTextStyle", _this.valueIndicatorTextStyle, defaultData.valueIndicatorTextStyle, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, A.TextStyle0));
    }
  };
  Q.SliderTrackShape.prototype = {};
  Q.SliderTickMarkShape.prototype = {};
  Q.SliderComponentShape.prototype = {};
  Q.BaseSliderTrackShape.prototype = {};
  Q.RoundedRectSliderTrackShape.prototype = {};
  Q.RoundSliderTickMarkShape.prototype = {};
  Q.RoundSliderThumbShape.prototype = {};
  Q.RoundSliderOverlayShape.prototype = {};
  Q.PaddleSliderValueIndicatorShape.prototype = {};
  Q._RoundedRectSliderTrackShape_SliderTrackShape_BaseSliderTrackShape.prototype = {};
  N.SnackBarClosedReason.prototype = {};
  N.SnackBar.prototype = {};
  K.SnackBarBehavior.prototype = {};
  K.SnackBarThemeData.prototype = {
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.backgroundColor, _this.actionTextColor, _this.disabledActionTextColor, _this.elevation, _this.shape, _this.behavior, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isSnackBarThemeData");
      return J.$eq$(other.backgroundColor, _this.backgroundColor) && J.$eq$(other.actionTextColor, _this.actionTextColor) && J.$eq$(other.disabledActionTextColor, _this.disabledActionTextColor) && other.elevation == _this.elevation && J.$eq$(other.shape, _this.shape) && true;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      t1 = P.Color;
      t2 = Y.DiagnosticsProperty$("backgroundColor", _this.backgroundColor, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t2);
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("actionTextColor", _this.actionTextColor, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("disabledActionTextColor", _this.disabledActionTextColor, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("elevation", _this.elevation, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.double));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("shape", _this.shape, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, Y.ShapeBorder));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("behavior", _this.behavior, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.SnackBarBehavior));
    }
  };
  U.TabBarTheme.prototype = {
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.indicator, _this.indicatorSize, _this.labelColor, _this.labelPadding, _this.labelStyle, _this.unselectedLabelColor, _this.unselectedLabelStyle, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isTabBarTheme");
      if (J.$eq$(other.indicator, _this.indicator))
        t1 = J.$eq$(other.labelColor, _this.labelColor) && J.$eq$(other.labelPadding, _this.labelPadding) && J.$eq$(other.labelStyle, _this.labelStyle) && J.$eq$(other.unselectedLabelColor, _this.unselectedLabelColor) && J.$eq$(other.unselectedLabelStyle, _this.unselectedLabelStyle);
      else
        t1 = false;
      return t1;
    }
  };
  R.TextTheme.prototype = {
    merge$1: function(other) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, _this = this, _null = null;
      if (other == null)
        return _this;
      t1 = _this.display4;
      t2 = t1 == null ? _null : t1.merge$1(other.display4);
      if (t2 == null)
        t2 = other.display4;
      t3 = _this.display3;
      t4 = t3 == null ? _null : t3.merge$1(other.display3);
      if (t4 == null)
        t4 = other.display3;
      t5 = _this.display2;
      t6 = t5 == null ? _null : t5.merge$1(other.display2);
      if (t6 == null)
        t6 = other.display2;
      t7 = _this.display1;
      t8 = t7 == null ? _null : t7.merge$1(other.display1);
      if (t8 == null)
        t8 = other.display1;
      t9 = _this.headline;
      t10 = t9 == null ? _null : t9.merge$1(other.headline);
      if (t10 == null)
        t10 = other.headline;
      t11 = _this.title;
      t12 = t11 == null ? _null : t11.merge$1(other.title);
      if (t12 == null)
        t12 = other.title;
      t13 = _this.subhead;
      t14 = t13 == null ? _null : t13.merge$1(other.subhead);
      if (t14 == null)
        t14 = other.subhead;
      t15 = _this.body2;
      t16 = t15 == null ? _null : t15.merge$1(other.body2);
      if (t16 == null)
        t16 = other.body2;
      t17 = _this.body1;
      t18 = t17 == null ? _null : t17.merge$1(other.body1);
      if (t18 == null)
        t18 = other.body1;
      t19 = _this.caption;
      t20 = t19 == null ? _null : t19.merge$1(other.caption);
      if (t20 == null)
        t20 = other.caption;
      t21 = _this.button;
      t22 = t21 == null ? _null : t21.merge$1(other.button);
      if (t22 == null)
        t22 = other.button;
      t23 = _this.subtitle;
      t24 = t23 == null ? _null : t23.merge$1(other.subtitle);
      if (t24 == null)
        t24 = other.subtitle;
      t25 = _this.overline;
      t26 = t25 == null ? _null : t25.merge$1(other.overline);
      if (t26 == null)
        t26 = other.overline;
      t1 = t2 == null ? t1 : t2;
      t2 = t4 == null ? t3 : t4;
      t3 = t6 == null ? t5 : t6;
      t4 = t8 == null ? t7 : t8;
      t5 = t10 == null ? t9 : t10;
      t6 = t12 == null ? t11 : t12;
      t7 = t14 == null ? t13 : t14;
      t8 = t16 == null ? t15 : t16;
      t9 = t18 == null ? t17 : t18;
      t10 = t20 == null ? t19 : t20;
      t11 = t22 == null ? t21 : t22;
      t12 = t24 == null ? t23 : t24;
      return R.TextTheme$(t9, t8, t11, t10, t4, t3, t2, t1, t5, t26 == null ? t25 : t26, t7, t12, t6);
    },
    apply$1$fontFamily: function(fontFamily) {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, _this = this, _null = null,
        t1 = _this.display4;
      t1 = t1 == null ? _null : t1.apply$7$color$decoration$decorationColor$decorationStyle$fontFamily$fontSizeDelta$fontSizeFactor(_null, _null, _null, _null, fontFamily, 0, 1);
      t2 = _this.display3;
      t2 = t2 == null ? _null : t2.apply$7$color$decoration$decorationColor$decorationStyle$fontFamily$fontSizeDelta$fontSizeFactor(_null, _null, _null, _null, fontFamily, 0, 1);
      t3 = _this.display2;
      t3 = t3 == null ? _null : t3.apply$7$color$decoration$decorationColor$decorationStyle$fontFamily$fontSizeDelta$fontSizeFactor(_null, _null, _null, _null, fontFamily, 0, 1);
      t4 = _this.display1;
      t4 = t4 == null ? _null : t4.apply$7$color$decoration$decorationColor$decorationStyle$fontFamily$fontSizeDelta$fontSizeFactor(_null, _null, _null, _null, fontFamily, 0, 1);
      t5 = _this.headline;
      t5 = t5 == null ? _null : t5.apply$7$color$decoration$decorationColor$decorationStyle$fontFamily$fontSizeDelta$fontSizeFactor(_null, _null, _null, _null, fontFamily, 0, 1);
      t6 = _this.title;
      t6 = t6 == null ? _null : t6.apply$7$color$decoration$decorationColor$decorationStyle$fontFamily$fontSizeDelta$fontSizeFactor(_null, _null, _null, _null, fontFamily, 0, 1);
      t7 = _this.subhead;
      t7 = t7 == null ? _null : t7.apply$7$color$decoration$decorationColor$decorationStyle$fontFamily$fontSizeDelta$fontSizeFactor(_null, _null, _null, _null, fontFamily, 0, 1);
      t8 = _this.body2;
      t8 = t8 == null ? _null : t8.apply$7$color$decoration$decorationColor$decorationStyle$fontFamily$fontSizeDelta$fontSizeFactor(_null, _null, _null, _null, fontFamily, 0, 1);
      t9 = _this.body1;
      t9 = t9 == null ? _null : t9.apply$7$color$decoration$decorationColor$decorationStyle$fontFamily$fontSizeDelta$fontSizeFactor(_null, _null, _null, _null, fontFamily, 0, 1);
      t10 = _this.caption;
      t10 = t10 == null ? _null : t10.apply$7$color$decoration$decorationColor$decorationStyle$fontFamily$fontSizeDelta$fontSizeFactor(_null, _null, _null, _null, fontFamily, 0, 1);
      t11 = _this.button;
      t11 = t11 == null ? _null : t11.apply$7$color$decoration$decorationColor$decorationStyle$fontFamily$fontSizeDelta$fontSizeFactor(_null, _null, _null, _null, fontFamily, 0, 1);
      t12 = _this.subtitle;
      t12 = t12 == null ? _null : t12.apply$7$color$decoration$decorationColor$decorationStyle$fontFamily$fontSizeDelta$fontSizeFactor(_null, _null, _null, _null, fontFamily, 0, 1);
      t13 = _this.overline;
      return R.TextTheme$(t9, t8, t11, t10, t4, t3, t2, t1, t5, t13 == null ? _null : t13.apply$7$color$decoration$decorationColor$decorationStyle$fontFamily$fontSizeDelta$fontSizeFactor(_null, _null, _null, _null, fontFamily, 0, 1), t7, t12, t6);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isTextTheme");
      return J.$eq$(_this.display4, other.display4) && J.$eq$(_this.display3, other.display3) && J.$eq$(_this.display2, other.display2) && J.$eq$(_this.display1, other.display1) && J.$eq$(_this.headline, other.headline) && J.$eq$(_this.title, other.title) && J.$eq$(_this.subhead, other.subhead) && J.$eq$(_this.body2, other.body2) && J.$eq$(_this.body1, other.body1) && J.$eq$(_this.caption, other.caption) && J.$eq$(_this.button, other.button) && J.$eq$(_this.subtitle, other.subtitle) && J.$eq$(_this.overline, other.overline);
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.display4, _this.display3, _this.display2, _this.display1, _this.headline, _this.title, _this.subhead, _this.body2, _this.body1, _this.caption, _this.button, _this.subtitle, _this.overline, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    debugFillProperties$1: function(properties) {
      var defaultTheme, t1, t2, t3, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      defaultTheme = U.Typography_Typography(_null, _null, _null, T.defaultTargetPlatform(), _null, _null).black;
      t1 = A.TextStyle0;
      t2 = Y.DiagnosticsProperty$("display4", _this.display4, defaultTheme.display4, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t2);
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("display3", _this.display3, defaultTheme.display3, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("display2", _this.display2, defaultTheme.display2, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("display1", _this.display1, defaultTheme.display1, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("headline", _this.headline, defaultTheme.headline, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("title", _this.title, defaultTheme.title, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("subhead", _this.subhead, defaultTheme.subhead, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("body2", _this.body2, defaultTheme.body2, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("body1", _this.body1, defaultTheme.body1, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("caption", _this.caption, defaultTheme.caption, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("button", _this.button, defaultTheme.button, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("subtitle)", _this.subtitle, defaultTheme.subtitle, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("overline", _this.overline, defaultTheme.overline, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
    }
  };
  K.Theme.prototype = {
    build$1: function(context) {
      var _null = null,
        t1 = this.data;
      return new K._InheritedTheme(this, new K.CupertinoTheme(new X.MaterialBasedCupertinoThemeData(t1, _null, _null, _null, _null, _null, _null), Y.IconTheme$(this.child, t1.iconTheme, _null), _null), _null);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("data", this.data, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_5, _null, X.ThemeData);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  K._InheritedTheme.prototype = {
    updateShouldNotify$1: function(old) {
      return !J.$eq$(this.theme.data, H.interceptedTypeCheck(old, "$is_InheritedTheme").theme.data);
    }
  };
  K.ThemeDataTween.prototype = {
    lerp$1: function(t) {
      var t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65, t66, t67, t68, t69, t70,
        t1 = this.begin,
        t2 = this.end;
      H.assertHelper(t1 != null);
      H.assertHelper(t2 != null);
      H.assertHelper(t != null);
      if (typeof t !== "number")
        return t.$lt();
      t3 = t < 0.5;
      t4 = t3 ? t1.brightness : t2.brightness;
      t5 = P.Color_lerp(t1.primaryColor, t2.primaryColor, t);
      t6 = t3 ? t1.primaryColorBrightness : t2.primaryColorBrightness;
      t7 = P.Color_lerp(t1.primaryColorLight, t2.primaryColorLight, t);
      t8 = P.Color_lerp(t1.primaryColorDark, t2.primaryColorDark, t);
      t9 = P.Color_lerp(t1.canvasColor, t2.canvasColor, t);
      t10 = P.Color_lerp(t1.accentColor, t2.accentColor, t);
      t11 = t3 ? t1.accentColorBrightness : t2.accentColorBrightness;
      t12 = P.Color_lerp(t1.scaffoldBackgroundColor, t2.scaffoldBackgroundColor, t);
      t13 = P.Color_lerp(t1.bottomAppBarColor, t2.bottomAppBarColor, t);
      t14 = P.Color_lerp(t1.cardColor, t2.cardColor, t);
      t15 = P.Color_lerp(t1.dividerColor, t2.dividerColor, t);
      t16 = P.Color_lerp(t1.highlightColor, t2.highlightColor, t);
      t17 = P.Color_lerp(t1.splashColor, t2.splashColor, t);
      t18 = t3 ? t1.splashFactory : t2.splashFactory;
      t19 = P.Color_lerp(t1.selectedRowColor, t2.selectedRowColor, t);
      t20 = P.Color_lerp(t1.unselectedWidgetColor, t2.unselectedWidgetColor, t);
      t21 = P.Color_lerp(t1.disabledColor, t2.disabledColor, t);
      t22 = t3 ? t1.buttonTheme : t2.buttonTheme;
      t23 = P.Color_lerp(t1.buttonColor, t2.buttonColor, t);
      t24 = P.Color_lerp(t1.secondaryHeaderColor, t2.secondaryHeaderColor, t);
      t25 = P.Color_lerp(t1.textSelectionColor, t2.textSelectionColor, t);
      t26 = P.Color_lerp(t1.cursorColor, t2.cursorColor, t);
      t27 = P.Color_lerp(t1.textSelectionHandleColor, t2.textSelectionHandleColor, t);
      t28 = P.Color_lerp(t1.backgroundColor, t2.backgroundColor, t);
      t29 = P.Color_lerp(t1.dialogBackgroundColor, t2.dialogBackgroundColor, t);
      t30 = P.Color_lerp(t1.indicatorColor, t2.indicatorColor, t);
      t31 = P.Color_lerp(t1.hintColor, t2.hintColor, t);
      t32 = P.Color_lerp(t1.errorColor, t2.errorColor, t);
      t33 = P.Color_lerp(t1.toggleableActiveColor, t2.toggleableActiveColor, t);
      t34 = R.TextTheme_lerp(t1.textTheme, t2.textTheme, t);
      t35 = R.TextTheme_lerp(t1.primaryTextTheme, t2.primaryTextTheme, t);
      t36 = R.TextTheme_lerp(t1.accentTextTheme, t2.accentTextTheme, t);
      t37 = t3 ? t1.inputDecorationTheme : t2.inputDecorationTheme;
      t38 = T.IconThemeData_lerp(t1.iconTheme, t2.iconTheme, t);
      t39 = T.IconThemeData_lerp(t1.primaryIconTheme, t2.primaryIconTheme, t);
      t40 = T.IconThemeData_lerp(t1.accentIconTheme, t2.accentIconTheme, t);
      t41 = t1.sliderTheme;
      t42 = t2.sliderTheme;
      t43 = P.lerpDouble(t41.trackHeight, t42.trackHeight, t);
      t44 = P.Color_lerp(t41.activeTrackColor, t42.activeTrackColor, t);
      t45 = P.Color_lerp(t41.inactiveTrackColor, t42.inactiveTrackColor, t);
      t46 = P.Color_lerp(t41.disabledActiveTrackColor, t42.disabledActiveTrackColor, t);
      t47 = P.Color_lerp(t41.disabledInactiveTrackColor, t42.disabledInactiveTrackColor, t);
      t48 = P.Color_lerp(t41.activeTickMarkColor, t42.activeTickMarkColor, t);
      t49 = P.Color_lerp(t41.inactiveTickMarkColor, t42.inactiveTickMarkColor, t);
      t50 = P.Color_lerp(t41.disabledActiveTickMarkColor, t42.disabledActiveTickMarkColor, t);
      t51 = P.Color_lerp(t41.disabledInactiveTickMarkColor, t42.disabledInactiveTickMarkColor, t);
      t52 = P.Color_lerp(t41.thumbColor, t42.thumbColor, t);
      t53 = P.Color_lerp(t41.disabledThumbColor, t42.disabledThumbColor, t);
      t54 = P.Color_lerp(t41.overlayColor, t42.overlayColor, t);
      t55 = P.Color_lerp(t41.valueIndicatorColor, t42.valueIndicatorColor, t);
      t56 = t3 ? t41.trackShape : t42.trackShape;
      t57 = t3 ? t41.tickMarkShape : t42.tickMarkShape;
      t58 = t3 ? t41.thumbShape : t42.thumbShape;
      t59 = t3 ? t41.overlayShape : t42.overlayShape;
      t60 = t3 ? t41.valueIndicatorShape : t42.valueIndicatorShape;
      t61 = t3 ? t41.showValueIndicator : t42.showValueIndicator;
      t42 = Q.SliderThemeData$(t48, t44, t50, t46, t51, t47, t53, t49, t45, t54, t59, t61, t52, t58, t57, t43, t56, t55, t60, A.TextStyle_lerp(t41.valueIndicatorTextStyle, t42.valueIndicatorTextStyle, t));
      t41 = t1.tabBarTheme;
      t60 = t2.tabBarTheme;
      t55 = Z.Decoration_lerp(t41.indicator, t60.indicator, t);
      t43 = t3 ? t41.indicatorSize : t60.indicatorSize;
      t60 = U.TabBarTheme$(t55, t43, P.Color_lerp(t41.labelColor, t60.labelColor, t), V.EdgeInsets_lerp(t41.labelPadding, t60.labelPadding, t), A.TextStyle_lerp(t41.labelStyle, t60.labelStyle, t), P.Color_lerp(t41.unselectedLabelColor, t60.unselectedLabelColor, t), A.TextStyle_lerp(t41.unselectedLabelStyle, t60.unselectedLabelStyle, t));
      t41 = t1.cardTheme;
      t43 = t2.cardTheme;
      if (t3)
        t44 = t41.clipBehavior;
      else
        t44 = t43.clipBehavior;
      t45 = P.Color_lerp(t41.color, t43.color, t);
      t46 = P.lerpDouble(t41.elevation, t43.elevation, t);
      t47 = V.EdgeInsetsGeometry_lerp(t41.margin, t43.margin, t);
      t41 = A.CardTheme$(t44, t45, t46, t47, Y.ShapeBorder_lerp(t41.shape, t43.shape, t));
      t43 = K.ChipThemeData_lerp(t1.chipTheme, t2.chipTheme, t);
      t44 = t3 ? t1.platform : t2.platform;
      t45 = t3 ? t1.materialTapTargetSize : t2.materialTapTargetSize;
      t46 = t3 ? t1.pageTransitionsTheme : t2.pageTransitionsTheme;
      t47 = t1.appBarTheme;
      t48 = t2.appBarTheme;
      if (t3)
        t49 = t47.brightness;
      else
        t49 = t48.brightness;
      t50 = P.Color_lerp(t47.color, t48.color, t);
      t51 = P.lerpDouble(t47.elevation, t48.elevation, t);
      t52 = T.IconThemeData_lerp(t47.iconTheme, t48.iconTheme, t);
      t53 = T.IconThemeData_lerp(t47.actionsIconTheme, t48.actionsIconTheme, t);
      t47 = R.TextTheme_lerp(t47.textTheme, t48.textTheme, t);
      t48 = t1.bottomAppBarTheme;
      t54 = t2.bottomAppBarTheme;
      t55 = P.Color_lerp(t48.color, t54.color, t);
      t56 = P.lerpDouble(t48.elevation, t54.elevation, t);
      if (t3)
        t48 = t48.shape;
      else
        t48 = t54.shape;
      t54 = t1.colorScheme;
      t57 = t2.colorScheme;
      t58 = P.Color_lerp(t54.primary, t57.primary, t);
      t59 = P.Color_lerp(t54.primaryVariant, t57.primaryVariant, t);
      t61 = P.Color_lerp(t54.secondary, t57.secondary, t);
      t62 = P.Color_lerp(t54.secondaryVariant, t57.secondaryVariant, t);
      t63 = P.Color_lerp(t54.surface, t57.surface, t);
      t64 = P.Color_lerp(t54.background, t57.background, t);
      t65 = P.Color_lerp(t54.error, t57.error, t);
      t66 = P.Color_lerp(t54.onPrimary, t57.onPrimary, t);
      t67 = P.Color_lerp(t54.onSecondary, t57.onSecondary, t);
      t68 = P.Color_lerp(t54.onSurface, t57.onSurface, t);
      t69 = P.Color_lerp(t54.onBackground, t57.onBackground, t);
      t70 = P.Color_lerp(t54.onError, t57.onError, t);
      t54 = A.ColorScheme$(t64, t3 ? t54.brightness : t57.brightness, t65, t69, t70, t66, t67, t68, t58, t59, t61, t62, t63);
      t57 = t1.dialogTheme;
      t58 = t2.dialogTheme;
      t59 = P.Color_lerp(t57.backgroundColor, t58.backgroundColor, t);
      t61 = P.lerpDouble(t57.elevation, t58.elevation, t);
      t62 = Y.ShapeBorder_lerp(t57.shape, t58.shape, t);
      t63 = A.TextStyle_lerp(t57.titleTextStyle, t58.titleTextStyle, t);
      t57 = A.TextStyle_lerp(t57.contentTextStyle, t58.contentTextStyle, t);
      t58 = S.FloatingActionButtonThemeData_lerp(t1.floatingActionButtonTheme, t2.floatingActionButtonTheme, t);
      t64 = t1.typography;
      t65 = t2.typography;
      t66 = R.TextTheme_lerp(t64.black, t65.black, t);
      t67 = R.TextTheme_lerp(t64.white, t65.white, t);
      t68 = R.TextTheme_lerp(t64.englishLike, t65.englishLike, t);
      t67 = U.Typography_Typography(t66, R.TextTheme_lerp(t64.dense, t65.dense, t), t68, C.TargetPlatform_0, R.TextTheme_lerp(t64.tall, t65.tall, t), t67);
      t64 = t3 ? t1.cupertinoOverrideTheme : t2.cupertinoOverrideTheme;
      t1 = t1.snackBarTheme;
      t2 = t2.snackBarTheme;
      t65 = P.Color_lerp(t1.backgroundColor, t2.backgroundColor, t);
      t66 = P.Color_lerp(t1.actionTextColor, t2.actionTextColor, t);
      t68 = P.Color_lerp(t1.disabledActionTextColor, t2.disabledActionTextColor, t);
      t69 = P.lerpDouble(t1.elevation, t2.elevation, t);
      t70 = Y.ShapeBorder_lerp(t1.shape, t2.shape, t);
      return X.ThemeData$raw(t10, t11, t40, t36, new V.AppBarTheme(t49, t50, t51, t52, t53, t47), t28, t13, new D.BottomAppBarTheme(t55, t56, t48), t4, t23, t22, t9, t14, t41, t43, t54, t64, t26, t29, new Y.DialogTheme(t59, t61, t62, t63, t57), t21, t15, t32, t58, t16, t31, t38, t30, t37, t45, t46, t44, t5, t6, t8, t7, t39, t35, t12, t24, t19, t42, K.SnackBarThemeData$(t66, t65, t3 ? t1.behavior : t2.behavior, t68, t69, t70), t17, t18, t60, t25, t27, t34, t33, t67, t20);
    },
    $asAnimatable: function() {
      return [X.ThemeData];
    },
    $asTween: function() {
      return [X.ThemeData];
    }
  };
  K.AnimatedTheme.prototype = {
    createState$0: function() {
      return new K._AnimatedThemeState(null, C._StateLifecycle_0);
    },
    get$child: function() {
      return this.child;
    }
  };
  K._AnimatedThemeState.prototype = {
    forEachTween$1: function(visitor) {
      var t1 = H.interceptedTypeCheck(H.functionTypeCheck(visitor, {func: 1, ret: [R.Tween,,], args: [[R.Tween,,],, {func: 1, ret: [R.Tween,,], args: [,]}]}).call$3(this._theme$_data, this._widget.data, new K._AnimatedThemeState_forEachTween_closure()), "$isThemeDataTween");
      this._theme$_data = t1;
      H.assertHelper(t1 != null);
    },
    build$1: function(context) {
      var t1 = this._widget.child,
        t2 = this._theme$_data,
        t3 = this._animation;
      t2.toString;
      return new K.Theme(t2.transform$1(H.assertSubtype(t3, "$isAnimation", [P.double], "$asAnimation").get$value()), true, t1, null);
    },
    debugFillProperties$1: function(description) {
      var t1, _null = null;
      this.super$_ImplicitlyAnimatedWidgetState_State_SingleTickerProviderStateMixin$debugFillProperties(description);
      t1 = Y.DiagnosticsProperty$("data", this._theme$_data, _null, _null, _null, _null, C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_5, _null, K.ThemeDataTween);
      C.JSArray_methods.add$1(description.properties, t1);
    },
    $asState: function() {
      return [K.AnimatedTheme];
    },
    $asImplicitlyAnimatedWidgetState: function() {
      return [K.AnimatedTheme];
    }
  };
  K._AnimatedThemeState_forEachTween_closure.prototype = {
    call$1: function(value) {
      return new K.ThemeDataTween(H.interceptedTypeCheck(value, "$isThemeData"), null);
    },
    $signature: 76
  };
  X.MaterialTapTargetSize.prototype = {
    toString$0: function(_) {
      return this._theme_data$_name;
    }
  };
  X.ThemeData.prototype = {
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isThemeData");
      if (other.brightness === _this.brightness)
        if (J.$eq$(other.primaryColor, _this.primaryColor))
          if (other.primaryColorBrightness === _this.primaryColorBrightness)
            if (J.$eq$(other.primaryColorLight, _this.primaryColorLight))
              if (J.$eq$(other.primaryColorDark, _this.primaryColorDark))
                if (J.$eq$(other.accentColor, _this.accentColor))
                  if (other.accentColorBrightness === _this.accentColorBrightness)
                    if (J.$eq$(other.canvasColor, _this.canvasColor))
                      if (J.$eq$(other.scaffoldBackgroundColor, _this.scaffoldBackgroundColor))
                        if (J.$eq$(other.bottomAppBarColor, _this.bottomAppBarColor))
                          if (J.$eq$(other.cardColor, _this.cardColor))
                            if (J.$eq$(other.dividerColor, _this.dividerColor))
                              if (J.$eq$(other.highlightColor, _this.highlightColor))
                                if (J.$eq$(other.splashColor, _this.splashColor))
                                  if (other.splashFactory === _this.splashFactory)
                                    if (J.$eq$(other.selectedRowColor, _this.selectedRowColor))
                                      if (J.$eq$(other.unselectedWidgetColor, _this.unselectedWidgetColor))
                                        if (J.$eq$(other.disabledColor, _this.disabledColor))
                                          if (other.buttonTheme.$eq(0, _this.buttonTheme))
                                            if (J.$eq$(other.buttonColor, _this.buttonColor))
                                              if (J.$eq$(other.secondaryHeaderColor, _this.secondaryHeaderColor))
                                                if (J.$eq$(other.textSelectionColor, _this.textSelectionColor))
                                                  if (J.$eq$(other.cursorColor, _this.cursorColor))
                                                    if (J.$eq$(other.textSelectionHandleColor, _this.textSelectionHandleColor))
                                                      if (J.$eq$(other.backgroundColor, _this.backgroundColor))
                                                        if (J.$eq$(other.dialogBackgroundColor, _this.dialogBackgroundColor))
                                                          if (J.$eq$(other.indicatorColor, _this.indicatorColor))
                                                            if (J.$eq$(other.hintColor, _this.hintColor))
                                                              if (J.$eq$(other.errorColor, _this.errorColor))
                                                                if (J.$eq$(other.toggleableActiveColor, _this.toggleableActiveColor))
                                                                  if (other.textTheme.$eq(0, _this.textTheme))
                                                                    if (other.primaryTextTheme.$eq(0, _this.primaryTextTheme))
                                                                      if (other.accentTextTheme.$eq(0, _this.accentTextTheme))
                                                                        if (other.inputDecorationTheme === _this.inputDecorationTheme)
                                                                          if (other.iconTheme.$eq(0, _this.iconTheme))
                                                                            if (other.primaryIconTheme.$eq(0, _this.primaryIconTheme))
                                                                              if (other.accentIconTheme.$eq(0, _this.accentIconTheme))
                                                                                if (other.sliderTheme.$eq(0, _this.sliderTheme))
                                                                                  if (other.tabBarTheme.$eq(0, _this.tabBarTheme))
                                                                                    if (other.cardTheme.$eq(0, _this.cardTheme))
                                                                                      if (J.$eq$(other.chipTheme, _this.chipTheme))
                                                                                        if (other.platform == _this.platform)
                                                                                          if (other.materialTapTargetSize === _this.materialTapTargetSize)
                                                                                            if (other.pageTransitionsTheme.$eq(0, _this.pageTransitionsTheme))
                                                                                              if (other.appBarTheme.$eq(0, _this.appBarTheme))
                                                                                                if (other.bottomAppBarTheme.$eq(0, _this.bottomAppBarTheme))
                                                                                                  if (other.colorScheme.$eq(0, _this.colorScheme))
                                                                                                    if (other.dialogTheme.$eq(0, _this.dialogTheme))
                                                                                                      if (J.$eq$(other.floatingActionButtonTheme, _this.floatingActionButtonTheme))
                                                                                                        if (other.typography.$eq(0, _this.typography))
                                                                                                          t1 = other.snackBarTheme.$eq(0, _this.snackBarTheme);
                                                                                                        else
                                                                                                          t1 = false;
                                                                                                      else
                                                                                                        t1 = false;
                                                                                                    else
                                                                                                      t1 = false;
                                                                                                  else
                                                                                                    t1 = false;
                                                                                                else
                                                                                                  t1 = false;
                                                                                              else
                                                                                                t1 = false;
                                                                                            else
                                                                                              t1 = false;
                                                                                          else
                                                                                            t1 = false;
                                                                                        else
                                                                                          t1 = false;
                                                                                      else
                                                                                        t1 = false;
                                                                                    else
                                                                                      t1 = false;
                                                                                  else
                                                                                    t1 = false;
                                                                                else
                                                                                  t1 = false;
                                                                              else
                                                                                t1 = false;
                                                                            else
                                                                              t1 = false;
                                                                          else
                                                                            t1 = false;
                                                                        else
                                                                          t1 = false;
                                                                      else
                                                                        t1 = false;
                                                                    else
                                                                      t1 = false;
                                                                  else
                                                                    t1 = false;
                                                                else
                                                                  t1 = false;
                                                              else
                                                                t1 = false;
                                                            else
                                                              t1 = false;
                                                          else
                                                            t1 = false;
                                                        else
                                                          t1 = false;
                                                      else
                                                        t1 = false;
                                                    else
                                                      t1 = false;
                                                  else
                                                    t1 = false;
                                                else
                                                  t1 = false;
                                              else
                                                t1 = false;
                                            else
                                              t1 = false;
                                          else
                                            t1 = false;
                                        else
                                          t1 = false;
                                      else
                                        t1 = false;
                                    else
                                      t1 = false;
                                  else
                                    t1 = false;
                                else
                                  t1 = false;
                              else
                                t1 = false;
                            else
                              t1 = false;
                          else
                            t1 = false;
                        else
                          t1 = false;
                      else
                        t1 = false;
                    else
                      t1 = false;
                  else
                    t1 = false;
                else
                  t1 = false;
              else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.brightness, _this.primaryColor, _this.primaryColorBrightness, _this.primaryColorLight, _this.primaryColorDark, _this.accentColor, _this.accentColorBrightness, _this.canvasColor, _this.scaffoldBackgroundColor, _this.bottomAppBarColor, _this.cardColor, _this.dividerColor, _this.highlightColor, _this.splashColor, _this.splashFactory, _this.selectedRowColor, _this.unselectedWidgetColor, _this.disabledColor, _this.buttonTheme, P.hashValues(_this.buttonColor, _this.toggleableActiveColor, _this.secondaryHeaderColor, _this.textSelectionColor, _this.cursorColor, _this.textSelectionHandleColor, _this.backgroundColor, _this.dialogBackgroundColor, _this.indicatorColor, _this.hintColor, _this.errorColor, _this.textTheme, _this.primaryTextTheme, _this.accentTextTheme, _this.inputDecorationTheme, _this.iconTheme, _this.primaryIconTheme, _this.accentIconTheme, _this.sliderTheme, P.hashValues(_this.tabBarTheme, _this.cardTheme, _this.chipTheme, _this.platform, _this.materialTapTargetSize, _this.pageTransitionsTheme, _this.appBarTheme, _this.bottomAppBarTheme, _this.colorScheme, _this.dialogTheme, _this.floatingActionButtonTheme, _this.typography, _this.cupertinoOverrideTheme, _this.snackBarTheme, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd)));
    },
    debugFillProperties$1: function(properties) {
      var defaultData, t1, t2, t3, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      defaultData = X.ThemeData_ThemeData(C.Brightness_1, _null, _null, _null, _null);
      t1 = T.defaultTargetPlatform();
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, _this.platform, t1, C.DiagnosticLevel_3, "platform", true, true, C.DiagnosticsTreeStyle_5, [T.TargetPlatform]));
      t1 = [P.Brightness];
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, _this.brightness, defaultData.brightness, C.DiagnosticLevel_3, "brightness", true, true, C.DiagnosticsTreeStyle_5, t1));
      t3 = P.Color;
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("primaryColor", _this.primaryColor, defaultData.primaryColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, _this.primaryColorBrightness, defaultData.primaryColorBrightness, C.DiagnosticLevel_3, "primaryColorBrightness", true, true, C.DiagnosticsTreeStyle_5, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("accentColor", _this.accentColor, defaultData.accentColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, _this.accentColorBrightness, defaultData.accentColorBrightness, C.DiagnosticLevel_3, "accentColorBrightness", true, true, C.DiagnosticsTreeStyle_5, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("canvasColor", _this.canvasColor, defaultData.canvasColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("scaffoldBackgroundColor", _this.scaffoldBackgroundColor, defaultData.scaffoldBackgroundColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("bottomAppBarColor", _this.bottomAppBarColor, defaultData.bottomAppBarColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("cardColor", _this.cardColor, defaultData.cardColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("dividerColor", _this.dividerColor, defaultData.dividerColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("highlightColor", _this.highlightColor, defaultData.highlightColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("splashColor", _this.splashColor, defaultData.splashColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("selectedRowColor", _this.selectedRowColor, defaultData.selectedRowColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("unselectedWidgetColor", _this.unselectedWidgetColor, defaultData.unselectedWidgetColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("disabledColor", _this.disabledColor, defaultData.disabledColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("buttonColor", _this.buttonColor, defaultData.buttonColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("secondaryHeaderColor", _this.secondaryHeaderColor, defaultData.secondaryHeaderColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("textSelectionColor", _this.textSelectionColor, defaultData.textSelectionColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("cursorColor", _this.cursorColor, defaultData.cursorColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("textSelectionHandleColor", _this.textSelectionHandleColor, defaultData.textSelectionHandleColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("backgroundColor", _this.backgroundColor, defaultData.backgroundColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("dialogBackgroundColor", _this.dialogBackgroundColor, defaultData.dialogBackgroundColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("indicatorColor", _this.indicatorColor, defaultData.indicatorColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("hintColor", _this.hintColor, defaultData.hintColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("errorColor", _this.errorColor, defaultData.errorColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("toggleableActiveColor", _this.toggleableActiveColor, defaultData.toggleableActiveColor, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("buttonTheme", _this.buttonTheme, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, M.ButtonThemeData));
      t1 = R.TextTheme;
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("textTheme", _this.textTheme, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("primaryTextTheme", _this.primaryTextTheme, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("accentTextTheme", _this.accentTextTheme, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("inputDecorationTheme", _this.inputDecorationTheme, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, L.InputDecorationTheme));
      t1 = T.IconThemeData;
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("iconTheme", _this.iconTheme, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("primaryIconTheme", _this.primaryIconTheme, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("accentIconTheme", _this.accentIconTheme, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("sliderTheme", _this.sliderTheme, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, Q.SliderThemeData));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("tabBarTheme", _this.tabBarTheme, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, U.TabBarTheme));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("cardTheme", _this.cardTheme, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, A.CardTheme));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("chipTheme", _this.chipTheme, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.ChipThemeData));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("materialTapTargetSize", _this.materialTapTargetSize, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, X.MaterialTapTargetSize));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("pageTransitionsTheme", _this.pageTransitionsTheme, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.PageTransitionsTheme));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("appBarTheme", _this.appBarTheme, defaultData.appBarTheme, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, V.AppBarTheme));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("bottomAppBarTheme", _this.bottomAppBarTheme, defaultData.bottomAppBarTheme, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, D.BottomAppBarTheme));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("colorScheme", _this.colorScheme, defaultData.colorScheme, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, A.ColorScheme));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("dialogTheme", _this.dialogTheme, defaultData.dialogTheme, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, Y.DialogTheme));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("floatingActionButtonThemeData", _this.floatingActionButtonTheme, defaultData.floatingActionButtonTheme, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, S.FloatingActionButtonThemeData));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("typography", _this.typography, defaultData.typography, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, U.Typography));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("cupertinoOverrideTheme", _this.cupertinoOverrideTheme, defaultData.cupertinoOverrideTheme, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.CupertinoThemeData));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("snackBarTheme", _this.snackBarTheme, defaultData.snackBarTheme, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.SnackBarThemeData));
    }
  };
  X.ThemeData_localize_closure.prototype = {
    call$0: function() {
      var t1 = this.baseTheme,
        t2 = this.localTextGeometry,
        t3 = t2.merge$1(t1.primaryTextTheme),
        t4 = t2.merge$1(t1.accentTextTheme);
      t2 = t2.merge$1(t1.textTheme);
      return X.ThemeData$raw(t1.accentColor, t1.accentColorBrightness, t1.accentIconTheme, t4, t1.appBarTheme, t1.backgroundColor, t1.bottomAppBarColor, t1.bottomAppBarTheme, t1.brightness, t1.buttonColor, t1.buttonTheme, t1.canvasColor, t1.cardColor, t1.cardTheme, t1.chipTheme, t1.colorScheme, t1.cupertinoOverrideTheme, t1.cursorColor, t1.dialogBackgroundColor, t1.dialogTheme, t1.disabledColor, t1.dividerColor, t1.errorColor, t1.floatingActionButtonTheme, t1.highlightColor, t1.hintColor, t1.iconTheme, t1.indicatorColor, t1.inputDecorationTheme, t1.materialTapTargetSize, t1.pageTransitionsTheme, t1.platform, t1.primaryColor, t1.primaryColorBrightness, t1.primaryColorDark, t1.primaryColorLight, t1.primaryIconTheme, t3, t1.scaffoldBackgroundColor, t1.secondaryHeaderColor, t1.selectedRowColor, t1.sliderTheme, t1.snackBarTheme, t1.splashColor, t1.splashFactory, t1.tabBarTheme, t1.textSelectionColor, t1.textSelectionHandleColor, t2, t1.toggleableActiveColor, t1.typography, t1.unselectedWidgetColor);
    },
    $signature: 77
  };
  X.MaterialBasedCupertinoThemeData.prototype = {
    get$brightness: function() {
      var t1 = this._materialTheme.brightness;
      return t1;
    },
    get$primaryColor: function() {
      var t1 = this._materialTheme.colorScheme;
      return t1.primary;
    },
    get$primaryContrastingColor: function() {
      var t1 = this._materialTheme.colorScheme;
      return t1.onPrimary;
    },
    get$scaffoldBackgroundColor: function() {
      var t1 = this._materialTheme.scaffoldBackgroundColor;
      return t1;
    }
  };
  X._IdentityThemeDataCacheKey.prototype = {
    get$hashCode: function(_) {
      return (H.objectHashCode(this.baseTheme) ^ H.objectHashCode(this.localTextGeometry)) >>> 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      H.interceptedTypeCheck(other, "$is_IdentityThemeDataCacheKey");
      return this.baseTheme === other.baseTheme && this.localTextGeometry === other.localTextGeometry;
    }
  };
  X._FifoCache.prototype = {
    putIfAbsent$2: function(key, loader) {
      var t1, result, t2, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.functionTypeCheck(loader, {func: 1, ret: H.getTypeArgumentByIndex(_this, 1)});
      t1 = _this._cache;
      result = t1.$index(0, key);
      if (result != null)
        return result;
      if (t1.get$length(t1) === _this._maximumSize) {
        t2 = t1.get$keys();
        t1.remove$1(0, t2.get$first(t2));
      }
      t2 = loader.call$0();
      t1.$indexSet(0, key, t2);
      return t2;
    }
  };
  S.Tooltip.prototype = {
    createState$0: function() {
      return new S._TooltipState(null, C._StateLifecycle_0);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.StringProperty$("message", this.message, C.C__NoDefaultValue, true, false);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("vertical offset", 24, C.C__NoDefaultValue, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t2, Y.FlagProperty$("position", _null, "above", "below", C.DiagnosticLevel_3, true, true));
    },
    get$excludeFromSemantics: function() {
      return false;
    },
    get$child: function() {
      return this.child;
    }
  };
  S._TooltipState.prototype = {
    initState$0: function() {
      var t1, _this = this;
      _this.super$State$initState();
      t1 = G.AnimationController$(null, C.Duration_200000, 0, 1, null, _this);
      t1.addStatusListener$1(_this.get$_handleStatusChanged());
      _this._controller = t1;
    },
    _handleStatusChanged$1: function($status) {
      if (H.interceptedTypeCheck($status, "$isAnimationStatus") === C.AnimationStatus_0)
        this._removeEntry$0();
    },
    ensureTooltipVisible$0: function() {
      var t1, box, target, t2, t3, _this = this;
      if (_this._entry != null) {
        t1 = _this._tooltip$_timer;
        if (t1 != null)
          t1.cancel$0();
        _this._tooltip$_timer = null;
        _this._controller.forward$0();
        return false;
      }
      box = H.interceptedTypeCheck(_this._element.get$renderObject(), "$isRenderBox");
      t1 = box.get$size().center$1(C.Offset_0_0);
      target = T.MatrixUtils_transformPoint(box.getTransformTo$1(null), t1);
      t1 = _this._widget;
      t2 = t1.message;
      t1.toString;
      t1 = S.CurvedAnimation$(C.Cubic_ifx, _this._controller, null);
      t3 = _this._widget;
      t3.toString;
      _this._entry = X.OverlayEntry$(new S._TooltipState_ensureTooltipVisible_closure(new S._TooltipOverlay(t2, 32, C.EdgeInsets_16_0_16_0, t1, target, 24, true, null)), false);
      X.Overlay_of(_this._element, t3).insert$1(0, _this._entry);
      $.GestureBinding__instance.GestureBinding_pointerRouter.addGlobalRoute$1(_this.get$_tooltip$_handlePointerEvent());
      S.SemanticsService_tooltip(_this._widget.message);
      _this._controller.forward$0();
      return true;
    },
    _removeEntry$0: function() {
      var t1, t2, _this = this;
      H.assertHelper(_this._entry != null);
      t1 = _this._tooltip$_timer;
      if (t1 != null)
        t1.cancel$0();
      _this._tooltip$_timer = null;
      _this._entry.remove$0(0);
      _this._entry = null;
      t1 = $.GestureBinding__instance.GestureBinding_pointerRouter;
      t2 = H.functionTypeCheck(_this.get$_tooltip$_handlePointerEvent(), {func: 1, ret: -1, args: [F.PointerEvent]});
      t1 = t1._globalRoutes;
      H.assertHelper(t1.contains$1(0, t2));
      t1.remove$1(0, t2);
    },
    _tooltip$_handlePointerEvent$1: function($event) {
      var t1, _this = this;
      H.interceptedTypeCheck($event, "$isPointerEvent");
      H.assertHelper(_this._entry != null);
      t1 = J.getInterceptor$($event);
      if (!!t1.$isPointerUpEvent || !!t1.$isPointerCancelEvent) {
        if (_this._tooltip$_timer == null)
          _this._tooltip$_timer = P.Timer_Timer(C.Duration_1500000, _this._controller.get$reverse());
      } else if (!!t1.$isPointerDownEvent)
        _this._controller.reverse$0();
    },
    deactivate$0: function() {
      if (this._entry != null)
        this._controller.reverse$0();
      this.super$State$deactivate();
    },
    dispose$0: function() {
      var _this = this;
      if (_this._entry != null)
        _this._removeEntry$0();
      _this._controller.dispose$0();
      _this.super$__TooltipState_State_SingleTickerProviderStateMixin$dispose();
    },
    _handleLongPress$0: function() {
      if (this.ensureTooltipVisible$0())
        M.Feedback_forLongPress(this._element);
    },
    build$1: function(context) {
      var t1, t2, _null = null;
      H.assertHelper(X.Overlay_of(context, this._widget) != null);
      t1 = this._widget;
      t2 = t1.message;
      return D.GestureDetector$(C.HitTestBehavior_1, T.Semantics$(_null, t1.child, false, _null, false, _null, t2, _null, _null, _null, _null), C.DragStartBehavior_1, true, _null, _null, _null, _null, _null, _null, this.get$_handleLongPress(), _null, _null, _null, _null, _null, _null, _null, _null);
    },
    $isTickerProvider: 1,
    $asState: function() {
      return [S.Tooltip];
    }
  };
  S._TooltipState_ensureTooltipVisible_closure.prototype = {
    call$1: function(context) {
      H.interceptedTypeCheck(context, "$isBuildContext");
      return this.overlay;
    },
    $signature: 11
  };
  S._TooltipPositionDelegate.prototype = {
    getConstraintsForChild$1: function(constraints) {
      return constraints.loosen$0();
    },
    getPositionForChild$2: function(size, childSize) {
      return N.positionDependentBox(childSize, true, size, this.target, this.verticalOffset);
    },
    shouldRelayout$1: function(oldDelegate) {
      H.interceptedTypeCheck(oldDelegate, "$is_TooltipPositionDelegate");
      return !this.target.$eq(0, oldDelegate.target) || this.verticalOffset !== oldDelegate.verticalOffset || false;
    },
    get$target: function(receiver) {
      return this.target;
    }
  };
  S._TooltipOverlay.prototype = {
    build$1: function(context) {
      var _this = this, _null = null,
        theme = K.Theme_of(context),
        t1 = theme.brightness === C.Brightness_0 ? theme.textTheme : theme.primaryTextTheme,
        darkTheme = X.ThemeData_ThemeData(C.Brightness_0, _null, theme.platform, _null, t1);
      t1 = new P.Radius(2, 2);
      t1 = S.BoxDecoration$(_null, new K.BorderRadius(t1, t1, t1, t1), _null, darkTheme.backgroundColor, _null, _null, C.BoxShape_0);
      return new T.Positioned(0, 0, 0, 0, _null, _null, T.IgnorePointer$(T.CustomSingleChildLayout$(K.FadeTransition$(T.Opacity$(T.ConstrainedBox$(M.Container$(_null, new T.Center(C.Alignment_0_0, 1, 1, L.Text$(_this.message, darkTheme.textTheme.body1), _null), _null, _null, t1, _this.padding, _null), new S.BoxConstraints(0, 1 / 0, _this.height, 1 / 0)), 0.9), _this.animation), new S._TooltipPositionDelegate(_this.target, _this.verticalOffset, true)), true, _null, _null), _null);
    },
    get$target: function(receiver) {
      return this.target;
    }
  };
  S.__TooltipState_State_SingleTickerProviderStateMixin_dispose_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1.SingleTickerProviderStateMixin__ticker;
      if (t2 == null || t2._future == null)
        return true;
      throw H.wrapException(U.FlutterError$(t1.toString$0(0) + " was disposed with an active Ticker.\n" + H.getRuntimeType(t1).toString$0(0) + " created a Ticker via its SingleTickerProviderStateMixin, but at the time dispose() was called on the mixin, that Ticker was still active. The Ticker must be disposed before calling super.dispose(). Tickers used by AnimationControllers should be disposed by calling dispose() on the AnimationController itself. Otherwise, the ticker will leak.\nThe offending ticker was: " + J.toString$1$debugIncludeStack$(t1.SingleTickerProviderStateMixin__ticker, true)));
    },
    $signature: 0
  };
  S.__TooltipState_State_SingleTickerProviderStateMixin.prototype = {
    dispose$0: function() {
      H.assertHelper(new S.__TooltipState_State_SingleTickerProviderStateMixin_dispose_closure(this).call$0());
      this.super$State$dispose();
    },
    didChangeDependencies$0: function() {
      var t1 = this.SingleTickerProviderStateMixin__ticker;
      if (t1 != null)
        t1.set$muted(!U.TickerMode_of(this._element));
      this.super$State$didChangeDependencies();
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, tickerDescription, _null = null;
      this.super$State$debugFillProperties(properties);
      t1 = this.SingleTickerProviderStateMixin__ticker;
      if (t1 != null) {
        t2 = t1._future != null;
        if (t2 && t1._muted)
          tickerDescription = "active but muted";
        else if (t2)
          tickerDescription = "active";
        else
          tickerDescription = t1._muted ? "inactive and muted" : "inactive";
      } else
        tickerDescription = _null;
      t1 = Y.DiagnosticsProperty$("ticker", t1, _null, tickerDescription, _null, _null, C.DiagnosticLevel_3, false, true, false, C.DiagnosticsTreeStyle_5, _null, M.Ticker);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  U.ScriptCategory.prototype = {
    toString$0: function(_) {
      return this._typography$_name;
    }
  };
  U.Typography.prototype = {
    geometryThemeFor$1: function(category) {
      switch (category) {
        case C.ScriptCategory_0:
          return this.englishLike;
        case C.ScriptCategory_1:
          return this.dense;
        case C.ScriptCategory_2:
          return this.tall;
      }
      return;
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isTypography");
      return J.$eq$(other.black, _this.black) && J.$eq$(other.white, _this.white) && other.englishLike.$eq(0, _this.englishLike) && other.dense.$eq(0, _this.dense) && other.tall.$eq(0, _this.tall);
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.black, _this.white, _this.englishLike, _this.dense, _this.tall, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    debugFillProperties$1: function(properties) {
      var defaultTypography, t1, t2, t3, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      defaultTypography = U.Typography_Typography(_null, _null, _null, C.TargetPlatform_0, _null, _null);
      t1 = R.TextTheme;
      t2 = Y.DiagnosticsProperty$("black", _this.black, defaultTypography.black, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t2);
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("white", _this.white, defaultTypography.white, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("englishLike", _this.englishLike, defaultTypography.englishLike, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("dense", _this.dense, defaultTypography.dense, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("tall", _this.tall, defaultTypography.tall, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
    }
  };
  K.AlignmentGeometry.prototype = {
    toString$0: function(_) {
      var _this = this;
      if (_this.get$_alignment$_start() === 0)
        return K.Alignment__stringify(_this.get$_x(), _this.get$_y());
      if (_this.get$_x() === 0)
        return K.AlignmentDirectional__stringify(_this.get$_alignment$_start(), _this.get$_y());
      return K.Alignment__stringify(_this.get$_x(), _this.get$_y()) + " + " + K.AlignmentDirectional__stringify(_this.get$_alignment$_start(), 0);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof K.AlignmentGeometry))
        return false;
      return this.get$_x() == other.get$_x() && this.get$_alignment$_start() == other.get$_alignment$_start() && this.get$_y() == other.get$_y();
    },
    get$hashCode: function(_) {
      return P.hashValues(this.get$_x(), this.get$_alignment$_start(), this.get$_y(), C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    }
  };
  K.Alignment.prototype = {
    get$_x: function() {
      return this.x;
    },
    get$_alignment$_start: function() {
      return 0;
    },
    get$_y: function() {
      return this.y;
    },
    $sub: function(_, other) {
      var t1, t2, t3, t4;
      H.interceptedTypeCheck(other, "$isAlignment");
      t1 = this.x;
      t2 = other.x;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this.y;
      t4 = other.y;
      if (typeof t3 !== "number")
        return t3.$sub();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return K.Alignment$(t1 - t2, t3 - t4);
    },
    $add: function(_, other) {
      var t1, t2, t3, t4;
      H.interceptedTypeCheck(other, "$isAlignment");
      t1 = this.x;
      t2 = other.x;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this.y;
      t4 = other.y;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return K.Alignment$(t1 + t2, t3 + t4);
    },
    $mul: function(_, other) {
      var t2,
        t1 = this.x;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof other !== "number")
        return H.iae(other);
      t2 = this.y;
      if (typeof t2 !== "number")
        return t2.$mul();
      return K.Alignment$(t1 * other, t2 * other);
    },
    alongOffset$1: function(other) {
      var centerX, centerY, t2,
        t1 = other._dx;
      if (typeof t1 !== "number")
        return t1.$div();
      centerX = t1 / 2;
      t1 = other._dy;
      if (typeof t1 !== "number")
        return t1.$div();
      centerY = t1 / 2;
      t1 = this.x;
      if (typeof t1 !== "number")
        return t1.$mul();
      t2 = this.y;
      if (typeof t2 !== "number")
        return t2.$mul();
      return new P.Offset(centerX + t1 * centerX, centerY + t2 * centerY);
    },
    withinRect$1: function(rect) {
      var halfWidth, t3, halfHeight, t4,
        t1 = rect.right,
        t2 = rect.left;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      halfWidth = (t1 - t2) / 2;
      t1 = rect.bottom;
      t3 = rect.top;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t3 !== "number")
        return H.iae(t3);
      halfHeight = (t1 - t3) / 2;
      t1 = this.x;
      if (typeof t1 !== "number")
        return t1.$mul();
      t4 = this.y;
      if (typeof t4 !== "number")
        return t4.$mul();
      return new P.Offset(t2 + halfWidth + t1 * halfWidth, t3 + halfHeight + t4 * halfHeight);
    },
    resolve$1: function(direction) {
      return this;
    },
    toString$0: function(_) {
      return K.Alignment__stringify(this.x, this.y);
    }
  };
  K.AlignmentDirectional.prototype = {
    get$_x: function() {
      return 0;
    },
    get$_alignment$_start: function() {
      return this.start;
    },
    get$_y: function() {
      return this.y;
    },
    $sub: function(_, other) {
      var t1, t2, t3, t4;
      H.interceptedTypeCheck(other, "$isAlignmentDirectional");
      t1 = this.start;
      t2 = other.start;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this.y;
      t4 = other.y;
      if (typeof t3 !== "number")
        return t3.$sub();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return K.AlignmentDirectional$(t1 - t2, t3 - t4);
    },
    $add: function(_, other) {
      var t1, t2, t3, t4;
      H.interceptedTypeCheck(other, "$isAlignmentDirectional");
      t1 = this.start;
      t2 = other.start;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this.y;
      t4 = other.y;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return K.AlignmentDirectional$(t1 + t2, t3 + t4);
    },
    $mul: function(_, other) {
      var t2,
        t1 = this.start;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof other !== "number")
        return H.iae(other);
      t2 = this.y;
      if (typeof t2 !== "number")
        return t2.$mul();
      return K.AlignmentDirectional$(t1 * other, t2 * other);
    },
    resolve$1: function(direction) {
      var t1, _this = this;
      H.assertHelper(direction != null);
      switch (direction) {
        case C.TextDirection_0:
          t1 = _this.start;
          if (typeof t1 !== "number")
            return t1.$negate();
          return K.Alignment$(-t1, _this.y);
        case C.TextDirection_1:
          return K.Alignment$(_this.start, _this.y);
      }
      return;
    },
    toString$0: function(_) {
      return K.AlignmentDirectional__stringify(this.start, this.y);
    }
  };
  K._MixedAlignment.prototype = {
    $mul: function(_, other) {
      var t2, t3,
        t1 = this._x;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof other !== "number")
        return H.iae(other);
      t2 = this._alignment$_start;
      if (typeof t2 !== "number")
        return t2.$mul();
      t3 = this._y;
      if (typeof t3 !== "number")
        return t3.$mul();
      return new K._MixedAlignment(t1 * other, t2 * other, t3 * other);
    },
    resolve$1: function(direction) {
      var t1, t2, _this = this;
      switch (direction) {
        case C.TextDirection_0:
          t1 = _this._x;
          t2 = _this._alignment$_start;
          if (typeof t1 !== "number")
            return t1.$sub();
          if (typeof t2 !== "number")
            return H.iae(t2);
          return K.Alignment$(t1 - t2, _this._y);
        case C.TextDirection_1:
          t1 = _this._x;
          t2 = _this._alignment$_start;
          if (typeof t1 !== "number")
            return t1.$add();
          if (typeof t2 !== "number")
            return H.iae(t2);
          return K.Alignment$(t1 + t2, _this._y);
      }
      return;
    },
    get$_x: function() {
      return this._x;
    },
    get$_alignment$_start: function() {
      return this._alignment$_start;
    },
    get$_y: function() {
      return this._y;
    }
  };
  G.RenderComparison.prototype = {
    toString$0: function(_) {
      return this._basic_types$_name;
    }
  };
  G.Axis.prototype = {
    toString$0: function(_) {
      return this._basic_types$_name;
    }
  };
  G.VerticalDirection.prototype = {
    toString$0: function(_) {
      return this._basic_types$_name;
    }
  };
  N.PaintingBinding.prototype = {};
  K.BorderRadiusGeometry.prototype = {
    subtract$1: function(other) {
      var _this = this;
      return new K._MixedBorderRadius(_this.get$_topLeft().$sub(0, other.get$_topLeft()), _this.get$_topRight().$sub(0, other.get$_topRight()), _this.get$_bottomLeft().$sub(0, other.get$_bottomLeft()), _this.get$_bottomRight().$sub(0, other.get$_bottomRight()), _this.get$_topStart().$sub(0, other.get$_topStart()), _this.get$_topEnd().$sub(0, other.get$_topEnd()), _this.get$_bottomStart().$sub(0, other.get$_bottomStart()), _this.get$_bottomEnd().$sub(0, other.get$_bottomEnd()));
    },
    add$1: function(_, other) {
      var _this = this;
      return new K._MixedBorderRadius(_this.get$_topLeft().$add(0, other.get$_topLeft()), _this.get$_topRight().$add(0, other.get$_topRight()), _this.get$_bottomLeft().$add(0, other.get$_bottomLeft()), _this.get$_bottomRight().$add(0, other.get$_bottomRight()), _this.get$_topStart().$add(0, other.get$_topStart()), _this.get$_topEnd().$add(0, other.get$_topEnd()), _this.get$_bottomStart().$add(0, other.get$_bottomStart()), _this.get$_bottomEnd().$add(0, other.get$_bottomEnd()));
    },
    toString$0: function(_) {
      var visual, t1, comma, logical, _this = this,
        _s18_ = "BorderRadius.only(",
        _s29_ = "BorderRadiusDirectional.only(";
      if (J.$eq$(_this.get$_topLeft(), _this.get$_topRight()) && J.$eq$(_this.get$_topRight(), _this.get$_bottomLeft()) && J.$eq$(_this.get$_bottomLeft(), _this.get$_bottomRight()))
        if (!J.$eq$(_this.get$_topLeft(), C.Radius_0_0))
          visual = _this.get$_topLeft().x == _this.get$_topLeft().y ? "BorderRadius.circular(" + J.toStringAsFixed$1$n(_this.get$_topLeft().x, 1) + ")" : "BorderRadius.all(" + H.S(_this.get$_topLeft()) + ")";
        else
          visual = null;
      else {
        if (!J.$eq$(_this.get$_topLeft(), C.Radius_0_0)) {
          t1 = _s18_ + ("topLeft: " + H.S(_this.get$_topLeft()));
          comma = true;
        } else {
          t1 = _s18_;
          comma = false;
        }
        if (!J.$eq$(_this.get$_topRight(), C.Radius_0_0)) {
          if (comma)
            t1 += ", ";
          t1 += "topRight: " + H.S(_this.get$_topRight());
          comma = true;
        }
        if (!J.$eq$(_this.get$_bottomLeft(), C.Radius_0_0)) {
          if (comma)
            t1 += ", ";
          t1 += "bottomLeft: " + H.S(_this.get$_bottomLeft());
          comma = true;
        }
        if (!J.$eq$(_this.get$_bottomRight(), C.Radius_0_0)) {
          if (comma)
            t1 += ", ";
          t1 += "bottomRight: " + H.S(_this.get$_bottomRight());
        }
        t1 += ")";
        visual = t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      if (_this.get$_topStart().$eq(0, _this.get$_topEnd()) && _this.get$_topEnd().$eq(0, _this.get$_bottomEnd()) && _this.get$_bottomEnd().$eq(0, _this.get$_bottomStart()))
        if (!_this.get$_topStart().$eq(0, C.Radius_0_0))
          logical = _this.get$_topStart().x == _this.get$_topStart().y ? "BorderRadiusDirectional.circular(" + J.toStringAsFixed$1$n(_this.get$_topStart().x, 1) + ")" : "BorderRadiusDirectional.all(" + _this.get$_topStart().toString$0(0) + ")";
        else
          logical = null;
      else {
        if (!_this.get$_topStart().$eq(0, C.Radius_0_0)) {
          t1 = _s29_ + ("topStart: " + _this.get$_topStart().toString$0(0));
          comma = true;
        } else {
          t1 = _s29_;
          comma = false;
        }
        if (!_this.get$_topEnd().$eq(0, C.Radius_0_0)) {
          if (comma)
            t1 += ", ";
          t1 += "topEnd: " + _this.get$_topEnd().toString$0(0);
          comma = true;
        }
        if (!_this.get$_bottomStart().$eq(0, C.Radius_0_0)) {
          if (comma)
            t1 += ", ";
          t1 += "bottomStart: " + _this.get$_bottomStart().toString$0(0);
          comma = true;
        }
        if (!_this.get$_bottomEnd().$eq(0, C.Radius_0_0)) {
          if (comma)
            t1 += ", ";
          t1 += "bottomEnd: " + _this.get$_bottomEnd().toString$0(0);
        }
        t1 += ")";
        logical = t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      t1 = visual != null;
      if (t1 && logical != null)
        return H.S(visual) + " + " + logical;
      if (t1)
        return visual;
      if (logical != null)
        return logical;
      return "BorderRadius.zero";
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$isBorderRadiusGeometry");
      return J.$eq$(_this.get$_topLeft(), other.get$_topLeft()) && J.$eq$(_this.get$_topRight(), other.get$_topRight()) && J.$eq$(_this.get$_bottomLeft(), other.get$_bottomLeft()) && J.$eq$(_this.get$_bottomRight(), other.get$_bottomRight()) && _this.get$_topStart().$eq(0, other.get$_topStart()) && _this.get$_topEnd().$eq(0, other.get$_topEnd()) && _this.get$_bottomStart().$eq(0, other.get$_bottomStart()) && _this.get$_bottomEnd().$eq(0, other.get$_bottomEnd());
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.get$_topLeft(), _this.get$_topRight(), _this.get$_bottomLeft(), _this.get$_bottomRight(), _this.get$_topStart(), _this.get$_topEnd(), _this.get$_bottomStart(), _this.get$_bottomEnd(), C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    }
  };
  K.BorderRadius.prototype = {
    get$_topLeft: function() {
      return this.topLeft;
    },
    get$_topRight: function() {
      return this.topRight;
    },
    get$_bottomLeft: function() {
      return this.bottomLeft;
    },
    get$_bottomRight: function() {
      return this.bottomRight;
    },
    get$_topStart: function() {
      return C.Radius_0_0;
    },
    get$_topEnd: function() {
      return C.Radius_0_0;
    },
    get$_bottomStart: function() {
      return C.Radius_0_0;
    },
    get$_bottomEnd: function() {
      return C.Radius_0_0;
    },
    toRRect$1: function(rect) {
      var _this = this;
      return P.RRect$fromRectAndCorners(rect, _this.bottomLeft, _this.bottomRight, _this.topLeft, _this.topRight);
    },
    subtract$1: function(other) {
      if (!!other.$isBorderRadius)
        return this.$sub(0, other);
      return this.super$BorderRadiusGeometry$subtract(other);
    },
    add$1: function(_, other) {
      if (!!other.$isBorderRadius)
        return this.$add(0, other);
      return this.super$BorderRadiusGeometry$add(0, other);
    },
    $sub: function(_, other) {
      var _this = this;
      H.interceptedTypeCheck(other, "$isBorderRadius");
      return new K.BorderRadius(_this.topLeft.$sub(0, other.topLeft), _this.topRight.$sub(0, other.topRight), _this.bottomLeft.$sub(0, other.bottomLeft), _this.bottomRight.$sub(0, other.bottomRight));
    },
    $add: function(_, other) {
      var _this = this;
      H.interceptedTypeCheck(other, "$isBorderRadius");
      return new K.BorderRadius(_this.topLeft.$add(0, other.topLeft), _this.topRight.$add(0, other.topRight), _this.bottomLeft.$add(0, other.bottomLeft), _this.bottomRight.$add(0, other.bottomRight));
    },
    $mul: function(_, other) {
      var _this = this;
      return new K.BorderRadius(_this.topLeft.$mul(0, other), _this.topRight.$mul(0, other), _this.bottomLeft.$mul(0, other), _this.bottomRight.$mul(0, other));
    },
    resolve$1: function(direction) {
      return this;
    }
  };
  K._MixedBorderRadius.prototype = {
    $mul: function(_, other) {
      var _this = this;
      return new K._MixedBorderRadius(_this._topLeft.$mul(0, other), _this._topRight.$mul(0, other), _this._bottomLeft.$mul(0, other), _this._bottomRight.$mul(0, other), _this._topStart.$mul(0, other), _this._topEnd.$mul(0, other), _this._bottomStart.$mul(0, other), _this._bottomEnd.$mul(0, other));
    },
    resolve$1: function(direction) {
      var _this = this;
      H.assertHelper(direction != null);
      switch (direction) {
        case C.TextDirection_0:
          return new K.BorderRadius(_this._topLeft.$add(0, _this._topEnd), _this._topRight.$add(0, _this._topStart), _this._bottomLeft.$add(0, _this._bottomEnd), _this._bottomRight.$add(0, _this._bottomStart));
        case C.TextDirection_1:
          return new K.BorderRadius(_this._topLeft.$add(0, _this._topStart), _this._topRight.$add(0, _this._topEnd), _this._bottomLeft.$add(0, _this._bottomStart), _this._bottomRight.$add(0, _this._bottomEnd));
      }
      return;
    },
    get$_topLeft: function() {
      return this._topLeft;
    },
    get$_topRight: function() {
      return this._topRight;
    },
    get$_bottomLeft: function() {
      return this._bottomLeft;
    },
    get$_bottomRight: function() {
      return this._bottomRight;
    },
    get$_topStart: function() {
      return this._topStart;
    },
    get$_topEnd: function() {
      return this._topEnd;
    },
    get$_bottomStart: function() {
      return this._bottomStart;
    },
    get$_bottomEnd: function() {
      return this._bottomEnd;
    }
  };
  Y.BorderStyle.prototype = {
    toString$0: function(_) {
      return this._borders$_name;
    }
  };
  Y.BorderSide.prototype = {
    scale$1: function(t) {
      var t1 = Math.max(0, this.width * t),
        t2 = t <= 0 ? C.BorderStyle_0 : this.style;
      return Y.BorderSide$(this.color, t2, t1);
    },
    toPaint$0: function() {
      switch (this.style) {
        case C.BorderStyle_1:
          var t1 = new P.Paint(new DataView(new ArrayBuffer(75)));
          t1.set$color(this.color);
          t1.set$strokeWidth(this.width);
          t1.set$style(C.PaintingStyle_1);
          return t1;
        case C.BorderStyle_0:
          t1 = new P.Paint(new DataView(new ArrayBuffer(75)));
          t1.set$color(C.Color_0);
          t1.set$strokeWidth(0);
          t1.set$style(C.PaintingStyle_1);
          return t1;
      }
      return;
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$isBorderSide");
      return J.$eq$(_this.color, other.color) && _this.width === other.width && _this.style === other.style;
    },
    get$hashCode: function(_) {
      return P.hashValues(this.color, this.width, this.style, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var _this = this;
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(" + H.S(_this.color) + ", " + C.JSNumber_methods.toStringAsFixed$1(_this.width, 1) + ", " + _this.style.toString$0(0) + ")";
    }
  };
  Y.ShapeBorder.prototype = {
    add$2$reversed: function(_, other, reversed) {
      return;
    },
    add$1: function($receiver, other) {
      return this.add$2$reversed($receiver, other, false);
    },
    $add: function(_, other) {
      var t1;
      H.interceptedTypeCheck(other, "$isShapeBorder");
      t1 = this.add$1(0, other);
      if (t1 == null)
        t1 = other.add$2$reversed(0, this, true);
      return t1 == null ? Y._CompoundBorder$(H.setRuntimeTypeInfo([other, this], [Y.ShapeBorder])) : t1;
    },
    lerpFrom$2: function(a, t) {
      if (a == null)
        return this.scale$1(t);
      return;
    },
    lerpTo$2: function(b, t) {
      if (b == null)
        return this.scale$1(1 - t);
      return;
    },
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "()";
    }
  };
  Y._CompoundBorder.prototype = {
    get$dimensions: function() {
      return C.JSArray_methods.fold$1$2(this.borders, C.EdgeInsets_0_0_0_0, new Y._CompoundBorder_dimensions_closure(), V.EdgeInsetsGeometry);
    },
    add$2$reversed: function(_, other, reversed) {
      var t2, ours, merged, result, mergedBorders,
        t1 = !!other.$is_CompoundBorder;
      if (!t1) {
        t2 = this.borders;
        ours = reversed ? C.JSArray_methods.get$last(t2) : C.JSArray_methods.get$first(t2);
        merged = ours.add$2$reversed(0, other, reversed);
        if (merged == null)
          merged = other.add$2$reversed(0, ours, !reversed);
        if (merged != null) {
          result = H.setRuntimeTypeInfo([], [Y.ShapeBorder]);
          C.JSArray_methods.addAll$1(result, t2);
          C.JSArray_methods.$indexSet(result, reversed ? result.length - 1 : 0, merged);
          return Y._CompoundBorder$(result);
        }
      }
      mergedBorders = H.setRuntimeTypeInfo([], [Y.ShapeBorder]);
      if (reversed)
        C.JSArray_methods.addAll$1(mergedBorders, this.borders);
      if (t1)
        C.JSArray_methods.addAll$1(mergedBorders, other.borders);
      else
        C.JSArray_methods.add$1(mergedBorders, other);
      if (!reversed)
        C.JSArray_methods.addAll$1(mergedBorders, this.borders);
      return Y._CompoundBorder$(mergedBorders);
    },
    add$1: function($receiver, other) {
      return this.add$2$reversed($receiver, other, false);
    },
    scale$1: function(t) {
      var t1 = this.borders,
        t2 = Y.ShapeBorder,
        t3 = H.getTypeArgumentByIndex(t1, 0);
      return Y._CompoundBorder$(new H.MappedListIterable(t1, H.functionTypeCheck(new Y._CompoundBorder_scale_closure(t), {func: 1, ret: t2, args: [t3]}), [t3, t2]).toList$0(0));
    },
    lerpFrom$2: function(a, t) {
      return Y._CompoundBorder_lerp(a, this, t);
    },
    lerpTo$2: function(b, t) {
      return Y._CompoundBorder_lerp(this, b, t);
    },
    getOuterPath$2$textDirection: function(rect, textDirection) {
      return C.JSArray_methods.get$first(this.borders).getOuterPath$2$textDirection(rect, textDirection);
    },
    paint$3$textDirection: function(canvas, rect, textDirection) {
      var t1, t2, _i, border;
      for (t1 = this.borders, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        border = t1[_i];
        border.paint$3$textDirection(canvas, rect, textDirection);
        rect = border.get$dimensions().resolve$1(textDirection).deflateRect$1(rect);
      }
    },
    $eq: function(_, other) {
      var t1, t2, index, t3;
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!new H.TypeImpl(H.getRti(this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      t1 = this.borders;
      t2 = H.interceptedTypeCheck(other, "$is_CompoundBorder").borders;
      if (t1 === t2)
        return true;
      if (t1.length !== t2.length)
        return false;
      for (index = 0; index < t1.length; ++index) {
        t3 = t1[index];
        if (index >= t2.length)
          return H.ioore(t2, index);
        if (!J.$eq$(t3, t2[index]))
          return false;
      }
      return true;
    },
    get$hashCode: function(_) {
      return P.hashList(this.borders);
    },
    toString$0: function(_) {
      var t1 = this.borders,
        t2 = H.getTypeArgumentByIndex(t1, 0),
        t3 = P.String;
      return new H.MappedListIterable(new H.ReversedListIterable(t1, [t2]), H.functionTypeCheck(new Y._CompoundBorder_toString_closure(), {func: 1, ret: t3, args: [t2]}), [t2, t3]).join$1(0, " + ");
    }
  };
  Y._CompoundBorder_dimensions_closure.prototype = {
    call$2: function(previousValue, border) {
      return H.interceptedTypeCheck(previousValue, "$isEdgeInsetsGeometry").add$1(0, H.interceptedTypeCheck(border, "$isShapeBorder").get$dimensions());
    },
    $signature: 79
  };
  Y._CompoundBorder_scale_closure.prototype = {
    call$1: function(border) {
      return H.interceptedTypeCheck(border, "$isShapeBorder").scale$1(this.t);
    },
    $signature: 80
  };
  Y._CompoundBorder_toString_closure.prototype = {
    call$1: function(border) {
      return J.toString$0$(H.interceptedTypeCheck(border, "$isShapeBorder"));
    },
    $signature: 81
  };
  F.BoxShape.prototype = {
    toString$0: function(_) {
      return this._box_border$_name;
    }
  };
  F.BoxBorder.prototype = {
    add$2$reversed: function(_, other, reversed) {
      return;
    },
    add$1: function($receiver, other) {
      return this.add$2$reversed($receiver, other, false);
    },
    getOuterPath$2$textDirection: function(rect, textDirection) {
      var t1;
      if (H.assertTest(textDirection != null))
        H.assertThrow("The textDirection argument to " + new H.TypeImpl(H.getRti(this)).toString$0(0) + ".getOuterPath must not be null.");
      t1 = new P.Path();
      H.throwExpression(P.UnimplementedError$(null));
      t1.addRect$1(rect);
      return t1;
    }
  };
  F.Border.prototype = {
    get$dimensions: function() {
      var _this = this;
      return new V.EdgeInsets(_this.left.width, _this.top.width, _this.right.width, _this.bottom.width);
    },
    get$isUniform: function() {
      var topWidth, topStyle, _this = this,
        t1 = _this.top,
        topColor = t1.color,
        t2 = _this.right;
      if (!J.$eq$(t2.color, topColor) || !J.$eq$(_this.bottom.color, topColor) || !J.$eq$(_this.left.color, topColor))
        return false;
      topWidth = t1.width;
      if (t2.width !== topWidth || _this.bottom.width !== topWidth || _this.left.width !== topWidth)
        return false;
      topStyle = t1.style;
      if (t2.style !== topStyle || _this.bottom.style !== topStyle || _this.left.style !== topStyle)
        return false;
      return true;
    },
    add$2$reversed: function(_, other, reversed) {
      var t1, t2, t3, t4, t5, t6, t7, t8, _this = this;
      if (!other.$isBorder)
        return;
      t1 = _this.top;
      t2 = other.top;
      if (Y.BorderSide_canMerge(t1, t2) && Y.BorderSide_canMerge(_this.right, other.right) && Y.BorderSide_canMerge(_this.bottom, other.bottom) && Y.BorderSide_canMerge(_this.left, other.left)) {
        H.assertHelper(Y.BorderSide_canMerge(t1, t2));
        t3 = _this.right;
        t4 = other.right;
        H.assertHelper(Y.BorderSide_canMerge(t3, t4));
        t5 = _this.bottom;
        t6 = other.bottom;
        H.assertHelper(Y.BorderSide_canMerge(t5, t6));
        t7 = _this.left;
        t8 = other.left;
        H.assertHelper(Y.BorderSide_canMerge(t7, t8));
        t2 = Y.BorderSide_merge(t1, t2);
        t4 = Y.BorderSide_merge(t3, t4);
        return F.Border$(Y.BorderSide_merge(t5, t6), Y.BorderSide_merge(t7, t8), t4, t2);
      }
      return;
    },
    add$1: function($receiver, other) {
      return this.add$2$reversed($receiver, other, false);
    },
    scale$1: function(t) {
      var _this = this,
        t1 = _this.top.scale$1(t),
        t2 = _this.right.scale$1(t);
      return F.Border$(_this.bottom.scale$1(t), _this.left.scale$1(t), t2, t1);
    },
    lerpFrom$2: function(a, t) {
      if (a instanceof F.Border)
        return F.Border_lerp(a, this, t);
      return this.super$ShapeBorder$lerpFrom(a, t);
    },
    lerpTo$2: function(b, t) {
      if (b instanceof F.Border)
        return F.Border_lerp(this, b, t);
      return this.super$ShapeBorder$lerpTo(b, t);
    },
    paint$5$borderRadius$shape$textDirection: function(canvas, rect, borderRadius, shape, textDirection) {
      var t1, _this = this;
      if (_this.get$isUniform()) {
        t1 = _this.top;
        switch (t1.style) {
          case C.BorderStyle_0:
            return;
          case C.BorderStyle_1:
            switch (shape) {
              case C.BoxShape_1:
                if (H.assertTest(borderRadius == null))
                  H.assertThrow("A borderRadius can only be given for rectangular boxes.");
                F.BoxBorder__paintUniformBorderWithCircle(canvas, rect, t1);
                break;
              case C.BoxShape_0:
                if (borderRadius != null) {
                  F.BoxBorder__paintUniformBorderWithRadius(canvas, rect, t1, borderRadius);
                  return;
                }
                F.BoxBorder__paintUniformBorderWithRectangle(canvas, rect, t1);
                break;
            }
            return;
        }
      }
      if (H.assertTest(borderRadius == null))
        H.assertThrow("A borderRadius can only be given for uniform borders.");
      if (H.assertTest(shape === C.BoxShape_0))
        H.assertThrow("A border can only be drawn as a circle if it is uniform.");
      Y.paintBorder(canvas, rect, _this.bottom, _this.left, _this.right, _this.top);
    },
    paint$3$textDirection: function(canvas, rect, textDirection) {
      return this.paint$5$borderRadius$shape$textDirection(canvas, rect, null, C.BoxShape_0, textDirection);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$isBorder");
      return _this.top.$eq(0, other.top) && _this.right.$eq(0, other.right) && _this.bottom.$eq(0, other.bottom) && _this.left.$eq(0, other.left);
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.top, _this.right, _this.bottom, _this.left, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var $arguments, t1, _this = this;
      if (_this.get$isUniform())
        return new H.TypeImpl(H.getRti(_this)).toString$0(0) + ".all(" + _this.top.toString$0(0) + ")";
      $arguments = H.setRuntimeTypeInfo([], [P.String]);
      t1 = _this.top;
      if (!t1.$eq(0, C.BorderSide_m7u))
        C.JSArray_methods.add$1($arguments, "top: " + t1.toString$0(0));
      t1 = _this.right;
      if (!t1.$eq(0, C.BorderSide_m7u))
        C.JSArray_methods.add$1($arguments, "right: " + t1.toString$0(0));
      t1 = _this.bottom;
      if (!t1.$eq(0, C.BorderSide_m7u))
        C.JSArray_methods.add$1($arguments, "bottom: " + t1.toString$0(0));
      t1 = _this.left;
      if (!t1.$eq(0, C.BorderSide_m7u))
        C.JSArray_methods.add$1($arguments, "left: " + t1.toString$0(0));
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(" + C.JSArray_methods.join$1($arguments, ", ") + ")";
    }
  };
  F.BorderDirectional.prototype = {
    get$dimensions: function() {
      var _this = this;
      return new V.EdgeInsetsDirectional(_this.start.width, _this.top.width, _this.end.width, _this.bottom.width);
    },
    get$isUniform: function() {
      var topWidth, topStyle, _this = this,
        t1 = _this.top,
        topColor = t1.color,
        t2 = _this.start;
      if (!J.$eq$(t2.color, topColor) || !J.$eq$(_this.end.color, topColor) || !J.$eq$(_this.bottom.color, topColor))
        return false;
      topWidth = t1.width;
      if (t2.width !== topWidth || _this.end.width !== topWidth || _this.bottom.width !== topWidth)
        return false;
      topStyle = t1.style;
      if (t2.style !== topStyle || _this.end.style !== topStyle || _this.bottom.style !== topStyle)
        return false;
      return true;
    },
    add$2$reversed: function(_, other, reversed) {
      var t1, t2, t3, t4, t5, t6, t7, t8, _this = this;
      if (!!other.$isBorderDirectional) {
        t1 = _this.top;
        t2 = other.top;
        if (Y.BorderSide_canMerge(t1, t2) && Y.BorderSide_canMerge(_this.start, other.start) && Y.BorderSide_canMerge(_this.end, other.end) && Y.BorderSide_canMerge(_this.bottom, other.bottom)) {
          H.assertHelper(Y.BorderSide_canMerge(t1, t2));
          t3 = _this.start;
          t4 = other.start;
          H.assertHelper(Y.BorderSide_canMerge(t3, t4));
          t5 = _this.end;
          t6 = other.end;
          H.assertHelper(Y.BorderSide_canMerge(t5, t6));
          t7 = _this.bottom;
          t8 = other.bottom;
          H.assertHelper(Y.BorderSide_canMerge(t7, t8));
          t2 = Y.BorderSide_merge(t1, t2);
          t4 = Y.BorderSide_merge(t3, t4);
          t6 = Y.BorderSide_merge(t5, t6);
          return F.BorderDirectional$(Y.BorderSide_merge(t7, t8), t6, t4, t2);
        }
        return;
      }
      if (!!other.$isBorder) {
        t1 = other.top;
        t2 = _this.top;
        if (!Y.BorderSide_canMerge(t1, t2) || !Y.BorderSide_canMerge(other.bottom, _this.bottom))
          return;
        t3 = _this.start;
        if (!t3.$eq(0, C.BorderSide_m7u) || !_this.end.$eq(0, C.BorderSide_m7u)) {
          t4 = other.left;
          if (!t4.$eq(0, C.BorderSide_m7u) || !other.right.$eq(0, C.BorderSide_m7u))
            return;
          H.assertHelper(t4.$eq(0, C.BorderSide_m7u));
          H.assertHelper(other.right.$eq(0, C.BorderSide_m7u));
          t1 = Y.BorderSide_merge(t1, t2);
          return F.BorderDirectional$(Y.BorderSide_merge(other.bottom, _this.bottom), _this.end, t3, t1);
        }
        H.assertHelper(t3.$eq(0, C.BorderSide_m7u));
        H.assertHelper(_this.end.$eq(0, C.BorderSide_m7u));
        t1 = Y.BorderSide_merge(t1, t2);
        return F.Border$(Y.BorderSide_merge(other.bottom, _this.bottom), other.left, other.right, t1);
      }
      return;
    },
    add$1: function($receiver, other) {
      return this.add$2$reversed($receiver, other, false);
    },
    scale$1: function(t) {
      var _this = this,
        t1 = _this.top.scale$1(t),
        t2 = _this.start.scale$1(t),
        t3 = _this.end.scale$1(t);
      return F.BorderDirectional$(_this.bottom.scale$1(t), t3, t2, t1);
    },
    lerpFrom$2: function(a, t) {
      if (a instanceof F.BorderDirectional)
        return F.BorderDirectional_lerp(a, this, t);
      return this.super$ShapeBorder$lerpFrom(a, t);
    },
    lerpTo$2: function(b, t) {
      if (b instanceof F.BorderDirectional)
        return F.BorderDirectional_lerp(this, b, t);
      return this.super$ShapeBorder$lerpTo(b, t);
    },
    paint$5$borderRadius$shape$textDirection: function(canvas, rect, borderRadius, shape, textDirection) {
      var t1, left, right, _this = this;
      if (_this.get$isUniform()) {
        t1 = _this.top;
        switch (t1.style) {
          case C.BorderStyle_0:
            return;
          case C.BorderStyle_1:
            switch (shape) {
              case C.BoxShape_1:
                if (H.assertTest(borderRadius == null))
                  H.assertThrow("A borderRadius can only be given for rectangular boxes.");
                F.BoxBorder__paintUniformBorderWithCircle(canvas, rect, t1);
                break;
              case C.BoxShape_0:
                if (borderRadius != null) {
                  F.BoxBorder__paintUniformBorderWithRadius(canvas, rect, t1, borderRadius);
                  return;
                }
                F.BoxBorder__paintUniformBorderWithRectangle(canvas, rect, t1);
                break;
            }
            return;
        }
      }
      if (H.assertTest(borderRadius == null))
        H.assertThrow("A borderRadius can only be given for uniform borders.");
      if (H.assertTest(shape === C.BoxShape_0))
        H.assertThrow("A border can only be drawn as a circle if it is uniform.");
      if (H.assertTest(textDirection != null))
        H.assertThrow("Non-uniform BorderDirectional objects require a TextDirection when painting.");
      switch (textDirection) {
        case C.TextDirection_0:
          left = _this.end;
          right = _this.start;
          break;
        case C.TextDirection_1:
          left = _this.start;
          right = _this.end;
          break;
        default:
          left = null;
          right = null;
      }
      Y.paintBorder(canvas, rect, _this.bottom, left, right, _this.top);
    },
    paint$3$textDirection: function(canvas, rect, textDirection) {
      return this.paint$5$borderRadius$shape$textDirection(canvas, rect, null, C.BoxShape_0, textDirection);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$isBorderDirectional");
      return _this.top.$eq(0, other.top) && _this.start.$eq(0, other.start) && _this.end.$eq(0, other.end) && _this.bottom.$eq(0, other.bottom);
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.top, _this.start, _this.end, _this.bottom, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var _this = this,
        $arguments = H.setRuntimeTypeInfo([], [P.String]),
        t1 = _this.top;
      if (!t1.$eq(0, C.BorderSide_m7u))
        C.JSArray_methods.add$1($arguments, "top: " + t1.toString$0(0));
      t1 = _this.start;
      if (!t1.$eq(0, C.BorderSide_m7u))
        C.JSArray_methods.add$1($arguments, "start: " + t1.toString$0(0));
      t1 = _this.end;
      if (!t1.$eq(0, C.BorderSide_m7u))
        C.JSArray_methods.add$1($arguments, "end: " + t1.toString$0(0));
      t1 = _this.bottom;
      if (!t1.$eq(0, C.BorderSide_m7u))
        C.JSArray_methods.add$1($arguments, "bottom: " + t1.toString$0(0));
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(" + C.JSArray_methods.join$1($arguments, ", ") + ")";
    }
  };
  S.BoxDecoration.prototype = {
    get$padding: function() {
      var t1 = this.border;
      return t1 == null ? null : t1.get$dimensions();
    },
    scale$1: function(factor) {
      var _this = this, _null = null,
        t1 = P.Color_lerp(_null, _this.color, factor),
        t2 = F.BoxBorder_lerp(_null, _this.border, factor),
        t3 = K.BorderRadiusGeometry_lerp(_null, _this.borderRadius, factor),
        t4 = O.BoxShadow_lerpList(_null, _this.boxShadow, factor);
      return S.BoxDecoration$(t2, t3, t4, t1, _null, _this.image, _this.shape);
    },
    get$isComplex: function() {
      return this.boxShadow != null;
    },
    lerpFrom$2: function(a, t) {
      if (a == null)
        return this.scale$1(t);
      if (!!a.$isBoxDecoration)
        return S.BoxDecoration_lerp(a, this, t);
      return this.super$Decoration$lerpFrom(a, t);
    },
    lerpTo$2: function(b, t) {
      if (b == null)
        return this.scale$1(1 - t);
      if (!!b.$isBoxDecoration)
        return S.BoxDecoration_lerp(this, b, t);
      return this.super$Decoration$lerpTo(b, t);
    },
    $eq: function(_, other) {
      var t1, t2, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$isBoxDecoration");
      if (J.$eq$(_this.color, other.color))
        if (J.$eq$(_this.border, other.border))
          if (J.$eq$(_this.borderRadius, other.borderRadius)) {
            t1 = _this.boxShadow;
            t2 = other.boxShadow;
            if (t1 == null ? t2 == null : t1 === t2)
              t1 = _this.shape === other.shape;
            else
              t1 = false;
          } else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.color, _this.image, _this.border, _this.borderRadius, _this.boxShadow, _this.gradient, _this.shape, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      properties.defaultDiagnosticsTreeStyle = C.DiagnosticsTreeStyle_4;
      properties.emptyBodyDescription = "<no decorations specified>";
      t1 = Y.DiagnosticsProperty$("color", _this.color, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Color);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("image", _this.image, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, X.DecorationImage));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("border", _this.border, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, F.BoxBorder));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("borderRadius", _this.borderRadius, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.BorderRadiusGeometry));
      C.JSArray_methods.add$1(t2, Y.IterableProperty$("boxShadow", _this.boxShadow, _null, "[]", C.DiagnosticLevel_3, C.DiagnosticsTreeStyle_4, O.BoxShadow));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("gradient", _this.gradient, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, T.Gradient));
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, _this.shape, C.BoxShape_0, C.DiagnosticLevel_3, "shape", true, true, C.DiagnosticsTreeStyle_5, [F.BoxShape]));
    },
    hitTest$3$textDirection: function(size, position, textDirection) {
      var t3, t4,
        t1 = size._dx,
        t2 = size._dy;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t3 = 0 + t1;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t4 = 0 + t2;
      H.assertHelper(new P.Rect(0, 0, t3, t4).contains$1(0, position));
      switch (this.shape) {
        case C.BoxShape_0:
          t1 = this.borderRadius;
          if (t1 != null)
            return t1.resolve$1(textDirection).toRRect$1(new P.Rect(0, 0, t3, t4)).contains$1(0, position);
          return true;
        case C.BoxShape_1:
          return position.$sub(0, size.center$1(C.Offset_0_0)).get$distance() <= Math.min(t1, t2) / 2;
      }
      return;
    },
    createBoxPainter$1: function(onChanged) {
      H.functionTypeCheck(onChanged, {func: 1, ret: -1});
      return new S._BoxDecorationPainter(this, onChanged);
    }
  };
  S._BoxDecorationPainter.prototype = {
    _paintBox$4: function(canvas, rect, paint, textDirection) {
      var t1 = this._box_decoration$_decoration;
      switch (t1.shape) {
        case C.BoxShape_1:
          H.assertHelper(t1.borderRadius == null);
          canvas.drawCircle$3(rect.get$center(), rect.get$shortestSide() / 2, paint);
          break;
        case C.BoxShape_0:
          t1 = t1.borderRadius;
          if (t1 == null)
            canvas.drawRect$2(rect, paint);
          else
            canvas.drawRRect$2(t1.resolve$1(textDirection).toRRect$1(rect), paint);
          break;
      }
    },
    _paintShadows$3: function(canvas, rect, textDirection) {
      var t2, _i, boxShadow, paint, t3, t4, t5, t6, t7,
        t1 = this._box_decoration$_decoration.boxShadow;
      if (t1 == null)
        return;
      for (t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        boxShadow = t1[_i];
        paint = boxShadow.toPaint$0();
        t3 = rect.shift$1(boxShadow.offset);
        t4 = boxShadow.spreadRadius;
        t5 = t3.left;
        if (typeof t5 !== "number")
          return t5.$sub();
        if (typeof t4 !== "number")
          return H.iae(t4);
        t6 = t3.top;
        if (typeof t6 !== "number")
          return t6.$sub();
        t7 = t3.right;
        if (typeof t7 !== "number")
          return t7.$add();
        t3 = t3.bottom;
        if (typeof t3 !== "number")
          return t3.$add();
        this._paintBox$4(canvas, new P.Rect(t5 - t4, t6 - t4, t7 + t4, t3 + t4), paint, textDirection);
      }
    },
    _paintBackgroundImage$3: function(canvas, rect, configuration) {
      return;
    },
    dispose$0: function() {
      this.super$BoxPainter$dispose();
    },
    paint$3: function(canvas, offset, configuration) {
      var t2, t3, t4, rect, textDirection, t5, paint, _this = this,
        t1 = configuration.size;
      H.assertHelper(t1 != null);
      t2 = offset._dx;
      t3 = offset._dy;
      t4 = t1._dx;
      t1 = t1._dy;
      if (typeof t2 !== "number")
        return t2.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t1 !== "number")
        return H.iae(t1);
      rect = new P.Rect(t2, t3, t2 + t4, t3 + t1);
      textDirection = configuration.textDirection;
      _this._paintShadows$3(canvas, rect, textDirection);
      t1 = _this._box_decoration$_decoration;
      t2 = t1.color;
      t3 = t2 == null;
      if (!t3 || false) {
        t4 = _this._rectForCachedBackgroundPaint;
        H.assertHelper(t4 == null);
        t4 = _this._cachedBackgroundPaint;
        if (t4 != null)
          t5 = false;
        else
          t5 = true;
        if (t5) {
          paint = new P.Paint(new DataView(new ArrayBuffer(75)));
          if (!t3)
            paint.set$color(t2);
          _this._cachedBackgroundPaint = paint;
          t2 = paint;
        } else
          t2 = t4;
        _this._paintBox$4(canvas, rect, t2, textDirection);
      }
      _this._paintBackgroundImage$3(canvas, rect, configuration);
      t2 = t1.border;
      if (t2 != null)
        t2.paint$5$borderRadius$shape$textDirection(canvas, rect, H.interceptedTypeCheck(t1.borderRadius, "$isBorderRadius"), t1.shape, textDirection);
    },
    toString$0: function(_) {
      return "BoxPainter for " + this._box_decoration$_decoration.toString$0(0);
    }
  };
  O.BoxShadow.prototype = {
    toPaint$0: function() {
      var t1,
        result = new P.Paint(new DataView(new ArrayBuffer(75)));
      result.set$color(this.color);
      t1 = this.blurRadius;
      if (typeof t1 !== "number")
        return t1.$mul();
      result.set$maskFilter(P.MaskFilter$blur(C.BlurStyle_0, t1 * 0.57735 + 0.5));
      H.assertHelper(new O.BoxShadow_toPaint_closure(result).call$0());
      return result;
    },
    scale$1: function(factor) {
      var t3, _this = this,
        t1 = _this.offset.$mul(0, factor),
        t2 = _this.blurRadius;
      if (typeof t2 !== "number")
        return t2.$mul();
      t3 = _this.spreadRadius;
      if (typeof t3 !== "number")
        return t3.$mul();
      return new O.BoxShadow(t3 * factor, _this.color, t1, t2 * factor);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$isBoxShadow");
      return J.$eq$(_this.color, other.color) && J.$eq$(_this.offset, other.offset) && _this.blurRadius == other.blurRadius && _this.spreadRadius == other.spreadRadius;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.color, _this.offset, _this.blurRadius, _this.spreadRadius, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var _this = this;
      return "BoxShadow(" + H.S(_this.color) + ", " + H.S(_this.offset) + ", " + H.S(_this.blurRadius) + ", " + H.S(_this.spreadRadius) + ")";
    }
  };
  O.BoxShadow_toPaint_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  X.CircleBorder.prototype = {
    get$dimensions: function() {
      var t1 = this.side.width;
      return new V.EdgeInsets(t1, t1, t1, t1);
    },
    scale$1: function(t) {
      return new X.CircleBorder(this.side.scale$1(t));
    },
    lerpFrom$2: function(a, t) {
      if (a instanceof X.CircleBorder)
        return new X.CircleBorder(Y.BorderSide_lerp(a.side, this.side, t));
      return this.super$ShapeBorder$lerpFrom(a, t);
    },
    lerpTo$2: function(b, t) {
      if (b instanceof X.CircleBorder)
        return new X.CircleBorder(Y.BorderSide_lerp(this.side, b.side, t));
      return this.super$ShapeBorder$lerpTo(b, t);
    },
    getOuterPath$2$textDirection: function(rect, textDirection) {
      var t1 = new P.Path();
      H.throwExpression(P.UnimplementedError$(null));
      t1.addOval$1(P.Rect$fromCircle(rect.get$center(), rect.get$shortestSide() / 2));
      return t1;
    },
    paint$3$textDirection: function(canvas, rect, textDirection) {
      var t1 = this.side;
      switch (t1.style) {
        case C.BorderStyle_0:
          break;
        case C.BorderStyle_1:
          canvas.drawCircle$3(rect.get$center(), (rect.get$shortestSide() - t1.width) / 2, t1.toPaint$0());
          break;
      }
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!new H.TypeImpl(H.getRti(this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      return this.side.$eq(0, H.interceptedTypeCheck(other, "$isCircleBorder").side);
    },
    get$hashCode: function(_) {
      var t1 = this.side;
      return P.hashValues(t1.color, t1.width, t1.style, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(" + this.side.toString$0(0) + ")";
    }
  };
  Z.ClipContext.prototype = {
    _clipAndPaint$4: function(canvasClipCall, clipBehavior, bounds, painter) {
      var t1, _this = this;
      H.functionTypeCheck(canvasClipCall, {func: 1, ret: -1, args: [P.bool]});
      H.functionTypeCheck(painter, {func: 1, ret: -1});
      _this.get$canvas().save$0();
      switch (clipBehavior) {
        case C.Clip_0:
          break;
        case C.Clip_1:
          canvasClipCall.call$1(false);
          break;
        case C.Clip_2:
          canvasClipCall.call$1(true);
          break;
        case C.Clip_3:
          canvasClipCall.call$1(true);
          t1 = _this.get$canvas();
          t1.saveLayer$2(bounds, new P.Paint(new DataView(new ArrayBuffer(75))));
          break;
      }
      painter.call$0();
      if (clipBehavior === C.Clip_3)
        _this.get$canvas().restore$0();
      _this.get$canvas().restore$0();
    },
    clipRectAndPaint$4: function(rect, clipBehavior, bounds, painter) {
      this._clipAndPaint$4(new Z.ClipContext_clipRectAndPaint_closure(this, rect), clipBehavior, bounds, H.functionTypeCheck(painter, {func: 1, ret: -1}));
    }
  };
  Z.ClipContext_clipRectAndPaint_closure.prototype = {
    call$1: function(doAntiAias) {
      return this.$this.get$canvas().clipRect$2$doAntiAlias(this.rect, doAntiAias);
    },
    $signature: 38
  };
  E.HSVColor.prototype = {
    toColor$0: function() {
      var green, red, blue, _this = this,
        t1 = _this.value,
        chroma = _this.saturation * t1,
        t2 = _this.hue,
        secondary = chroma * (1 - Math.abs(C.JSDouble_methods.$mod(t2 / 60, 2) - 1)),
        match = t1 - chroma;
      if (t2 < 60) {
        green = secondary;
        red = chroma;
        blue = 0;
      } else if (t2 < 120) {
        green = chroma;
        red = secondary;
        blue = 0;
      } else if (t2 < 180) {
        blue = secondary;
        green = chroma;
        red = 0;
      } else if (t2 < 240) {
        blue = chroma;
        green = secondary;
        red = 0;
      } else {
        if (t2 < 300) {
          blue = chroma;
          red = secondary;
        } else {
          blue = secondary;
          red = chroma;
        }
        green = 0;
      }
      return P.Color$fromARGB(C.JSDouble_methods.round$0(_this.alpha * 255), C.JSNumber_methods.round$0((red + match) * 255), C.JSNumber_methods.round$0((green + match) * 255), C.JSNumber_methods.round$0((blue + match) * 255));
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!(other instanceof E.HSVColor))
        return false;
      return other.alpha === _this.alpha && other.hue === _this.hue && other.saturation === _this.saturation && other.value === _this.value;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.alpha, _this.hue, _this.saturation, _this.value, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var _this = this;
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(" + H.S(_this.alpha) + ", " + _this.hue + ", " + _this.saturation + ", " + _this.value + ")";
    }
  };
  E.ColorSwatch.prototype = {
    $index: function(_, index) {
      return this._swatch.$index(0, H.assertSubtypeOfRuntimeType(index, H.getRuntimeTypeArgument(this, "ColorSwatch", 0)));
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.assertSubtype(other, "$isColorSwatch", [H.getRuntimeTypeArgument(_this, "ColorSwatch", 0)], "$asColorSwatch");
      return _this.super$Color$$eq(0, other) && _this._swatch === other._swatch;
    },
    get$hashCode: function(_) {
      return P.hashValues(new H.TypeImpl(H.getRti(this)), this.value, this._swatch, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(primary value: " + this.super$Color$toString(0) + ")";
    }
  };
  Z.Decoration.prototype = {
    toStringShort$0: function() {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    },
    get$isComplex: function() {
      return false;
    },
    lerpFrom$2: function(a, t) {
      return;
    },
    lerpTo$2: function(b, t) {
      return;
    },
    hitTest$3$textDirection: function(size, position, textDirection) {
      return true;
    }
  };
  Z.BoxPainter.prototype = {
    dispose$0: function() {
    }
  };
  X.DecorationImage.prototype = {};
  V.EdgeInsetsGeometry.prototype = {
    get$isNonNegative: function() {
      var _this = this,
        t1 = _this.get$_left();
      if (typeof t1 !== "number")
        return t1.$ge();
      if (t1 >= 0) {
        t1 = _this.get$_right();
        if (typeof t1 !== "number")
          return t1.$ge();
        if (t1 >= 0) {
          t1 = _this.get$_edge_insets$_start();
          if (typeof t1 !== "number")
            return t1.$ge();
          if (t1 >= 0) {
            t1 = _this.get$_edge_insets$_end();
            if (typeof t1 !== "number")
              return t1.$ge();
            if (t1 >= 0) {
              t1 = _this.get$_top();
              if (typeof t1 !== "number")
                return t1.$ge();
              if (t1 >= 0) {
                t1 = _this.get$_bottom();
                if (typeof t1 !== "number")
                  return t1.$ge();
                t1 = t1 >= 0;
              } else
                t1 = false;
            } else
              t1 = false;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$horizontal: function() {
      var t3, t4, _this = this,
        t1 = _this.get$_left(),
        t2 = _this.get$_right();
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = _this.get$_edge_insets$_start();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = _this.get$_edge_insets$_end();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return t1 + t2 + t3 + t4;
    },
    add$1: function(_, other) {
      var t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, _this = this,
        t1 = _this.get$_left(),
        t2 = other.get$_left();
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = _this.get$_right();
      t4 = other.get$_right();
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = _this.get$_edge_insets$_start();
      t6 = other.get$_edge_insets$_start();
      if (typeof t5 !== "number")
        return t5.$add();
      if (typeof t6 !== "number")
        return H.iae(t6);
      t7 = _this.get$_edge_insets$_end();
      t8 = other.get$_edge_insets$_end();
      if (typeof t7 !== "number")
        return t7.$add();
      if (typeof t8 !== "number")
        return H.iae(t8);
      t9 = _this.get$_top();
      t10 = other.get$_top();
      if (typeof t9 !== "number")
        return t9.$add();
      if (typeof t10 !== "number")
        return H.iae(t10);
      t11 = _this.get$_bottom();
      t12 = other.get$_bottom();
      if (typeof t11 !== "number")
        return t11.$add();
      if (typeof t12 !== "number")
        return H.iae(t12);
      return new V._MixedEdgeInsets(t1 + t2, t3 + t4, t5 + t6, t7 + t8, t9 + t10, t11 + t12);
    },
    toString$0: function(_) {
      var _this = this;
      if (_this.get$_edge_insets$_start() === 0 && _this.get$_edge_insets$_end() === 0) {
        if (_this.get$_left() === 0 && _this.get$_right() === 0 && _this.get$_top() === 0 && _this.get$_bottom() === 0)
          return "EdgeInsets.zero";
        if (_this.get$_left() == _this.get$_right() && _this.get$_right() == _this.get$_top() && _this.get$_top() == _this.get$_bottom())
          return "EdgeInsets.all(" + J.toStringAsFixed$1$n(_this.get$_left(), 1) + ")";
        return "EdgeInsets(" + J.toStringAsFixed$1$n(_this.get$_left(), 1) + ", " + J.toStringAsFixed$1$n(_this.get$_top(), 1) + ", " + J.toStringAsFixed$1$n(_this.get$_right(), 1) + ", " + J.toStringAsFixed$1$n(_this.get$_bottom(), 1) + ")";
      }
      if (_this.get$_left() === 0 && _this.get$_right() === 0)
        return "EdgeInsetsDirectional(" + J.toStringAsFixed$1$n(_this.get$_edge_insets$_start(), 1) + ", " + J.toStringAsFixed$1$n(_this.get$_top(), 1) + ", " + J.toStringAsFixed$1$n(_this.get$_edge_insets$_end(), 1) + ", " + J.toStringAsFixed$1$n(_this.get$_bottom(), 1) + ")";
      return "EdgeInsets(" + J.toStringAsFixed$1$n(_this.get$_left(), 1) + ", " + J.toStringAsFixed$1$n(_this.get$_top(), 1) + ", " + J.toStringAsFixed$1$n(_this.get$_right(), 1) + ", " + J.toStringAsFixed$1$n(_this.get$_bottom(), 1) + ") + EdgeInsetsDirectional(" + J.toStringAsFixed$1$n(_this.get$_edge_insets$_start(), 1) + ", 0.0, " + J.toStringAsFixed$1$n(_this.get$_edge_insets$_end(), 1) + ", 0.0)";
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (!(other instanceof V.EdgeInsetsGeometry))
        return false;
      return _this.get$_left() == other.get$_left() && _this.get$_right() == other.get$_right() && _this.get$_edge_insets$_start() == other.get$_edge_insets$_start() && _this.get$_edge_insets$_end() == other.get$_edge_insets$_end() && _this.get$_top() == other.get$_top() && _this.get$_bottom() == other.get$_bottom();
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.get$_left(), _this.get$_right(), _this.get$_edge_insets$_start(), _this.get$_edge_insets$_end(), _this.get$_top(), _this.get$_bottom(), C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    }
  };
  V.EdgeInsets.prototype = {
    get$_left: function() {
      return this.left;
    },
    get$_top: function() {
      return this.top;
    },
    get$_right: function() {
      return this.right;
    },
    get$_bottom: function() {
      return this.bottom;
    },
    get$_edge_insets$_start: function() {
      return 0;
    },
    get$_edge_insets$_end: function() {
      return 0;
    },
    deflateRect$1: function(rect) {
      var t3, t4, t5, t6, t7, t8, _this = this,
        t1 = rect.left,
        t2 = _this.left;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = rect.top;
      t4 = _this.top;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = rect.right;
      t6 = _this.right;
      if (typeof t5 !== "number")
        return t5.$sub();
      if (typeof t6 !== "number")
        return H.iae(t6);
      t7 = rect.bottom;
      t8 = _this.bottom;
      if (typeof t7 !== "number")
        return t7.$sub();
      if (typeof t8 !== "number")
        return H.iae(t8);
      return P.Rect$fromLTRB(t1 + t2, t3 + t4, t5 - t6, t7 - t8);
    },
    add$1: function(_, other) {
      if (other instanceof V.EdgeInsets)
        return this.$add(0, other);
      return this.super$EdgeInsetsGeometry$add(0, other);
    },
    $sub: function(_, other) {
      var t1, t2, t3, t4, t5, t6, t7, t8, _this = this;
      H.interceptedTypeCheck(other, "$isEdgeInsets");
      t1 = _this.left;
      t2 = other.left;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = _this.top;
      t4 = other.top;
      if (typeof t3 !== "number")
        return t3.$sub();
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = _this.right;
      t6 = other.right;
      if (typeof t5 !== "number")
        return t5.$sub();
      if (typeof t6 !== "number")
        return H.iae(t6);
      t7 = _this.bottom;
      t8 = other.bottom;
      if (typeof t7 !== "number")
        return t7.$sub();
      if (typeof t8 !== "number")
        return H.iae(t8);
      return new V.EdgeInsets(t1 - t2, t3 - t4, t5 - t6, t7 - t8);
    },
    $add: function(_, other) {
      var t1, t2, t3, t4, t5, t6, t7, t8, _this = this;
      H.interceptedTypeCheck(other, "$isEdgeInsets");
      t1 = _this.left;
      t2 = other.left;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = _this.top;
      t4 = other.top;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = _this.right;
      t6 = other.right;
      if (typeof t5 !== "number")
        return t5.$add();
      if (typeof t6 !== "number")
        return H.iae(t6);
      t7 = _this.bottom;
      t8 = other.bottom;
      if (typeof t7 !== "number")
        return t7.$add();
      if (typeof t8 !== "number")
        return H.iae(t8);
      return new V.EdgeInsets(t1 + t2, t3 + t4, t5 + t6, t7 + t8);
    },
    $mul: function(_, other) {
      var t2, t3, t4, _this = this,
        t1 = _this.left;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof other !== "number")
        return H.iae(other);
      t2 = _this.top;
      if (typeof t2 !== "number")
        return t2.$mul();
      t3 = _this.right;
      if (typeof t3 !== "number")
        return t3.$mul();
      t4 = _this.bottom;
      if (typeof t4 !== "number")
        return t4.$mul();
      return new V.EdgeInsets(t1 * other, t2 * other, t3 * other, t4 * other);
    },
    resolve$1: function(direction) {
      return this;
    },
    copyWith$4$bottom$left$right$top: function(bottom, left, right, $top) {
      var _this = this,
        t1 = left == null ? _this.left : left,
        t2 = $top == null ? _this.top : $top,
        t3 = right == null ? _this.right : right;
      return new V.EdgeInsets(t1, t2, t3, bottom == null ? _this.bottom : bottom);
    },
    copyWith$1$bottom: function(bottom) {
      return this.copyWith$4$bottom$left$right$top(bottom, null, null, null);
    }
  };
  V.EdgeInsetsDirectional.prototype = {
    get$_edge_insets$_start: function() {
      return this.start;
    },
    get$_top: function() {
      return this.top;
    },
    get$_edge_insets$_end: function() {
      return this.end;
    },
    get$_bottom: function() {
      return this.bottom;
    },
    get$_left: function() {
      return 0;
    },
    get$_right: function() {
      return 0;
    },
    get$isNonNegative: function() {
      var _this = this,
        t1 = _this.start;
      if (typeof t1 !== "number")
        return t1.$ge();
      if (t1 >= 0) {
        t1 = _this.top;
        if (typeof t1 !== "number")
          return t1.$ge();
        if (t1 >= 0) {
          t1 = _this.end;
          if (typeof t1 !== "number")
            return t1.$ge();
          if (t1 >= 0) {
            t1 = _this.bottom;
            if (typeof t1 !== "number")
              return t1.$ge();
            t1 = t1 >= 0;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    add$1: function(_, other) {
      if (other instanceof V.EdgeInsetsDirectional)
        return this.$add(0, other);
      return this.super$EdgeInsetsGeometry$add(0, other);
    },
    $sub: function(_, other) {
      var t1, t2, t3, t4, t5, t6, t7, t8, _this = this;
      H.interceptedTypeCheck(other, "$isEdgeInsetsDirectional");
      t1 = _this.start;
      t2 = other.start;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = _this.top;
      t4 = other.top;
      if (typeof t3 !== "number")
        return t3.$sub();
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = _this.end;
      t6 = other.end;
      if (typeof t5 !== "number")
        return t5.$sub();
      if (typeof t6 !== "number")
        return H.iae(t6);
      t7 = _this.bottom;
      t8 = other.bottom;
      if (typeof t7 !== "number")
        return t7.$sub();
      if (typeof t8 !== "number")
        return H.iae(t8);
      return new V.EdgeInsetsDirectional(t1 - t2, t3 - t4, t5 - t6, t7 - t8);
    },
    $add: function(_, other) {
      var t1, t2, t3, t4, t5, t6, t7, t8, _this = this;
      H.interceptedTypeCheck(other, "$isEdgeInsetsDirectional");
      t1 = _this.start;
      t2 = other.start;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = _this.top;
      t4 = other.top;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = _this.end;
      t6 = other.end;
      if (typeof t5 !== "number")
        return t5.$add();
      if (typeof t6 !== "number")
        return H.iae(t6);
      t7 = _this.bottom;
      t8 = other.bottom;
      if (typeof t7 !== "number")
        return t7.$add();
      if (typeof t8 !== "number")
        return H.iae(t8);
      return new V.EdgeInsetsDirectional(t1 + t2, t3 + t4, t5 + t6, t7 + t8);
    },
    $mul: function(_, other) {
      var t2, t3, t4, _this = this,
        t1 = _this.start;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof other !== "number")
        return H.iae(other);
      t2 = _this.top;
      if (typeof t2 !== "number")
        return t2.$mul();
      t3 = _this.end;
      if (typeof t3 !== "number")
        return t3.$mul();
      t4 = _this.bottom;
      if (typeof t4 !== "number")
        return t4.$mul();
      return new V.EdgeInsetsDirectional(t1 * other, t2 * other, t3 * other, t4 * other);
    },
    resolve$1: function(direction) {
      var _this = this;
      H.assertHelper(direction != null);
      switch (direction) {
        case C.TextDirection_0:
          return new V.EdgeInsets(_this.end, _this.top, _this.start, _this.bottom);
        case C.TextDirection_1:
          return new V.EdgeInsets(_this.start, _this.top, _this.end, _this.bottom);
      }
      return;
    }
  };
  V._MixedEdgeInsets.prototype = {
    get$isNonNegative: function() {
      var _this = this,
        t1 = _this._left;
      if (typeof t1 !== "number")
        return t1.$ge();
      if (t1 >= 0) {
        t1 = _this._right;
        if (typeof t1 !== "number")
          return t1.$ge();
        if (t1 >= 0) {
          t1 = _this._edge_insets$_start;
          if (typeof t1 !== "number")
            return t1.$ge();
          if (t1 >= 0) {
            t1 = _this._edge_insets$_end;
            if (typeof t1 !== "number")
              return t1.$ge();
            if (t1 >= 0) {
              t1 = _this._top;
              if (typeof t1 !== "number")
                return t1.$ge();
              if (t1 >= 0) {
                t1 = _this._bottom;
                if (typeof t1 !== "number")
                  return t1.$ge();
                t1 = t1 >= 0;
              } else
                t1 = false;
            } else
              t1 = false;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    $mul: function(_, other) {
      var t2, t3, t4, t5, t6, _this = this,
        t1 = _this._left;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof other !== "number")
        return H.iae(other);
      t2 = _this._right;
      if (typeof t2 !== "number")
        return t2.$mul();
      t3 = _this._edge_insets$_start;
      if (typeof t3 !== "number")
        return t3.$mul();
      t4 = _this._edge_insets$_end;
      if (typeof t4 !== "number")
        return t4.$mul();
      t5 = _this._top;
      if (typeof t5 !== "number")
        return t5.$mul();
      t6 = _this._bottom;
      if (typeof t6 !== "number")
        return t6.$mul();
      return new V._MixedEdgeInsets(t1 * other, t2 * other, t3 * other, t4 * other, t5 * other, t6 * other);
    },
    resolve$1: function(direction) {
      var t1, t2, t3, t4, _this = this;
      H.assertHelper(direction != null);
      switch (direction) {
        case C.TextDirection_0:
          t1 = _this._edge_insets$_end;
          t2 = _this._left;
          if (typeof t1 !== "number")
            return t1.$add();
          if (typeof t2 !== "number")
            return H.iae(t2);
          t3 = _this._edge_insets$_start;
          t4 = _this._right;
          if (typeof t3 !== "number")
            return t3.$add();
          if (typeof t4 !== "number")
            return H.iae(t4);
          return new V.EdgeInsets(t1 + t2, _this._top, t3 + t4, _this._bottom);
        case C.TextDirection_1:
          t1 = _this._edge_insets$_start;
          t2 = _this._left;
          if (typeof t1 !== "number")
            return t1.$add();
          if (typeof t2 !== "number")
            return H.iae(t2);
          t3 = _this._edge_insets$_end;
          t4 = _this._right;
          if (typeof t3 !== "number")
            return t3.$add();
          if (typeof t4 !== "number")
            return H.iae(t4);
          return new V.EdgeInsets(t1 + t2, _this._top, t3 + t4, _this._bottom);
      }
      return;
    },
    get$_left: function() {
      return this._left;
    },
    get$_right: function() {
      return this._right;
    },
    get$_edge_insets$_start: function() {
      return this._edge_insets$_start;
    },
    get$_edge_insets$_end: function() {
      return this._edge_insets$_end;
    },
    get$_top: function() {
      return this._top;
    },
    get$_bottom: function() {
      return this._bottom;
    }
  };
  T._ColorsAndStops.prototype = {};
  T._sample_closure.prototype = {
    call$1: function(s) {
      H.doubleTypeCheck(s);
      if (typeof s !== "number")
        return s.$le();
      return s <= this.t;
    },
    $signature: 82
  };
  T._interpolateColorsAndStops_closure.prototype = {
    call$1: function($stop) {
      var _this = this;
      H.doubleTypeCheck($stop);
      return P.Color_lerp(T._sample(_this.aColors, _this.aStops, $stop), T._sample(_this.bColors, _this.bStops, $stop), _this.t);
    },
    $signature: 58
  };
  T.Gradient.prototype = {
    _impliedStops$0: function() {
      return this.stops;
    }
  };
  T.LinearGradient.prototype = {
    scale$1: function(factor) {
      var _this = this,
        t1 = _this.colors,
        t2 = P.Color,
        t3 = H.getTypeArgumentByIndex(t1, 0);
      return T.LinearGradient$(_this.begin, new H.MappedListIterable(t1, H.functionTypeCheck(new T.LinearGradient_scale_closure(factor), {func: 1, ret: t2, args: [t3]}), [t3, t2]).toList$0(0), _this.end, _this.stops, _this.tileMode);
    },
    $eq: function(_, other) {
      var t1, t2, i, t3, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$isLinearGradient");
      if (J.$eq$(_this.begin, other.begin))
        if (J.$eq$(_this.end, other.end))
          if (_this.tileMode === other.tileMode) {
            t1 = _this.colors.length;
            t2 = other.colors.length;
            if (t1 === t2) {
              t1 = _this.stops.length;
              t2 = other.stops.length;
              t1 = t1 !== t2;
            } else
              t1 = true;
          } else
            t1 = true;
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        return false;
      t1 = _this.colors;
      t2 = other.colors;
      H.assertHelper(t1.length === t2.length);
      for (i = 0; i < t1.length; ++i) {
        t3 = t1[i];
        if (i >= t2.length)
          return H.ioore(t2, i);
        if (!J.$eq$(t3, t2[i]))
          return false;
      }
      t1 = _this.stops;
      t2 = other.stops;
      H.assertHelper(t1.length === t2.length);
      for (i = 0; i < t1.length; ++i) {
        t3 = t1[i];
        if (i >= t2.length)
          return H.ioore(t2, i);
        if (!J.$eq$(t3, t2[i]))
          return false;
      }
      return true;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.begin, _this.end, _this.tileMode, P.hashList(_this.colors), P.hashList(_this.stops), C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var _this = this;
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(" + H.S(_this.begin) + ", " + H.S(_this.end) + ", " + H.S(_this.colors) + ", " + H.S(_this.stops) + ", " + _this.tileMode.toString$0(0) + ")";
    }
  };
  T.LinearGradient_scale_closure.prototype = {
    call$1: function(color) {
      return P.Color_lerp(null, H.interceptedTypeCheck(color, "$isColor"), this.factor);
    },
    $signature: 84
  };
  E.ImageCache.prototype = {};
  E._CachedImage.prototype = {};
  E._PendingImage.prototype = {};
  M.ImageConfiguration.prototype = {
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isImageConfiguration");
      return other.bundle == _this.bundle && other.devicePixelRatio == _this.devicePixelRatio && J.$eq$(other.locale, _this.locale) && other.textDirection == _this.textDirection && J.$eq$(other.size, _this.size) && other.platform == _this.platform;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.bundle, _this.devicePixelRatio, _this.locale, _this.size, _this.platform, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var hasArguments, t2, _this = this,
        _s19_ = "ImageConfiguration(",
        t1 = _this.bundle;
      if (t1 != null) {
        t1 = _s19_ + ("bundle: " + t1.toString$0(0));
        hasArguments = true;
      } else {
        t1 = _s19_;
        hasArguments = false;
      }
      t2 = _this.devicePixelRatio;
      if (t2 != null) {
        if (hasArguments)
          t1 += ", ";
        t2 = t1 + ("devicePixelRatio: " + C.JSInt_methods.toStringAsFixed$1(t2, 1));
        t1 = t2;
        hasArguments = true;
      }
      t2 = _this.locale;
      if (t2 != null) {
        if (hasArguments)
          t1 += ", ";
        t2 = t1 + ("locale: " + t2.toString$0(0));
        t1 = t2;
        hasArguments = true;
      }
      t2 = _this.textDirection;
      if (t2 != null) {
        if (hasArguments)
          t1 += ", ";
        t2 = t1 + ("textDirection: " + t2.toString$0(0));
        t1 = t2;
        hasArguments = true;
      }
      t2 = _this.size;
      if (t2 != null) {
        if (hasArguments)
          t1 += ", ";
        t2 = t1 + ("size: " + t2.toString$0(0));
        t1 = t2;
        hasArguments = true;
      }
      t2 = _this.platform;
      if (t2 != null) {
        if (hasArguments)
          t1 += ", ";
        t2 = t1 + ("platform: " + Y.describeEnum(t2));
        t1 = t2;
      }
      t1 += ")";
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  T.TransformProperty.prototype = {
    valueToString$1$parentConfiguration: function(parentConfiguration) {
      var t1, t2, t3, _this = this;
      if (parentConfiguration != null && !parentConfiguration.lineBreakProperties) {
        _this._maybeCacheValue$0();
        t1 = _this._value.getRow$1(0);
        _this._maybeCacheValue$0();
        t2 = _this._value.getRow$1(1);
        _this._maybeCacheValue$0();
        t3 = _this._value.getRow$1(2);
        _this._maybeCacheValue$0();
        return "[" + C.JSArray_methods.join$1(H.setRuntimeTypeInfo([t1, t2, t3, _this._value.getRow$1(3)], [E.Vector4]), "; ") + "]";
      }
      _this._maybeCacheValue$0();
      return C.JSArray_methods.join$1(T.debugDescribeTransform(_this._value), "\n");
    },
    valueToString$0: function() {
      return this.valueToString$1$parentConfiguration(null);
    },
    $asDiagnosticsProperty: function() {
      return [E.Matrix4];
    }
  };
  V.NotchedShape.prototype = {};
  X.RoundedRectangleBorder.prototype = {
    get$dimensions: function() {
      var t1 = this.side.width;
      return new V.EdgeInsets(t1, t1, t1, t1);
    },
    scale$1: function(t) {
      var t1 = this.side.scale$1(t);
      return X.RoundedRectangleBorder$(this.borderRadius.$mul(0, t), t1);
    },
    lerpFrom$2: function(a, t) {
      var _this = this,
        t1 = J.getInterceptor$(a);
      if (!!t1.$isRoundedRectangleBorder) {
        t1 = Y.BorderSide_lerp(a.side, _this.side, t);
        return X.RoundedRectangleBorder$(K.BorderRadiusGeometry_lerp(a.borderRadius, _this.borderRadius, t), t1);
      }
      if (!!t1.$isCircleBorder)
        return X._RoundedRectangleToCircleBorder$(_this.borderRadius, 1 - t, Y.BorderSide_lerp(a.side, _this.side, t));
      return _this.super$ShapeBorder$lerpFrom(a, t);
    },
    lerpTo$2: function(b, t) {
      var _this = this,
        t1 = J.getInterceptor$(b);
      if (!!t1.$isRoundedRectangleBorder) {
        t1 = Y.BorderSide_lerp(_this.side, b.side, t);
        return X.RoundedRectangleBorder$(K.BorderRadiusGeometry_lerp(_this.borderRadius, b.borderRadius, t), t1);
      }
      if (!!t1.$isCircleBorder)
        return X._RoundedRectangleToCircleBorder$(_this.borderRadius, t, Y.BorderSide_lerp(_this.side, b.side, t));
      return _this.super$ShapeBorder$lerpTo(b, t);
    },
    getOuterPath$2$textDirection: function(rect, textDirection) {
      var t1 = new P.Path();
      H.throwExpression(P.UnimplementedError$(null));
      t1.addRRect$1(this.borderRadius.resolve$1(textDirection).toRRect$1(rect));
      return t1;
    },
    paint$3$textDirection: function(canvas, rect, textDirection) {
      var width, t2, outer, inner, paint,
        t1 = this.side;
      switch (t1.style) {
        case C.BorderStyle_0:
          break;
        case C.BorderStyle_1:
          width = t1.width;
          t2 = this.borderRadius;
          if (width === 0)
            canvas.drawRRect$2(t2.resolve$1(textDirection).toRRect$1(rect), t1.toPaint$0());
          else {
            outer = t2.resolve$1(textDirection).toRRect$1(rect);
            inner = outer.inflate$1(-width);
            paint = new P.Paint(new DataView(new ArrayBuffer(75)));
            paint.set$color(t1.color);
            canvas.drawDRRect$3(outer, inner, paint);
          }
          break;
      }
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!new H.TypeImpl(H.getRti(this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$isRoundedRectangleBorder");
      return this.side.$eq(0, other.side) && J.$eq$(this.borderRadius, other.borderRadius);
    },
    get$hashCode: function(_) {
      return P.hashValues(this.side, this.borderRadius, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(" + this.side.toString$0(0) + ", " + H.S(this.borderRadius) + ")";
    }
  };
  X._RoundedRectangleToCircleBorder.prototype = {
    get$dimensions: function() {
      var t1 = this.side.width;
      return new V.EdgeInsets(t1, t1, t1, t1);
    },
    scale$1: function(t) {
      var t1 = this.side.scale$1(t);
      return X._RoundedRectangleToCircleBorder$(this.borderRadius.$mul(0, t), t, t1);
    },
    lerpFrom$2: function(a, t) {
      var t2, t3, _this = this,
        t1 = J.getInterceptor$(a);
      if (!!t1.$isRoundedRectangleBorder) {
        t1 = Y.BorderSide_lerp(a.side, _this.side, t);
        t2 = K.BorderRadiusGeometry_lerp(a.borderRadius, _this.borderRadius, t);
        t3 = _this.circleness;
        if (typeof t3 !== "number")
          return t3.$mul();
        return X._RoundedRectangleToCircleBorder$(t2, t3 * t, t1);
      }
      if (!!t1.$isCircleBorder) {
        t1 = Y.BorderSide_lerp(a.side, _this.side, t);
        t2 = _this.circleness;
        if (typeof t2 !== "number")
          return H.iae(t2);
        return X._RoundedRectangleToCircleBorder$(_this.borderRadius, t2 + (1 - t2) * (1 - t), t1);
      }
      if (!!t1.$is_RoundedRectangleToCircleBorder) {
        t1 = Y.BorderSide_lerp(a.side, _this.side, t);
        return X._RoundedRectangleToCircleBorder$(K.BorderRadiusGeometry_lerp(a.borderRadius, _this.borderRadius, t), P.lerpDouble(a.circleness, _this.circleness, t), t1);
      }
      return _this.super$ShapeBorder$lerpFrom(a, t);
    },
    lerpTo$2: function(b, t) {
      var t2, t3, _this = this,
        t1 = J.getInterceptor$(b);
      if (!!t1.$isRoundedRectangleBorder) {
        t1 = Y.BorderSide_lerp(_this.side, b.side, t);
        t2 = K.BorderRadiusGeometry_lerp(_this.borderRadius, b.borderRadius, t);
        t3 = _this.circleness;
        if (typeof t3 !== "number")
          return t3.$mul();
        return X._RoundedRectangleToCircleBorder$(t2, t3 * (1 - t), t1);
      }
      if (!!t1.$isCircleBorder) {
        t1 = Y.BorderSide_lerp(_this.side, b.side, t);
        t2 = _this.circleness;
        if (typeof t2 !== "number")
          return H.iae(t2);
        return X._RoundedRectangleToCircleBorder$(_this.borderRadius, t2 + (1 - t2) * t, t1);
      }
      if (!!t1.$is_RoundedRectangleToCircleBorder) {
        t1 = Y.BorderSide_lerp(_this.side, b.side, t);
        return X._RoundedRectangleToCircleBorder$(K.BorderRadiusGeometry_lerp(_this.borderRadius, b.borderRadius, t), P.lerpDouble(_this.circleness, b.circleness, t), t1);
      }
      return _this.super$ShapeBorder$lerpTo(b, t);
    },
    _adjustRect$1: function(rect) {
      var t2, t3, t4, t5, t6, t7, delta,
        t1 = this.circleness;
      if (t1 !== 0) {
        t2 = rect.right;
        t3 = rect.left;
        if (typeof t2 !== "number")
          return t2.$sub();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t4 = rect.bottom;
        t5 = rect.top;
        if (typeof t4 !== "number")
          return t4.$sub();
        if (typeof t5 !== "number")
          return H.iae(t5);
        t5 = t2 - t3 === t4 - t5;
        t2 = t5;
      } else
        t2 = true;
      if (t2)
        return rect;
      t2 = rect.right;
      t3 = rect.left;
      if (typeof t2 !== "number")
        return t2.$sub();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = t2 - t3;
      t5 = rect.bottom;
      t6 = rect.top;
      if (typeof t5 !== "number")
        return t5.$sub();
      if (typeof t6 !== "number")
        return H.iae(t6);
      t7 = t5 - t6;
      if (t4 < t7) {
        if (typeof t1 !== "number")
          return t1.$mul();
        delta = t1 * (t7 - t4) / 2;
        return P.Rect$fromLTRB(t3, t6 + delta, t2, t5 - delta);
      } else {
        if (typeof t1 !== "number")
          return t1.$mul();
        delta = t1 * (t4 - t7) / 2;
        return P.Rect$fromLTRB(t3 + delta, t6, t2 - delta, t5);
      }
    },
    _adjustBorderRadius$2: function(rect, textDirection) {
      var t2,
        resolvedRadius = this.borderRadius.resolve$1(textDirection),
        t1 = this.circleness;
      if (t1 === 0)
        return resolvedRadius;
      t2 = rect.get$shortestSide() / 2;
      t2 = new P.Radius(t2, t2);
      return K.BorderRadius_lerp(resolvedRadius, new K.BorderRadius(t2, t2, t2, t2), t1);
    },
    getOuterPath$2$textDirection: function(rect, textDirection) {
      var t1 = new P.Path();
      H.throwExpression(P.UnimplementedError$(null));
      t1.addRRect$1(this._adjustBorderRadius$2(rect, textDirection).toRRect$1(this._adjustRect$1(rect)));
      return t1;
    },
    paint$3$textDirection: function(canvas, rect, textDirection) {
      var width, outer, inner, paint, _this = this,
        t1 = _this.side;
      switch (t1.style) {
        case C.BorderStyle_0:
          break;
        case C.BorderStyle_1:
          width = t1.width;
          if (width === 0)
            canvas.drawRRect$2(_this._adjustBorderRadius$2(rect, textDirection).toRRect$1(_this._adjustRect$1(rect)), t1.toPaint$0());
          else {
            outer = _this._adjustBorderRadius$2(rect, textDirection).toRRect$1(_this._adjustRect$1(rect));
            inner = outer.inflate$1(-width);
            paint = new P.Paint(new DataView(new ArrayBuffer(75)));
            paint.set$color(t1.color);
            canvas.drawDRRect$3(outer, inner, paint);
          }
          break;
      }
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$is_RoundedRectangleToCircleBorder");
      return _this.side.$eq(0, other.side) && J.$eq$(_this.borderRadius, other.borderRadius) && _this.circleness == other.circleness;
    },
    get$hashCode: function(_) {
      return P.hashValues(this.side, this.borderRadius, this.circleness, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t1 = "RoundedRectangleBorder(" + this.side.toString$0(0) + ", " + H.S(this.borderRadius) + ", ",
        t2 = this.circleness;
      if (typeof t2 !== "number")
        return t2.$mul();
      return t1 + C.JSNumber_methods.toStringAsFixed$1(t2 * 100, 1) + "% of the way to being a CircleBorder)";
    }
  };
  D.ShaderWarmUp.prototype = {
    execute$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this;
      var $async$execute$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait($async$self.warmUpOnCanvas$1(new P.Canvas()), $async$execute$0);
            case 2:
              // returning from await.
              new P.PictureRecorder().endRecording$0();
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$execute$0, $async$completer);
    }
  };
  D.DefaultShaderWarmUp.prototype = {
    warmUpOnCanvas$1: function(canvas) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1);
      var $async$warmUpOnCanvas$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              H.throwExpression(P.UnimplementedError$(null));
              new P.Path().addRRect$1(new P.RRect(20, 20, 60, 60, 10, 10, 10, 10, 10, 10, 10, 10));
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$warmUpOnCanvas$1, $async$completer);
    }
  };
  S.StadiumBorder.prototype = {
    get$dimensions: function() {
      var t1 = this.side.width;
      return new V.EdgeInsets(t1, t1, t1, t1);
    },
    scale$1: function(t) {
      return new S.StadiumBorder(this.side.scale$1(t));
    },
    lerpFrom$2: function(a, t) {
      var _this = this,
        t1 = J.getInterceptor$(a);
      if (!!t1.$isStadiumBorder)
        return new S.StadiumBorder(Y.BorderSide_lerp(a.side, _this.side, t));
      if (!!t1.$isCircleBorder)
        return S._StadiumToCircleBorder$(1 - t, Y.BorderSide_lerp(a.side, _this.side, t));
      if (!!t1.$isRoundedRectangleBorder) {
        t1 = Y.BorderSide_lerp(a.side, _this.side, t);
        return S._StadiumToRoundedRectangleBorder$(H.interceptedTypeCheck(a.borderRadius, "$isBorderRadius"), 1 - t, t1);
      }
      return _this.super$ShapeBorder$lerpFrom(a, t);
    },
    lerpTo$2: function(b, t) {
      var _this = this,
        t1 = J.getInterceptor$(b);
      if (!!t1.$isStadiumBorder)
        return new S.StadiumBorder(Y.BorderSide_lerp(_this.side, b.side, t));
      if (!!t1.$isCircleBorder)
        return S._StadiumToCircleBorder$(t, Y.BorderSide_lerp(_this.side, b.side, t));
      if (!!t1.$isRoundedRectangleBorder) {
        t1 = Y.BorderSide_lerp(_this.side, b.side, t);
        return S._StadiumToRoundedRectangleBorder$(H.interceptedTypeCheck(b.borderRadius, "$isBorderRadius"), t, t1);
      }
      return _this.super$ShapeBorder$lerpTo(b, t);
    },
    getOuterPath$2$textDirection: function(rect, textDirection) {
      var t1 = rect.get$shortestSide() / 2,
        t2 = new P.Path();
      H.throwExpression(P.UnimplementedError$(null));
      t2.addRRect$1(P.RRect$fromRectAndRadius(rect, new P.Radius(t1, t1)));
      return t2;
    },
    paint$3$textDirection: function(canvas, rect, textDirection) {
      var t2,
        t1 = this.side;
      switch (t1.style) {
        case C.BorderStyle_0:
          break;
        case C.BorderStyle_1:
          t2 = rect.get$shortestSide() / 2;
          canvas.drawRRect$2(P.RRect$fromRectAndRadius(rect, new P.Radius(t2, t2)).inflate$1(-(t1.width / 2)), t1.toPaint$0());
          break;
      }
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!new H.TypeImpl(H.getRti(this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      return this.side.$eq(0, H.interceptedTypeCheck(other, "$isStadiumBorder").side);
    },
    get$hashCode: function(_) {
      var t1 = this.side;
      return P.hashValues(t1.color, t1.width, t1.style, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(" + this.side.toString$0(0) + ")";
    }
  };
  S._StadiumToCircleBorder.prototype = {
    get$dimensions: function() {
      var t1 = this.side.width;
      return new V.EdgeInsets(t1, t1, t1, t1);
    },
    scale$1: function(t) {
      return S._StadiumToCircleBorder$(t, this.side.scale$1(t));
    },
    lerpFrom$2: function(a, t) {
      var t2, _this = this,
        t1 = J.getInterceptor$(a);
      if (!!t1.$isStadiumBorder) {
        t1 = Y.BorderSide_lerp(a.side, _this.side, t);
        t2 = _this.circleness;
        if (typeof t2 !== "number")
          return t2.$mul();
        return S._StadiumToCircleBorder$(t2 * t, t1);
      }
      if (!!t1.$isCircleBorder) {
        t1 = Y.BorderSide_lerp(a.side, _this.side, t);
        t2 = _this.circleness;
        if (typeof t2 !== "number")
          return H.iae(t2);
        return S._StadiumToCircleBorder$(t2 + (1 - t2) * (1 - t), t1);
      }
      if (!!t1.$is_StadiumToCircleBorder) {
        t1 = Y.BorderSide_lerp(a.side, _this.side, t);
        return S._StadiumToCircleBorder$(P.lerpDouble(a.circleness, _this.circleness, t), t1);
      }
      return _this.super$ShapeBorder$lerpFrom(a, t);
    },
    lerpTo$2: function(b, t) {
      var t2, _this = this,
        t1 = J.getInterceptor$(b);
      if (!!t1.$isStadiumBorder) {
        t1 = Y.BorderSide_lerp(_this.side, b.side, t);
        t2 = _this.circleness;
        if (typeof t2 !== "number")
          return t2.$mul();
        return S._StadiumToCircleBorder$(t2 * (1 - t), t1);
      }
      if (!!t1.$isCircleBorder) {
        t1 = Y.BorderSide_lerp(_this.side, b.side, t);
        t2 = _this.circleness;
        if (typeof t2 !== "number")
          return H.iae(t2);
        return S._StadiumToCircleBorder$(t2 + (1 - t2) * t, t1);
      }
      if (!!t1.$is_StadiumToCircleBorder) {
        t1 = Y.BorderSide_lerp(_this.side, b.side, t);
        return S._StadiumToCircleBorder$(P.lerpDouble(_this.circleness, b.circleness, t), t1);
      }
      return _this.super$ShapeBorder$lerpTo(b, t);
    },
    _stadium_border$_adjustRect$1: function(rect) {
      var t2, t3, t4, t5, t6, t7, delta,
        t1 = this.circleness;
      if (t1 !== 0) {
        t2 = rect.right;
        t3 = rect.left;
        if (typeof t2 !== "number")
          return t2.$sub();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t4 = rect.bottom;
        t5 = rect.top;
        if (typeof t4 !== "number")
          return t4.$sub();
        if (typeof t5 !== "number")
          return H.iae(t5);
        t5 = t2 - t3 === t4 - t5;
        t2 = t5;
      } else
        t2 = true;
      if (t2)
        return rect;
      t2 = rect.right;
      t3 = rect.left;
      if (typeof t2 !== "number")
        return t2.$sub();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = t2 - t3;
      t5 = rect.bottom;
      t6 = rect.top;
      if (typeof t5 !== "number")
        return t5.$sub();
      if (typeof t6 !== "number")
        return H.iae(t6);
      t7 = t5 - t6;
      if (t4 < t7) {
        if (typeof t1 !== "number")
          return t1.$mul();
        delta = t1 * (t7 - t4) / 2;
        return P.Rect$fromLTRB(t3, t6 + delta, t2, t5 - delta);
      } else {
        if (typeof t1 !== "number")
          return t1.$mul();
        delta = t1 * (t4 - t7) / 2;
        return P.Rect$fromLTRB(t3 + delta, t6, t2 - delta, t5);
      }
    },
    getOuterPath$2$textDirection: function(rect, textDirection) {
      var t1 = new P.Path();
      H.throwExpression(P.UnimplementedError$(null));
      t1.addRRect$1(null.toRRect$1(this._stadium_border$_adjustRect$1(rect)));
      return t1;
    },
    paint$3$textDirection: function(canvas, rect, textDirection) {
      var width, t2, outer, inner, paint,
        t1 = this.side;
      switch (t1.style) {
        case C.BorderStyle_0:
          break;
        case C.BorderStyle_1:
          width = t1.width;
          if (width === 0) {
            t2 = rect.get$shortestSide() / 2;
            t2 = new P.Radius(t2, t2);
            canvas.drawRRect$2(new K.BorderRadius(t2, t2, t2, t2).toRRect$1(this._stadium_border$_adjustRect$1(rect)), t1.toPaint$0());
          } else {
            t2 = rect.get$shortestSide() / 2;
            t2 = new P.Radius(t2, t2);
            outer = new K.BorderRadius(t2, t2, t2, t2).toRRect$1(this._stadium_border$_adjustRect$1(rect));
            inner = outer.inflate$1(-width);
            paint = new P.Paint(new DataView(new ArrayBuffer(75)));
            paint.set$color(t1.color);
            canvas.drawDRRect$3(outer, inner, paint);
          }
          break;
      }
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!new H.TypeImpl(H.getRti(this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$is_StadiumToCircleBorder");
      return this.side.$eq(0, other.side) && this.circleness == other.circleness;
    },
    get$hashCode: function(_) {
      return P.hashValues(this.side, this.circleness, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t1 = "StadiumBorder(" + this.side.toString$0(0) + ", ",
        t2 = this.circleness;
      if (typeof t2 !== "number")
        return t2.$mul();
      return t1 + C.JSNumber_methods.toStringAsFixed$1(t2 * 100, 1) + "% of the way to being a CircleBorder)";
    }
  };
  S._StadiumToRoundedRectangleBorder.prototype = {
    get$dimensions: function() {
      var t1 = this.side.width;
      return new V.EdgeInsets(t1, t1, t1, t1);
    },
    scale$1: function(t) {
      var t1 = this.side.scale$1(t);
      return S._StadiumToRoundedRectangleBorder$(this.borderRadius.$mul(0, t), t, t1);
    },
    lerpFrom$2: function(a, t) {
      var t2, _this = this,
        t1 = J.getInterceptor$(a);
      if (!!t1.$isStadiumBorder) {
        t1 = Y.BorderSide_lerp(a.side, _this.side, t);
        t2 = _this.rectness;
        if (typeof t2 !== "number")
          return t2.$mul();
        return S._StadiumToRoundedRectangleBorder$(_this.borderRadius, t2 * t, t1);
      }
      if (!!t1.$isRoundedRectangleBorder) {
        t1 = Y.BorderSide_lerp(a.side, _this.side, t);
        t2 = _this.rectness;
        if (typeof t2 !== "number")
          return H.iae(t2);
        return S._StadiumToRoundedRectangleBorder$(_this.borderRadius, t2 + (1 - t2) * (1 - t), t1);
      }
      if (!!t1.$is_StadiumToRoundedRectangleBorder) {
        t1 = Y.BorderSide_lerp(a.side, _this.side, t);
        return S._StadiumToRoundedRectangleBorder$(K.BorderRadius_lerp(a.borderRadius, _this.borderRadius, t), P.lerpDouble(a.rectness, _this.rectness, t), t1);
      }
      return _this.super$ShapeBorder$lerpFrom(a, t);
    },
    lerpTo$2: function(b, t) {
      var t2, _this = this,
        t1 = J.getInterceptor$(b);
      if (!!t1.$isStadiumBorder) {
        t1 = Y.BorderSide_lerp(_this.side, b.side, t);
        t2 = _this.rectness;
        if (typeof t2 !== "number")
          return t2.$mul();
        return S._StadiumToRoundedRectangleBorder$(_this.borderRadius, t2 * (1 - t), t1);
      }
      if (!!t1.$isRoundedRectangleBorder) {
        t1 = Y.BorderSide_lerp(_this.side, b.side, t);
        t2 = _this.rectness;
        if (typeof t2 !== "number")
          return H.iae(t2);
        return S._StadiumToRoundedRectangleBorder$(_this.borderRadius, t2 + (1 - t2) * t, t1);
      }
      if (!!t1.$is_StadiumToRoundedRectangleBorder) {
        t1 = Y.BorderSide_lerp(_this.side, b.side, t);
        return S._StadiumToRoundedRectangleBorder$(K.BorderRadius_lerp(_this.borderRadius, b.borderRadius, t), P.lerpDouble(_this.rectness, b.rectness, t), t1);
      }
      return _this.super$ShapeBorder$lerpTo(b, t);
    },
    _stadium_border$_adjustBorderRadius$1: function(rect) {
      var t2,
        t1 = rect.get$shortestSide() / 2;
      t1 = new P.Radius(t1, t1);
      t2 = this.rectness;
      if (typeof t2 !== "number")
        return H.iae(t2);
      return K.BorderRadius_lerp(this.borderRadius, new K.BorderRadius(t1, t1, t1, t1), 1 - t2);
    },
    getOuterPath$2$textDirection: function(rect, textDirection) {
      var t1 = new P.Path();
      H.throwExpression(P.UnimplementedError$(null));
      t1.addRRect$1(this._stadium_border$_adjustBorderRadius$1(rect).toRRect$1(rect));
      return t1;
    },
    paint$3$textDirection: function(canvas, rect, textDirection) {
      var width, outer, inner, paint,
        t1 = this.side;
      switch (t1.style) {
        case C.BorderStyle_0:
          break;
        case C.BorderStyle_1:
          width = t1.width;
          if (width === 0)
            canvas.drawRRect$2(this._stadium_border$_adjustBorderRadius$1(rect).toRRect$1(rect), t1.toPaint$0());
          else {
            outer = this._stadium_border$_adjustBorderRadius$1(rect).toRRect$1(rect);
            inner = outer.inflate$1(-width);
            paint = new P.Paint(new DataView(new ArrayBuffer(75)));
            paint.set$color(t1.color);
            canvas.drawDRRect$3(outer, inner, paint);
          }
          break;
      }
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$is_StadiumToRoundedRectangleBorder");
      return _this.side.$eq(0, other.side) && J.$eq$(_this.borderRadius, other.borderRadius) && _this.rectness == other.rectness;
    },
    get$hashCode: function(_) {
      return P.hashValues(this.side, this.borderRadius, this.rectness, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t1 = "StadiumBorder(" + this.side.toString$0(0) + ", " + H.S(this.borderRadius) + ", ",
        t2 = this.rectness;
      if (typeof t2 !== "number")
        return t2.$mul();
      return t1 + C.JSNumber_methods.toStringAsFixed$1(t2 * 100, 1) + "% of the way to being a RoundedRectangleBorder)";
    }
  };
  U.TextPainter.prototype = {
    set$text: function(value) {
      var t1, _this = this;
      value.debugAssertIsValid$0();
      if (J.$eq$(_this._text, value))
        return;
      t1 = _this._text;
      t1 = t1 == null ? null : t1.style;
      J.$eq$(t1, value.style);
      _this._text = value;
      _this._text_painter$_paragraph = null;
      _this._text_painter$_needsLayout = true;
    },
    set$textAlign: function(value) {
      var _this = this;
      if (_this._textAlign === value)
        return;
      _this._textAlign = value;
      _this._text_painter$_paragraph = null;
      _this._text_painter$_needsLayout = true;
    },
    set$textDirection: function(value) {
      var _this = this;
      if (_this._text_painter$_textDirection === value)
        return;
      _this._text_painter$_textDirection = value;
      _this._text_painter$_paragraph = null;
      _this._text_painter$_needsLayout = true;
    },
    set$textScaleFactor: function(value) {
      var _this = this;
      if (_this._textScaleFactor === value)
        return;
      _this._textScaleFactor = value;
      _this._text_painter$_paragraph = null;
      _this._text_painter$_needsLayout = true;
    },
    set$ellipsis: function(value) {
      var _this = this;
      H.assertHelper(value == null || value.length !== 0);
      if (_this._text_painter$_ellipsis == value)
        return;
      _this._text_painter$_ellipsis = value;
      _this._text_painter$_paragraph = null;
      _this._text_painter$_needsLayout = true;
    },
    set$locale: function(value) {
      var _this = this;
      if (J.$eq$(_this._text_painter$_locale, value))
        return;
      _this._text_painter$_locale = value;
      _this._text_painter$_paragraph = null;
      _this._text_painter$_needsLayout = true;
    },
    set$maxLines: function(value) {
      var _this = this;
      H.assertHelper(value == null || value > 0);
      if (_this._maxLines == value)
        return;
      _this._maxLines = value;
      _this._text_painter$_paragraph = null;
      _this._text_painter$_needsLayout = true;
    },
    _applyFloatingPointHack$1: function(layoutValue) {
      return layoutValue.ceilToDouble$0(0);
    },
    get$maxIntrinsicWidth: function() {
      H.assertHelper(!this._text_painter$_needsLayout);
      return this._applyFloatingPointHack$1(this._text_painter$_paragraph.get$maxIntrinsicWidth());
    },
    get$width: function() {
      H.assertHelper(!this._text_painter$_needsLayout);
      return this._applyFloatingPointHack$1(this._text_painter$_paragraph.get$width());
    },
    get$height: function() {
      H.assertHelper(!this._text_painter$_needsLayout);
      return this._applyFloatingPointHack$1(this._text_painter$_paragraph.get$height());
    },
    computeDistanceToActualBaseline$1: function(baseline) {
      H.assertHelper(!this._text_painter$_needsLayout);
      H.assertHelper(baseline != null);
      switch (baseline) {
        case C.TextBaseline_0:
          return this._text_painter$_paragraph.get$alphabeticBaseline();
        case C.TextBaseline_1:
          return this._text_painter$_paragraph.get$ideographicBaseline();
      }
      return;
    },
    layout$2$maxWidth$minWidth: function(maxWidth, minWidth) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, builder, _this = this, _null = null,
        _s87_ = "TextPainter.textDirection must be set to a non-null value before using the TextPainter.";
      if (H.assertTest(_this._text != null))
        H.assertThrow("TextPainter.text must be set to a non-null value before using the TextPainter.");
      if (H.assertTest(_this._text_painter$_textDirection != null))
        H.assertThrow(_s87_);
      if (!_this._text_painter$_needsLayout && minWidth == _this._lastMinWidth && maxWidth == _this._lastMaxWidth)
        return;
      t1 = _this._text_painter$_needsLayout = false;
      if (H.assertTest(_this._text_painter$_textDirection != null || t1))
        H.assertThrow(_s87_);
      t1 = _this._text.style;
      if (t1 == null)
        t1 = _null;
      else {
        t2 = _this._textAlign;
        t3 = _this._text_painter$_textDirection;
        if (t3 == null)
          t3 = _null;
        t4 = _this._textScaleFactor;
        t5 = _this._maxLines;
        t6 = _this._text_painter$_ellipsis;
        t7 = _this._text_painter$_locale;
        H.assertHelper(t5 == null || t5 > 0);
        t8 = t1.fontWeight;
        t9 = t1.fontStyle;
        t10 = t1.fontFamily;
        t11 = t1.fontSize;
        if (t11 == null)
          t11 = 14;
        t1 = t1.height;
        t1 = P.ParagraphStyle$(t6, t10, t11 * t4, t9, t8, t1, t7, t5, _null, t2, t3);
      }
      if (t1 == null) {
        t1 = _this._textAlign;
        t2 = _this._text_painter$_textDirection;
        if (t2 == null)
          t2 = _null;
        t3 = _this._maxLines;
        P.ParagraphStyle$(_this._text_painter$_ellipsis, _null, _null, _null, _null, _null, _this._text_painter$_locale, t3, _null, t1, t2);
      }
      builder = new P.ParagraphBuilder();
      _this._text.build$2$textScaleFactor(builder, _this._textScaleFactor);
      _this._text_painter$_paragraph = builder.build$0();
      _this._lastMinWidth = minWidth;
      _this._lastMaxWidth = maxWidth;
      _this._text_painter$_paragraph.layout$1(new P.ParagraphConstraints(maxWidth));
      if (minWidth != maxWidth)
        _this.get$maxIntrinsicWidth().clamp$2(0, minWidth, maxWidth);
    },
    layout$0: function() {
      return this.layout$2$maxWidth$minWidth(1 / 0, 0);
    },
    paint$2: function(canvas, offset) {
      H.assertHelper(new U.TextPainter_paint_closure(this).call$0());
      canvas.drawParagraph$2(this._text_painter$_paragraph, offset);
    },
    getBoxesForSelection$1: function(selection) {
      H.assertHelper(!this._text_painter$_needsLayout);
      return this._text_painter$_paragraph.getBoxesForRange$2(selection.start, selection.end);
    },
    getPositionForOffset$1: function(offset) {
      H.assertHelper(!this._text_painter$_needsLayout);
      return this._text_painter$_paragraph.getPositionForOffset$1(offset);
    }
  };
  U.TextPainter_paint_closure.prototype = {
    call$0: function() {
      if (this.$this._text_painter$_needsLayout)
        throw H.wrapException(U.FlutterError$("TextPainter.paint called when text geometry was not yet calculated.\nPlease call layout() before paint() to position the text before painting it."));
      return true;
    },
    $signature: 0
  };
  Q.TextSpan.prototype = {
    build$2$textScaleFactor: function(builder, textScaleFactor) {
      var t1, hasStyle, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, _i, child, _this = this;
      _this.debugAssertIsValid$0();
      t1 = _this.style;
      hasStyle = t1 != null;
      if (hasStyle) {
        t2 = t1.color;
        t3 = t1.decoration;
        t4 = t1.decorationColor;
        t5 = t1.decorationStyle;
        t6 = t1.decorationThickness;
        t7 = t1.fontWeight;
        t8 = t1.fontStyle;
        t9 = t1.textBaseline;
        t10 = t1.fontFamily;
        t11 = t1.get$fontFamilyFallback();
        t12 = t1.fontSize;
        t12 = t12 == null ? null : t12 * textScaleFactor;
        t13 = t1.letterSpacing;
        t14 = t1.wordSpacing;
        t15 = t1.height;
        t16 = t1.locale;
        t17 = t1.foreground;
        t18 = t1.background;
        if (t18 == null) {
          t18 = t1.backgroundColor;
          if (t18 != null) {
            t19 = new P.Paint(new DataView(new ArrayBuffer(75)));
            t19.set$color(t18);
            t18 = t19;
          } else
            t18 = null;
        }
        builder.pushStyle$1(P.TextStyle$(t18, t2, t3, t4, t5, t6, t10, t11, t12, t8, t7, t17, t15, t13, t16, t1.shadows, t9, t14));
      }
      t1 = _this.text;
      if (t1 != null)
        builder.addText$1(t1);
      t1 = _this.children;
      if (t1 != null)
        for (_i = 0; _i < 1; ++_i) {
          child = t1[_i];
          H.assertHelper(false);
          child.build$2$textScaleFactor(builder, textScaleFactor);
        }
      if (hasStyle)
        builder.pop$0();
    },
    visitTextSpan$1: function(visitor) {
      var t1, _i;
      H.functionTypeCheck(visitor, {func: 1, ret: P.bool, args: [Q.TextSpan]});
      if (this.text != null)
        if (!H.boolConversionCheck(visitor.call$1(this)))
          return false;
      t1 = this.children;
      if (t1 != null)
        for (_i = 0; _i < 1; ++_i)
          if (!t1[_i].visitTextSpan$1(visitor))
            return false;
      return true;
    },
    toPlainText$0: function() {
      var buffer, t1;
      this.debugAssertIsValid$0();
      buffer = new P.StringBuffer("");
      this.visitTextSpan$1(new Q.TextSpan_toPlainText_closure(true, buffer));
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    debugAssertIsValid$0: function() {
      H.assertHelper(new Q.TextSpan_debugAssertIsValid_closure(this).call$0());
      return true;
    },
    compareTo$1: function(_, other) {
      var t1, candidate, result, t2, index, _this = this;
      if (_this === other)
        return C.RenderComparison_0;
      if (other.text == _this.text) {
        t1 = _this.children == null ? null : 1;
        t1 = t1 != (other.children == null ? null : 1) || _this.style == null !== (other.style == null);
      } else
        t1 = true;
      if (t1)
        return C.RenderComparison_3;
      t1 = _this.style;
      if (t1 != null) {
        candidate = t1.compareTo$1(0, other.style);
        result = candidate.index > 0 ? candidate : C.RenderComparison_0;
        if (result === C.RenderComparison_3)
          return result;
      } else
        result = C.RenderComparison_0;
      t1 = _this.children;
      if (t1 != null)
        for (t2 = other.children, index = 0; index < 1; ++index) {
          candidate = C.JSNull_methods.compareTo$1(t1[index], t2[index]);
          if (candidate.get$index().$gt(0, result.index))
            result = candidate;
          if (result === C.RenderComparison_3)
            return result;
        }
      return result;
    },
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isTextSpan");
      if (other.text == _this.text)
        if (J.$eq$(other.style, _this.style))
          t1 = S.listEquals(other.children, _this.children, Q.TextSpan);
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return P.hashValues(this.style, this.text, null, null, P.hashList(this.children), C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toStringShort$0: function() {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      properties.defaultDiagnosticsTreeStyle = C.DiagnosticsTreeStyle_4;
      t1 = _this.style;
      t2 = t1 == null;
      if (!t2)
        t1.debugFillProperties$1(properties);
      t1 = Y.DiagnosticsProperty$("recognizer", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, S.GestureRecognizer);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t1);
      t1 = _this.text;
      C.JSArray_methods.add$1(t3, Y.StringProperty$("text", t1, _null, true, false));
      if (t2 && t1 == null && _this.children == null)
        C.JSArray_methods.add$1(t3, Y.DiagnosticsNode_DiagnosticsNode$message("(empty)", C.DiagnosticsTreeStyle_5));
    },
    debugDescribeChildren$0: function() {
      var t2, t3,
        t1 = this.children;
      if (t1 == null)
        return C.List_empty;
      t2 = Y.DiagnosticsNode;
      t3 = H.getTypeArgumentByIndex(t1, 0);
      return new H.MappedListIterable(t1, H.functionTypeCheck(new Q.TextSpan_debugDescribeChildren_closure(), {func: 1, ret: t2, args: [t3]}), [t3, t2]).toList$0(0);
    }
  };
  Q.TextSpan_toPlainText_closure.prototype = {
    call$1: function(span) {
      this.buffer._contents += H.S(span.text);
      return true;
    },
    $signature: 28
  };
  Q.TextSpan_debugAssertIsValid_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (!t1.visitTextSpan$1(new Q.TextSpan_debugAssertIsValid__closure()))
        throw H.wrapException(U.FlutterError$("TextSpan contains a null child.\nA TextSpan object with a non-null child list should not have any nulls in its child list.\nThe full text in question was:\n" + t1.toStringDeep$1$prefixLineOne("  ")));
      return true;
    },
    $signature: 0
  };
  Q.TextSpan_debugAssertIsValid__closure.prototype = {
    call$1: function(span) {
      if (span.children != null)
        for (; true;)
          return false;
      return true;
    },
    $signature: 28
  };
  Q.TextSpan_debugDescribeChildren_closure.prototype = {
    call$1: function(child) {
      H.interceptedTypeCheck(child, "$isTextSpan");
      if (child != null)
        return new Y._DiagnosticableTreeNode(child, null, true, true, null);
      else
        return Y.DiagnosticsNode_DiagnosticsNode$message("<null child>", C.DiagnosticsTreeStyle_5);
    },
    $signature: 86
  };
  A.TextStyle0.prototype = {
    get$fontFamilyFallback: function() {
      return this._text_style$_fontFamilyFallback;
    },
    copyWith$20$background$backgroundColor$color$debugLabel$decoration$decorationColor$decorationStyle$decorationThickness$fontFamily$fontFamilyFallback$fontSize$fontStyle$fontWeight$foreground$height$letterSpacing$locale$shadows$textBaseline$wordSpacing: function(background, backgroundColor, color, debugLabel, decoration, decorationColor, decorationStyle, decorationThickness, fontFamily, fontFamilyFallback, fontSize, fontStyle, fontWeight, foreground, height, letterSpacing, locale, shadows, textBaseline, wordSpacing) {
      var t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, _this = this, t1 = {},
        t2 = color == null;
      if (H.assertTest(t2 || foreground == null))
        H.assertThrow('Cannot provide both a color and a foreground\nThe color argument is just a shorthand for "foreground: new Paint()..color = color".');
      t3 = backgroundColor == null;
      if (H.assertTest(t3 || background == null))
        H.assertThrow('Cannot provide both a backgroundColor and a background\nThe backgroundColor argument is just a shorthand for "background: new Paint()..color = color".');
      t1.newDebugLabel = null;
      H.assertHelper(new A.TextStyle_copyWith_closure(t1, _this, debugLabel).call$0());
      t4 = _this.foreground;
      if (t4 == null && foreground == null)
        t2 = t2 ? _this.color : color;
      else
        t2 = null;
      t5 = _this.background;
      if (t5 == null && background == null)
        t3 = t3 ? _this.backgroundColor : backgroundColor;
      else
        t3 = null;
      t6 = fontFamily == null ? _this.fontFamily : fontFamily;
      t7 = _this.get$fontFamilyFallback();
      t8 = fontSize == null ? _this.fontSize : fontSize;
      t9 = fontWeight == null ? _this.fontWeight : fontWeight;
      t10 = letterSpacing == null ? _this.letterSpacing : letterSpacing;
      t11 = wordSpacing == null ? _this.wordSpacing : wordSpacing;
      t12 = textBaseline == null ? _this.textBaseline : textBaseline;
      t13 = height == null ? _this.height : height;
      t4 = foreground == null ? t4 : foreground;
      t5 = background == null ? t5 : background;
      t14 = decoration == null ? _this.decoration : decoration;
      t15 = decorationColor == null ? _this.decorationColor : decorationColor;
      t16 = decorationStyle == null ? _this.decorationStyle : decorationStyle;
      t17 = decorationThickness == null ? _this.decorationThickness : decorationThickness;
      return A.TextStyle$0(t5, t3, t2, t1.newDebugLabel, t14, t15, t16, t17, t6, t7, t8, _this.fontStyle, t9, t4, t13, _this.inherit, t10, _this.locale, null, _this.shadows, t12, t11);
    },
    copyWith$2$color$letterSpacing: function(color, letterSpacing) {
      return this.copyWith$20$background$backgroundColor$color$debugLabel$decoration$decorationColor$decorationStyle$decorationThickness$fontFamily$fontFamilyFallback$fontSize$fontStyle$fontWeight$foreground$height$letterSpacing$locale$shadows$textBaseline$wordSpacing(null, null, color, null, null, null, null, null, null, null, null, null, null, null, null, letterSpacing, null, null, null, null);
    },
    copyWith$1$color: function(color) {
      return this.copyWith$20$background$backgroundColor$color$debugLabel$decoration$decorationColor$decorationStyle$decorationThickness$fontFamily$fontFamilyFallback$fontSize$fontStyle$fontWeight$foreground$height$letterSpacing$locale$shadows$textBaseline$wordSpacing(null, null, color, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    },
    apply$7$color$decoration$decorationColor$decorationStyle$fontFamily$fontSizeDelta$fontSizeFactor: function(color, decoration, decorationColor, decorationStyle, fontFamily, fontSizeDelta, fontSizeFactor) {
      var t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, _this = this, _null = null, t1 = {},
        t2 = _this.fontSize,
        t3 = t2 == null;
      if (t3)
        t4 = fontSizeFactor === 1 && fontSizeDelta === 0;
      else
        t4 = true;
      H.assertHelper(t4);
      t4 = _this.letterSpacing;
      t5 = t4 == null;
      t5;
      t6 = _this.wordSpacing;
      t7 = t6 == null;
      t7;
      t8 = _this.decorationThickness;
      t9 = t8 == null;
      t9;
      t1.modifiedDebugLabel = null;
      H.assertHelper(new A.TextStyle_apply_closure(t1, _this).call$0());
      t10 = _this.foreground;
      if (t10 == null)
        t11 = _this.color;
      else
        t11 = _null;
      t12 = _this.background;
      if (t12 == null)
        t13 = _this.backgroundColor;
      else
        t13 = _null;
      t14 = _this.get$fontFamilyFallback();
      t2 = t3 ? _null : t2 * fontSizeFactor + fontSizeDelta;
      t3 = _this.fontWeight;
      if (t3 == null)
        t3 = _null;
      else {
        t3 = H.intTypeCheck(C.JSInt_methods.clamp$2(t3.index, 0, 8));
        if (t3 < 0 || t3 >= 9)
          return H.ioore(C.List_27p, t3);
        t3 = C.List_27p[t3];
      }
      t4 = t5 ? _null : t4 + 0;
      t5 = t7 ? _null : t6 + 0;
      t6 = _this.height;
      t6 = t6 == null ? _null : t6 + 0;
      t7 = t9 ? _null : t8 + 0;
      return A.TextStyle$0(t12, t13, t11, t1.modifiedDebugLabel, _this.decoration, _this.decorationColor, _this.decorationStyle, t7, fontFamily, t14, t2, _this.fontStyle, t3, t10, t6, _this.inherit, t4, _this.locale, _null, _this.shadows, _this.textBaseline, t5);
    },
    merge$1: function(other) {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t1 = {};
      if (other == null)
        return this;
      if (!other.inherit)
        return other;
      t1.mergedDebugLabel = null;
      H.assertHelper(new A.TextStyle_merge_closure(t1, this, other).call$0());
      t2 = other.color;
      t3 = other.backgroundColor;
      t4 = other.fontFamily;
      t5 = other.get$fontFamilyFallback();
      t6 = other.fontSize;
      t7 = other.fontWeight;
      t8 = other.fontStyle;
      t9 = other.letterSpacing;
      t10 = other.wordSpacing;
      t11 = other.textBaseline;
      t12 = other.height;
      t13 = other.locale;
      t14 = other.foreground;
      t15 = other.background;
      t16 = other.shadows;
      t17 = other.decoration;
      t18 = other.decorationColor;
      t19 = other.decorationStyle;
      t20 = other.decorationThickness;
      return this.copyWith$20$background$backgroundColor$color$debugLabel$decoration$decorationColor$decorationStyle$decorationThickness$fontFamily$fontFamilyFallback$fontSize$fontStyle$fontWeight$foreground$height$letterSpacing$locale$shadows$textBaseline$wordSpacing(t15, t3, t2, t1.mergedDebugLabel, t17, t18, t19, t20, t4, t5, t6, t8, t7, t14, t12, t9, t13, t16, t11, t10);
    },
    compareTo$1: function(_, other) {
      var t1, _this = this;
      if (_this === other)
        return C.RenderComparison_0;
      if (_this.inherit === other.inherit)
        if (_this.fontFamily == other.fontFamily)
          if (_this.fontSize == other.fontSize)
            if (_this.fontWeight == other.fontWeight)
              if (_this.letterSpacing == other.letterSpacing)
                if (_this.wordSpacing == other.wordSpacing)
                  if (_this.textBaseline == other.textBaseline)
                    if (_this.height == other.height)
                      t1 = _this.foreground != other.foreground || _this.background != other.background || !S.listEquals(_this.shadows, other.shadows, P.Shadow) || !S.listEquals(_this.get$fontFamilyFallback(), other.get$fontFamilyFallback(), P.String);
                    else
                      t1 = true;
                  else
                    t1 = true;
                else
                  t1 = true;
              else
                t1 = true;
            else
              t1 = true;
          else
            t1 = true;
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        return C.RenderComparison_3;
      if (!J.$eq$(_this.color, other.color) || !J.$eq$(_this.backgroundColor, other.backgroundColor) || !J.$eq$(_this.decoration, other.decoration) || !J.$eq$(_this.decorationColor, other.decorationColor) || _this.decorationStyle != other.decorationStyle || _this.decorationThickness != other.decorationThickness)
        return C.RenderComparison_2;
      return C.RenderComparison_0;
    },
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isTextStyle0");
      if (_this.inherit === other.inherit)
        if (J.$eq$(_this.color, other.color))
          if (J.$eq$(_this.backgroundColor, other.backgroundColor))
            if (_this.fontFamily == other.fontFamily)
              if (_this.fontSize == other.fontSize)
                if (_this.fontWeight == other.fontWeight)
                  if (_this.letterSpacing == other.letterSpacing)
                    if (_this.wordSpacing == other.wordSpacing)
                      if (_this.textBaseline == other.textBaseline)
                        if (_this.height == other.height)
                          t1 = _this.foreground == other.foreground && _this.background == other.background && J.$eq$(_this.decoration, other.decoration) && J.$eq$(_this.decorationColor, other.decorationColor) && _this.decorationStyle == other.decorationStyle && _this.decorationThickness == other.decorationThickness && S.listEquals(_this.shadows, other.shadows, P.Shadow) && S.listEquals(_this.get$fontFamilyFallback(), other.get$fontFamilyFallback(), P.String);
                        else
                          t1 = false;
                      else
                        t1 = false;
                    else
                      t1 = false;
                  else
                    t1 = false;
                else
                  t1 = false;
              else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.inherit, _this.color, _this.backgroundColor, _this.fontFamily, _this.get$fontFamilyFallback(), _this.fontSize, _this.fontWeight, _this.fontStyle, _this.letterSpacing, _this.wordSpacing, _this.textBaseline, _this.height, _this.locale, _this.foreground, _this.background, _this.decoration, _this.decorationColor, _this.decorationStyle, _this.shadows, C.C__HashEnd);
    },
    toStringShort$0: function() {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    },
    debugFillProperties$2$prefix: function(properties, prefix) {
      var t1, styles, t2, t3, weightDescription, t4, decorationDescription, styleSpecified, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      t1 = _this.debugLabel;
      if (t1 != null) {
        t1 = Y.MessageProperty$(prefix + "debugLabel", t1);
        C.JSArray_methods.add$1(properties.properties, t1);
      }
      styles = H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]);
      t1 = P.Color;
      C.JSArray_methods.add$1(styles, Y.DiagnosticsProperty$(prefix + "color", _this.color, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(styles, Y.DiagnosticsProperty$(prefix + "backgroundColor", _this.backgroundColor, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(styles, Y.StringProperty$(prefix + "family", _this.fontFamily, _null, false, true));
      t2 = P.String;
      C.JSArray_methods.add$1(styles, Y.IterableProperty$(prefix + "familyFallback", _this.get$fontFamilyFallback(), _null, "[]", C.DiagnosticLevel_3, C.DiagnosticsTreeStyle_5, t2));
      C.JSArray_methods.add$1(styles, Y.DoubleProperty$(prefix + "size", _this.fontSize, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
      t3 = _this.fontWeight;
      weightDescription = t3 != null ? "" + (t3.index + 1) + "00" : _null;
      C.JSArray_methods.add$1(styles, Y.DiagnosticsProperty$(prefix + "weight", t3, _null, weightDescription, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.FontWeight));
      t3 = prefix + "style";
      C.JSArray_methods.add$1(styles, new Y.EnumProperty(_null, _null, _null, _null, false, _this.fontStyle, _null, C.DiagnosticLevel_3, t3, true, true, C.DiagnosticsTreeStyle_5, [P.FontStyle]));
      C.JSArray_methods.add$1(styles, Y.DoubleProperty$(prefix + "letterSpacing", _this.letterSpacing, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(styles, Y.DoubleProperty$(prefix + "wordSpacing", _this.wordSpacing, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
      t3 = prefix + "baseline";
      C.JSArray_methods.add$1(styles, new Y.EnumProperty(_null, _null, _null, _null, false, _this.textBaseline, _null, C.DiagnosticLevel_3, t3, true, true, C.DiagnosticsTreeStyle_5, [P.TextBaseline]));
      C.JSArray_methods.add$1(styles, Y.DoubleProperty$(prefix + "height", _this.height, _null, _null, C.DiagnosticLevel_3, true, _null, "x"));
      C.JSArray_methods.add$1(styles, Y.DiagnosticsProperty$(prefix + "locale", _this.locale, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Locale));
      t3 = P.Paint;
      C.JSArray_methods.add$1(styles, Y.DiagnosticsProperty$(prefix + "foreground", _this.foreground, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(styles, Y.DiagnosticsProperty$(prefix + "background", _this.background, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      t3 = _this.decoration;
      t4 = t3 == null;
      if (!t4 || _this.decorationColor != null || _this.decorationStyle != null || _this.decorationThickness != null) {
        decorationDescription = H.setRuntimeTypeInfo([], [t2]);
        t2 = _this.decorationStyle;
        if (t2 != null)
          C.JSArray_methods.add$1(decorationDescription, Y.describeEnum(t2));
        t2 = _this.decorationColor;
        C.JSArray_methods.add$1(styles, Y.DiagnosticsProperty$(prefix + "decorationColor", t2, _null, _null, _null, _null, C.DiagnosticLevel_1, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
        if (t2 != null)
          C.JSArray_methods.add$1(decorationDescription, t2.toString$0(0));
        C.JSArray_methods.add$1(styles, Y.DiagnosticsProperty$(prefix + "decoration", t3, _null, _null, _null, _null, C.DiagnosticLevel_0, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.TextDecoration));
        if (!t4)
          C.JSArray_methods.add$1(decorationDescription, t3.toString$0(0));
        H.assertHelper(decorationDescription.length !== 0);
        C.JSArray_methods.add$1(styles, Y.MessageProperty$(prefix + "decoration", C.JSArray_methods.join$1(decorationDescription, " ")));
        C.JSArray_methods.add$1(styles, Y.DoubleProperty$(prefix + "decorationThickness", _this.decorationThickness, _null, _null, C.DiagnosticLevel_3, true, _null, "x"));
      }
      styleSpecified = C.JSArray_methods.any$1(styles, new A.TextStyle_debugFillProperties_closure());
      t1 = prefix + "inherit";
      t2 = _this.inherit;
      t3 = !styleSpecified;
      t4 = t3 && t2 ? C.DiagnosticLevel_1 : C.DiagnosticLevel_3;
      t4 = Y.DiagnosticsProperty$(t1, t2, C.C__NoDefaultValue, _null, _null, _null, t4, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.bool);
      t1 = properties.properties;
      C.JSArray_methods.add$1(t1, t4);
      C.JSArray_methods.forEach$1(styles, properties.get$add(properties));
      if (t3) {
        t3 = prefix + "<all styles inherited>";
        C.JSArray_methods.add$1(t1, Y.FlagProperty$("inherit", _null, prefix + "<no style specified>", t3, C.DiagnosticLevel_3, false, t2));
      }
    },
    debugFillProperties$1: function(properties) {
      return this.debugFillProperties$2$prefix(properties, "");
    }
  };
  A.TextStyle_copyWith_closure.prototype = {
    call$0: function() {
      var newDebugLabel,
        t1 = this.$this.debugLabel;
      if (t1 != null) {
        newDebugLabel = this.debugLabel;
        if (newDebugLabel == null)
          newDebugLabel = "(" + t1 + ").copyWith";
        this._box_0.newDebugLabel = newDebugLabel;
      }
      return true;
    },
    $signature: 0
  };
  A.TextStyle_apply_closure.prototype = {
    call$0: function() {
      var t1 = this.$this.debugLabel;
      if (t1 != null)
        this._box_0.modifiedDebugLabel = "(" + t1 + ").apply";
      return true;
    },
    $signature: 0
  };
  A.TextStyle_merge_closure.prototype = {
    call$0: function() {
      var t3, _this = this,
        t1 = _this.other.debugLabel,
        t2 = t1 == null;
      if (!t2 || _this.$this.debugLabel != null) {
        t3 = _this.$this.debugLabel;
        t3 = "(" + (t3 == null ? "unknown" : t3) + ").merge(";
        _this._box_0.mergedDebugLabel = t3 + (t2 ? "unknown" : t1) + ")";
      }
      return true;
    },
    $signature: 0
  };
  A.TextStyle_lerp_closure.prototype = {
    call$0: function() {
      var t2, _this = this,
        t1 = _this.a;
      t1 = t1 == null ? null : t1.debugLabel;
      t1 = "lerp(" + (t1 == null ? "unknown" : t1) + " \u23af" + C.JSNumber_methods.toStringAsFixed$1(_this.t, 1) + "\u2192 ";
      t2 = _this.b;
      t2 = t2 == null ? null : t2.debugLabel;
      _this._box_0.lerpDebugLabel = t1 + (t2 == null ? "unknown" : t2) + ")";
      return true;
    },
    $signature: 0
  };
  A.TextStyle_debugFillProperties_closure.prototype = {
    call$1: function(n) {
      return H.interceptedTypeCheck(n, "$isDiagnosticsNode").get$level().index >= 3;
    },
    $signature: 18
  };
  T.Simulation.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    }
  };
  N.Tolerance.prototype = {
    toString$0: function(_) {
      return "Tolerance(distance: \xb1" + H.S(this.distance) + ", time: \xb10.001, velocity: \xb1" + H.S(this.velocity) + ")";
    }
  };
  N.RendererBinding.prototype = {
    handleMetricsChanged$0: function() {
      var _this = this;
      H.assertHelper(_this.RendererBinding__pipelineOwner._rootNode != null);
      _this.RendererBinding__pipelineOwner._rootNode.set$configuration(_this.createViewConfiguration$0());
      _this.scheduleForcedFrame$0();
    },
    handleTextScaleFactorChanged$0: function() {
    },
    handlePlatformBrightnessChanged$0: function() {
    },
    createViewConfiguration$0: function() {
      $.$get$window().toString;
      return new A.ViewConfiguration(C.Size_0_0.$div(0, 1), 1);
    },
    _createMouseTracker$0: function() {
      var t1 = new Y.MouseTracker(new N.RendererBinding__createMouseTracker_closure(this), P.LinkedHashMap_LinkedHashMap$_empty(Y.MouseTrackerAnnotation, Y._TrackedAnnotation), P.LinkedHashMap_LinkedHashMap$_empty(P.int, F.PointerEvent));
      this.GestureBinding_pointerRouter.addGlobalRoute$1(t1.get$_mouse_tracking$_handleEvent());
      return t1;
    },
    _handleSemanticsEnabledChanged$0: function() {
      $.$get$window().toString;
      this.setSemanticsEnabled$1(false);
    },
    setSemanticsEnabled$1: function(enabled) {
      var t1 = this.RendererBinding__semanticsHandle;
      if (t1 != null)
        t1.dispose$0();
      this.RendererBinding__semanticsHandle = null;
    },
    _handleSemanticsAction$3: function(id, action, args) {
      var t2,
        t1 = this.RendererBinding__pipelineOwner._semanticsOwner;
      if (t1 != null) {
        t2 = C.C_StandardMessageCodec.decodeMessage$1(args);
        t1.performAction$3(id, action, t2);
      }
    },
    _handleSemanticsOwnerCreated$0: function() {
      var t1 = this.RendererBinding__pipelineOwner._rootNode;
      H.assertHelper(t1._node$_owner != null);
      H.assertHelper(!(t1._node$_parent instanceof K.RenderObject));
      H.assertHelper(!H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner")._debugDoingSemantics);
      H.assertHelper(t1._semantics == null);
      H.assertHelper(t1._needsSemanticsUpdate);
      H.assertHelper(H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner")._semanticsOwner != null);
      H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner")._nodesNeedingSemantics.add$1(0, t1);
      H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner").onNeedVisualUpdate.call$0();
    },
    _handleSemanticsOwnerDisposed$0: function() {
      this.RendererBinding__pipelineOwner._rootNode.clearSemantics$0();
    },
    _handlePersistentFrameCallback$1: function(timeStamp) {
      H.interceptedTypeCheck(timeStamp, "$isDuration");
      this.drawFrame$0();
    },
    drawFrame$0: function() {
      var _this = this;
      H.assertHelper(_this.RendererBinding__pipelineOwner._rootNode != null);
      _this.RendererBinding__pipelineOwner.flushLayout$0();
      _this.RendererBinding__pipelineOwner.flushCompositingBits$0();
      _this.RendererBinding__pipelineOwner.flushPaint$0();
      _this.RendererBinding__pipelineOwner._rootNode.compositeFrame$0();
      _this.RendererBinding__pipelineOwner.flushSemantics$0();
    },
    _forceRepaint$0: function() {
      var visitor, t1 = {};
      t1.visitor = null;
      visitor = new N.RendererBinding__forceRepaint_closure(t1);
      t1.visitor = visitor;
      t1 = $.RendererBinding__instance;
      t1 = t1 == null ? null : t1.RendererBinding__pipelineOwner._rootNode;
      if (t1 != null)
        t1.visitChildren$1(visitor);
      return this.get$endOfFrame();
    }
  };
  N.RendererBinding__createMouseTracker_closure.prototype = {
    call$1: function(offset) {
      var t1;
      H.interceptedTypeCheck(offset, "$isOffset");
      t1 = this.$this.RendererBinding__pipelineOwner._rootNode;
      t1.get$isRepaintBoundary();
      H.assertHelper(!t1._needsPaint);
      t1 = t1._layer;
      $.$get$window().toString;
      return t1.find$1$1(offset.$mul(0, 1), Y.MouseTrackerAnnotation);
    },
    $signature: 88
  };
  N.RendererBinding__forceRepaint_closure.prototype = {
    call$1: function(child) {
      child.markNeedsPaint$0();
      child.visitChildren$1(this._box_0.visitor);
    },
    $signature: 10
  };
  S._DebugSize.prototype = {};
  S.BoxConstraints.prototype = {
    loosen$0: function() {
      H.assertHelper(this.debugAssertIsValid$0());
      return new S.BoxConstraints(0, this.maxWidth, 0, this.maxHeight);
    },
    enforce$1: function(constraints) {
      var t4, _this = this,
        t1 = constraints.minWidth,
        t2 = constraints.maxWidth,
        t3 = J.clamp$2$n(_this.minWidth, t1, t2);
      t2 = J.clamp$2$n(_this.maxWidth, t1, t2);
      t1 = constraints.minHeight;
      t4 = constraints.maxHeight;
      return new S.BoxConstraints(t3, t2, J.clamp$2$n(_this.minHeight, t1, t4), J.clamp$2$n(_this.maxHeight, t1, t4));
    },
    tighten$2$height$width: function(height, width) {
      var t5, t6, _this = this,
        t1 = width == null,
        t2 = _this.minWidth,
        t3 = t1 ? t2 : C.JSNumber_methods.clamp$2(width, t2, _this.maxWidth),
        t4 = _this.maxWidth;
      t1 = t1 ? t4 : C.JSNumber_methods.clamp$2(width, t2, t4);
      t2 = height == null;
      t4 = _this.minHeight;
      t5 = t2 ? t4 : C.JSNumber_methods.clamp$2(height, t4, _this.maxHeight);
      t6 = _this.maxHeight;
      return new S.BoxConstraints(t3, t1, t5, t2 ? t6 : C.JSNumber_methods.clamp$2(height, t4, t6));
    },
    tighten$1$width: function(width) {
      return this.tighten$2$height$width(null, width);
    },
    tighten$1$height: function(height) {
      return this.tighten$2$height$width(height, null);
    },
    constrainWidth$1: function(width) {
      H.assertHelper(this.debugAssertIsValid$0());
      return J.clamp$2$n(width, this.minWidth, this.maxWidth);
    },
    constrainWidth$0: function() {
      return this.constrainWidth$1(1 / 0);
    },
    constrainHeight$1: function(height) {
      H.assertHelper(this.debugAssertIsValid$0());
      return J.clamp$2$n(height, this.minHeight, this.maxHeight);
    },
    constrainHeight$0: function() {
      return this.constrainHeight$1(1 / 0);
    },
    _debugPropagateDebugSize$2: function(size, result) {
      var t1 = {};
      t1.result = result;
      H.assertHelper(new S.BoxConstraints__debugPropagateDebugSize_closure(t1, size).call$0());
      return t1.result;
    },
    constrain$1: function(size) {
      var t1 = {};
      t1.result = new P.Size(this.constrainWidth$1(size._dx), this.constrainHeight$1(size._dy));
      H.assertHelper(new S.BoxConstraints_constrain_closure(t1, this, size).call$0());
      return t1.result;
    },
    $mul: function(_, factor) {
      var t2, t3, t4, _this = this,
        t1 = _this.minWidth;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof factor !== "number")
        return H.iae(factor);
      t2 = _this.maxWidth;
      if (typeof t2 !== "number")
        return t2.$mul();
      t3 = _this.minHeight;
      if (typeof t3 !== "number")
        return t3.$mul();
      t4 = _this.maxHeight;
      if (typeof t4 !== "number")
        return t4.$mul();
      return new S.BoxConstraints(t1 * factor, t2 * factor, t3 * factor, t4 * factor);
    },
    get$isNormalized: function() {
      var t2, _this = this,
        t1 = _this.minWidth;
      if (typeof t1 !== "number")
        return t1.$ge();
      if (t1 >= 0) {
        t2 = _this.maxWidth;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (t1 <= t2) {
          t1 = _this.minHeight;
          if (typeof t1 !== "number")
            return t1.$ge();
          if (t1 >= 0) {
            t2 = _this.maxHeight;
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = t1 <= t2;
            t1 = t2;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    debugAssertIsValid$2$informationCollector$isAppliedConstraint: function(informationCollector, isAppliedConstraint) {
      H.assertHelper(new S.BoxConstraints_debugAssertIsValid_closure(this, H.functionTypeCheck(informationCollector, {func: 1, ret: -1, args: [P.StringBuffer]}), isAppliedConstraint).call$0());
      return this.get$isNormalized();
    },
    debugAssertIsValid$0: function() {
      return this.debugAssertIsValid$2$informationCollector$isAppliedConstraint(null, false);
    },
    debugAssertIsValid$1$isAppliedConstraint: function(isAppliedConstraint) {
      return this.debugAssertIsValid$2$informationCollector$isAppliedConstraint(null, isAppliedConstraint);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      H.assertHelper(_this.debugAssertIsValid$0());
      if (_this === other)
        return true;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$isBoxConstraints");
      H.assertHelper(other.debugAssertIsValid$0());
      return _this.minWidth == other.minWidth && _this.maxWidth == other.maxWidth && _this.minHeight == other.minHeight && _this.maxHeight == other.maxHeight;
    },
    get$hashCode: function(_) {
      var _this = this;
      H.assertHelper(_this.debugAssertIsValid$0());
      return P.hashValues(_this.minWidth, _this.maxWidth, _this.minHeight, _this.maxHeight, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t2, width, height, _this = this,
        annotation = _this.get$isNormalized() ? "" : "; NOT NORMALIZED",
        t1 = _this.minWidth;
      if (t1 === 1 / 0 && _this.minHeight === 1 / 0)
        return "BoxConstraints(biggest" + annotation + ")";
      if (t1 === 0 && _this.maxWidth === 1 / 0 && _this.minHeight === 0 && _this.maxHeight === 1 / 0)
        return "BoxConstraints(unconstrained" + annotation + ")";
      t2 = new S.BoxConstraints_toString_describe();
      width = t2.call$3(t1, _this.maxWidth, "w");
      height = t2.call$3(_this.minHeight, _this.maxHeight, "h");
      return "BoxConstraints(" + H.S(width) + ", " + H.S(height) + annotation + ")";
    }
  };
  S.BoxConstraints__debugPropagateDebugSize_closure.prototype = {
    call$0: function() {
      var t2, t3,
        t1 = this.size;
      if (!!t1.$is_DebugSize) {
        t2 = this._box_0;
        t3 = t2.result;
        t2.result = new S._DebugSize(t1._box$_owner, t1._canBeUsedByParent, t3._dx, t3._dy);
      }
      return true;
    },
    $signature: 0
  };
  S.BoxConstraints_constrain_closure.prototype = {
    call$0: function() {
      var t1 = this._box_0;
      t1.result = this.$this._debugPropagateDebugSize$2(this.size, t1.result);
      return true;
    },
    $signature: 0
  };
  S.BoxConstraints_debugAssertIsValid_closure.prototype = {
    call$0: function() {
      var t4, t5, affectedFieldsList, whichFields, t6,
        t1 = this.$this,
        t2 = new S.BoxConstraints_debugAssertIsValid_closure_throwError(t1, this.informationCollector),
        t3 = t1.minWidth;
      t3.toString;
      t4 = isNaN(t3);
      if (!t4) {
        t5 = t1.maxWidth;
        t5.toString;
        if (!isNaN(t5)) {
          t5 = t1.minHeight;
          t5.toString;
          if (!isNaN(t5)) {
            t5 = t1.maxHeight;
            t5.toString;
            t5 = isNaN(t5);
          } else
            t5 = true;
        } else
          t5 = true;
      } else
        t5 = true;
      if (t5) {
        affectedFieldsList = H.setRuntimeTypeInfo([], [P.String]);
        if (t4)
          C.JSArray_methods.add$1(affectedFieldsList, "minWidth");
        t4 = t1.maxWidth;
        t4.toString;
        if (isNaN(t4))
          C.JSArray_methods.add$1(affectedFieldsList, "maxWidth");
        t4 = t1.minHeight;
        t4.toString;
        if (isNaN(t4))
          C.JSArray_methods.add$1(affectedFieldsList, "minHeight");
        t4 = t1.maxHeight;
        t4.toString;
        if (isNaN(t4))
          C.JSArray_methods.add$1(affectedFieldsList, "maxHeight");
        H.assertHelper(affectedFieldsList.length !== 0);
        if (affectedFieldsList.length > 1)
          C.JSArray_methods.add$1(affectedFieldsList, "and " + affectedFieldsList.pop());
        t4 = affectedFieldsList.length;
        if (t4 > 2)
          whichFields = C.JSArray_methods.join$1(affectedFieldsList, ", ");
        else
          whichFields = t4 === 2 ? C.JSArray_methods.join$1(affectedFieldsList, " ") : C.JSArray_methods.get$single(affectedFieldsList);
        t2.call$1("BoxConstraints has " + (affectedFieldsList.length === 1 ? "a NaN value" : "NaN values") + " in " + whichFields + ".");
      }
      if (typeof t3 !== "number")
        return t3.$lt();
      t4 = t3 < 0;
      if (t4) {
        t5 = t1.minHeight;
        if (typeof t5 !== "number")
          return t5.$lt();
        t5 = t5 < 0;
      } else
        t5 = false;
      if (t5)
        t2.call$1("BoxConstraints has both a negative minimum width and a negative minimum height.");
      if (t4)
        t2.call$1("BoxConstraints has a negative minimum width.");
      t4 = t1.minHeight;
      if (typeof t4 !== "number")
        return t4.$lt();
      if (t4 < 0)
        t2.call$1("BoxConstraints has a negative minimum height.");
      t5 = t1.maxWidth;
      if (typeof t5 !== "number")
        return t5.$lt();
      t5 = t5 < t3;
      if (t5) {
        t6 = t1.maxHeight;
        if (typeof t6 !== "number")
          return t6.$lt();
        t6 = t6 < t4;
      } else
        t6 = false;
      if (t6)
        t2.call$1("BoxConstraints has both width and height constraints non-normalized.");
      if (t5)
        t2.call$1("BoxConstraints has non-normalized width constraints.");
      t5 = t1.maxHeight;
      if (typeof t5 !== "number")
        return t5.$lt();
      if (t5 < t4)
        t2.call$1("BoxConstraints has non-normalized height constraints.");
      if (this.isAppliedConstraint) {
        if (t3 == 1 / 0 || t3 == -1 / 0)
          t5 = t4 == 1 / 0 || t4 == -1 / 0;
        else
          t5 = false;
        if (t5)
          t2.call$1("BoxConstraints forces an infinite width and infinite height.");
        if (t3 == 1 / 0 || t3 == -1 / 0)
          t2.call$1("BoxConstraints forces an infinite width.");
        if (t4 == 1 / 0 || t4 == -1 / 0)
          t2.call$1("BoxConstraints forces an infinite height.");
      }
      H.assertHelper(t1.get$isNormalized());
      return true;
    },
    $signature: 0
  };
  S.BoxConstraints_debugAssertIsValid_closure_throwError.prototype = {
    call$1: function(message) {
      var information = new P.StringBuffer(""),
        t1 = this.informationCollector;
      if (t1 != null)
        t1.call$1(information);
      throw H.wrapException(U.FlutterError$(message + "\n" + information.toString$0(0) + "The offending constraints were:\n  " + this.$this.toString$0(0)));
    },
    $signature: 41
  };
  S.BoxConstraints_toString_describe.prototype = {
    call$3: function(min, max, dim) {
      if (min == max)
        return dim + "=" + J.toStringAsFixed$1$n(min, 1);
      return J.toStringAsFixed$1$n(min, 1) + "<=" + dim + "<=" + J.toStringAsFixed$1$n(max, 1);
    },
    $signature: 91
  };
  S.BoxHitTestEntry.prototype = {
    get$target: function(_) {
      return H.interceptedTypeCheck(this.target, "$isRenderBox");
    },
    toString$0: function(_) {
      var t1 = H.interceptedTypeCheck(this.target, "$isRenderBox");
      return J.get$runtimeType$(t1).toString$0(0) + "#" + Y.shortHash(t1) + "@" + H.S(this.localPosition);
    }
  };
  S.BoxParentData.prototype = {
    toString$0: function(_) {
      return "offset=" + this.offset.toString$0(0);
    },
    get$offset: function() {
      return this.offset;
    }
  };
  S.ContainerBoxParentData.prototype = {};
  S._IntrinsicDimensionsCacheEntry.prototype = {};
  S.RenderBox.prototype = {
    setupParentData$1: function(child) {
      if (!(child.parentData instanceof S.BoxParentData))
        child.parentData = new S.BoxParentData(C.Offset_0_0);
    },
    get$size: function() {
      var _this = this;
      if (H.assertTest(_this._size != null))
        H.assertThrow("RenderBox was not laid out: " + _this.toStringShort$0());
      H.assertHelper(new S.RenderBox_size_closure(_this).call$0());
      return _this._size;
    },
    set$size: function(value) {
      var _this = this, t1 = {};
      t1.value = value;
      H.assertHelper(!(_this._debugDoingThisResize && _this._debugDoingThisLayout));
      H.assertHelper(_this.get$sizedByParent() || !_this._debugDoingThisResize);
      H.assertHelper(new S.RenderBox_size_closure0(_this).call$0());
      H.assertHelper(new S.RenderBox_size_closure1(t1, _this).call$0());
      _this._size = t1.value;
      H.assertHelper(new S.RenderBox_size_closure2(_this).call$0());
    },
    debugAdoptSize$1: function(value) {
      var t1 = {};
      t1.result = value;
      H.assertHelper(new S.RenderBox_debugAdoptSize_closure(t1, this, value).call$0());
      return t1.result;
    },
    get$semanticBounds: function() {
      var t1 = this.get$size(),
        t2 = t1._dx;
      t1 = t1._dy;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return new P.Rect(0, 0, 0 + t2, 0 + t1);
    },
    debugResetSize$0: function() {
      this.set$size(this.get$size());
    },
    getDistanceToBaseline$2$onlyReal: function(baseline, onlyReal) {
      var result;
      if (H.assertTest(!$.RenderBox__debugDoingBaseline))
        H.assertThrow("Please see the documentation for computeDistanceToActualBaseline for the required calling conventions of this method.");
      H.assertHelper(!H.boolConversionCheck(this.get$debugNeedsLayout()));
      H.assertHelper(new S.RenderBox_getDistanceToBaseline_closure(this).call$0());
      $.RenderBox__debugDoingBaseline = true;
      result = this.getDistanceToActualBaseline$1(baseline);
      $.RenderBox__debugDoingBaseline = false;
      return result;
    },
    getDistanceToActualBaseline$1: function(baseline) {
      var _this = this;
      if (H.assertTest($.RenderBox__debugDoingBaseline))
        H.assertThrow("Please see the documentation for computeDistanceToActualBaseline for the required calling conventions of this method.");
      if (_this._cachedBaselines == null)
        _this.set$_cachedBaselines(P.LinkedHashMap_LinkedHashMap$_empty(P.TextBaseline, P.double));
      _this._cachedBaselines.putIfAbsent$2(baseline, new S.RenderBox_getDistanceToActualBaseline_closure(_this, baseline));
      return _this._cachedBaselines.$index(0, baseline);
    },
    computeDistanceToActualBaseline$1: function(baseline) {
      if (H.assertTest($.RenderBox__debugDoingBaseline))
        H.assertThrow("Please see the documentation for computeDistanceToActualBaseline for the required calling conventions of this method.");
      return;
    },
    get$constraints: function() {
      return K.RenderObject.prototype.get$constraints.call(this);
    },
    debugAssertDoesMeetConstraints$0: function() {
      H.assertHelper(K.RenderObject.prototype.get$constraints.call(this) != null);
      H.assertHelper(new S.RenderBox_debugAssertDoesMeetConstraints_closure(this).call$0());
    },
    markNeedsLayout$0: function() {
      var _this = this,
        t1 = _this._cachedBaselines;
      if (!(t1 != null && t1.get$isNotEmpty(t1))) {
        t1 = _this._cachedIntrinsicDimensions;
        t1 = t1 != null && t1.get$isNotEmpty(t1);
      } else
        t1 = true;
      if (t1) {
        t1 = _this._cachedBaselines;
        if (t1 != null)
          t1.clear$0(0);
        t1 = _this._cachedIntrinsicDimensions;
        if (t1 != null)
          t1.clear$0(0);
        if (_this._node$_parent instanceof K.RenderObject) {
          _this.markParentNeedsLayout$0();
          return;
        }
      }
      _this.super$RenderObject$markNeedsLayout();
    },
    performResize$0: function() {
      var t2,
        t1 = K.RenderObject.prototype.get$constraints.call(this);
      this.set$size(new P.Size(t1.constrainWidth$1(0), t1.constrainHeight$1(0)));
      t1 = this.get$size();
      t2 = t1._dx;
      t2.toString;
      if (isFinite(t2)) {
        t1 = t1._dy;
        t1.toString;
        t1 = isFinite(t1);
      } else
        t1 = false;
      H.assertHelper(t1);
    },
    performLayout$0: function() {
      H.assertHelper(new S.RenderBox_performLayout_closure(this).call$0());
    },
    hitTest$2$position: function(result, position) {
      var _this = this;
      H.assertHelper(new S.RenderBox_hitTest_closure(_this).call$0());
      if (_this._size.contains$1(0, position))
        if (_this.hitTestChildren$2$position(result, position) || H.boolConversionCheck(_this.hitTestSelf$1(position))) {
          C.JSArray_methods.add$1(result._path, new S.BoxHitTestEntry(position, _this));
          return true;
        }
      return false;
    },
    hitTestSelf$1: function(position) {
      return false;
    },
    hitTestChildren$2$position: function(result, position) {
      return false;
    },
    applyPaintTransform$2: function(child, transform) {
      var offset;
      H.assertHelper(child != null);
      H.assertHelper(child._node$_parent === this);
      H.assertHelper(new S.RenderBox_applyPaintTransform_closure(this, child).call$0());
      offset = H.interceptedTypeCheck(child.parentData, "$isBoxParentData").offset;
      transform.translate$2(offset._dx, offset._dy);
    },
    globalToLocal$1: function(point) {
      var n, t1, i, d, t2, t3, s,
        transform = this.getTransformTo$1(null);
      if (transform.copyInverse$1(transform) === 0)
        return C.Offset_0_0;
      n = new E.Vector3(new Float64Array(3));
      n.setValues$3(0, 0, 1);
      t1 = new E.Vector3(new Float64Array(3));
      t1.setValues$3(0, 0, 0);
      i = transform.perspectiveTransform$1(t1);
      t1 = new E.Vector3(new Float64Array(3));
      t1.setValues$3(0, 0, 1);
      d = transform.perspectiveTransform$1(t1).$sub(0, i);
      t1 = point._dx;
      t2 = point._dy;
      t3 = new E.Vector3(new Float64Array(3));
      t3.setValues$3(t1, t2, 0);
      s = transform.perspectiveTransform$1(t3);
      t3 = s.$sub(0, d.scaled$1(n.dot$1(s) / n.dot$1(d)))._v3storage;
      return new P.Offset(t3[0], t3[1]);
    },
    get$paintBounds: function() {
      var t1 = this.get$size(),
        t2 = t1._dx;
      t1 = t1._dy;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return new P.Rect(0, 0, 0 + t2, 0 + t1);
    },
    handleEvent$2: function($event, entry) {
      this.super$RenderObject$handleEvent($event, H.interceptedTypeCheck(entry, "$isBoxHitTestEntry"));
    },
    debugHandleEvent$2: function($event, entry) {
      H.assertHelper(new S.RenderBox_debugHandleEvent_closure(this, $event).call$0());
      return true;
    },
    debugPaint$2: function(context, offset) {
      H.assertHelper(new S.RenderBox_debugPaint_closure(this, context, offset).call$0());
    },
    debugPaintSize$2: function(context, offset) {
      H.assertHelper(new S.RenderBox_debugPaintSize_closure(this, context, offset).call$0());
    },
    debugPaintBaselines$2: function(context, offset) {
      H.assertHelper(new S.RenderBox_debugPaintBaselines_closure(this, offset, context).call$0());
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$RenderObject$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("size", this._size, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, true, true, true, C.DiagnosticsTreeStyle_5, _null, P.Size);
      C.JSArray_methods.add$1(properties.properties, t1);
    },
    set$_cachedBaselines: function(_cachedBaselines) {
      this._cachedBaselines = H.assertSubtype(_cachedBaselines, "$isMap", [P.TextBaseline, P.double], "$asMap");
    }
  };
  S.RenderBox_size_closure.prototype = {
    call$0: function() {
      var t3,
        t1 = this.$this,
        t2 = t1._size;
      if (t2 instanceof S._DebugSize) {
        H.assertHelper(t2._box$_owner === t1);
        t3 = $.RenderObject__debugActiveLayout;
        if (t3 != null) {
          if (!t1._debugDoingThisResize)
            if (!t1._debugDoingThisLayout)
              t3 = t3 === t1._node$_parent && H.boolConversionCheck(t2._canBeUsedByParent);
            else
              t3 = true;
          else
            t3 = true;
          H.assertHelper(t3);
        }
        H.assertHelper(t2.$eq(0, t1._size));
      }
      return true;
    },
    $signature: 0
  };
  S.RenderBox_size_closure0.prototype = {
    call$0: function() {
      var t2, violation, hint, contract,
        t1 = this.$this;
      if (!(t1.get$sizedByParent() && t1._debugDoingThisResize))
        t2 = !t1.get$sizedByParent() && t1._debugDoingThisLayout;
      else
        t2 = true;
      if (t2)
        return true;
      H.assertHelper(!t1._debugDoingThisResize);
      if (t1._debugDoingThisLayout) {
        H.assertHelper(t1.get$sizedByParent());
        violation = "It appears that the size setter was called from performLayout().";
        hint = "";
      } else {
        hint = H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner") != null && H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner")._debugDoingLayout ? "Only the object itself can set its size. It is a contract violation for other objects to set it." : null;
        violation = "The size setter was called from outside layout (neither performResize() nor performLayout() were being run for this object).";
      }
      contract = t1.get$sizedByParent() ? "Because this RenderBox has sizedByParent set to true, it must set its size in performResize()." : "Because this RenderBox has sizedByParent set to false, it must set its size in performLayout().";
      throw H.wrapException(U.FlutterError$("RenderBox size setter called incorrectly.\n" + violation + "\n" + H.S(hint) + "\n" + contract + "\nThe RenderBox in question is:\n  " + t1.toString$0(0)));
    },
    $signature: 0
  };
  S.RenderBox_size_closure1.prototype = {
    call$0: function() {
      var t1 = this._box_0;
      t1.value = this.$this.debugAdoptSize$1(t1.value);
      return true;
    },
    $signature: 0
  };
  S.RenderBox_size_closure2.prototype = {
    call$0: function() {
      this.$this.debugAssertDoesMeetConstraints$0();
      return true;
    },
    $signature: 0
  };
  S.RenderBox_debugAdoptSize_closure.prototype = {
    call$0: function() {
      var t2, t3, _this = this,
        t1 = _this.value;
      if (t1 instanceof S._DebugSize) {
        t2 = t1._box$_owner;
        t3 = _this.$this;
        if (t2 !== t3) {
          if (t2._node$_parent !== t3)
            throw H.wrapException(U.FlutterError$("The size property was assigned a size inappropriately.\nThe following render object:\n  " + t3.toString$0(0) + "\n...was assigned a size obtained from:\n  " + t2.toString$0(0) + "\nHowever, this second render object is not, or is no longer, a child of the first, and it is therefore a violation of the RenderBox layout protocol to use that size in the layout of the first render object.\nIf the size was obtained at a time where it was valid to read the size (because the second render object above was a child of the first at the time), then it should be adopted using debugAdoptSize at that time.\nIf the size comes from a grandchild or a render object from an entirely different part of the render tree, then there is no way to be notified when the size changes and therefore attempts to read that size are almost certainly a source of bugs. A different approach should be used."));
          if (!H.boolConversionCheck(t1._canBeUsedByParent))
            throw H.wrapException(U.FlutterError$("A child's size was used without setting parentUsesSize.\nThe following render object:\n  " + t3.toString$0(0) + "\n...was assigned a size obtained from its child:\n  " + t2.toString$0(0) + "\nHowever, when the child was laid out, the parentUsesSize argument was not set or set to false. Subsequently this transpired to be inaccurate: the size was nonetheless used by the parent.\nIt is important to tell the framework if the size will be used or not as several important performance optimizations can be made if the size will not be used by the parent."));
        }
      }
      t2 = _this.$this;
      _this._box_0.result = new S._DebugSize(t2, t2._debugCanParentUseSize, t1._dx, t1._dy);
      return true;
    },
    $signature: 0
  };
  S.RenderBox_getDistanceToBaseline_closure.prototype = {
    call$0: function() {
      var t2,
        t1 = this.$this,
        $parent = H.interceptedTypeCheck(t1._node$_parent, "$isRenderObject");
      if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner")._debugDoingLayout)
        return $.RenderObject__debugActiveLayout == $parent && $parent._debugDoingThisLayout;
      if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner")._debugDoingPaint) {
        t2 = $.RenderObject__debugActivePaint;
        if (!(t2 == $parent && $parent._debugDoingThisPaint))
          t1 = t2 === t1 && t1._debugDoingThisPaint;
        else
          t1 = true;
        return t1;
      }
      H.assertHelper($parent == t1._node$_parent);
      return false;
    },
    $signature: 0
  };
  S.RenderBox_getDistanceToActualBaseline_closure.prototype = {
    call$0: function() {
      return this.$this.computeDistanceToActualBaseline$1(this.baseline);
    },
    $signature: 46
  };
  S.RenderBox_debugAssertDoesMeetConstraints_closure.prototype = {
    call$0: function() {
      var t2, t3, information, node0, t4,
        node = this.$this,
        t1 = node._size;
      if (t1 == null) {
        H.assertHelper(!H.boolConversionCheck(node.get$debugNeedsLayout()));
        throw H.wrapException(U.FlutterError$("RenderBox did not set its size during layout.\n" + (node.get$sizedByParent() ? "Because this RenderBox has sizedByParent set to true, it must set its size in performResize().\n" : "Because this RenderBox has sizedByParent set to false, it must set its size in performLayout().\n") + "It appears that this did not happen; layout completed, but the size property is still null.\nThe RenderBox in question is:\n  " + node.toString$0(0)));
      }
      t2 = t1._dx;
      t2.toString;
      if (isFinite(t2)) {
        t3 = t1._dy;
        t3.toString;
        t3 = isFinite(t3);
      } else
        t3 = false;
      if (!t3) {
        information = new P.StringBuffer("");
        t1 = K.RenderObject.prototype.get$constraints.call(node).maxWidth;
        if (typeof t1 !== "number")
          return t1.$lt();
        if (!(t1 < 1 / 0)) {
          node0 = node;
          while (true) {
            t1 = K.RenderObject.prototype.get$constraints.call(node0).maxWidth;
            if (typeof t1 !== "number")
              return t1.$lt();
            if (!(!(t1 < 1 / 0) && node0._node$_parent instanceof S.RenderBox))
              break;
            node0 = H.interceptedTypeCheck(node0._node$_parent, "$isRenderBox");
          }
          t1 = information._contents += "The nearest ancestor providing an unbounded width constraint is:\n";
          information._contents = t1 + "  ";
          information._contents += node0.toStringShallow$1$joiner("\n  ") + "\n";
        }
        t1 = K.RenderObject.prototype.get$constraints.call(node).maxHeight;
        if (typeof t1 !== "number")
          return t1.$lt();
        if (!(t1 < 1 / 0)) {
          node0 = node;
          while (true) {
            t1 = K.RenderObject.prototype.get$constraints.call(node0).maxHeight;
            if (typeof t1 !== "number")
              return t1.$lt();
            if (!(!(t1 < 1 / 0) && node0._node$_parent instanceof S.RenderBox))
              break;
            node0 = H.interceptedTypeCheck(node0._node$_parent, "$isRenderBox");
          }
          t1 = information._contents += "The nearest ancestor providing an unbounded height constraint is:\n";
          information._contents = t1 + "  ";
          information._contents += node0.toStringShallow$1$joiner("\n  ") + "\n";
        }
        throw H.wrapException(U.FlutterError$(H.getRuntimeType(node).toString$0(0) + " object was given an infinite size during layout.\nThis probably means that it is a render object that tries to be as big as possible, but it was put inside another render object that allows its children to pick their own size.\n" + information.toString$0(0) + "The constraints that applied to the " + H.getRuntimeType(node).toString$0(0) + " were:\n  " + H.S(node.get$constraints()) + "\nThe exact size it was given was:\n  " + H.S(node._size) + "\nSee https://flutter.dev/layout/ for more information."));
      }
      t3 = K.RenderObject.prototype.get$constraints.call(node);
      H.assertHelper(t3.debugAssertIsValid$0());
      t4 = t3.minWidth;
      if (typeof t4 !== "number")
        return t4.$le();
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t4 <= t2) {
        t4 = t3.maxWidth;
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (t2 <= t4) {
          t2 = t3.minHeight;
          t1 = t1._dy;
          if (typeof t2 !== "number")
            return t2.$le();
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (t2 <= t1) {
            t2 = t3.maxHeight;
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = t1 <= t2;
            t1 = t2;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      if (!t1)
        throw H.wrapException(U.FlutterError$(H.getRuntimeType(node).toString$0(0) + " does not meet its constraints.\nConstraints: " + H.S(node.get$constraints()) + "\nSize: " + H.S(node._size) + "\nIf you are not writing your own RenderBox subclass, then this is not your fault. Contact support: https://github.com/flutter/flutter/issues/new?template=BUG.md"));
      return true;
    },
    $signature: 0
  };
  S.RenderBox_performLayout_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (!t1.get$sizedByParent())
        throw H.wrapException(U.FlutterError$(H.getRuntimeType(t1).toString$0(0) + " did not implement performLayout().\nRenderBox subclasses need to either override performLayout() to set a size and lay out any children, or, set sizedByParent to true so that performResize() sizes the render object."));
      return true;
    },
    $signature: 0
  };
  S.RenderBox_hitTest_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (t1._size == null) {
        if (H.boolConversionCheck(t1.get$debugNeedsLayout()))
          throw H.wrapException(U.FlutterError$("Cannot hit test a render box that has never been laid out.\nThe hitTest() method was called on this RenderBox:\n  " + t1.toString$0(0) + "\nUnfortunately, this object's geometry is not known at this time, probably because it has never been laid out. This means it cannot be accurately hit-tested. If you are trying to perform a hit test during the layout phase itself, make sure you only hit test nodes that have completed layout (e.g. the node's children, after their layout() method has been called)."));
        throw H.wrapException(U.FlutterError$("Cannot hit test a render box with no size.\nThe hitTest() method was called on this RenderBox:\n  " + t1.toString$0(0) + "\nAlthough this node is not marked as needing layout, its size is not set. A RenderBox object must have an explicit size before it can be hit-tested. Make sure that the RenderBox in question sets its size during layout."));
      }
      return true;
    },
    $signature: 0
  };
  S.RenderBox_applyPaintTransform_closure.prototype = {
    call$0: function() {
      var t2,
        t1 = this.child;
      if (!(t1.parentData instanceof S.BoxParentData)) {
        t2 = this.$this;
        throw H.wrapException(U.FlutterError$(H.getRuntimeType(t2).toString$0(0) + " does not implement applyPaintTransform.\nThe following " + H.getRuntimeType(t2).toString$0(0) + " object:\n  " + t2.toStringShallow$0() + "\n...did not use a BoxParentData class for the parentData field of the following child:\n  " + t1.toStringShallow$0() + "\nThe " + H.getRuntimeType(t2).toString$0(0) + " class inherits from RenderBox. The default applyPaintTransform implementation provided by RenderBox assumes that the children all use BoxParentData objects for their parentData field. Since " + H.getRuntimeType(t2).toString$0(0) + " does not in fact use that ParentData class for its children, it must provide an implementation of applyPaintTransform that supports the specific ParentData subclass used by its children (which apparently is " + J.get$runtimeType$(t1.parentData).toString$0(0) + ")."));
      }
      return true;
    },
    $signature: 0
  };
  S.RenderBox_debugHandleEvent_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  S.RenderBox_debugPaint_closure.prototype = {
    call$0: function() {
      var _this = this;
      if ($.debugPaintSizeEnabled)
        _this.$this.debugPaintSize$2(_this.context, _this.offset);
      if ($.debugPaintBaselinesEnabled)
        _this.$this.debugPaintBaselines$2(_this.context, _this.offset);
      return true;
    },
    $signature: 0
  };
  S.RenderBox_debugPaintSize_closure.prototype = {
    call$0: function() {
      var t1, t2, t3, t4, t5,
        paint = new P.Paint(new DataView(new ArrayBuffer(75)));
      paint.set$style(C.PaintingStyle_1);
      paint.set$strokeWidth(1);
      paint.set$color(C.Color_4278255615);
      t1 = this.context.get$canvas();
      t2 = this.offset;
      t3 = this.$this.get$size();
      t4 = t2._dx;
      t2 = t2._dy;
      t5 = t3._dx;
      t3 = t3._dy;
      if (typeof t4 !== "number")
        return t4.$add();
      if (typeof t5 !== "number")
        return H.iae(t5);
      if (typeof t2 !== "number")
        return t2.$add();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t1.drawRect$2(new P.Rect(t4, t2, t4 + t5, t2 + t3).inflate$1(-0.5), paint);
      return true;
    },
    $signature: 0
  };
  S.RenderBox_debugPaintBaselines_closure.prototype = {
    call$0: function() {
      var t1,
        paint = new P.Paint(new DataView(new ArrayBuffer(75)));
      paint.set$style(C.PaintingStyle_1);
      paint.set$strokeWidth(0.25);
      t1 = this.$this;
      if (t1.getDistanceToBaseline$2$onlyReal(C.TextBaseline_1, true) != null) {
        paint.set$color(C.Color_4294955008);
        H.throwExpression(P.UnimplementedError$(null));
      }
      if (t1.getDistanceToBaseline$2$onlyReal(C.TextBaseline_0, true) != null) {
        paint.set$color(C.Color_4278255360);
        H.throwExpression(P.UnimplementedError$(null));
      }
      return true;
    },
    $signature: 0
  };
  S.RenderBoxContainerDefaultsMixin.prototype = {
    defaultComputeDistanceToFirstActualBaseline$1: function(baseline) {
      var child, t1, childParentData, result;
      H.assertHelper(!H.boolConversionCheck(this.get$debugNeedsLayout()));
      child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = H.getRuntimeTypeArgument(this, "RenderBoxContainerDefaultsMixin", 1); child != null;) {
        childParentData = H.assertSubtypeOfRuntimeType(child.parentData, t1);
        result = child.getDistanceToActualBaseline$1(baseline);
        if (result != null) {
          t1 = childParentData.get$offset()._dy;
          if (typeof t1 !== "number")
            return H.iae(t1);
          return result + t1;
        }
        child = childParentData.get$nextSibling();
      }
      return;
    },
    defaultComputeDistanceToHighestActualBaseline$1: function(baseline) {
      var child, t1, result, childParentData, candidate, t2;
      H.assertHelper(!H.boolConversionCheck(this.get$debugNeedsLayout()));
      child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = H.getRuntimeTypeArgument(this, "RenderBoxContainerDefaultsMixin", 1), result = null; child != null;) {
        childParentData = H.assertSubtypeOfRuntimeType(child.parentData, t1);
        candidate = child.getDistanceToActualBaseline$1(baseline);
        if (candidate != null) {
          t2 = childParentData.get$offset()._dy;
          if (typeof t2 !== "number")
            return H.iae(t2);
          candidate += t2;
          result = result != null ? Math.min(result, candidate) : candidate;
        }
        child = childParentData.get$nextSibling();
      }
      return result;
    },
    defaultHitTestChildren$2$position: function(result, position) {
      var t1, childParentData, t2, t3, t4, t5,
        child = this.ContainerRenderObjectMixin__lastChild;
      for (t1 = H.getRuntimeTypeArgument(this, "RenderBoxContainerDefaultsMixin", 1); child != null;) {
        childParentData = H.assertSubtypeOfRuntimeType(child.parentData, t1);
        t2 = childParentData.get$offset();
        t3 = position._dx;
        t4 = t2._dx;
        if (typeof t3 !== "number")
          return t3.$sub();
        if (typeof t4 !== "number")
          return H.iae(t4);
        t5 = position._dy;
        t2 = t2._dy;
        if (typeof t5 !== "number")
          return t5.$sub();
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (child.hitTest$2$position(result, new P.Offset(t3 - t4, t5 - t2)))
          return true;
        child = childParentData.get$previousSibling();
      }
      return false;
    },
    defaultPaint$2: function(context, offset) {
      var t1, t2, t3, childParentData, t4, t5,
        child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = H.getRuntimeTypeArgument(this, "RenderBoxContainerDefaultsMixin", 1), t2 = offset._dx, t3 = offset._dy; child != null;) {
        childParentData = H.assertSubtypeOfRuntimeType(child.parentData, t1);
        t4 = childParentData.get$offset();
        t5 = t4._dx;
        if (typeof t5 !== "number")
          return t5.$add();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t4 = t4._dy;
        if (typeof t4 !== "number")
          return t4.$add();
        if (typeof t3 !== "number")
          return H.iae(t3);
        context.paintChild$2(child, new P.Offset(t5 + t2, t4 + t3));
        child = childParentData.get$nextSibling();
      }
    }
  };
  S._ContainerBoxParentData_BoxParentData_ContainerParentDataMixin.prototype = {
    detach$0: function() {
      var t1, previousSiblingParentData, nextSiblingParentData, _this = this;
      _this.super$ParentData$detach();
      t1 = _this.ContainerParentDataMixin_previousSibling;
      if (t1 != null) {
        previousSiblingParentData = H.assertSubtype(t1.parentData, "$isContainerParentDataMixin", [H.getRuntimeTypeArgument(_this, "_ContainerBoxParentData_BoxParentData_ContainerParentDataMixin", 0)], "$asContainerParentDataMixin");
        previousSiblingParentData.ContainerParentDataMixin_nextSibling;
        H.assertHelper(false);
        previousSiblingParentData.set$nextSibling(_this.ContainerParentDataMixin_nextSibling);
      }
      t1 = _this.ContainerParentDataMixin_nextSibling;
      if (t1 != null) {
        nextSiblingParentData = H.assertSubtype(t1.parentData, "$isContainerParentDataMixin", [H.getRuntimeTypeArgument(_this, "_ContainerBoxParentData_BoxParentData_ContainerParentDataMixin", 0)], "$asContainerParentDataMixin");
        nextSiblingParentData.ContainerParentDataMixin_previousSibling;
        H.assertHelper(false);
        nextSiblingParentData.set$previousSibling(_this.ContainerParentDataMixin_previousSibling);
      }
      _this.set$previousSibling(null);
      _this.set$nextSibling(null);
    },
    set$previousSibling: function(previousSibling) {
      this.ContainerParentDataMixin_previousSibling = H.assertSubtypeOfRuntimeType(previousSibling, H.getRuntimeTypeArgument(this, "ContainerParentDataMixin", 0));
    },
    set$nextSibling: function(nextSibling) {
      this.ContainerParentDataMixin_nextSibling = H.assertSubtypeOfRuntimeType(nextSibling, H.getRuntimeTypeArgument(this, "ContainerParentDataMixin", 0));
    },
    get$previousSibling: function() {
      return this.ContainerParentDataMixin_previousSibling;
    },
    get$nextSibling: function() {
      return this.ContainerParentDataMixin_nextSibling;
    }
  };
  B.MultiChildLayoutParentData.prototype = {
    toString$0: function(_) {
      return this.super$BoxParentData$toString(0) + "; id=" + H.S(this.id);
    },
    $asContainerParentDataMixin: function() {
      return [S.RenderBox];
    },
    $as_ContainerBoxParentData_BoxParentData_ContainerParentDataMixin: function() {
      return [S.RenderBox];
    }
  };
  B.MultiChildLayoutDelegate.prototype = {
    layoutChild$2: function(childId, constraints) {
      var child = this._idToChild.$index(0, childId);
      H.assertHelper(new B.MultiChildLayoutDelegate_layoutChild_closure(this, child, childId, constraints).call$0());
      child.layout$2$parentUsesSize(constraints, true);
      return child.get$size();
    },
    positionChild$2: function(childId, offset) {
      var child = this._idToChild.$index(0, childId);
      H.assertHelper(new B.MultiChildLayoutDelegate_positionChild_closure(this, child, childId, offset).call$0());
      H.interceptedTypeCheck(child.parentData, "$isMultiChildLayoutParentData").offset = offset;
    },
    _debugDescribeChild$1: function(child) {
      H.interceptedTypeCheck(child, "$isRenderBox");
      return H.S(H.interceptedTypeCheck(child.parentData, "$isMultiChildLayoutParentData").id) + ": " + H.S(child);
    },
    _callPerformLayout$2: function(size, firstChild) {
      var childParentData, t1, child, _this = this, _box_0 = {},
        previousIdToChild = _this._idToChild;
      _box_0.debugPreviousChildrenNeedingLayout = null;
      H.assertHelper(new B.MultiChildLayoutDelegate__callPerformLayout_closure(_box_0, _this).call$0());
      try {
        _this.set$_idToChild(P.LinkedHashMap_LinkedHashMap$_empty(P.Object, S.RenderBox));
        t1 = _box_0.child = firstChild;
        for (; t1 != null; t1 = child) {
          childParentData = H.interceptedTypeCheck(t1.parentData, "$isMultiChildLayoutParentData");
          H.assertHelper(new B.MultiChildLayoutDelegate__callPerformLayout_closure0(_box_0, childParentData).call$0());
          _this._idToChild.$indexSet(0, childParentData.id, _box_0.child);
          H.assertHelper(new B.MultiChildLayoutDelegate__callPerformLayout_closure1(_box_0, _this).call$0());
          child = childParentData.ContainerParentDataMixin_nextSibling;
          _box_0.child = child;
        }
        _this.performLayout$1(size);
        H.assertHelper(new B.MultiChildLayoutDelegate__callPerformLayout_closure2(_this).call$0());
      } finally {
        _this.set$_idToChild(previousIdToChild);
        H.assertHelper(new B.MultiChildLayoutDelegate__callPerformLayout_closure3(_box_0, _this).call$0());
      }
    },
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    },
    set$_idToChild: function(_idToChild) {
      this._idToChild = H.assertSubtype(_idToChild, "$isMap", [P.Object, S.RenderBox], "$asMap");
    },
    set$_debugChildrenNeedingLayout: function(_debugChildrenNeedingLayout) {
      this._debugChildrenNeedingLayout = H.assertSubtype(_debugChildrenNeedingLayout, "$isSet", [S.RenderBox], "$asSet");
    }
  };
  B.MultiChildLayoutDelegate_layoutChild_closure.prototype = {
    call$0: function() {
      var exception, t2, exception0, _this = this,
        t1 = _this.child;
      if (t1 == null)
        throw H.wrapException(U.FlutterError$("The " + _this.$this.toString$0(0) + ' custom multichild layout delegate tried to lay out a non-existent child.\nThere is no child with the id "' + _this.childId.toString$0(0) + '".'));
      t2 = _this.$this;
      if (!t2._debugChildrenNeedingLayout.remove$1(0, t1))
        throw H.wrapException(U.FlutterError$("The " + t2.toString$0(0) + ' custom multichild layout delegate tried to lay out the child with id "' + _this.childId.toString$0(0) + '" more than once.\nEach child must be laid out exactly once.'));
      try {
        H.assertHelper(_this.constraints.debugAssertIsValid$1$isAppliedConstraint(true));
      } catch (exception0) {
        t1 = H.unwrapException(exception0);
        if (!!J.getInterceptor$(t1).$isAssertionError) {
          exception = t1;
          throw H.wrapException(U.FlutterError$("The " + t2.toString$0(0) + ' custom multichild layout delegate provided invalid box constraints for the child with id "' + _this.childId.toString$0(0) + '".\n' + H.S(exception) + "\nThe minimum width and height must be greater than or equal to zero.\nThe maximum width must be greater than or equal to the minimum width.\nThe maximum height must be greater than or equal to the minimum height."));
        } else
          throw exception0;
      }
      return true;
    },
    $signature: 0
  };
  B.MultiChildLayoutDelegate_positionChild_closure.prototype = {
    call$0: function() {
      if (this.child == null)
        throw H.wrapException(U.FlutterError$("The " + this.$this.toString$0(0) + ' custom multichild layout delegate tried to position out a non-existent child:\nThere is no child with the id "' + this.childId.toString$0(0) + '".'));
      return true;
    },
    $signature: 0
  };
  B.MultiChildLayoutDelegate__callPerformLayout_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      this._box_0.debugPreviousChildrenNeedingLayout = t1._debugChildrenNeedingLayout;
      t1.set$_debugChildrenNeedingLayout(P.LinkedHashSet_LinkedHashSet$_empty(S.RenderBox));
      return true;
    },
    $signature: 0
  };
  B.MultiChildLayoutDelegate__callPerformLayout_closure0.prototype = {
    call$0: function() {
      if (this.childParentData.id == null)
        throw H.wrapException(U.FlutterError$("The following child has no ID:\n  " + H.S(this._box_0.child) + "\nEvery child of a RenderCustomMultiChildLayoutBox must have an ID in its parent data."));
      return true;
    },
    $signature: 0
  };
  B.MultiChildLayoutDelegate__callPerformLayout_closure1.prototype = {
    call$0: function() {
      this.$this._debugChildrenNeedingLayout.add$1(0, this._box_0.child);
      return true;
    },
    $signature: 0
  };
  B.MultiChildLayoutDelegate__callPerformLayout_closure2.prototype = {
    call$0: function() {
      var t3,
        _s42_ = "\nEach child must be laid out exactly once.",
        t1 = this.$this,
        t2 = t1._debugChildrenNeedingLayout._collection$_length;
      if (t2 !== 0)
        if (t2 > 1)
          throw H.wrapException(U.FlutterError$("The " + t1.toString$0(0) + " custom multichild layout delegate forgot to lay out the following children:\n  " + t1._debugChildrenNeedingLayout.map$1$1(0, t1.get$_debugDescribeChild(), P.String).join$1(0, "\n  ") + _s42_));
        else {
          t2 = "The " + t1.toString$0(0) + " custom multichild layout delegate forgot to lay out the following child:\n  ";
          t3 = t1._debugChildrenNeedingLayout;
          throw H.wrapException(U.FlutterError$(t2 + t1._debugDescribeChild$1(t3.get$single(t3)) + _s42_));
        }
      return true;
    },
    $signature: 0
  };
  B.MultiChildLayoutDelegate__callPerformLayout_closure3.prototype = {
    call$0: function() {
      this.$this.set$_debugChildrenNeedingLayout(this._box_0.debugPreviousChildrenNeedingLayout);
      return true;
    },
    $signature: 0
  };
  B.RenderCustomMultiChildLayoutBox.prototype = {
    setupParentData$1: function(child) {
      H.interceptedTypeCheck(child, "$isRenderBox");
      if (!(child.parentData instanceof B.MultiChildLayoutParentData))
        child.parentData = new B.MultiChildLayoutParentData(null, null, C.Offset_0_0);
    },
    set$delegate: function(value) {
      var _this = this;
      if (_this._custom_layout$_delegate === value)
        return;
      if (!new H.TypeImpl(H.getRti(value)).$eq(0, new H.TypeImpl(H.getRti(_this._custom_layout$_delegate))) || value.shouldRelayout$1(_this._custom_layout$_delegate))
        _this.markNeedsLayout$0();
      _this._custom_layout$_delegate = value;
    },
    _getSize$1: function(constraints) {
      H.assertHelper(constraints.debugAssertIsValid$0());
      return constraints.constrain$1(new P.Size(constraints.constrainWidth$0(), constraints.constrainHeight$0()));
    },
    performLayout$0: function() {
      var _this = this;
      _this.set$size(_this._getSize$1(K.RenderObject.prototype.get$constraints.call(_this)));
      _this._custom_layout$_delegate._callPerformLayout$2(_this.get$size(), _this.ContainerRenderObjectMixin__firstChild);
    },
    paint$2: function(context, offset) {
      this.defaultPaint$2(context, offset);
    },
    hitTestChildren$2$position: function(result, position) {
      return this.defaultHitTestChildren$2$position(result, position);
    },
    $asRenderBoxContainerDefaultsMixin: function() {
      return [S.RenderBox, B.MultiChildLayoutParentData];
    },
    $asContainerRenderObjectMixin: function() {
      return [S.RenderBox, B.MultiChildLayoutParentData];
    }
  };
  B._RenderCustomMultiChildLayoutBox_RenderBox_ContainerRenderObjectMixin.prototype = {
    attach$1: function(owner) {
      var child;
      H.interceptedTypeCheck(owner, "$isPipelineOwner");
      this.super$RenderObject$attach(owner);
      child = this.ContainerRenderObjectMixin__firstChild;
      for (; child != null;) {
        child.attach$1(owner);
        child = H.interceptedTypeCheck(child.parentData, "$isMultiChildLayoutParentData").ContainerParentDataMixin_nextSibling;
      }
    },
    detach$0: function() {
      this.super$AbstractNode$detach();
      var child = this.ContainerRenderObjectMixin__firstChild;
      for (; child != null;) {
        child.detach$0();
        child = H.interceptedTypeCheck(child.parentData, "$isMultiChildLayoutParentData").ContainerParentDataMixin_nextSibling;
      }
    },
    set$_firstChild: function(_firstChild) {
      this.ContainerRenderObjectMixin__firstChild = H.assertSubtypeOfRuntimeType(_firstChild, H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 0));
    },
    set$_lastChild: function(_lastChild) {
      this.ContainerRenderObjectMixin__lastChild = H.assertSubtypeOfRuntimeType(_lastChild, H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 0));
    }
  };
  B._RenderCustomMultiChildLayoutBox_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin.prototype = {};
  V.CustomPainter.prototype = {
    addListener$1: function(listener) {
      H.functionTypeCheck(listener, {func: 1, ret: -1});
      return;
    },
    removeListener$1: function(listener) {
      H.functionTypeCheck(listener, {func: 1, ret: -1});
      return;
    },
    hitTest$1: function(position) {
      return;
    },
    toString$0: function(_) {
      var t1 = this.get$runtimeType(this).toString$0(0) + "#" + Y.shortHash(this);
      t1 + "(";
      return t1 + "()";
    }
  };
  V.CustomPainterSemantics.prototype = {};
  V.RenderCustomPaint.prototype = {
    set$painter: function(value) {
      var t1 = this._custom_paint$_painter;
      if (t1 == value)
        return;
      this._custom_paint$_painter = value;
      this._didUpdatePainter$2(value, t1);
    },
    set$foregroundPainter: function(value) {
      var t1 = this._foregroundPainter;
      if (t1 == value)
        return;
      this._foregroundPainter = value;
      this._didUpdatePainter$2(value, t1);
    },
    _didUpdatePainter$2: function(newPainter, oldPainter) {
      var _this = this,
        t1 = newPainter == null;
      if (t1) {
        H.assertHelper(oldPainter != null);
        _this.markNeedsPaint$0();
      } else if (oldPainter == null || !new H.TypeImpl(H.getRti(newPainter)).$eq(0, new H.TypeImpl(H.getRti(oldPainter))) || newPainter.shouldRepaint$1(oldPainter))
        _this.markNeedsPaint$0();
      if (_this._node$_owner != null) {
        if (oldPainter != null)
          oldPainter.removeListener$1(_this.get$markNeedsPaint());
        if (!t1)
          newPainter.addListener$1(_this.get$markNeedsPaint());
      }
      if (t1) {
        H.assertHelper(oldPainter != null);
        if (_this._node$_owner != null)
          _this.markNeedsSemanticsUpdate$0();
      } else if (oldPainter == null || !new H.TypeImpl(H.getRti(newPainter)).$eq(0, new H.TypeImpl(H.getRti(oldPainter))) || newPainter.shouldRepaint$1(oldPainter))
        _this.markNeedsSemanticsUpdate$0();
    },
    set$preferredSize: function(value) {
      if (this._preferredSize.$eq(0, value))
        return;
      this._preferredSize = value;
      this.markNeedsLayout$0();
    },
    attach$1: function(owner) {
      var t1, _this = this;
      _this.super$_RenderProxyBox_RenderBox_RenderObjectWithChildMixin$attach(H.interceptedTypeCheck(owner, "$isPipelineOwner"));
      t1 = _this._custom_paint$_painter;
      if (t1 != null)
        t1.addListener$1(_this.get$markNeedsPaint());
      t1 = _this._foregroundPainter;
      if (t1 != null)
        t1.addListener$1(_this.get$markNeedsPaint());
    },
    detach$0: function() {
      var _this = this,
        t1 = _this._custom_paint$_painter;
      if (t1 != null)
        t1.removeListener$1(_this.get$markNeedsPaint());
      t1 = _this._foregroundPainter;
      if (t1 != null)
        t1.removeListener$1(_this.get$markNeedsPaint());
      _this.super$_RenderProxyBox_RenderBox_RenderObjectWithChildMixin$detach();
    },
    hitTestChildren$2$position: function(result, position) {
      var t1 = this._foregroundPainter;
      if (t1 != null) {
        t1 = t1.hitTest$1(position);
        t1 = t1 === true;
      } else
        t1 = false;
      if (t1)
        return true;
      return this.super$RenderProxyBoxMixin$hitTestChildren(result, position);
    },
    hitTestSelf$1: function(position) {
      var t1;
      if (this._custom_paint$_painter != null)
        t1 = true;
      else
        t1 = false;
      return t1;
    },
    performResize$0: function() {
      var _this = this;
      _this.set$size(K.RenderObject.prototype.get$constraints.call(_this).constrain$1(_this._preferredSize));
      _this.markNeedsSemanticsUpdate$0();
    },
    _paintWithPainter$3: function(canvas, offset, painter) {
      var t1 = {};
      t1.debugPreviousCanvasSaveCount = null;
      canvas.save$0();
      H.assertHelper(new V.RenderCustomPaint__paintWithPainter_closure(t1, canvas).call$0());
      if (!offset.$eq(0, C.Offset_0_0))
        canvas.translate$2(offset._dx, offset._dy);
      painter.paint$2(canvas, this.get$size());
      H.assertHelper(new V.RenderCustomPaint__paintWithPainter_closure0(t1, canvas, painter).call$0());
      canvas.restore$0();
    },
    paint$2: function(context, offset) {
      var _this = this;
      if (_this._custom_paint$_painter != null) {
        _this._paintWithPainter$3(context.get$canvas(), offset, _this._custom_paint$_painter);
        _this._setRasterCacheHints$1(context);
      }
      _this.super$RenderProxyBoxMixin$paint(context, offset);
      if (_this._foregroundPainter != null) {
        _this._paintWithPainter$3(context.get$canvas(), offset, _this._foregroundPainter);
        _this._setRasterCacheHints$1(context);
      }
    },
    _setRasterCacheHints$1: function(context) {
    },
    describeSemanticsConfiguration$1: function(config) {
      this.super$RenderObject$describeSemanticsConfiguration(config);
      this.set$_backgroundSemanticsBuilder(null);
      this.set$_foregroundSemanticsBuilder(null);
      H.assertHelper(!config._isMergingSemanticsOfDescendants || false);
      config._isSemanticBoundary = false;
    },
    assembleSemanticsNode$3: function(node, config, children) {
      var t2, hasBackgroundSemantics, hasForegroundSemantics, finalChildren, _this = this,
        t1 = A.SemanticsNode;
      H.assertSubtype(children, "$isIterable", [t1], "$asIterable");
      H.assertHelper(new V.RenderCustomPaint_assembleSemanticsNode_closure(_this, children).call$0());
      _this.set$_backgroundSemanticsNodes(V.RenderCustomPaint__updateSemanticsChildren(_this._backgroundSemanticsNodes, C.List_empty3));
      _this.set$_foregroundSemanticsNodes(V.RenderCustomPaint__updateSemanticsChildren(_this._foregroundSemanticsNodes, C.List_empty3));
      t2 = _this._backgroundSemanticsNodes;
      hasBackgroundSemantics = t2 != null && t2.length !== 0;
      t2 = _this._foregroundSemanticsNodes;
      hasForegroundSemantics = t2 != null && t2.length !== 0;
      finalChildren = H.setRuntimeTypeInfo([], [t1]);
      if (hasBackgroundSemantics)
        C.JSArray_methods.addAll$1(finalChildren, _this._backgroundSemanticsNodes);
      C.JSArray_methods.addAll$1(finalChildren, children);
      if (hasForegroundSemantics)
        C.JSArray_methods.addAll$1(finalChildren, _this._foregroundSemanticsNodes);
      _this.super$RenderObject$assembleSemanticsNode(node, config, finalChildren);
    },
    clearSemantics$0: function() {
      this.super$RenderObject$clearSemantics();
      this.set$_backgroundSemanticsNodes(null);
      this.set$_foregroundSemanticsNodes(null);
    },
    set$_backgroundSemanticsBuilder: function(_backgroundSemanticsBuilder) {
      this._backgroundSemanticsBuilder = H.functionTypeCheck(_backgroundSemanticsBuilder, {func: 1, ret: [P.List, V.CustomPainterSemantics], args: [P.Size]});
    },
    set$_foregroundSemanticsBuilder: function(_foregroundSemanticsBuilder) {
      this._foregroundSemanticsBuilder = H.functionTypeCheck(_foregroundSemanticsBuilder, {func: 1, ret: [P.List, V.CustomPainterSemantics], args: [P.Size]});
    },
    set$_backgroundSemanticsNodes: function(_backgroundSemanticsNodes) {
      this._backgroundSemanticsNodes = H.assertSubtype(_backgroundSemanticsNodes, "$isList", [A.SemanticsNode], "$asList");
    },
    set$_foregroundSemanticsNodes: function(_foregroundSemanticsNodes) {
      this._foregroundSemanticsNodes = H.assertSubtype(_foregroundSemanticsNodes, "$isList", [A.SemanticsNode], "$asList");
    }
  };
  V.RenderCustomPaint__paintWithPainter_closure.prototype = {
    call$0: function() {
      this._box_0.debugPreviousCanvasSaveCount = this.canvas.getSaveCount$0();
      return true;
    },
    $signature: 0
  };
  V.RenderCustomPaint__paintWithPainter_closure0.prototype = {
    call$0: function() {
      var t2, _this = this,
        debugNewCanvasSaveCount = _this.canvas.getSaveCount$0(),
        t1 = _this._box_0;
      if (debugNewCanvasSaveCount.$gt(0, t1.debugPreviousCanvasSaveCount)) {
        t2 = "The " + _this.painter.toString$0(0) + " custom painter called canvas.save() or canvas.saveLayer() at least " + H.S(debugNewCanvasSaveCount.$sub(0, t1.debugPreviousCanvasSaveCount));
        debugNewCanvasSaveCount.$sub(0, t1.debugPreviousCanvasSaveCount);
        throw H.wrapException(U.FlutterError$(t2 + " more times than it called canvas.restore().\nThis leaves the canvas in an inconsistent state and will probably result in a broken display.\nYou must pair each call to save()/saveLayer() with a later matching call to restore()."));
      }
      if (debugNewCanvasSaveCount.$lt(0, t1.debugPreviousCanvasSaveCount)) {
        t2 = "The " + _this.painter.toString$0(0) + " custom painter called canvas.restore() " + H.S(C.JSNull_methods.$sub(t1.debugPreviousCanvasSaveCount, debugNewCanvasSaveCount));
        C.JSNull_methods.$sub(t1.debugPreviousCanvasSaveCount, debugNewCanvasSaveCount);
        throw H.wrapException(U.FlutterError$(t2 + " more times than it called canvas.save() or canvas.saveLayer().\nThis leaves the canvas in an inconsistent state and will result in a broken display.\nYou should only call restore() if you first called save() or saveLayer()."));
      }
      return false;
    },
    $signature: 0
  };
  V.RenderCustomPaint_assembleSemanticsNode_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (t1.RenderObjectWithChildMixin__child == null && this.children.length !== 0)
        throw H.wrapException(U.FlutterError$(H.getRuntimeType(t1).toString$0(0) + " does not have a child widget but received a non-empty list of child SemanticsNode:\n" + C.JSArray_methods.join$1(this.children, "\n")));
      return true;
    },
    $signature: 0
  };
  V.RenderCustomPaint__updateSemanticsChildren_closure.prototype = {
    call$0: function() {
      var t1, i, child,
        keys = P.HashMap_HashMap(D.Key, P.int),
        errors = new P.StringBuffer("");
      for (t1 = this._box_0, i = 0; i < J.get$length$asx(t1.newChildSemantics); ++i) {
        child = J.$index$asx(t1.newChildSemantics, i);
        child.get$key();
        if (keys.containsKey$1(child.get$key()))
          errors._contents += "- duplicate key " + H.S(child.get$key()) + " found at position " + i + "\n";
        keys.$indexSet(0, child.get$key(), i);
      }
      if (errors._contents.length !== 0)
        throw H.wrapException(U.FlutterError$("Failed to update the list of CustomPainterSemantics:\n" + errors.toString$0(0)));
      return true;
    },
    $signature: 0
  };
  V.RenderCustomPaint__updateSemanticsChildren_closure0.prototype = {
    call$0: function() {
      var t1, t2, _i;
      for (t1 = this.newChildren, t2 = t1.length, _i = 0; _i < t2; ++_i)
        H.assertHelper(t1[_i] != null);
      return true;
    },
    $signature: 0
  };
  E.debugPaintPadding_closure.prototype = {
    call$0: function() {
      var t2, t3, paint, _this = this,
        t1 = _this.innerRect;
      if (t1 != null && !t1.get$isEmpty(t1)) {
        t2 = _this.canvas;
        t3 = _this.outerRect;
        E._debugDrawDoubleRect(t2, t3, t1, C.Color_2415956223);
        E._debugDrawDoubleRect(t2, t1.inflate$1(_this.outlineWidth).intersect$1(t3), t1, C.Color_4278227199);
      } else {
        paint = new P.Paint(new DataView(new ArrayBuffer(75)));
        paint.set$color(C.Color_2425393296);
        _this.canvas.drawRect$2(_this.outerRect, paint);
      }
      return true;
    },
    $signature: 0
  };
  T._OverflowSide.prototype = {
    toString$0: function(_) {
      return this._debug_overflow_indicator$_name;
    }
  };
  T._OverflowRegionData.prototype = {};
  T.DebugOverflowIndicatorMixin.prototype = {
    _formatPixels$1: function(value) {
      var pixels;
      if (typeof value !== "number")
        return value.$gt();
      H.assertHelper(value > 0);
      if (value > 10)
        pixels = C.JSNumber_methods.toStringAsFixed$1(value, 0);
      else
        pixels = value > 1 ? C.JSNumber_methods.toStringAsFixed$1(value, 1) : C.JSNumber_methods.toStringAsPrecision$1(value, 3);
      return pixels;
    },
    _reportOverflow$2: function(overflow, overflowHints) {
      var overflows, t1, overflowText, t2, _this = this, _box_0 = {};
      _box_0.overflowHints = overflowHints;
      overflows = H.setRuntimeTypeInfo([], [P.String]);
      t1 = overflow.left;
      if (typeof t1 !== "number")
        return t1.$gt();
      if (t1 > 0)
        C.JSArray_methods.add$1(overflows, _this._formatPixels$1(t1) + " pixels on the left");
      t1 = overflow.top;
      if (typeof t1 !== "number")
        return t1.$gt();
      if (t1 > 0)
        C.JSArray_methods.add$1(overflows, _this._formatPixels$1(t1) + " pixels on the top");
      t1 = overflow.bottom;
      if (t1 > 0)
        C.JSArray_methods.add$1(overflows, _this._formatPixels$1(t1) + " pixels on the bottom");
      t1 = overflow.right;
      if (t1 > 0)
        C.JSArray_methods.add$1(overflows, _this._formatPixels$1(t1) + " pixels on the right");
      if (H.assertTest(overflows.length !== 0))
        H.assertThrow("Somehow " + new H.TypeImpl(H.getRti(_this)).toString$0(0) + " didn't actually overflow like it thought it did.");
      t1 = overflows.length;
      switch (t1) {
        case 1:
          overflowText = C.JSArray_methods.get$first(overflows);
          break;
        case 2:
          overflowText = C.JSArray_methods.get$first(overflows) + " and " + C.JSArray_methods.get$last(overflows);
          break;
        default:
          t2 = t1 - 1;
          if (t2 < 0)
            return H.ioore(overflows, t2);
          C.JSArray_methods.$indexSet(overflows, t2, "and " + overflows[t2]);
          overflowText = C.JSArray_methods.join$1(overflows, ", ");
      }
      U.FlutterError_reportError(K.FlutterErrorDetailsForRendering$("during layout", "A " + new H.TypeImpl(H.getRti(_this)).toString$0(0) + " overflowed by " + overflowText + ".", new T.DebugOverflowIndicatorMixin__reportOverflow_closure(_box_0, _this), "rendering library", _this, null));
    },
    paintOverflowIndicator$5$overflowHints: function(context, offset, containerRect, childRect, overflowHints) {
      var t3, t4, t5, t6, t7, t8, overflow, regions, _i, region, t9, _this = this,
        t1 = containerRect.left,
        t2 = childRect.left;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = containerRect.top;
      t4 = childRect.top;
      if (typeof t3 !== "number")
        return t3.$sub();
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = childRect.right;
      t6 = containerRect.right;
      if (typeof t5 !== "number")
        return t5.$sub();
      if (typeof t6 !== "number")
        return H.iae(t6);
      t7 = childRect.bottom;
      t8 = containerRect.bottom;
      if (typeof t7 !== "number")
        return t7.$sub();
      if (typeof t8 !== "number")
        return H.iae(t8);
      overflow = K.RelativeRect$fromLTRB(t1 - t2, t3 - t4, t5 - t6, t7 - t8);
      t2 = overflow.left;
      if (typeof t2 !== "number")
        return t2.$le();
      if (t2 <= 0)
        if (overflow.right <= 0) {
          t4 = overflow.top;
          if (typeof t4 !== "number")
            return t4.$le();
          t4 = t4 <= 0 && overflow.bottom <= 0;
        } else
          t4 = false;
      else
        t4 = false;
      if (t4)
        return;
      regions = H.setRuntimeTypeInfo([], [T._OverflowRegionData]);
      if (t2 > 0) {
        t4 = 0 + (t8 - t3);
        C.JSArray_methods.add$1(regions, new T._OverflowRegionData(new P.Rect(0, 0, 0 + (t6 - t1) * 0.1, t4), "LEFT OVERFLOWED BY " + _this._formatPixels$1(t2) + " PIXELS", new P.Offset(0, 0 + (t4 - 0) / 2).$add(0, C.Offset_YLH), 1.5707963267948966, C._OverflowSide_0));
      }
      t2 = overflow.right;
      if (t2 > 0) {
        t4 = t6 - t1;
        t5 = t4 * 0.9;
        t4 = t5 + t4 * 0.1;
        t7 = 0 + (t8 - t3);
        C.JSArray_methods.add$1(regions, new T._OverflowRegionData(new P.Rect(t5, 0, t4, t7), "RIGHT OVERFLOWED BY " + _this._formatPixels$1(t2) + " PIXELS", new P.Offset(t4, 0 + (t7 - 0) / 2).$sub(0, C.Offset_YLH), -1.5707963267948966, C._OverflowSide_3));
      }
      t2 = overflow.top;
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t4 = 0 + (t6 - t1);
        C.JSArray_methods.add$1(regions, new T._OverflowRegionData(new P.Rect(0, 0, t4, 0 + (t8 - t3) * 0.1), "TOP OVERFLOWED BY " + _this._formatPixels$1(t2) + " PIXELS", new P.Offset(0 + (t4 - 0) / 2, 0).$add(0, C.Offset_0_1), 0, C._OverflowSide_1));
      }
      t2 = overflow.bottom;
      if (t2 > 0) {
        t3 = t8 - t3;
        t4 = t3 * 0.9;
        t1 = 0 + (t6 - t1);
        t3 = t4 + t3 * 0.1;
        C.JSArray_methods.add$1(regions, new T._OverflowRegionData(new P.Rect(0, t4, t1, t3), "BOTTOM OVERFLOWED BY " + _this._formatPixels$1(t2) + " PIXELS", new P.Offset(0 + (t1 - 0) / 2, t3).$sub(0, C.Offset_cMC), 0, C._OverflowSide_2));
      }
      for (t1 = regions.length, t2 = offset._dx, t3 = offset._dy, t4 = _this.DebugOverflowIndicatorMixin__indicatorLabel, t5 = t4.length, _i = 0; _i < regions.length; regions.length === t1 || (0, H.throwConcurrentModificationError)(regions), ++_i) {
        region = regions[_i];
        context.get$canvas().drawRect$2(region.rect.shift$1(offset), $.$get$DebugOverflowIndicatorMixin__indicatorPaint());
        t6 = region.side.index;
        if (t6 >= t5)
          return H.ioore(t4, t6);
        t7 = t4[t6];
        t8 = t7._text;
        t8 = t8 == null ? null : t8.text;
        t9 = region.label;
        if (t8 !== t9) {
          t7.set$text(new Q.TextSpan(C.TextStyle_a56, t9, null));
          t4[t6].layout$0();
        }
        t7 = region.labelOffset;
        t8 = t7._dx;
        if (typeof t8 !== "number")
          return t8.$add();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t7 = t7._dy;
        if (typeof t7 !== "number")
          return t7.$add();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t4[t6].get$width().$negate(0).$div(0, 2);
      }
      if (_this.DebugOverflowIndicatorMixin__overflowReportNeeded) {
        _this.DebugOverflowIndicatorMixin__overflowReportNeeded = false;
        _this._reportOverflow$2(overflow, overflowHints);
      }
    }
  };
  T.DebugOverflowIndicatorMixin__reportOverflow_closure.prototype = {
    call$1: function(information) {
      var t1;
      information._contents += H.S(this._box_0.overflowHints) + "\n";
      t1 = this.$this;
      information._contents += "The specific " + new H.TypeImpl(H.getRti(t1)).toString$0(0) + " in question is:\n";
      information._contents += "  " + t1.toStringShallow$1$joiner("\n  ") + "\n";
      information._contents += C.JSString_methods.$mul("\u25e2\u25e4", 50) + "\n";
    },
    $signature: 3
  };
  V.RenderErrorBox.prototype = {
    RenderErrorBox$1: function(message) {
      var builder, exception;
      try {
        if (this.message !== "") {
          $.$get$RenderErrorBox_paragraphStyle();
          builder = new P.ParagraphBuilder();
          builder.pushStyle$1($.$get$RenderErrorBox_textStyle());
        }
      } catch (exception) {
        H.unwrapException(exception);
      }
    },
    get$sizedByParent: function() {
      return true;
    },
    hitTestSelf$1: function(position) {
      return true;
    },
    performResize$0: function() {
      this.set$size(K.RenderObject.prototype.get$constraints.call(this).constrain$1(C.Size_100000_100000));
    },
    paint$2: function(context, offset) {
      var width, t1, t2, t3, t4, t5, t6, exception;
      try {
        t1 = context.get$canvas();
        t2 = this.get$size();
        t3 = offset._dx;
        t4 = offset._dy;
        t5 = t2._dx;
        t2 = t2._dy;
        if (typeof t3 !== "number")
          return t3.$add();
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (typeof t4 !== "number")
          return t4.$add();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t6 = new P.Paint(new DataView(new ArrayBuffer(75)));
        t6.set$color(C.Color_4035969024);
        t1.drawRect$2(new P.Rect(t3, t4, t3 + t5, t4 + t2), t6);
        width = null;
      } catch (exception) {
        H.unwrapException(exception);
      }
    }
  };
  F._RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin_DebugOverflowIndicatorMixin_reassemble_closure.prototype = {
    call$0: function() {
      return this.$this.DebugOverflowIndicatorMixin__overflowReportNeeded = true;
    },
    $signature: 0
  };
  F.FlexFit.prototype = {
    toString$0: function(_) {
      return this._flex$_name;
    }
  };
  F.FlexParentData.prototype = {
    toString$0: function(_) {
      return this.super$BoxParentData$toString(0) + "; flex=" + H.S(this.flex) + "; fit=" + H.S(this.fit);
    },
    $asContainerParentDataMixin: function() {
      return [S.RenderBox];
    },
    $as_ContainerBoxParentData_BoxParentData_ContainerParentDataMixin: function() {
      return [S.RenderBox];
    }
  };
  F.MainAxisSize.prototype = {
    toString$0: function(_) {
      return this._flex$_name;
    }
  };
  F.MainAxisAlignment.prototype = {
    toString$0: function(_) {
      return this._flex$_name;
    }
  };
  F.CrossAxisAlignment.prototype = {
    toString$0: function(_) {
      return this._flex$_name;
    }
  };
  F.RenderFlex.prototype = {
    setupParentData$1: function(child) {
      H.interceptedTypeCheck(child, "$isRenderBox");
      if (!(child.parentData instanceof F.FlexParentData))
        child.parentData = new F.FlexParentData(null, null, C.Offset_0_0);
    },
    computeDistanceToActualBaseline$1: function(baseline) {
      if (this._flex$_direction === C.Axis_0)
        return this.defaultComputeDistanceToHighestActualBaseline$1(baseline);
      return this.defaultComputeDistanceToFirstActualBaseline$1(baseline);
    },
    _getFit$1: function(child) {
      var t1 = H.interceptedTypeCheck(child.parentData, "$isFlexParentData").fit;
      return t1 == null ? C.FlexFit_0 : t1;
    },
    _getCrossSize$1: function(child) {
      switch (this._flex$_direction) {
        case C.Axis_0:
          return child.get$size()._dy;
        case C.Axis_1:
          return child.get$size()._dx;
      }
      return;
    },
    _getMainSize$1: function(child) {
      switch (this._flex$_direction) {
        case C.Axis_0:
          return child.get$size()._dx;
        case C.Axis_1:
          return child.get$size()._dy;
      }
      return;
    },
    performLayout$0: function() {
      var maxMainSize, canFlex, lastFlexChild, totalFlex, totalChildren, crossSize, allocatedSize, childParentData, flex, innerConstraints, child, freeSpace, spacePerFlex, allocatedFlexSpace, maxBaselineDistance, maxSizeAboveBaseline, maxSizeBelowBaseline, maxChildExtent, minChildExtent, childSize, distance, idealSize, actualSize, actualSizeDelta, remainingSpace, flipMainAxis, leadingSpace, betweenSpace, childMainPosition, t2, childCrossPosition, _this = this, _null = null,
        _s63_ = " has a null textDirection, so the alignment cannot be resolved.",
        _box_0 = {},
        t1 = _this.ContainerRenderObjectMixin__firstChild;
      if (t1 != null && _this.ContainerRenderObjectMixin__lastChild !== t1)
        switch (_this._flex$_direction) {
          case C.Axis_0:
            if (H.assertTest(_this._flex$_textDirection != null))
              H.assertThrow("Horizontal " + new H.TypeImpl(H.getRti(_this)).toString$0(0) + " with multiple children has a null textDirection, so the layout order is undefined.");
            break;
          case C.Axis_1:
            break;
        }
      t1 = _this._mainAxisAlignment;
      if (t1 === C.MainAxisAlignment_0 || t1 === C.MainAxisAlignment_1)
        switch (_this._flex$_direction) {
          case C.Axis_0:
            if (H.assertTest(_this._flex$_textDirection != null))
              H.assertThrow("Horizontal " + new H.TypeImpl(H.getRti(_this)).toString$0(0) + " with " + _this._mainAxisAlignment.toString$0(0) + _s63_);
            break;
          case C.Axis_1:
            break;
        }
      t1 = _this._crossAxisAlignment;
      if (t1 === C.CrossAxisAlignment_0 || t1 === C.CrossAxisAlignment_1)
        switch (_this._flex$_direction) {
          case C.Axis_0:
            break;
          case C.Axis_1:
            if (H.assertTest(_this._flex$_textDirection != null))
              H.assertThrow("Vertical " + new H.TypeImpl(H.getRti(_this)).toString$0(0) + " with " + _this._crossAxisAlignment.toString$0(0) + _s63_);
            break;
        }
      H.assertHelper(K.RenderObject.prototype.get$constraints.call(_this) != null);
      maxMainSize = _this._flex$_direction === C.Axis_0 ? K.RenderObject.prototype.get$constraints.call(_this).maxWidth : K.RenderObject.prototype.get$constraints.call(_this).maxHeight;
      if (typeof maxMainSize !== "number")
        return maxMainSize.$lt();
      canFlex = maxMainSize < 1 / 0;
      t1 = _box_0.child = _this.ContainerRenderObjectMixin__firstChild;
      for (lastFlexChild = _null, totalFlex = 0, totalChildren = 0, crossSize = 0, allocatedSize = 0; t1 != null; t1 = child) {
        childParentData = H.interceptedTypeCheck(t1.parentData, "$isFlexParentData");
        ++totalChildren;
        flex = childParentData.flex;
        if ((flex == null ? 0 : flex) > 0) {
          H.assertHelper(new F.RenderFlex_performLayout_closure(_box_0, _this, canFlex).call$0());
          t1 = childParentData.flex;
          if (typeof t1 !== "number")
            return H.iae(t1);
          totalFlex += t1;
          lastFlexChild = _box_0.child;
        } else {
          if (_this._crossAxisAlignment === C.CrossAxisAlignment_3)
            switch (_this._flex$_direction) {
              case C.Axis_0:
                innerConstraints = new S.BoxConstraints(0, 1 / 0, K.RenderObject.prototype.get$constraints.call(_this).maxHeight, K.RenderObject.prototype.get$constraints.call(_this).maxHeight);
                break;
              case C.Axis_1:
                innerConstraints = new S.BoxConstraints(K.RenderObject.prototype.get$constraints.call(_this).maxWidth, K.RenderObject.prototype.get$constraints.call(_this).maxWidth, 0, 1 / 0);
                break;
              default:
                innerConstraints = _null;
            }
          else
            switch (_this._flex$_direction) {
              case C.Axis_0:
                innerConstraints = new S.BoxConstraints(0, 1 / 0, 0, K.RenderObject.prototype.get$constraints.call(_this).maxHeight);
                break;
              case C.Axis_1:
                innerConstraints = new S.BoxConstraints(0, K.RenderObject.prototype.get$constraints.call(_this).maxWidth, 0, 1 / 0);
                break;
              default:
                innerConstraints = _null;
            }
          t1.layout$2$parentUsesSize(innerConstraints, true);
          t1 = _this._getMainSize$1(_box_0.child);
          if (typeof t1 !== "number")
            return H.iae(t1);
          allocatedSize += t1;
          crossSize = Math.max(crossSize, H.checkNum(_this._getCrossSize$1(_box_0.child)));
        }
        H.assertHelper(_box_0.child.parentData == childParentData);
        child = childParentData.ContainerParentDataMixin_nextSibling;
        _box_0.child = child;
      }
      if (canFlex)
        t1 = maxMainSize;
      else
        t1 = 0;
      freeSpace = Math.max(0, t1 - allocatedSize);
      t1 = totalFlex > 0;
      if (t1 || _this._crossAxisAlignment === C.CrossAxisAlignment_4) {
        spacePerFlex = canFlex && t1 ? freeSpace / totalFlex : 0 / 0;
        t1 = _box_0.child = _this.ContainerRenderObjectMixin__firstChild;
        for (allocatedFlexSpace = 0, maxBaselineDistance = 0, maxSizeAboveBaseline = 0, maxSizeBelowBaseline = 0; t1 != null; t1 = child) {
          childParentData = H.interceptedTypeCheck(t1.parentData, "$isFlexParentData");
          flex = childParentData.flex;
          if (flex == null)
            flex = 0;
          if (flex > 0) {
            if (canFlex)
              maxChildExtent = t1 === lastFlexChild ? freeSpace - allocatedFlexSpace : spacePerFlex * flex;
            else
              maxChildExtent = 1 / 0;
            t1 = childParentData.fit;
            switch (t1 == null ? C.FlexFit_0 : t1) {
              case C.FlexFit_0:
                H.assertHelper(maxChildExtent < 1 / 0);
                minChildExtent = maxChildExtent;
                break;
              case C.FlexFit_1:
                minChildExtent = 0;
                break;
              default:
                minChildExtent = _null;
            }
            H.assertHelper(minChildExtent != null);
            if (_this._crossAxisAlignment === C.CrossAxisAlignment_3)
              switch (_this._flex$_direction) {
                case C.Axis_0:
                  innerConstraints = new S.BoxConstraints(minChildExtent, maxChildExtent, K.RenderObject.prototype.get$constraints.call(_this).maxHeight, K.RenderObject.prototype.get$constraints.call(_this).maxHeight);
                  break;
                case C.Axis_1:
                  innerConstraints = new S.BoxConstraints(K.RenderObject.prototype.get$constraints.call(_this).maxWidth, K.RenderObject.prototype.get$constraints.call(_this).maxWidth, minChildExtent, maxChildExtent);
                  break;
                default:
                  innerConstraints = _null;
              }
            else
              switch (_this._flex$_direction) {
                case C.Axis_0:
                  innerConstraints = new S.BoxConstraints(minChildExtent, maxChildExtent, 0, K.RenderObject.prototype.get$constraints.call(_this).maxHeight);
                  break;
                case C.Axis_1:
                  innerConstraints = new S.BoxConstraints(0, K.RenderObject.prototype.get$constraints.call(_this).maxWidth, minChildExtent, maxChildExtent);
                  break;
                default:
                  innerConstraints = _null;
              }
            _box_0.child.layout$2$parentUsesSize(innerConstraints, true);
            childSize = _this._getMainSize$1(_box_0.child);
            if (typeof childSize !== "number")
              return childSize.$le();
            H.assertHelper(childSize <= maxChildExtent);
            allocatedSize += childSize;
            allocatedFlexSpace += maxChildExtent;
            crossSize = Math.max(crossSize, H.checkNum(_this._getCrossSize$1(_box_0.child)));
          }
          if (_this._crossAxisAlignment === C.CrossAxisAlignment_4) {
            H.assertHelper(new F.RenderFlex_performLayout_closure0(_this).call$0());
            distance = _box_0.child.getDistanceToBaseline$2$onlyReal(_this._textBaseline, true);
            if (distance != null) {
              maxBaselineDistance = Math.max(maxBaselineDistance, distance);
              maxSizeAboveBaseline = Math.max(distance, maxSizeAboveBaseline);
              t1 = _box_0.child.get$size()._dy;
              if (typeof t1 !== "number")
                return t1.$sub();
              maxSizeBelowBaseline = Math.max(t1 - distance, maxSizeBelowBaseline);
              crossSize = maxSizeAboveBaseline + maxSizeBelowBaseline;
            }
          }
          child = H.interceptedTypeCheck(_box_0.child.parentData, "$isFlexParentData").ContainerParentDataMixin_nextSibling;
          _box_0.child = child;
        }
      } else
        maxBaselineDistance = 0;
      if (canFlex && _this._mainAxisSize === C.MainAxisSize_1)
        idealSize = maxMainSize;
      else
        idealSize = allocatedSize;
      switch (_this._flex$_direction) {
        case C.Axis_0:
          _this.set$size(K.RenderObject.prototype.get$constraints.call(_this).constrain$1(new P.Size(idealSize, crossSize)));
          actualSize = _this.get$size()._dx;
          crossSize = _this.get$size()._dy;
          break;
        case C.Axis_1:
          _this.set$size(K.RenderObject.prototype.get$constraints.call(_this).constrain$1(new P.Size(crossSize, idealSize)));
          actualSize = _this.get$size()._dy;
          crossSize = _this.get$size()._dx;
          break;
        default:
          actualSize = _null;
      }
      if (typeof actualSize !== "number")
        return actualSize.$sub();
      actualSizeDelta = actualSize - allocatedSize;
      _this._flex$_overflow = Math.max(0, -actualSizeDelta);
      remainingSpace = Math.max(0, actualSizeDelta);
      t1 = F._startIsTopLeft(_this._flex$_direction, _this._flex$_textDirection, _this._verticalDirection);
      flipMainAxis = t1 === false;
      switch (_this._mainAxisAlignment) {
        case C.MainAxisAlignment_0:
          leadingSpace = 0;
          betweenSpace = 0;
          break;
        case C.MainAxisAlignment_1:
          leadingSpace = remainingSpace;
          betweenSpace = 0;
          break;
        case C.MainAxisAlignment_2:
          leadingSpace = remainingSpace / 2;
          betweenSpace = 0;
          break;
        case C.MainAxisAlignment_3:
          betweenSpace = totalChildren > 1 ? remainingSpace / (totalChildren - 1) : 0;
          leadingSpace = 0;
          break;
        case C.MainAxisAlignment_4:
          betweenSpace = totalChildren > 0 ? remainingSpace / totalChildren : 0;
          leadingSpace = betweenSpace / 2;
          break;
        case C.MainAxisAlignment_5:
          betweenSpace = totalChildren > 0 ? remainingSpace / (totalChildren + 1) : 0;
          leadingSpace = betweenSpace;
          break;
        default:
          betweenSpace = _null;
          leadingSpace = betweenSpace;
      }
      if (flipMainAxis) {
        if (typeof leadingSpace !== "number")
          return H.iae(leadingSpace);
        childMainPosition = actualSize - leadingSpace;
      } else
        childMainPosition = leadingSpace;
      t1 = _box_0.child = _this.ContainerRenderObjectMixin__firstChild;
      for (; t1 != null; t1 = child) {
        childParentData = H.interceptedTypeCheck(t1.parentData, "$isFlexParentData");
        t2 = _this._crossAxisAlignment;
        switch (t2) {
          case C.CrossAxisAlignment_0:
          case C.CrossAxisAlignment_1:
            if (F._startIsTopLeft(G.flipAxis(_this._flex$_direction), _this._flex$_textDirection, _this._verticalDirection) === (t2 === C.CrossAxisAlignment_0))
              childCrossPosition = 0;
            else {
              t1 = _this._getCrossSize$1(t1);
              if (typeof crossSize !== "number")
                return crossSize.$sub();
              if (typeof t1 !== "number")
                return H.iae(t1);
              childCrossPosition = crossSize - t1;
            }
            break;
          case C.CrossAxisAlignment_2:
            if (typeof crossSize !== "number")
              return crossSize.$div();
            t1 = _this._getCrossSize$1(t1);
            if (typeof t1 !== "number")
              return t1.$div();
            childCrossPosition = crossSize / 2 - t1 / 2;
            break;
          case C.CrossAxisAlignment_3:
            childCrossPosition = 0;
            break;
          case C.CrossAxisAlignment_4:
            if (_this._flex$_direction === C.Axis_0) {
              H.assertHelper(false);
              distance = _box_0.child.getDistanceToBaseline$2$onlyReal(_this._textBaseline, true);
              childCrossPosition = distance != null ? maxBaselineDistance - distance : 0;
            } else
              childCrossPosition = 0;
            break;
          default:
            childCrossPosition = _null;
        }
        if (flipMainAxis) {
          t1 = _this._getMainSize$1(_box_0.child);
          if (typeof childMainPosition !== "number")
            return childMainPosition.$sub();
          if (typeof t1 !== "number")
            return H.iae(t1);
          childMainPosition -= t1;
        }
        switch (_this._flex$_direction) {
          case C.Axis_0:
            childParentData.offset = new P.Offset(childMainPosition, childCrossPosition);
            break;
          case C.Axis_1:
            childParentData.offset = new P.Offset(childCrossPosition, childMainPosition);
            break;
        }
        if (flipMainAxis) {
          if (typeof childMainPosition !== "number")
            return childMainPosition.$sub();
          if (typeof betweenSpace !== "number")
            return H.iae(betweenSpace);
          childMainPosition -= betweenSpace;
        } else {
          t1 = _this._getMainSize$1(_box_0.child);
          if (typeof t1 !== "number")
            return t1.$add();
          if (typeof betweenSpace !== "number")
            return H.iae(betweenSpace);
          if (typeof childMainPosition !== "number")
            return childMainPosition.$add();
          childMainPosition += t1 + betweenSpace;
        }
        child = childParentData.ContainerParentDataMixin_nextSibling;
        _box_0.child = child;
      }
    },
    hitTestChildren$2$position: function(result, position) {
      return this.defaultHitTestChildren$2$position(result, position);
    },
    paint$2: function(context, offset) {
      var t2, t3, _this = this,
        t1 = _this._flex$_overflow;
      if (typeof t1 !== "number")
        return t1.$le();
      if (t1 <= 0) {
        _this.defaultPaint$2(context, offset);
        return;
      }
      t1 = _this.get$size();
      if (t1.get$isEmpty(t1))
        return;
      H.assertHelper(!_this._needsCompositingBitsUpdate);
      t1 = _this._needsCompositing;
      t2 = _this.get$size();
      t3 = t2._dx;
      t2 = t2._dy;
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (typeof t2 !== "number")
        return H.iae(t2);
      context.pushClipRect$4(t1, offset, new P.Rect(0, 0, 0 + t3, 0 + t2), _this.get$defaultPaint());
      H.assertHelper(new F.RenderFlex_paint_closure(_this, context, offset).call$0());
    },
    describeApproximatePaintClip$1: function(child) {
      var t2,
        t1 = this._flex$_overflow;
      if (typeof t1 !== "number")
        return t1.$gt();
      if (t1 > 0) {
        t1 = this.get$size();
        t2 = t1._dx;
        t1 = t1._dy;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = new P.Rect(0, 0, 0 + t2, 0 + t1);
      } else
        t1 = null;
      return t1;
    },
    toStringShort$0: function() {
      var header = this.super$RenderObject$toStringShort(),
        t1 = this._flex$_overflow;
      return typeof t1 === "number" && t1 > 0 ? header + " OVERFLOWING" : header;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$RenderBox$debugFillProperties(properties);
      t1 = _this._flex$_direction;
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, t1, C.C__NoDefaultValue, C.DiagnosticLevel_3, "direction", true, true, C.DiagnosticsTreeStyle_5, [G.Axis]));
      t1 = _this._mainAxisAlignment;
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, t1, C.C__NoDefaultValue, C.DiagnosticLevel_3, "mainAxisAlignment", true, true, C.DiagnosticsTreeStyle_5, [F.MainAxisAlignment]));
      t1 = _this._mainAxisSize;
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, t1, C.C__NoDefaultValue, C.DiagnosticLevel_3, "mainAxisSize", true, true, C.DiagnosticsTreeStyle_5, [F.MainAxisSize]));
      t1 = _this._crossAxisAlignment;
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, t1, C.C__NoDefaultValue, C.DiagnosticLevel_3, "crossAxisAlignment", true, true, C.DiagnosticsTreeStyle_5, [F.CrossAxisAlignment]));
      t1 = _this._flex$_textDirection;
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, "textDirection", true, true, C.DiagnosticsTreeStyle_5, [P.TextDirection]));
      t1 = _this._verticalDirection;
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, "verticalDirection", true, true, C.DiagnosticsTreeStyle_5, [G.VerticalDirection]));
      t1 = _this._textBaseline;
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, "textBaseline", true, true, C.DiagnosticsTreeStyle_5, [P.TextBaseline]));
    },
    $asRenderBoxContainerDefaultsMixin: function() {
      return [S.RenderBox, F.FlexParentData];
    },
    $asContainerRenderObjectMixin: function() {
      return [S.RenderBox, F.FlexParentData];
    }
  };
  F.RenderFlex_performLayout_closure.prototype = {
    call$0: function() {
      var message, information, node0, t2,
        node = this.$this,
        t1 = node._flex$_direction === C.Axis_0,
        identity = t1 ? "row" : "column",
        axis = t1 ? "horizontal" : "vertical",
        dimension = t1 ? "width" : "height";
      if (!this.canFlex)
        t1 = node._mainAxisSize === C.MainAxisSize_1 || node._getFit$1(this._box_0.child) === C.FlexFit_0;
      else
        t1 = false;
      if (t1) {
        t1 = "RenderFlex children have non-zero flex but incoming " + dimension;
        message = "When a " + identity + " is in a parent that does not provide a finite " + dimension + " constraint, for example if it is in a " + axis + " scrollable, it will try to shrink-wrap its children along the " + axis + " axis. Setting a flex on a child (e.g. using Expanded) indicates that the child is to expand to fill the remaining space in the " + axis + " direction.";
        information = new P.StringBuffer("");
        switch (node._flex$_direction) {
          case C.Axis_0:
            node0 = node;
            while (true) {
              t2 = K.RenderObject.prototype.get$constraints.call(node0).maxWidth;
              if (typeof t2 !== "number")
                return t2.$lt();
              if (!(!(t2 < 1 / 0) && node0._node$_parent instanceof S.RenderBox))
                break;
              node0 = H.interceptedTypeCheck(node0._node$_parent, "$isRenderBox");
            }
            t2 = K.RenderObject.prototype.get$constraints.call(node0).maxWidth;
            if (typeof t2 !== "number")
              return t2.$lt();
            if (!(t2 < 1 / 0))
              node0 = null;
            break;
          case C.Axis_1:
            node0 = node;
            while (true) {
              t2 = K.RenderObject.prototype.get$constraints.call(node0).maxHeight;
              if (typeof t2 !== "number")
                return t2.$lt();
              if (!(!(t2 < 1 / 0) && node0._node$_parent instanceof S.RenderBox))
                break;
              node0 = H.interceptedTypeCheck(node0._node$_parent, "$isRenderBox");
            }
            t2 = K.RenderObject.prototype.get$constraints.call(node0).maxHeight;
            if (typeof t2 !== "number")
              return t2.$lt();
            if (!(t2 < 1 / 0))
              node0 = null;
            break;
          default:
            node0 = node;
        }
        if (node0 != null) {
          t2 = information._contents += "The nearest ancestor providing an unbounded width constraint is:\n";
          t2 += "  ";
          information._contents = t2;
          information._contents = t2 + (node0.toStringShallow$1$joiner("\n  ") + "\n");
        }
        t2 = information._contents += "See also: https://flutter.dev/layout/\n";
      } else
        return true;
      throw H.wrapException(U.FlutterError$(t1 + " constraints are unbounded.\n" + message + "\nThese two directives are mutually exclusive. If a parent is to shrink-wrap its child, the child cannot simultaneously expand to fit its parent.\nConsider setting mainAxisSize to MainAxisSize.min and using FlexFit.loose fits for the flexible children (using Flexible rather than Expanded). This will allow the flexible children to size themselves to less than the infinite remaining space they would otherwise be forced to take, and then will cause the RenderFlex to shrink-wrap the children rather than expanding to fit the maximum constraints provided by the parent.\nThe affected RenderFlex is:\n  " + node.toString$0(0) + "\nThe creator information is set to:\n  " + H.S(node.debugCreator) + "\n" + (t2.charCodeAt(0) == 0 ? t2 : t2) + "If this message did not help you determine the problem, consider using debugDumpRenderTree():\n  https://flutter.dev/debugging/#rendering-layer\n  http://docs.flutter.io/flutter/rendering/debugDumpRenderTree.html\nIf none of the above helps enough to fix this problem, please don't hesitate to file a bug:\n  https://github.com/flutter/flutter/issues/new?template=BUG.md"));
    },
    $signature: 0
  };
  F.RenderFlex_performLayout_closure0.prototype = {
    call$0: function() {
      var t1 = U.FlutterError$('To use FlexAlignItems.baseline, you must also specify which baseline to use using the "baseline" argument.');
      throw H.wrapException(t1);
    },
    $signature: 0
  };
  F.RenderFlex_paint_closure.prototype = {
    call$0: function() {
      var t2, t3, overflowChildRect,
        t1 = this.$this,
        debugOverflowHints = "The overflowing " + new H.TypeImpl(H.getRti(t1)).toString$0(0) + " has an orientation of " + t1._flex$_direction.toString$0(0) + ".\nThe edge of the " + new H.TypeImpl(H.getRti(t1)).toString$0(0) + " that is overflowing has been marked in the rendering with a yellow and black striped pattern. This is usually caused by the contents being too big for the " + new H.TypeImpl(H.getRti(t1)).toString$0(0) + ". Consider applying a flex factor (e.g. using an Expanded widget) to force the children of the " + new H.TypeImpl(H.getRti(t1)).toString$0(0) + " to fit within the available space instead of being sized to their natural size.\nThis is considered an error condition because it indicates that there is content that cannot be seen. If the content is legitimately bigger than the available space, consider clipping it with a ClipRect widget before putting it in the flex, or using a scrollable container rather than a Flex, like a ListView.";
      switch (t1._flex$_direction) {
        case C.Axis_0:
          t2 = t1.get$size()._dx;
          t3 = t1._flex$_overflow;
          if (typeof t2 !== "number")
            return t2.$add();
          if (typeof t3 !== "number")
            return H.iae(t3);
          overflowChildRect = new P.Rect(0, 0, 0 + (t2 + t3), 0);
          break;
        case C.Axis_1:
          t2 = t1.get$size()._dy;
          t3 = t1._flex$_overflow;
          if (typeof t2 !== "number")
            return t2.$add();
          if (typeof t3 !== "number")
            return H.iae(t3);
          overflowChildRect = new P.Rect(0, 0, 0, 0 + (t2 + t3));
          break;
        default:
          overflowChildRect = null;
      }
      t2 = t1.get$size();
      t3 = t2._dx;
      t2 = t2._dy;
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t1.paintOverflowIndicator$5$overflowHints(this.context, this.offset, new P.Rect(0, 0, 0 + t3, 0 + t2), overflowChildRect, debugOverflowHints);
      return true;
    },
    $signature: 0
  };
  F._RenderFlex_RenderBox_ContainerRenderObjectMixin.prototype = {
    attach$1: function(owner) {
      var child;
      H.interceptedTypeCheck(owner, "$isPipelineOwner");
      this.super$RenderObject$attach(owner);
      child = this.ContainerRenderObjectMixin__firstChild;
      for (; child != null;) {
        child.attach$1(owner);
        child = H.interceptedTypeCheck(child.parentData, "$isFlexParentData").ContainerParentDataMixin_nextSibling;
      }
    },
    detach$0: function() {
      this.super$AbstractNode$detach();
      var child = this.ContainerRenderObjectMixin__firstChild;
      for (; child != null;) {
        child.detach$0();
        child = H.interceptedTypeCheck(child.parentData, "$isFlexParentData").ContainerParentDataMixin_nextSibling;
      }
    },
    set$_firstChild: function(_firstChild) {
      this.ContainerRenderObjectMixin__firstChild = H.assertSubtypeOfRuntimeType(_firstChild, H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 0));
    },
    set$_lastChild: function(_lastChild) {
      this.ContainerRenderObjectMixin__lastChild = H.assertSubtypeOfRuntimeType(_lastChild, H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 0));
    }
  };
  F._RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin.prototype = {};
  F._RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin_DebugOverflowIndicatorMixin.prototype = {
    reassemble$0: function() {
      this.super$RenderObject$reassemble();
      H.assertHelper(new F._RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin_DebugOverflowIndicatorMixin_reassemble_closure(this).call$0());
    }
  };
  T.Layer.prototype = {
    get$parent: function() {
      return H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(this), "$isContainerLayer");
    },
    updateSubtreeNeedsAddToScene$0: function() {
      this._subtreeNeedsAddToScene = this._needsAddToScene || false;
    },
    remove$0: function(_) {
      var t2, _this = this,
        t1 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(_this), "$isContainerLayer");
      if (t1 != null) {
        H.assertHelper(H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(_this), "$isContainerLayer") === t1);
        H.assertHelper(_this._node$_owner != null === (t1._node$_owner != null));
        H.assertHelper(t1._layer$_debugUltimatePreviousSiblingOf$2$equals(_this, t1._layer$_firstChild));
        H.assertHelper(t1._layer$_debugUltimateNextSiblingOf$2$equals(_this, t1._layer$_lastChild));
        t2 = _this._previousSibling;
        if (t2 == null) {
          H.assertHelper(t1._layer$_firstChild === _this);
          t1._layer$_firstChild = _this._nextSibling;
        } else
          t2._nextSibling = _this._nextSibling;
        t2 = _this._nextSibling;
        if (t2 == null) {
          H.assertHelper(t1._layer$_lastChild === _this);
          t1._layer$_lastChild = _this._previousSibling;
        } else
          t2._previousSibling = _this._previousSibling;
        H.assertHelper(t1._layer$_firstChild == null === (t1._layer$_lastChild == null));
        t2 = t1._layer$_firstChild;
        H.assertHelper(t2 == null || t2._node$_owner != null === (t1._node$_owner != null));
        t2 = t1._layer$_lastChild;
        H.assertHelper(t2 == null || t2._node$_owner != null === (t1._node$_owner != null));
        t2 = t1._layer$_firstChild;
        H.assertHelper(t2 == null || t1._layer$_debugUltimateNextSiblingOf$2$equals(t2, t1._layer$_lastChild));
        t2 = t1._layer$_lastChild;
        H.assertHelper(t2 == null || t1._layer$_debugUltimatePreviousSiblingOf$2$equals(t2, t1._layer$_firstChild));
        _this._nextSibling = _this._previousSibling = null;
        t1._needsAddToScene = true;
        t1.super$AbstractNode$dropChild(_this);
        H.assertHelper(_this._node$_owner == null);
      }
    },
    _addToSceneWithRetainedRendering$1: function(builder) {
      var _this = this;
      H.boolConversionCheck(_this._subtreeNeedsAddToScene);
      _this._engineLayer = _this.addToScene$1(builder);
      _this._needsAddToScene = false;
    },
    toStringShort$0: function() {
      var t1 = this.super$DiagnosticableTreeMixin$toStringShort();
      return t1 + (this._node$_owner == null ? " DETACHED" : "");
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$DiagnosticableTreeMixin$debugFillProperties(properties);
      t1 = _this._node$_owner;
      t2 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(_this), "$isContainerLayer") != null ? C.DiagnosticLevel_0 : C.DiagnosticLevel_3;
      t2 = Y.DiagnosticsProperty$("owner", t1, _null, _null, _null, _null, t2, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Object);
      t1 = properties.properties;
      C.JSArray_methods.add$1(t1, t2);
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("creator", _this.debugCreator, _null, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, _null));
    },
    $isDiagnosticable: 1,
    $isDiagnosticableTree: 1
  };
  T.PictureLayer.prototype = {
    addToScene$2: function(builder, layerOffset) {
      builder.addPicture$4$isComplexHint$willChangeHint(layerOffset, this._picture, this._isComplexHint, this._willChangeHint);
    },
    addToScene$1: function(builder) {
      return this.addToScene$2(builder, C.Offset_0_0);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Layer$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("paint bounds", this.canvasBounds, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Rect);
      C.JSArray_methods.add$1(properties.properties, t1);
    },
    find$1$1: function(regionOffset) {
      return;
    }
  };
  T.PerformanceOverlayLayer.prototype = {
    addToScene$2: function(builder, layerOffset) {
      builder.addPerformanceOverlay$2(this.optionsMask, this._overlayRect.shift$1(layerOffset));
    },
    addToScene$1: function(builder) {
      return this.addToScene$2(builder, C.Offset_0_0);
    },
    find$1$1: function(regionOffset) {
      return;
    }
  };
  T.ContainerLayer.prototype = {
    _layer$_debugUltimatePreviousSiblingOf$2$equals: function(child, equals) {
      var t1;
      H.assertHelper(child._node$_owner != null === (this._node$_owner != null));
      for (; t1 = child._previousSibling, t1 != null;) {
        H.assertHelper(t1 !== child);
        child = child._previousSibling;
        H.assertHelper(child._node$_owner != null === (this._node$_owner != null));
      }
      return child == equals;
    },
    _layer$_debugUltimateNextSiblingOf$2$equals: function(child, equals) {
      var t1;
      H.assertHelper(child._node$_owner != null === (this._node$_owner != null));
      for (; t1 = child._nextSibling, t1 != null;) {
        H.assertHelper(t1 !== child);
        child = child._nextSibling;
        H.assertHelper(child._node$_owner != null === (this._node$_owner != null));
      }
      return child == equals;
    },
    _debugCheckElevations$0: function() {
      var i, physicalModelLayer, accumulatedElevation, ancestor, j, predecessor, predecessorAccumulatedElevation,
        t1 = T.PhysicalModelLayer,
        physicalModelLayers = P.List_List$from(new H.WhereTypeIterable(this.depthFirstIterateChildren$0(), [t1]), true, t1),
        addedLayers = H.setRuntimeTypeInfo([], [T.PictureLayer]);
      for (i = 0; i < physicalModelLayers.length; ++i) {
        physicalModelLayer = physicalModelLayers[i];
        t1 = physicalModelLayer._layer$_lastChild;
        if (H.assertTest(!J.$eq$(t1 == null ? null : t1.debugCreator, physicalModelLayer)))
          H.assertThrow("debugCheckElevations has either already visited this layer or failed to remove the added picture from it.");
        accumulatedElevation = physicalModelLayer._layer$_elevation;
        ancestor = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(physicalModelLayer), "$isContainerLayer");
        for (; ancestor != null;) {
          if (!!ancestor.$isPhysicalModelLayer) {
            t1 = ancestor._layer$_elevation;
            if (typeof accumulatedElevation !== "number")
              return accumulatedElevation.$add();
            if (typeof t1 !== "number")
              return H.iae(t1);
            accumulatedElevation += t1;
          }
          ancestor = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(ancestor), "$isContainerLayer");
        }
        for (j = 0; j <= i; ++j) {
          if (j >= physicalModelLayers.length)
            return H.ioore(physicalModelLayers, j);
          predecessor = physicalModelLayers[j];
          predecessorAccumulatedElevation = predecessor._layer$_elevation;
          ancestor = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(predecessor), "$isContainerLayer");
          for (; ancestor != null;) {
            if (ancestor === predecessor)
              continue;
            if (!!ancestor.$isPhysicalModelLayer) {
              t1 = ancestor._layer$_elevation;
              if (typeof predecessorAccumulatedElevation !== "number")
                return predecessorAccumulatedElevation.$add();
              if (typeof t1 !== "number")
                return H.iae(t1);
              predecessorAccumulatedElevation += t1;
            }
            ancestor = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(ancestor), "$isContainerLayer");
          }
          if (typeof predecessorAccumulatedElevation !== "number")
            return predecessorAccumulatedElevation.$le();
          if (typeof accumulatedElevation !== "number")
            return H.iae(accumulatedElevation);
          if (predecessorAccumulatedElevation <= accumulatedElevation)
            continue;
          P.Path_combine(C.PathOperation_1, predecessor.get$_debugTransformedClipPath(), physicalModelLayer.get$_debugTransformedClipPath());
        }
      }
      return addedLayers;
    },
    updateSubtreeNeedsAddToScene$0: function() {
      var child, _this = this;
      _this.super$Layer$updateSubtreeNeedsAddToScene();
      child = _this._layer$_firstChild;
      for (; child != null;) {
        child.updateSubtreeNeedsAddToScene$0();
        _this._subtreeNeedsAddToScene = H.boolConversionCheck(_this._subtreeNeedsAddToScene) || H.boolConversionCheck(child._subtreeNeedsAddToScene);
        child = child._nextSibling;
      }
    },
    find$1$1: function(regionOffset, $S) {
      var value,
        current = this._layer$_lastChild;
      for (; current != null;) {
        value = current.find$1$1(regionOffset, $S);
        if (value != null)
          return H.assertSubtypeOfRuntimeType(value, $S);
        current = current._previousSibling;
      }
      return;
    },
    attach$1: function(owner) {
      var child;
      this.super$AbstractNode$attach(owner);
      child = this._layer$_firstChild;
      for (; child != null;) {
        child.attach$1(owner);
        child = child._nextSibling;
      }
    },
    detach$0: function() {
      this.super$AbstractNode$detach();
      var child = this._layer$_firstChild;
      for (; child != null;) {
        child.detach$0();
        child = child._nextSibling;
      }
    },
    append$1: function(child) {
      var t1, _this = this;
      H.assertHelper(child !== _this);
      H.assertHelper(child != _this._layer$_firstChild);
      H.assertHelper(child != _this._layer$_lastChild);
      H.assertHelper(H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(child), "$isContainerLayer") == null);
      H.assertHelper(child._node$_owner == null);
      H.assertHelper(child._nextSibling == null);
      H.assertHelper(child._previousSibling == null);
      H.assertHelper(new T.ContainerLayer_append_closure(_this, child).call$0());
      _this._needsAddToScene = true;
      _this.super$AbstractNode$adoptChild(child);
      t1 = child._previousSibling = _this._layer$_lastChild;
      if (t1 != null)
        t1._nextSibling = child;
      _this._layer$_lastChild = child;
      if (_this._layer$_firstChild == null)
        _this._layer$_firstChild = child;
      H.assertHelper(child._node$_owner != null === (_this._node$_owner != null));
    },
    removeAllChildren$0: function() {
      var next, _this = this,
        child = _this._layer$_firstChild;
      for (; child != null; child = next) {
        next = child._nextSibling;
        child._nextSibling = child._previousSibling = null;
        H.assertHelper(child._node$_owner != null === (_this._node$_owner != null));
        _this._needsAddToScene = true;
        _this.super$AbstractNode$dropChild(child);
      }
      _this._layer$_lastChild = _this._layer$_firstChild = null;
    },
    addToScene$2: function(builder, layerOffset) {
      this.addChildrenToScene$2(builder, layerOffset);
      return;
    },
    addToScene$1: function(builder) {
      return this.addToScene$2(builder, C.Offset_0_0);
    },
    addChildrenToScene$2: function(builder, childOffset) {
      var child = this._layer$_firstChild;
      for (; child != null;) {
        if (childOffset.$eq(0, C.Offset_0_0))
          child._addToSceneWithRetainedRendering$1(builder);
        else
          child.addToScene$2(builder, childOffset);
        child = child._nextSibling;
      }
    },
    addChildrenToScene$1: function(builder) {
      return this.addChildrenToScene$2(builder, C.Offset_0_0);
    },
    applyTransform$2: function(child, transform) {
    },
    depthFirstIterateChildren$0: function() {
      var children, child;
      if (this._layer$_firstChild == null)
        return H.setRuntimeTypeInfo([], [T.Layer]);
      children = H.setRuntimeTypeInfo([], [T.Layer]);
      child = this._layer$_firstChild;
      for (; child != null;) {
        C.JSArray_methods.add$1(children, child);
        if (!!child.$isContainerLayer)
          C.JSArray_methods.addAll$1(children, child.depthFirstIterateChildren$0());
        child = child._nextSibling;
      }
      return children;
    },
    debugDescribeChildren$0: function() {
      var count, t1,
        children = H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]),
        child = this._layer$_firstChild;
      if (child == null)
        return children;
      for (count = 1; true;) {
        t1 = "child " + count;
        child.toString;
        C.JSArray_methods.add$1(children, new Y._DiagnosticableTreeNode(child, t1, true, true, null));
        if (child == this._layer$_lastChild)
          break;
        ++count;
        child = child._nextSibling;
      }
      return children;
    }
  };
  T.ContainerLayer_append_closure.prototype = {
    call$0: function() {
      var node = this.$this;
      for (; H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(node), "$isContainerLayer") != null;)
        node = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(node), "$isContainerLayer");
      H.assertHelper(node !== this.child);
      return true;
    },
    $signature: 0
  };
  T.OffsetLayer.prototype = {
    set$offset: function(value) {
      if (!value.$eq(0, this._layer$_offset))
        this._needsAddToScene = true;
      this._layer$_offset = value;
    },
    find$1$1: function(regionOffset, $S) {
      return this.super$ContainerLayer$find(regionOffset.$sub(0, this._layer$_offset), $S);
    },
    applyTransform$2: function(child, transform) {
      var t1 = this._layer$_offset;
      transform.multiply$1(E.Matrix4_Matrix4$translationValues(t1._dx, t1._dy, 0));
    },
    buildScene$1: function(builder) {
      var t1 = {};
      t1.temporaryLayers = null;
      H.assertHelper(new T.OffsetLayer_buildScene_closure(t1, this).call$0());
      this.updateSubtreeNeedsAddToScene$0();
      this.addToScene$1(builder);
      builder.build$0();
    },
    addToScene$2: function(builder, layerOffset) {
      var t4,
        t1 = layerOffset._dx,
        t2 = this._layer$_offset,
        t3 = t2._dx;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = layerOffset._dy;
      t2 = t2._dy;
      if (typeof t4 !== "number")
        return t4.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      builder.pushOffset$2(t1 + t3, t4 + t2);
    },
    addToScene$1: function(builder) {
      return this.addToScene$2(builder, C.Offset_0_0);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Layer$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("offset", this._layer$_offset, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Offset);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  T.OffsetLayer_buildScene_closure.prototype = {
    call$0: function() {
      if ($.debugCheckElevationsEnabled)
        this._box_0.temporaryLayers = this.$this._debugCheckElevations$0();
      return true;
    },
    $signature: 0
  };
  T.ClipRectLayer.prototype = {
    find$1$1: function(regionOffset, $S) {
      if (!this._clipRect.contains$1(0, regionOffset))
        return;
      return this.super$ContainerLayer$find(regionOffset, $S);
    },
    addToScene$2: function(builder, layerOffset) {
      var t1 = {};
      t1.enabled = true;
      H.assertHelper(new T.ClipRectLayer_addToScene_closure(t1).call$0());
      if (t1.enabled)
        builder.pushClipRect$2$clipBehavior(this._clipRect.shift$1(layerOffset), this._clipBehavior);
      this.addChildrenToScene$2(builder, layerOffset);
      if (t1.enabled)
        builder.pop$0();
      return;
    },
    addToScene$1: function(builder) {
      return this.addToScene$2(builder, C.Offset_0_0);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Layer$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("clipRect", this._clipRect, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Rect);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  T.ClipRectLayer_addToScene_closure.prototype = {
    call$0: function() {
      return this._box_0.enabled = true;
    },
    $signature: 0
  };
  T.TransformLayer.prototype = {
    addToScene$2: function(builder, layerOffset) {
      var totalOffset, t1, _this = this;
      _this._lastEffectiveTransform = _this._layer$_transform;
      totalOffset = _this._layer$_offset.$add(0, layerOffset);
      if (!totalOffset.$eq(0, C.Offset_0_0)) {
        t1 = E.Matrix4_Matrix4$translationValues(totalOffset._dx, totalOffset._dy, 0);
        t1.multiply$1(_this._lastEffectiveTransform);
        _this._lastEffectiveTransform = t1;
      }
      builder.pushTransform$1(_this._lastEffectiveTransform._m4storage);
    },
    addToScene$1: function(builder) {
      return this.addToScene$2(builder, C.Offset_0_0);
    },
    find$1$1: function(regionOffset, $S) {
      var t1, _this = this;
      if (_this._inverseDirty) {
        _this._invertedTransform = E.Matrix4_tryInvert(_this._layer$_transform);
        _this._inverseDirty = false;
      }
      if (_this._invertedTransform == null)
        return;
      t1 = new Float64Array(4);
      t1[3] = 1;
      t1[2] = 0;
      C.NativeFloat64List_methods.$indexSet(t1, 1, regionOffset._dy);
      C.NativeFloat64List_methods.$indexSet(t1, 0, regionOffset._dx);
      t1 = _this._invertedTransform.transform$1(new E.Vector4(t1))._v4storage;
      return _this.super$OffsetLayer$find(new P.Offset(t1[0], t1[1]), $S);
    },
    applyTransform$2: function(child, transform) {
      var t1, _this = this;
      H.assertHelper(_this._lastEffectiveTransform != null || _this._layer$_transform != null);
      t1 = _this._lastEffectiveTransform;
      if (t1 == null)
        transform.multiply$1(_this._layer$_transform);
      else
        transform.multiply$1(t1);
    },
    debugFillProperties$1: function(properties) {
      var t1;
      this.super$OffsetLayer$debugFillProperties(properties);
      t1 = T.TransformProperty$("transform", this._layer$_transform, C.C__NoDefaultValue, true);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  T.OpacityLayer.prototype = {
    addToScene$2: function(builder, layerOffset) {
      var _this = this, t1 = {};
      t1.enabled = _this._layer$_firstChild != null;
      H.assertHelper(new T.OpacityLayer_addToScene_closure(t1).call$0());
      if (t1.enabled)
        builder.pushOpacity$2$offset(_this._layer$_alpha, _this._layer$_offset.$add(0, layerOffset));
      _this.addChildrenToScene$1(builder);
      if (t1.enabled)
        builder.pop$0();
      return;
    },
    addToScene$1: function(builder) {
      return this.addToScene$2(builder, C.Offset_0_0);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$Layer$debugFillProperties(properties);
      t1 = Y.IntProperty$("alpha", this._layer$_alpha, C.C__NoDefaultValue, _null, C.DiagnosticLevel_3, _null);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("offset", this._layer$_offset, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Offset));
    }
  };
  T.OpacityLayer_addToScene_closure.prototype = {
    call$0: function() {
      var t1 = this._box_0;
      t1.enabled = t1.enabled && true;
      return true;
    },
    $signature: 0
  };
  T.PhysicalModelLayer.prototype = {};
  T.AnnotatedRegionLayer.prototype = {
    find$1$1: function(regionOffset, $S) {
      var t1, t2, t3, t4, _this = this,
        result = _this.super$ContainerLayer$find(regionOffset, $S);
      if (result != null)
        return result;
      t1 = _this.size;
      if (t1 != null) {
        t2 = _this.offset;
        t3 = t2._dx;
        t2 = t2._dy;
        t4 = t1._dx;
        t1 = t1._dy;
        if (typeof t3 !== "number")
          return t3.$add();
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (typeof t2 !== "number")
          return t2.$add();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = !new P.Rect(t3, t2, t3 + t4, t2 + t1).contains$1(0, regionOffset);
      } else
        t1 = false;
      if (t1)
        return;
      if (new H.TypeImpl(H.getTypeArgumentByIndex(_this, 0)).$eq(0, new H.TypeImpl($S)))
        return H.assertSubtypeOfRuntimeType(_this.value, $S);
      return _this.super$ContainerLayer$find(regionOffset, $S);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Layer$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("value", _this.value, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, H.getTypeArgumentByIndex(_this, 0));
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("size", _this.size, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Size));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("offset", _this.offset, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Offset));
    }
  };
  T._Layer_AbstractNode_DiagnosticableTreeMixin.prototype = {};
  K.ParentData.prototype = {
    detach$0: function() {
    },
    toString$0: function(_) {
      return "<none>";
    }
  };
  K.PaintingContext.prototype = {
    paintChild$2: function(child, offset) {
      H.assertHelper(new K.PaintingContext_paintChild_closure(child).call$0());
      if (child.get$isRepaintBoundary()) {
        this.stopRecordingIfNeeded$0();
        this._compositeChild$2(child, offset);
      } else
        child._paintWithContext$2(this, offset);
      H.assertHelper(new K.PaintingContext_paintChild_closure0().call$0());
    },
    _compositeChild$2: function(child, offset) {
      var t1;
      H.assertHelper(!this.get$_isRecording());
      H.assertHelper(child.get$isRepaintBoundary());
      t1 = this._canvas;
      if (t1 != null) {
        t1.getSaveCount$0();
        t1 = false;
      } else
        t1 = true;
      H.assertHelper(t1);
      if (child._needsPaint)
        K.PaintingContext__repaintCompositedChild(child, null, true);
      else {
        H.assertHelper(child._layer != null);
        H.assertHelper(new K.PaintingContext__compositeChild_closure(child).call$0());
      }
      H.assertHelper(child._layer != null);
      child._layer.set$offset(offset);
      this.appendLayer$1(child._layer);
    },
    appendLayer$1: function(layer) {
      H.assertHelper(!this.get$_isRecording());
      layer.remove$0(0);
      this._containerLayer.append$1(layer);
    },
    get$_isRecording: function() {
      var hasCanvas = this._canvas != null;
      H.assertHelper(new K.PaintingContext__isRecording_closure(this, hasCanvas).call$0());
      return hasCanvas;
    },
    get$canvas: function() {
      var t1, _this = this;
      if (_this._canvas == null) {
        H.assertHelper(!_this.get$_isRecording());
        t1 = new T.PictureLayer(_this.estimatedBounds);
        _this._currentLayer = t1;
        _this._recorder = new P.PictureRecorder();
        _this._canvas = new P.Canvas();
        _this._containerLayer.append$1(t1);
      }
      return _this._canvas;
    },
    stopRecordingIfNeeded$0: function() {
      var t1, _this = this;
      if (!_this.get$_isRecording())
        return;
      H.assertHelper(new K.PaintingContext_stopRecordingIfNeeded_closure(_this).call$0());
      t1 = _this._currentLayer;
      _this._recorder.endRecording$0();
      t1.toString;
    },
    setIsComplexHint$0: function() {
      var t1 = this._currentLayer;
      if (t1 != null)
        if (!t1._isComplexHint)
          t1._needsAddToScene = t1._isComplexHint = true;
    },
    pushLayer$4$childPaintBounds: function(childLayer, painter, offset, childPaintBounds) {
      var childContext, _this = this;
      H.functionTypeCheck(painter, {func: 1, ret: -1, args: [K.PaintingContext, P.Offset]});
      H.assertHelper(childLayer._node$_owner == null);
      H.assertHelper(H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(childLayer), "$isContainerLayer") == null);
      _this.stopRecordingIfNeeded$0();
      _this.appendLayer$1(childLayer);
      childContext = _this.createChildContext$2(childLayer, childPaintBounds == null ? _this.estimatedBounds : childPaintBounds);
      painter.call$2(childContext, offset);
      childContext.stopRecordingIfNeeded$0();
    },
    pushLayer$3: function(childLayer, painter, offset) {
      return this.pushLayer$4$childPaintBounds(childLayer, painter, offset, null);
    },
    createChildContext$2: function(childLayer, bounds) {
      return K.PaintingContext$(childLayer, bounds);
    },
    pushClipRect$5$clipBehavior: function(needsCompositing, offset, clipRect, painter, clipBehavior) {
      var offsetClipRect;
      H.functionTypeCheck(painter, {func: 1, ret: -1, args: [K.PaintingContext, P.Offset]});
      offsetClipRect = clipRect.shift$1(offset);
      if (H.boolConversionCheck(needsCompositing))
        this.pushLayer$4$childPaintBounds(new T.ClipRectLayer(offsetClipRect, clipBehavior), painter, offset, offsetClipRect);
      else
        this.clipRectAndPaint$4(offsetClipRect, clipBehavior, offsetClipRect, new K.PaintingContext_pushClipRect_closure(this, painter, offset));
    },
    pushClipRect$4: function(needsCompositing, offset, clipRect, painter) {
      return this.pushClipRect$5$clipBehavior(needsCompositing, offset, clipRect, painter, C.Clip_1);
    },
    pushClipPath$6$clipBehavior: function(needsCompositing, offset, bounds, clipPath, painter, clipBehavior) {
      H.functionTypeCheck(painter, {func: 1, ret: -1, args: [K.PaintingContext, P.Offset]});
      bounds.shift$1(offset);
      clipPath.shift$1(offset);
    },
    toString$0: function(_) {
      var _this = this;
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "#" + H.Primitives_objectHashCode(_this) + "(layer: " + H.S(_this._containerLayer) + ", canvas bounds: " + _this.estimatedBounds.toString$0(0) + ")";
    }
  };
  K.PaintingContext__repaintCompositedChild_closure.prototype = {
    call$0: function() {
      this.child.debugRegisterRepaintBoundaryPaint$2$includedChild$includedParent(true, this.debugAlsoPaintedParent);
      return true;
    },
    $signature: 0
  };
  K.PaintingContext__repaintCompositedChild_closure0.prototype = {
    call$0: function() {
      var t1 = this.child,
        t2 = t1._layer,
        t3 = t1.debugCreator;
      t2.debugCreator = t3 == null ? new H.TypeImpl(H.getRti(t1)) : t3;
      return true;
    },
    $signature: 0
  };
  K.PaintingContext_debugInstrumentRepaintCompositedChild_closure.prototype = {
    call$0: function() {
      K.PaintingContext__repaintCompositedChild(this.child, this.customContext, this.debugAlsoPaintedParent);
      return true;
    },
    $signature: 0
  };
  K.PaintingContext_paintChild_closure.prototype = {
    call$0: function() {
      var t1 = $.debugOnProfilePaint;
      if (t1 != null)
        t1.call$1(this.child);
      return true;
    },
    $signature: 0
  };
  K.PaintingContext_paintChild_closure0.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  K.PaintingContext__compositeChild_closure.prototype = {
    call$0: function() {
      var t2, t3,
        t1 = this.child;
      t1.debugRegisterRepaintBoundaryPaint$2$includedChild$includedParent(false, true);
      t2 = t1._layer;
      t3 = t1.debugCreator;
      t2.debugCreator = t3 == null ? t1 : t3;
      return true;
    },
    $signature: 0
  };
  K.PaintingContext__isRecording_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._currentLayer;
      if (this.hasCanvas) {
        H.assertHelper(t2 != null);
        H.assertHelper(t1._recorder != null);
        H.assertHelper(t1._canvas != null);
      } else {
        H.assertHelper(t2 == null);
        H.assertHelper(t1._recorder == null);
        H.assertHelper(t1._canvas == null);
      }
      return true;
    },
    $signature: 0
  };
  K.PaintingContext_stopRecordingIfNeeded_closure.prototype = {
    call$0: function() {
      var paint, t1;
      if ($.debugRepaintRainbowEnabled) {
        paint = new P.Paint(new DataView(new ArrayBuffer(75)));
        paint.set$style(C.PaintingStyle_1);
        paint.set$strokeWidth(6);
        paint.set$color($.debugCurrentRepaintColor.toColor$0());
        t1 = this.$this;
        t1.get$canvas().drawRect$2(t1.estimatedBounds.inflate$1(-3), paint);
      }
      return true;
    },
    $signature: 0
  };
  K.PaintingContext_pushClipRect_closure.prototype = {
    call$0: function() {
      return this.painter.call$2(this.$this, this.offset);
    },
    $signature: 1
  };
  K.Constraints.prototype = {};
  K.SemanticsHandle_dispose_closure.prototype = {
    call$0: function() {
      if (this.$this._object$_owner == null)
        throw H.wrapException(U.FlutterError$("SemanticsHandle has already been disposed.\nEach SemanticsHandle should be disposed exactly once."));
      return true;
    },
    $signature: 0
  };
  K.PipelineOwner.prototype = {
    set$rootNode: function(value) {
      var t1 = this._rootNode;
      if (t1 === value)
        return;
      if (t1 != null)
        t1.detach$0();
      this._rootNode = value;
      value.attach$1(this);
    },
    flushLayout$0: function() {
      var dirtyNodes, node, t1, t2, t3, t4, t5, _i, _this = this;
      P.Timeline_startSync("Layout", C.Map_9aZ6I, null);
      H.assertHelper(new K.PipelineOwner_flushLayout_closure(_this).call$0());
      try {
        for (t1 = [K.RenderObject]; t2 = _this._nodesNeedingLayout, t2.length !== 0;) {
          dirtyNodes = t2;
          _this.set$_nodesNeedingLayout(H.setRuntimeTypeInfo([], t1));
          t2 = dirtyNodes;
          t3 = H.getTypeArgumentByIndex(t2, 0);
          t4 = H.functionTypeCheck(new K.PipelineOwner_flushLayout_closure0(), {func: 1, ret: P.int, args: [t3, t3]});
          if (typeof t2 !== "object" || t2 === null || !!t2.immutable$list)
            H.throwExpression(P.UnsupportedError$("sort"));
          t5 = J.get$length$asx(t2) - 1;
          if (t5 - 0 <= 32)
            H.Sort__insertionSort(t2, 0, t5, t4, t3);
          else
            H.Sort__dualPivotQuicksort(t2, 0, t5, t4, t3);
          t3 = t2.length;
          _i = 0;
          for (; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
            node = t2[_i];
            if (node._needsLayout) {
              t4 = node;
              t4 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t4), "$isPipelineOwner") === _this;
            } else
              t4 = false;
            if (t4)
              node._layoutWithoutResize$0();
          }
        }
      } finally {
        H.assertHelper(new K.PipelineOwner_flushLayout_closure1(_this).call$0());
        P.Timeline_finishSync();
      }
    },
    flushCompositingBits$0: function() {
      var t1, t2, _i, node;
      P.Timeline_startSync("Compositing bits", null, null);
      t1 = this._nodesNeedingCompositingBitsUpdate;
      C.JSArray_methods.sort$1(t1, new K.PipelineOwner_flushCompositingBits_closure());
      for (t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        node = t1[_i];
        if (node._needsCompositingBitsUpdate && H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(node), "$isPipelineOwner") === this)
          node._updateCompositingBits$0();
      }
      C.JSArray_methods.set$length(t1, 0);
      P.Timeline_finishSync();
    },
    flushPaint$0: function() {
      var dirtyNodes, node, t1, t2, _i, t3, _this = this;
      P.Timeline_startSync("Paint", C.Map_9aZ6I, null);
      H.assertHelper(new K.PipelineOwner_flushPaint_closure(_this).call$0());
      try {
        dirtyNodes = _this._nodesNeedingPaint;
        _this.set$_nodesNeedingPaint(H.setRuntimeTypeInfo([], [K.RenderObject]));
        for (t1 = dirtyNodes, J.sort$1$ax(t1, new K.PipelineOwner_flushPaint_closure0()), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          node = t1[_i];
          H.assertHelper(node._layer != null);
          if (node._needsPaint) {
            t3 = node;
            t3 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t3), "$isPipelineOwner") === _this;
          } else
            t3 = false;
          if (t3)
            if (node._layer._node$_owner != null) {
              t3 = node;
              H.assertHelper(t3._needsPaint);
              K.PaintingContext__repaintCompositedChild(t3, null, false);
            } else
              node._skippedPaintingOnLayer$0();
        }
        H.assertHelper(_this._nodesNeedingPaint.length === 0);
      } finally {
        H.assertHelper(new K.PipelineOwner_flushPaint_closure1(_this).call$0());
        P.Timeline_finishSync();
      }
    },
    flushSemantics$0: function() {
      var nodesToProcess, node, t1, nodesToProcess0, t2, _i, t3, _this = this;
      if (_this._semanticsOwner == null)
        return;
      P.Timeline_startSync("Semantics", null, null);
      H.assertHelper(_this._semanticsOwner != null);
      H.assertHelper(new K.PipelineOwner_flushSemantics_closure(_this).call$0());
      try {
        t1 = _this._nodesNeedingSemantics;
        nodesToProcess0 = t1.toList$0(0);
        C.JSArray_methods.sort$1(nodesToProcess0, new K.PipelineOwner_flushSemantics_closure0());
        nodesToProcess = nodesToProcess0;
        t1.clear$0(0);
        for (t1 = nodesToProcess, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          node = t1[_i];
          if (node._needsSemanticsUpdate) {
            t3 = node;
            t3 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t3), "$isPipelineOwner") === _this;
          } else
            t3 = false;
          if (t3)
            node._updateSemantics$0();
        }
        _this._semanticsOwner.sendSemanticsUpdate$0();
      } finally {
        H.assertHelper(_this._nodesNeedingSemantics._collection$_length === 0);
        H.assertHelper(new K.PipelineOwner_flushSemantics_closure1(_this).call$0());
        P.Timeline_finishSync();
      }
    },
    set$_nodesNeedingLayout: function(_nodesNeedingLayout) {
      this._nodesNeedingLayout = H.assertSubtype(_nodesNeedingLayout, "$isList", [K.RenderObject], "$asList");
    },
    set$_nodesNeedingPaint: function(_nodesNeedingPaint) {
      this._nodesNeedingPaint = H.assertSubtype(_nodesNeedingPaint, "$isList", [K.RenderObject], "$asList");
    }
  };
  K.PipelineOwner_flushLayout_closure.prototype = {
    call$0: function() {
      return this.$this._debugDoingLayout = true;
    },
    $signature: 0
  };
  K.PipelineOwner_flushLayout_closure0.prototype = {
    call$2: function(a, b) {
      H.interceptedTypeCheck(a, "$isRenderObject");
      H.interceptedTypeCheck(b, "$isRenderObject");
      return a._node$_depth - b._node$_depth;
    },
    $signature: 17
  };
  K.PipelineOwner_flushLayout_closure1.prototype = {
    call$0: function() {
      this.$this._debugDoingLayout = false;
      return true;
    },
    $signature: 0
  };
  K.PipelineOwner_flushCompositingBits_closure.prototype = {
    call$2: function(a, b) {
      H.interceptedTypeCheck(a, "$isRenderObject");
      H.interceptedTypeCheck(b, "$isRenderObject");
      return a._node$_depth - b._node$_depth;
    },
    $signature: 17
  };
  K.PipelineOwner_flushPaint_closure.prototype = {
    call$0: function() {
      return this.$this._debugDoingPaint = true;
    },
    $signature: 0
  };
  K.PipelineOwner_flushPaint_closure0.prototype = {
    call$2: function(a, b) {
      H.interceptedTypeCheck(a, "$isRenderObject");
      H.interceptedTypeCheck(b, "$isRenderObject");
      return b._node$_depth - a._node$_depth;
    },
    $signature: 17
  };
  K.PipelineOwner_flushPaint_closure1.prototype = {
    call$0: function() {
      this.$this._debugDoingPaint = false;
      return true;
    },
    $signature: 0
  };
  K.PipelineOwner_flushSemantics_closure.prototype = {
    call$0: function() {
      return this.$this._debugDoingSemantics = true;
    },
    $signature: 0
  };
  K.PipelineOwner_flushSemantics_closure0.prototype = {
    call$2: function(a, b) {
      H.interceptedTypeCheck(a, "$isRenderObject");
      H.interceptedTypeCheck(b, "$isRenderObject");
      return a._node$_depth - b._node$_depth;
    },
    $signature: 17
  };
  K.PipelineOwner_flushSemantics_closure1.prototype = {
    call$0: function() {
      this.$this._debugDoingSemantics = false;
      return true;
    },
    $signature: 0
  };
  K.RenderObject.prototype = {
    reassemble$0: function() {
      var _this = this;
      _this.markNeedsLayout$0();
      _this.markNeedsCompositingBitsUpdate$0();
      _this.markNeedsPaint$0();
      _this.markNeedsSemanticsUpdate$0();
      _this.visitChildren$1(new K.RenderObject_reassemble_closure());
    },
    setupParentData$1: function(child) {
      H.assertHelper(this.get$_debugCanPerformMutations());
      if (!(child.parentData instanceof K.ParentData))
        child.parentData = new K.ParentData();
    },
    adoptChild$1: function(child) {
      var _this = this;
      H.assertHelper(_this.get$_debugCanPerformMutations());
      H.assertHelper(child != null);
      _this.setupParentData$1(child);
      _this.markNeedsLayout$0();
      _this.markNeedsCompositingBitsUpdate$0();
      _this.markNeedsSemanticsUpdate$0();
      _this.super$AbstractNode$adoptChild(child);
    },
    dropChild$1: function(child) {
      var _this = this;
      H.interceptedTypeCheck(child, "$isRenderObject");
      H.assertHelper(_this.get$_debugCanPerformMutations());
      H.assertHelper(child != null);
      H.assertHelper(child.parentData != null);
      child._cleanRelayoutBoundary$0();
      child.parentData.detach$0();
      child.parentData = null;
      _this.super$AbstractNode$dropChild(child);
      _this.markNeedsLayout$0();
      _this.markNeedsCompositingBitsUpdate$0();
      _this.markNeedsSemanticsUpdate$0();
    },
    visitChildren$1: function(visitor) {
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [K.RenderObject]});
    },
    _debugReportException$3: function(method, exception, stack) {
      H.interceptedTypeCheck(stack, "$isStackTrace");
      U.FlutterError_reportError(K.FlutterErrorDetailsForRendering$("during " + method + "()", exception, new K.RenderObject__debugReportException_closure(this), "rendering library", this, stack));
    },
    get$_debugCanPerformMutations: function() {
      var t1 = {};
      t1.result = null;
      H.assertHelper(new K.RenderObject__debugCanPerformMutations_closure(t1, this).call$0());
      return t1.result;
    },
    get$owner: function() {
      return H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(this), "$isPipelineOwner");
    },
    attach$1: function(owner) {
      var _this = this;
      _this.super$AbstractNode$attach(H.interceptedTypeCheck(owner, "$isPipelineOwner"));
      if (_this._needsLayout && _this._relayoutBoundary != null) {
        _this._needsLayout = false;
        _this.markNeedsLayout$0();
      }
      if (_this._needsCompositingBitsUpdate) {
        _this._needsCompositingBitsUpdate = false;
        _this.markNeedsCompositingBitsUpdate$0();
      }
      if (_this._needsPaint && _this._layer != null) {
        _this._needsPaint = false;
        _this.markNeedsPaint$0();
      }
      if (_this._needsSemanticsUpdate && _this.get$_semanticsConfiguration()._isSemanticBoundary) {
        _this._needsSemanticsUpdate = false;
        _this.markNeedsSemanticsUpdate$0();
      }
    },
    get$debugNeedsLayout: function() {
      var t1 = {};
      t1.result = null;
      H.assertHelper(new K.RenderObject_debugNeedsLayout_closure(t1, this).call$0());
      return t1.result;
    },
    get$constraints: function() {
      return this._constraints;
    },
    _debugSubtreeRelayoutRootAlreadyMarkedNeedsLayout$0: function() {
      var node, t1;
      if (this._relayoutBoundary == null)
        return true;
      for (node = this; t1 = this._relayoutBoundary, node != t1;) {
        H.assertHelper(node._relayoutBoundary == t1);
        H.assertHelper(node._node$_parent != null);
        node = H.interceptedTypeCheck(node._node$_parent, "$isRenderObject");
        if (!node._needsLayout && !node._debugDoingThisLayout)
          return false;
      }
      H.assertHelper(node._relayoutBoundary == node);
      return true;
    },
    markNeedsLayout$0: function() {
      var _this = this;
      H.assertHelper(_this.get$_debugCanPerformMutations());
      if (_this._needsLayout) {
        H.assertHelper(_this._debugSubtreeRelayoutRootAlreadyMarkedNeedsLayout$0());
        return;
      }
      H.assertHelper(_this._relayoutBoundary != null);
      if (_this._relayoutBoundary !== _this)
        _this.markParentNeedsLayout$0();
      else {
        _this._needsLayout = true;
        if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner") != null) {
          H.assertHelper(new K.RenderObject_markNeedsLayout_closure(_this).call$0());
          C.JSArray_methods.add$1(H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._nodesNeedingLayout, _this);
          H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner").onNeedVisualUpdate.call$0();
        }
      }
    },
    markParentNeedsLayout$0: function() {
      var $parent, _this = this;
      _this._needsLayout = true;
      $parent = H.interceptedTypeCheck(_this._node$_parent, "$isRenderObject");
      if (!_this._doingThisLayoutWithCallback)
        $parent.markNeedsLayout$0();
      else
        H.assertHelper($parent._debugDoingThisLayout);
      H.assertHelper($parent == _this._node$_parent);
    },
    _cleanRelayoutBoundary$0: function() {
      var _this = this;
      if (_this._relayoutBoundary !== _this) {
        _this._relayoutBoundary = null;
        _this._needsLayout = true;
        _this.visitChildren$1(new K.RenderObject__cleanRelayoutBoundary_closure());
      }
    },
    scheduleInitialLayout$0: function() {
      var _this = this;
      H.assertHelper(_this._node$_owner != null);
      H.assertHelper(!(_this._node$_parent instanceof K.RenderObject));
      H.assertHelper(!H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._debugDoingLayout);
      H.assertHelper(_this._relayoutBoundary == null);
      _this._relayoutBoundary = _this;
      H.assertHelper(new K.RenderObject_scheduleInitialLayout_closure(_this).call$0());
      C.JSArray_methods.add$1(H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._nodesNeedingLayout, _this);
    },
    _layoutWithoutResize$0: function() {
      var e, stack, exception, _this = this, t1 = {};
      H.assertHelper(_this._relayoutBoundary === _this);
      t1.debugPreviousActiveLayout = null;
      H.assertHelper(!_this._debugMutationsLocked);
      H.assertHelper(!_this._doingThisLayoutWithCallback);
      H.assertHelper(_this._debugCanParentUseSize != null);
      H.assertHelper(new K.RenderObject__layoutWithoutResize_closure(t1, _this).call$0());
      try {
        _this.performLayout$0();
        _this.markNeedsSemanticsUpdate$0();
      } catch (exception) {
        e = H.unwrapException(exception);
        stack = H.getTraceFromException(exception);
        _this._debugReportException$3("performLayout", e, stack);
      }
      H.assertHelper(new K.RenderObject__layoutWithoutResize_closure0(t1, _this).call$0());
      _this._needsLayout = false;
      _this.markNeedsPaint$0();
    },
    layout$2$parentUsesSize: function(constraints, parentUsesSize) {
      var e, stack, e0, stack0, t2, t3, relayoutBoundary, exception, _this = this, t1 = {};
      H.assertHelper(constraints != null);
      H.assertHelper(constraints.debugAssertIsValid$2$informationCollector$isAppliedConstraint(new K.RenderObject_layout_closure(_this), true));
      H.assertHelper(!_this._debugDoingThisResize);
      H.assertHelper(!_this._debugDoingThisLayout);
      if (parentUsesSize)
        if (!_this.get$sizedByParent()) {
          t2 = constraints.minWidth;
          t3 = constraints.maxWidth;
          if (typeof t2 !== "number")
            return t2.$ge();
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (t2 >= t3) {
            t2 = constraints.minHeight;
            t3 = constraints.maxHeight;
            if (typeof t2 !== "number")
              return t2.$ge();
            if (typeof t3 !== "number")
              return H.iae(t3);
            t3 = t2 >= t3;
            t2 = t3;
          } else
            t2 = false;
          t2 = t2 || !(_this._node$_parent instanceof K.RenderObject);
        } else
          t2 = true;
      else
        t2 = true;
      relayoutBoundary = t2 ? _this : H.interceptedTypeCheck(_this._node$_parent, "$isRenderObject")._relayoutBoundary;
      H.assertHelper(new K.RenderObject_layout_closure0(_this, parentUsesSize).call$0());
      if (!_this._needsLayout && constraints.$eq(0, _this._constraints) && relayoutBoundary == _this._relayoutBoundary) {
        H.assertHelper(new K.RenderObject_layout_closure1(_this).call$0());
        return;
      }
      _this._constraints = constraints;
      _this._relayoutBoundary = relayoutBoundary;
      H.assertHelper(!_this._debugMutationsLocked);
      H.assertHelper(!_this._doingThisLayoutWithCallback);
      H.assertHelper(new K.RenderObject_layout_closure2(_this).call$0());
      if (_this.get$sizedByParent()) {
        H.assertHelper(new K.RenderObject_layout_closure3(_this).call$0());
        try {
          _this.performResize$0();
          H.assertHelper(new K.RenderObject_layout_closure4(_this).call$0());
        } catch (exception) {
          e = H.unwrapException(exception);
          stack = H.getTraceFromException(exception);
          _this._debugReportException$3("performResize", e, stack);
        }
        H.assertHelper(new K.RenderObject_layout_closure5(_this).call$0());
      }
      t1.debugPreviousActiveLayout = null;
      H.assertHelper(new K.RenderObject_layout_closure6(t1, _this).call$0());
      try {
        _this.performLayout$0();
        _this.markNeedsSemanticsUpdate$0();
        H.assertHelper(new K.RenderObject_layout_closure7(_this).call$0());
      } catch (exception) {
        e0 = H.unwrapException(exception);
        stack0 = H.getTraceFromException(exception);
        _this._debugReportException$3("performLayout", e0, stack0);
      }
      H.assertHelper(new K.RenderObject_layout_closure8(t1, _this).call$0());
      _this._needsLayout = false;
      _this.markNeedsPaint$0();
    },
    layout$1: function(constraints) {
      return this.layout$2$parentUsesSize(constraints, false);
    },
    debugResetSize$0: function() {
    },
    get$sizedByParent: function() {
      return false;
    },
    get$isRepaintBoundary: function() {
      return false;
    },
    debugRegisterRepaintBoundaryPaint$2$includedChild$includedParent: function(includedChild, includedParent) {
    },
    get$alwaysNeedsCompositing: function() {
      return false;
    },
    get$debugLayer: function() {
      var t1 = {};
      t1.result = null;
      H.assertHelper(new K.RenderObject_debugLayer_closure(t1, this).call$0());
      return t1.result;
    },
    markNeedsCompositingBitsUpdate$0: function() {
      var t1, _this = this;
      if (_this._needsCompositingBitsUpdate)
        return;
      _this._needsCompositingBitsUpdate = true;
      t1 = _this._node$_parent;
      if (t1 instanceof K.RenderObject) {
        if (t1._needsCompositingBitsUpdate)
          return;
        if (!_this.get$isRepaintBoundary() && !t1.get$isRepaintBoundary()) {
          t1.markNeedsCompositingBitsUpdate$0();
          return;
        }
      }
      H.assertHelper(new K.RenderObject_markNeedsCompositingBitsUpdate_closure(_this).call$0());
      if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner") != null)
        C.JSArray_methods.add$1(H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._nodesNeedingCompositingBitsUpdate, _this);
    },
    _updateCompositingBits$0: function() {
      var oldNeedsCompositing, _this = this;
      if (!_this._needsCompositingBitsUpdate)
        return;
      oldNeedsCompositing = _this._needsCompositing;
      _this._needsCompositing = false;
      _this.visitChildren$1(new K.RenderObject__updateCompositingBits_closure(_this));
      if (_this.get$isRepaintBoundary() || _this.get$alwaysNeedsCompositing())
        _this._needsCompositing = true;
      if (oldNeedsCompositing != _this._needsCompositing)
        _this.markNeedsPaint$0();
      _this._needsCompositingBitsUpdate = false;
    },
    markNeedsPaint$0: function() {
      var $parent, _this = this;
      H.assertHelper(H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner") == null || !H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._debugDoingPaint);
      if (_this._needsPaint)
        return;
      _this._needsPaint = true;
      if (_this.get$isRepaintBoundary()) {
        H.assertHelper(new K.RenderObject_markNeedsPaint_closure(_this).call$0());
        H.assertHelper(_this._layer != null);
        if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner") != null) {
          C.JSArray_methods.add$1(H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._nodesNeedingPaint, _this);
          H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner").onNeedVisualUpdate.call$0();
        }
      } else if (_this._node$_parent instanceof K.RenderObject) {
        H.assertHelper(_this._layer == null);
        $parent = H.interceptedTypeCheck(_this._node$_parent, "$isRenderObject");
        $parent.markNeedsPaint$0();
        H.assertHelper($parent === _this._node$_parent);
      } else {
        H.assertHelper(new K.RenderObject_markNeedsPaint_closure0(_this).call$0());
        if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner") != null)
          H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner").onNeedVisualUpdate.call$0();
      }
    },
    _skippedPaintingOnLayer$0: function() {
      var ancestor, t1, _this = this;
      H.assertHelper(_this._node$_owner != null);
      H.assertHelper(_this.get$isRepaintBoundary());
      H.assertHelper(_this._needsPaint);
      H.assertHelper(_this._layer != null);
      H.assertHelper(_this._layer._node$_owner == null);
      ancestor = _this._node$_parent;
      for (; ancestor instanceof K.RenderObject;) {
        if (ancestor.get$isRepaintBoundary()) {
          t1 = ancestor._layer;
          if (t1 == null)
            break;
          if (t1._node$_owner != null)
            break;
          ancestor._needsPaint = true;
        }
        ancestor = ancestor._node$_parent;
      }
    },
    _paintWithContext$2: function(context, offset) {
      var e, stack, exception, _this = this, t1 = {};
      H.assertHelper(new K.RenderObject__paintWithContext_closure(_this).call$0());
      if (_this._needsLayout)
        return;
      H.assertHelper(new K.RenderObject__paintWithContext_closure0(_this).call$0());
      t1.debugLastActivePaint = null;
      H.assertHelper(new K.RenderObject__paintWithContext_closure1(t1, _this).call$0());
      _this._needsPaint = false;
      try {
        _this.paint$2(context, offset);
        H.assertHelper(!_this._needsLayout);
        H.assertHelper(!_this._needsPaint);
      } catch (exception) {
        e = H.unwrapException(exception);
        stack = H.getTraceFromException(exception);
        _this._debugReportException$3("paint", e, stack);
      }
      H.assertHelper(new K.RenderObject__paintWithContext_closure2(t1, _this, context, offset).call$0());
    },
    debugPaint$2: function(context, offset) {
    },
    paint$2: function(context, offset) {
    },
    applyPaintTransform$2: function(child, transform) {
      H.assertHelper(child._node$_parent === this);
    },
    getTransformTo$1: function(ancestor) {
      var rootNode, renderers, renderer, transform, index, t1, t2;
      H.assertHelper(this._node$_owner != null);
      if (ancestor == null) {
        rootNode = H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(this), "$isPipelineOwner")._rootNode;
        if (rootNode instanceof K.RenderObject)
          ancestor = rootNode;
      }
      renderers = H.setRuntimeTypeInfo([], [K.RenderObject]);
      for (renderer = this; renderer != ancestor; renderer = H.interceptedTypeCheck(renderer._node$_parent, "$isRenderObject")) {
        H.assertHelper(renderer != null);
        C.JSArray_methods.add$1(renderers, renderer);
      }
      transform = new E.Matrix4(new Float64Array(16));
      transform.setIdentity$0();
      for (index = renderers.length - 1; index > 0;) {
        t1 = renderers.length;
        if (index >= t1)
          return H.ioore(renderers, index);
        t2 = renderers[index];
        --index;
        if (index >= t1)
          return H.ioore(renderers, index);
        t2.applyPaintTransform$2(renderers[index], transform);
      }
      return transform;
    },
    describeApproximatePaintClip$1: function(child) {
      return;
    },
    describeSemanticsConfiguration$1: function(config) {
    },
    sendSemanticsEvent$1: function(semanticsEvent) {
      var t1;
      if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(this), "$isPipelineOwner")._semanticsOwner == null)
        return;
      t1 = this._semantics;
      if (t1 != null && !t1._isMergedIntoParent)
        t1.sendEvent$1(semanticsEvent);
      else {
        t1 = this._node$_parent;
        if (t1 != null)
          H.interceptedTypeCheck(t1, "$isRenderObject").sendSemanticsEvent$1(semanticsEvent);
      }
    },
    get$_semanticsConfiguration: function() {
      var t1, _this = this;
      if (_this._cachedSemanticsConfiguration == null) {
        t1 = new A.SemanticsConfiguration(P.LinkedHashMap_LinkedHashMap$_empty(P.SemanticsAction, {func: 1, ret: -1, args: [,]}), P.LinkedHashMap_LinkedHashMap$_empty(A.CustomSemanticsAction, {func: 1, ret: -1}));
        _this._cachedSemanticsConfiguration = t1;
        _this.describeSemanticsConfiguration$1(t1);
      }
      return _this._cachedSemanticsConfiguration;
    },
    get$debugSemantics: function() {
      var t1 = {};
      t1.result = null;
      H.assertHelper(new K.RenderObject_debugSemantics_closure(t1, this).call$0());
      return t1.result;
    },
    clearSemantics$0: function() {
      this._needsSemanticsUpdate = true;
      this._semantics = null;
      this.visitChildren$1(new K.RenderObject_clearSemantics_closure());
    },
    markNeedsSemanticsUpdate$0: function() {
      var t1, wasSemanticsBoundary, isEffectiveSemanticsBoundary, t2, t3, t4, node, t5, _this = this;
      H.assertHelper(_this._node$_owner == null || !H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._debugDoingSemantics);
      if (_this._node$_owner == null || H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._semanticsOwner == null)
        return _this._cachedSemanticsConfiguration = null;
      if (_this._semantics != null) {
        t1 = _this._cachedSemanticsConfiguration;
        wasSemanticsBoundary = (t1 == null ? null : t1._isSemanticBoundary) === true;
      } else
        wasSemanticsBoundary = false;
      _this._cachedSemanticsConfiguration = null;
      isEffectiveSemanticsBoundary = _this.get$_semanticsConfiguration()._isSemanticBoundary && wasSemanticsBoundary;
      t1 = P.SemanticsAction;
      t2 = {func: 1, ret: -1, args: [,]};
      t3 = A.CustomSemanticsAction;
      t4 = {func: 1, ret: -1};
      node = _this;
      while (true) {
        if (!(!isEffectiveSemanticsBoundary && node._node$_parent instanceof K.RenderObject))
          break;
        if (node !== _this && node._needsSemanticsUpdate)
          break;
        node._needsSemanticsUpdate = true;
        node = H.interceptedTypeCheck(node._node$_parent, "$isRenderObject");
        if (node._cachedSemanticsConfiguration == null) {
          t5 = new A.SemanticsConfiguration(P.LinkedHashMap_LinkedHashMap$_empty(t1, t2), P.LinkedHashMap_LinkedHashMap$_empty(t3, t4));
          node._cachedSemanticsConfiguration = t5;
          node.describeSemanticsConfiguration$1(t5);
        }
        isEffectiveSemanticsBoundary = node._cachedSemanticsConfiguration._isSemanticBoundary;
        if (isEffectiveSemanticsBoundary && node._semantics == null)
          return;
      }
      if (node !== _this && _this._semantics != null && _this._needsSemanticsUpdate)
        H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._nodesNeedingSemantics.remove$1(0, _this);
      if (!node._needsSemanticsUpdate) {
        node._needsSemanticsUpdate = true;
        if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner") != null) {
          H.assertHelper(node.get$_semanticsConfiguration()._isSemanticBoundary || !(node._node$_parent instanceof K.RenderObject));
          H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._nodesNeedingSemantics.add$1(0, node);
          H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner").onNeedVisualUpdate.call$0();
        }
      }
    },
    _updateSemantics$0: function() {
      var t1, fragment, t2, t3, t4, node, _this = this, _null = null;
      H.assertHelper(_this.get$_semanticsConfiguration()._isSemanticBoundary || !(_this._node$_parent instanceof K.RenderObject));
      if (_this._needsLayout)
        return;
      t1 = _this._semantics;
      t1 = t1 == null ? _null : H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(t1), "$isSemanticsNode");
      if (t1 == null)
        t1 = _null;
      else
        t1 = t1._mergeAllDescendantsIntoThisNode || t1._isMergedIntoParent;
      fragment = _this._getSemanticsForParent$1$mergeIntoParent(t1 === true);
      H.assertHelper(!!fragment.$is_InterestingSemanticsFragment);
      t1 = _this._semantics;
      t2 = t1 == null;
      t3 = t2 ? _null : t1.parentSemanticsClipRect;
      t4 = t2 ? _null : t1.parentPaintClipRect;
      t1 = t2 ? _null : t1.elevationAdjustment;
      t1 = fragment.compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect(t1 == null ? 0 : t1, t4, t3);
      node = t1.get$single(t1);
      H.assertHelper(fragment.get$config() == null && node == _this._semantics);
    },
    _getSemanticsForParent$1$mergeIntoParent: function(mergeIntoParent) {
      var config, producesForkingFragment, t1, t2, fragments, toBeMarkedExplicit, childrenMergeIntoParent, t3, result, _this = this, _box_0 = {};
      if (H.assertTest(!_this._needsLayout))
        H.assertThrow("Updated layout information required for " + _this.toString$0(0) + " to calculate semantics.");
      config = _this.get$_semanticsConfiguration();
      _box_0.dropSemanticsOfPreviousSiblings = config.isBlockingSemanticsOfPreviouslyPaintedNodes;
      producesForkingFragment = !config._hasBeenAnnotated && !config._isSemanticBoundary;
      t1 = K._InterestingSemanticsFragment;
      t2 = [t1];
      fragments = H.setRuntimeTypeInfo([], t2);
      toBeMarkedExplicit = P.LinkedHashSet_LinkedHashSet$_empty(t1);
      t1 = !mergeIntoParent;
      childrenMergeIntoParent = !t1 || config._isMergingSemanticsOfDescendants;
      _box_0.abortWalk = false;
      _this.visitChildrenForSemantics$1(new K.RenderObject__getSemanticsForParent_closure(_box_0, _this, childrenMergeIntoParent, fragments, toBeMarkedExplicit, config, producesForkingFragment));
      if (_box_0.abortWalk)
        return new K._AbortingSemanticsFragment(H.setRuntimeTypeInfo([_this], [K.RenderObject]), false);
      for (t3 = P._LinkedHashSetIterator$(toBeMarkedExplicit, toBeMarkedExplicit._collection$_modifications, H.getTypeArgumentByIndex(toBeMarkedExplicit, 0)); t3.moveNext$0();)
        t3._collection$_current.markAsExplicit$0();
      _this._needsSemanticsUpdate = false;
      if (!(_this._node$_parent instanceof K.RenderObject)) {
        H.assertHelper(!config._hasBeenAnnotated);
        H.assertHelper(t1);
        t1 = _box_0.dropSemanticsOfPreviousSiblings;
        result = new K._RootSemanticsFragment(H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([_this], [K.RenderObject]), t1);
      } else {
        t1 = _box_0.dropSemanticsOfPreviousSiblings;
        if (producesForkingFragment)
          result = new K._ContainerSemanticsFragment(H.setRuntimeTypeInfo([], t2), t1);
        else {
          result = new K._SwitchableSemanticsFragment(mergeIntoParent, config, H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([_this], [K.RenderObject]), t1);
          if (config._isSemanticBoundary)
            result._isExplicit = true;
        }
      }
      result.addAll$1(0, fragments);
      return result;
    },
    visitChildrenForSemantics$1: function(visitor) {
      this.visitChildren$1(H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [K.RenderObject]}));
    },
    assembleSemanticsNode$3: function(node, config, children) {
      var t1 = A.SemanticsNode;
      H.assertSubtype(children, "$isIterable", [t1], "$asIterable");
      H.assertHelper(node === this._semantics);
      node.updateWith$2$childrenInInversePaintOrder$config(H.assertSubtype(children, "$isList", [t1], "$asList"), config);
    },
    handleEvent$2: function($event, entry) {
    },
    toStringShort$0: function() {
      var target, count, _this = this,
        header = _this.get$runtimeType(_this).toString$0(0) + "#" + Y.shortHash(_this),
        t1 = _this._relayoutBoundary;
      if (t1 != null && t1 !== _this) {
        target = H.interceptedTypeCheck(_this._node$_parent, "$isRenderObject");
        count = 1;
        while (true) {
          if (!(target != null && target !== t1))
            break;
          target = H.interceptedTypeCheck(target._node$_parent, "$isRenderObject");
          ++count;
        }
        header += " relayoutBoundary=up" + count;
      }
      if (_this._needsLayout)
        header += " NEEDS-LAYOUT";
      if (_this._needsPaint)
        header += " NEEDS-PAINT";
      return _this._node$_owner == null ? header + " DETACHED" : header;
    },
    toString$0: function(_) {
      return this.toStringShort$0();
    },
    toStringDeep$0: function() {
      var result, t1 = {};
      t1.debugPreviousActiveLayout = null;
      H.assertHelper(new K.RenderObject_toStringDeep_closure(t1).call$0());
      result = this.super$DiagnosticableTreeMixin$toStringDeep(C.DiagnosticLevel_2, "", "");
      H.assertHelper(new K.RenderObject_toStringDeep_closure0(t1).call$0());
      return result;
    },
    toStringShallow$1$joiner: function(joiner) {
      var result, t1 = {};
      t1.debugPreviousActiveLayout = null;
      H.assertHelper(new K.RenderObject_toStringShallow_closure(t1).call$0());
      result = this.super$DiagnosticableTreeMixin$toStringShallow(joiner, C.DiagnosticLevel_2);
      H.assertHelper(new K.RenderObject_toStringShallow_closure0(t1).call$0());
      return result;
    },
    toStringShallow$0: function() {
      return this.toStringShallow$1$joiner(", ");
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _this = this, _null = null;
      _this.super$DiagnosticableTreeMixin$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("creator", _this.debugCreator, _null, _null, _null, _null, C.DiagnosticLevel_2, false, true, true, C.DiagnosticsTreeStyle_5, _null, _null);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      t1 = _this.parentData;
      t3 = _this._debugCanParentUseSize === true ? "can use size" : _null;
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("parentData", t1, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, true, true, true, C.DiagnosticsTreeStyle_5, t3, K.ParentData));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("constraints", _this.get$constraints(), C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, true, true, true, C.DiagnosticsTreeStyle_5, _null, K.Constraints));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("layer", _this._layer, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, T.OffsetLayer));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("semantics node", _this._semantics, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, A.SemanticsNode));
      C.JSArray_methods.add$1(t2, Y.FlagProperty$("isBlockingSemanticsOfPreviouslyPaintedNodes", _null, _null, "blocks semantics of earlier render objects below the common boundary", C.DiagnosticLevel_3, false, _this.get$_semanticsConfiguration().isBlockingSemanticsOfPreviouslyPaintedNodes));
      C.JSArray_methods.add$1(t2, Y.FlagProperty$("isSemanticBoundary", _null, _null, "semantic boundary", C.DiagnosticLevel_3, false, _this.get$_semanticsConfiguration()._isSemanticBoundary));
    },
    debugDescribeChildren$0: function() {
      return H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]);
    },
    showOnScreen$4$curve$descendant$duration$rect: function(curve, descendant, duration, rect) {
      var t1 = this._node$_parent;
      if (t1 instanceof K.RenderObject)
        t1.showOnScreen$4$curve$descendant$duration$rect(curve, descendant == null ? this : descendant, duration, rect);
    },
    showOnScreen$0: function() {
      return this.showOnScreen$4$curve$descendant$duration$rect(C.Cubic_JUR0, null, C.Duration_0, null);
    },
    $isDiagnosticable: 1,
    $isDiagnosticableTree: 1,
    $isHitTestTarget: 1,
    get$parentData: function() {
      return this.parentData;
    }
  };
  K.RenderObject_reassemble_closure.prototype = {
    call$1: function(child) {
      child.reassemble$0();
    },
    $signature: 10
  };
  K.RenderObject__debugReportException_closure.prototype = {
    call$1: function(information) {
      var t2, descendants, t1 = {};
      information._contents += "The following RenderObject was being processed when the exception was fired:\n";
      t2 = this.$this;
      information._contents += "  " + t2.toStringShallow$1$joiner("\n  ") + "\n";
      descendants = H.setRuntimeTypeInfo([], [P.String]);
      t1.lines = t1.depth = 0;
      t2.visitChildren$1(new K.RenderObject__debugReportException_closure_visitor(t1, 25, descendants, 5));
      if (t1.lines > 1)
        t1 = information._contents += "This RenderObject had the following descendants (showing up to depth 5):\n";
      else {
        t1 = descendants.length;
        t2 = information._contents;
        if (t1 === 1) {
          t1 = t2 + "This RenderObject had the following child:\n";
          information._contents = t1;
        } else {
          t1 = t2 + "This RenderObject has no descendants.\n";
          information._contents = t1;
        }
      }
      information._contents = P.StringBuffer__writeAll(t1, descendants, "\n");
    },
    $signature: 3
  };
  K.RenderObject__debugReportException_closure_visitor.prototype = {
    call$1: function(child) {
      var _this = this,
        t1 = _this._box_0,
        t2 = t1.lines,
        t3 = _this.maxLines;
      if (t2 < t3) {
        C.JSArray_methods.add$1(_this.descendants, C.JSString_methods.$mul("  ", ++t1.depth) + H.S(child));
        if (t1.depth < _this.maxDepth)
          child.visitChildren$1(_this);
        --t1.depth;
      } else if (t2 === t3)
        C.JSArray_methods.add$1(_this.descendants, "  ...(descendants list truncated after " + t2 + " lines)");
      ++t1.lines;
    },
    $signature: 33
  };
  K.RenderObject__debugCanPerformMutations_closure.prototype = {
    call$0: function() {
      var node0, _this = this,
        node = _this.$this;
      for (node0 = node; true;) {
        if (node0._doingThisLayoutWithCallback) {
          _this._box_0.result = true;
          break;
        }
        if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(node), "$isPipelineOwner") != null && H.boolConversionCheck(H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(node), "$isPipelineOwner")._debugAllowMutationsToDirtySubtrees) && node0._needsLayout) {
          _this._box_0.result = true;
          break;
        }
        if (node0._debugMutationsLocked) {
          _this._box_0.result = false;
          break;
        }
        node0 = node0._node$_parent;
        if (!(node0 instanceof K.RenderObject)) {
          _this._box_0.result = true;
          break;
        }
      }
      return true;
    },
    $signature: 0
  };
  K.RenderObject_debugNeedsLayout_closure.prototype = {
    call$0: function() {
      this._box_0.result = this.$this._needsLayout;
      return true;
    },
    $signature: 0
  };
  K.RenderObject_markNeedsLayout_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  K.RenderObject__cleanRelayoutBoundary_closure.prototype = {
    call$1: function(child) {
      child._cleanRelayoutBoundary$0();
    },
    $signature: 10
  };
  K.RenderObject_scheduleInitialLayout_closure.prototype = {
    call$0: function() {
      this.$this._debugCanParentUseSize = false;
      return true;
    },
    $signature: 0
  };
  K.RenderObject__layoutWithoutResize_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._debugDoingThisLayout = t1._debugMutationsLocked = true;
      this._box_0.debugPreviousActiveLayout = $.RenderObject__debugActiveLayout;
      $.RenderObject__debugActiveLayout = t1;
      return true;
    },
    $signature: 0
  };
  K.RenderObject__layoutWithoutResize_closure0.prototype = {
    call$0: function() {
      $.RenderObject__debugActiveLayout = this._box_0.debugPreviousActiveLayout;
      var t1 = this.$this;
      t1._debugMutationsLocked = t1._debugDoingThisLayout = false;
      return true;
    },
    $signature: 0
  };
  K.RenderObject_layout_closure.prototype = {
    call$1: function(information) {
      var targetFrame, t1, targetFrameMatch,
        stack = H.setRuntimeTypeInfo(J.toString$0$(P.StackTrace_current()).split("\n"), [P.String]),
        layoutFramePattern = P.RegExp_RegExp("^#[0-9]+ +RenderObject.layout \\("),
        i = 0;
      while (true) {
        if (!(i < stack.length)) {
          targetFrame = null;
          break;
        }
        t1 = H.stringTypeCheck(stack[i]);
        t1.length;
        if (layoutFramePattern._execAnchored$2(t1, 0) != null) {
          targetFrame = i + 1;
          break;
        }
        ++i;
      }
      if (targetFrame != null && targetFrame < stack.length) {
        information._contents += "These invalid constraints were provided to " + new H.TypeImpl(H.getRti(this.$this)).toString$0(0) + "'s layout() function by the following function, which probably computed the invalid constraints in question:\n";
        targetFrameMatch = P.RegExp_RegExp("^#[0-9]+ +(.+)$").matchAsPrefix$1(0, C.JSArray_methods.$index(stack, targetFrame));
        if (targetFrameMatch != null && targetFrameMatch._match.length - 1 > 0) {
          t1 = targetFrameMatch._match;
          if (1 >= t1.length)
            return H.ioore(t1, 1);
          information._contents += "  " + H.S(t1[1]) + "\n";
        } else
          information._contents += H.S(C.JSArray_methods.$index(stack, targetFrame)) + "\n";
      }
    },
    $signature: 3
  };
  K.RenderObject_layout_closure0.prototype = {
    call$0: function() {
      this.$this._debugCanParentUseSize = this.parentUsesSize;
      return true;
    },
    $signature: 0
  };
  K.RenderObject_layout_closure1.prototype = {
    call$0: function() {
      var debugPreviousActiveLayout,
        t1 = this.$this;
      t1._debugDoingThisResize = t1.get$sizedByParent();
      t1._debugDoingThisLayout = !t1.get$sizedByParent();
      debugPreviousActiveLayout = $.RenderObject__debugActiveLayout;
      $.RenderObject__debugActiveLayout = t1;
      t1.debugResetSize$0();
      $.RenderObject__debugActiveLayout = debugPreviousActiveLayout;
      t1._debugDoingThisResize = t1._debugDoingThisLayout = false;
      return true;
    },
    $signature: 0
  };
  K.RenderObject_layout_closure2.prototype = {
    call$0: function() {
      this.$this._debugMutationsLocked = true;
      return true;
    },
    $signature: 0
  };
  K.RenderObject_layout_closure3.prototype = {
    call$0: function() {
      return this.$this._debugDoingThisResize = true;
    },
    $signature: 0
  };
  K.RenderObject_layout_closure4.prototype = {
    call$0: function() {
      this.$this.debugAssertDoesMeetConstraints$0();
      return true;
    },
    $signature: 0
  };
  K.RenderObject_layout_closure5.prototype = {
    call$0: function() {
      this.$this._debugDoingThisResize = false;
      return true;
    },
    $signature: 0
  };
  K.RenderObject_layout_closure6.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._debugDoingThisLayout = true;
      this._box_0.debugPreviousActiveLayout = $.RenderObject__debugActiveLayout;
      $.RenderObject__debugActiveLayout = t1;
      return true;
    },
    $signature: 0
  };
  K.RenderObject_layout_closure7.prototype = {
    call$0: function() {
      this.$this.debugAssertDoesMeetConstraints$0();
      return true;
    },
    $signature: 0
  };
  K.RenderObject_layout_closure8.prototype = {
    call$0: function() {
      $.RenderObject__debugActiveLayout = this._box_0.debugPreviousActiveLayout;
      var t1 = this.$this;
      t1._debugMutationsLocked = t1._debugDoingThisLayout = false;
      return true;
    },
    $signature: 0
  };
  K.RenderObject_debugLayer_closure.prototype = {
    call$0: function() {
      this._box_0.result = this.$this._layer;
      return true;
    },
    $signature: 0
  };
  K.RenderObject_markNeedsCompositingBitsUpdate_closure.prototype = {
    call$0: function() {
      var $parent = this.$this._node$_parent;
      if ($parent instanceof K.RenderObject)
        return $parent._needsCompositing;
      return true;
    },
    $signature: 0
  };
  K.RenderObject__updateCompositingBits_closure.prototype = {
    call$1: function(child) {
      child._updateCompositingBits$0();
      H.assertHelper(!child._needsCompositingBitsUpdate);
      if (H.boolConversionCheck(child._needsCompositing))
        this.$this._needsCompositing = true;
    },
    $signature: 10
  };
  K.RenderObject_markNeedsPaint_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  K.RenderObject_markNeedsPaint_closure0.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  K.RenderObject__paintWithContext_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (t1._debugDoingThisPaint)
        throw H.wrapException(U.FlutterError$("Tried to paint a RenderObject reentrantly.\nThe following RenderObject was already being painted when it was painted again:\n  " + t1.toStringShallow$1$joiner("\n    ") + "\nSince this typically indicates an infinite recursion, it is disallowed."));
      return true;
    },
    $signature: 0
  };
  K.RenderObject__paintWithContext_closure0.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (t1._needsCompositingBitsUpdate)
        throw H.wrapException(U.FlutterError$("Tried to paint a RenderObject before its compositing bits were updated.\nThe following RenderObject was marked as having dirty compositing bits at the time that it was painted:\n  " + t1.toStringShallow$1$joiner("\n    ") + "\nA RenderObject that still has dirty compositing bits cannot be painted because this indicates that the tree has not yet been properly configured for creating the layer tree.\nThis usually indicates an error in the Flutter framework itself."));
      return true;
    },
    $signature: 0
  };
  K.RenderObject__paintWithContext_closure1.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._debugDoingThisPaint = true;
      this._box_0.debugLastActivePaint = $.RenderObject__debugActivePaint;
      $.RenderObject__debugActivePaint = t1;
      H.assertHelper(!t1.get$isRepaintBoundary() || t1._layer != null);
      return true;
    },
    $signature: 0
  };
  K.RenderObject__paintWithContext_closure2.prototype = {
    call$0: function() {
      var _this = this,
        t1 = _this.$this;
      t1.debugPaint$2(_this.context, _this.offset);
      $.RenderObject__debugActivePaint = _this._box_0.debugLastActivePaint;
      t1._debugDoingThisPaint = false;
      return true;
    },
    $signature: 0
  };
  K.RenderObject_debugSemantics_closure.prototype = {
    call$0: function() {
      this._box_0.result = this.$this._semantics;
      return true;
    },
    $signature: 0
  };
  K.RenderObject_clearSemantics_closure.prototype = {
    call$1: function(child) {
      child.clearSemantics$0();
    },
    $signature: 10
  };
  K.RenderObject__getSemanticsForParent_closure.prototype = {
    call$1: function(renderChild) {
      var parentFragment, t2, t3, t4, t5, t6, t7, t8, t9, _i, siblingFragment, _this = this,
        t1 = _this._box_0;
      if (t1.abortWalk || _this.$this._needsLayout) {
        t1.abortWalk = true;
        return;
      }
      parentFragment = renderChild._getSemanticsForParent$1$mergeIntoParent(_this.childrenMergeIntoParent);
      if (parentFragment.get$abortsWalk()) {
        t1.abortWalk = true;
        return;
      }
      if (parentFragment.dropsSemanticsOfPreviousSiblings) {
        C.JSArray_methods.set$length(_this.fragments, 0);
        _this.toBeMarkedExplicit.clear$0(0);
        if (!_this.config._isSemanticBoundary)
          t1.dropSemanticsOfPreviousSiblings = true;
      }
      for (t1 = J.get$iterator$ax(parentFragment.get$interestingFragments()), t2 = _this.fragments, t3 = _this.toBeMarkedExplicit, t4 = _this.config, t5 = _this.$this, t6 = _this.producesForkingFragment; t1.moveNext$0();) {
        t7 = t1.get$current();
        C.JSArray_methods.add$1(t2, t7);
        C.JSArray_methods.add$1(t7._ancestorChain, t5);
        t7.addTags$1(t4._tagsForChildren);
        if (t4.explicitChildNodes || !(t5._node$_parent instanceof K.RenderObject)) {
          t7.markAsExplicit$0();
          continue;
        }
        if (t7.get$config() == null || t6)
          continue;
        if (!t4.isCompatibleWith$1(t7.get$config()))
          t3.add$1(0, t7);
        for (t8 = C.JSArray_methods.sublist$2(t2, 0, t2.length - 1), t9 = t8.length, _i = 0; _i < t8.length; t8.length === t9 || (0, H.throwConcurrentModificationError)(t8), ++_i) {
          siblingFragment = t8[_i];
          if (!t7.get$config().isCompatibleWith$1(siblingFragment.get$config())) {
            t3.add$1(0, t7);
            t3.add$1(0, siblingFragment);
          }
        }
      }
    },
    $signature: 10
  };
  K.RenderObject_toStringDeep_closure.prototype = {
    call$0: function() {
      this._box_0.debugPreviousActiveLayout = $.RenderObject__debugActiveLayout;
      $.RenderObject__debugActiveLayout = null;
      return true;
    },
    $signature: 0
  };
  K.RenderObject_toStringDeep_closure0.prototype = {
    call$0: function() {
      $.RenderObject__debugActiveLayout = this._box_0.debugPreviousActiveLayout;
      return true;
    },
    $signature: 0
  };
  K.RenderObject_toStringShallow_closure.prototype = {
    call$0: function() {
      this._box_0.debugPreviousActiveLayout = $.RenderObject__debugActiveLayout;
      $.RenderObject__debugActiveLayout = null;
      return true;
    },
    $signature: 0
  };
  K.RenderObject_toStringShallow_closure0.prototype = {
    call$0: function() {
      $.RenderObject__debugActiveLayout = this._box_0.debugPreviousActiveLayout;
      return true;
    },
    $signature: 0
  };
  K.RenderObjectWithChildMixin.prototype = {
    debugValidateChild$1: function(child) {
      H.assertHelper(new K.RenderObjectWithChildMixin_debugValidateChild_closure(this, child).call$0());
      return true;
    },
    set$child: function(value) {
      var t1, _this = this;
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(_this, "RenderObjectWithChildMixin", 0));
      t1 = _this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        _this.dropChild$1(t1);
      _this.set$_object$_child(value);
      t1 = _this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        _this.adoptChild$1(t1);
    },
    redepthChildren$0: function() {
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        this.redepthChild$1(t1);
    },
    visitChildren$1: function(visitor) {
      var t1;
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [K.RenderObject]});
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        visitor.call$1(t1);
    },
    debugDescribeChildren$0: function() {
      var t1 = this.RenderObjectWithChildMixin__child,
        t2 = [Y.DiagnosticsNode];
      return t1 != null ? H.setRuntimeTypeInfo([new Y._DiagnosticableTreeNode(t1, "child", true, true, null)], t2) : H.setRuntimeTypeInfo([], t2);
    },
    set$_object$_child: function(_child) {
      this.RenderObjectWithChildMixin__child = H.assertSubtypeOfRuntimeType(_child, H.getRuntimeTypeArgument(this, "RenderObjectWithChildMixin", 0));
    }
  };
  K.RenderObjectWithChildMixin_debugValidateChild_closure.prototype = {
    call$0: function() {
      var t4,
        t1 = this.child,
        t2 = this.$this,
        t3 = H.getRuntimeTypeArgument(t2, "RenderObjectWithChildMixin", 0);
      if (!H.checkSubtypeOfRuntimeType(t1, t3)) {
        t4 = J.getInterceptor$(t1);
        throw H.wrapException(U.FlutterError$("A " + H.getRuntimeType(t2).toString$0(0) + " expected a child of type " + H.TypeImpl$(t3).toString$0(0) + " but received a child of type " + t4.get$runtimeType(t1).toString$0(0) + ".\nRenderObjects expect specific types of children because they coordinate with their children during layout and paint. For example, a RenderSliver cannot be the child of a RenderBox because a RenderSliver does not understand the RenderBox layout protocol.\n\nThe " + H.getRuntimeType(t2).toString$0(0) + " that expected a " + H.TypeImpl$(t3).toString$0(0) + " child was created by:\n  " + H.S(t2.debugCreator) + "\n\nThe " + t4.get$runtimeType(t1).toString$0(0) + " that did not match the expected child type was created by:\n  " + H.S(t1.debugCreator) + "\n"));
      }
      return true;
    },
    $signature: 0
  };
  K.ContainerParentDataMixin.prototype = {
    set$previousSibling: function(previousSibling) {
      this.ContainerParentDataMixin_previousSibling = H.assertSubtypeOfRuntimeType(previousSibling, H.getRuntimeTypeArgument(this, "ContainerParentDataMixin", 0));
    },
    set$nextSibling: function(nextSibling) {
      this.ContainerParentDataMixin_nextSibling = H.assertSubtypeOfRuntimeType(nextSibling, H.getRuntimeTypeArgument(this, "ContainerParentDataMixin", 0));
    },
    $isParentData: 1,
    get$previousSibling: function() {
      return this.ContainerParentDataMixin_previousSibling;
    },
    get$nextSibling: function() {
      return this.ContainerParentDataMixin_nextSibling;
    }
  };
  K.ContainerRenderObjectMixin.prototype = {
    _debugUltimatePreviousSiblingOf$2$equals: function(child, equals) {
      var childParentData, t2,
        t1 = H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 0);
      H.assertSubtypeOfRuntimeType(child, t1);
      H.assertSubtypeOfRuntimeType(equals, t1);
      t1 = H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 1);
      childParentData = H.assertSubtypeOfRuntimeType(child.get$parentData(), t1);
      for (; childParentData.get$previousSibling() != null;) {
        t2 = childParentData.get$previousSibling();
        H.assertHelper(t2 == null ? child != null : t2 !== child);
        child = childParentData.get$previousSibling();
        childParentData = H.assertSubtypeOfRuntimeType(child.parentData, t1);
      }
      return J.$eq$(child, equals);
    },
    _debugUltimateNextSiblingOf$2$equals: function(child, equals) {
      var childParentData, t2,
        t1 = H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 0);
      H.assertSubtypeOfRuntimeType(child, t1);
      H.assertSubtypeOfRuntimeType(equals, t1);
      t1 = H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 1);
      childParentData = H.assertSubtypeOfRuntimeType(child.get$parentData(), t1);
      for (; childParentData.get$nextSibling() != null;) {
        t2 = childParentData.get$nextSibling();
        H.assertHelper(t2 == null ? child != null : t2 !== child);
        child = childParentData.get$nextSibling();
        childParentData = H.assertSubtypeOfRuntimeType(child.parentData, t1);
      }
      return J.$eq$(child, equals);
    },
    debugValidateChild$1: function(child) {
      H.assertHelper(new K.ContainerRenderObjectMixin_debugValidateChild_closure(this, child).call$0());
      return true;
    },
    _insertIntoChildList$2$after: function(child, after) {
      var childParentData, t2, afterParentData, childPreviousSiblingParentData, childNextSiblingParentData, _this = this,
        t1 = H.getRuntimeTypeArgument(_this, "ContainerRenderObjectMixin", 0);
      H.assertSubtypeOfRuntimeType(child, t1);
      H.assertSubtypeOfRuntimeType(after, t1);
      t1 = H.getRuntimeTypeArgument(_this, "ContainerRenderObjectMixin", 1);
      childParentData = H.assertSubtypeOfRuntimeType(child.parentData, t1);
      H.assertHelper(childParentData.get$nextSibling() == null);
      H.assertHelper(childParentData.get$previousSibling() == null);
      H.assertHelper(++_this.ContainerRenderObjectMixin__childCount > 0);
      t2 = _this.ContainerRenderObjectMixin__firstChild;
      if (after == null) {
        childParentData.set$nextSibling(t2);
        t2 = _this.ContainerRenderObjectMixin__firstChild;
        if (t2 != null)
          H.assertSubtypeOfRuntimeType(t2.parentData, t1).set$previousSibling(child);
        _this.set$_firstChild(child);
        if (_this.ContainerRenderObjectMixin__lastChild == null)
          _this.set$_lastChild(child);
      } else {
        H.assertHelper(t2 != null);
        H.assertHelper(_this.ContainerRenderObjectMixin__lastChild != null);
        H.assertHelper(_this._debugUltimatePreviousSiblingOf$2$equals(after, _this.ContainerRenderObjectMixin__firstChild));
        H.assertHelper(_this._debugUltimateNextSiblingOf$2$equals(after, _this.ContainerRenderObjectMixin__lastChild));
        afterParentData = H.assertSubtypeOfRuntimeType(after.parentData, t1);
        if (afterParentData.get$nextSibling() == null) {
          H.assertHelper(after === _this.ContainerRenderObjectMixin__lastChild);
          childParentData.set$previousSibling(after);
          afterParentData.set$nextSibling(child);
          _this.set$_lastChild(child);
        } else {
          childParentData.set$nextSibling(afterParentData.get$nextSibling());
          childParentData.set$previousSibling(after);
          childPreviousSiblingParentData = H.assertSubtypeOfRuntimeType(childParentData.get$previousSibling().parentData, t1);
          childNextSiblingParentData = H.assertSubtypeOfRuntimeType(childParentData.get$nextSibling().parentData, t1);
          childPreviousSiblingParentData.set$nextSibling(child);
          childNextSiblingParentData.set$previousSibling(child);
          H.assertHelper(afterParentData.get$nextSibling() == child);
        }
      }
    },
    insert$2$after: function(_, child, after) {
      var _this = this,
        t1 = H.getRuntimeTypeArgument(_this, "ContainerRenderObjectMixin", 0);
      H.assertSubtypeOfRuntimeType(child, t1);
      H.assertSubtypeOfRuntimeType(after, t1);
      if (H.assertTest(child !== _this))
        H.assertThrow("A RenderObject cannot be inserted into itself.");
      if (H.assertTest(after !== _this))
        H.assertThrow("A RenderObject cannot simultaneously be both the parent and the sibling of another RenderObject.");
      if (H.assertTest(child != after))
        H.assertThrow("A RenderObject cannot be inserted after itself.");
      H.assertHelper(child != _this.ContainerRenderObjectMixin__firstChild);
      H.assertHelper(child != _this.ContainerRenderObjectMixin__lastChild);
      _this.adoptChild$1(child);
      _this._insertIntoChildList$2$after(child, after);
    },
    addAll$1: function(_, children) {
    },
    _removeFromChildList$1: function(child) {
      var t1, childParentData, _this = this;
      H.assertSubtypeOfRuntimeType(child, H.getRuntimeTypeArgument(_this, "ContainerRenderObjectMixin", 0));
      t1 = H.getRuntimeTypeArgument(_this, "ContainerRenderObjectMixin", 1);
      childParentData = H.assertSubtypeOfRuntimeType(child.get$parentData(), t1);
      H.assertHelper(_this._debugUltimatePreviousSiblingOf$2$equals(child, _this.ContainerRenderObjectMixin__firstChild));
      H.assertHelper(_this._debugUltimateNextSiblingOf$2$equals(child, _this.ContainerRenderObjectMixin__lastChild));
      H.assertHelper(_this.ContainerRenderObjectMixin__childCount >= 0);
      if (childParentData.get$previousSibling() == null) {
        H.assertHelper(_this.ContainerRenderObjectMixin__firstChild === child);
        _this.set$_firstChild(childParentData.get$nextSibling());
      } else
        H.assertSubtypeOfRuntimeType(childParentData.get$previousSibling().parentData, t1).set$nextSibling(childParentData.get$nextSibling());
      if (childParentData.get$nextSibling() == null) {
        H.assertHelper(_this.ContainerRenderObjectMixin__lastChild === child);
        _this.set$_lastChild(childParentData.get$previousSibling());
      } else
        H.assertSubtypeOfRuntimeType(childParentData.get$nextSibling().parentData, t1).set$previousSibling(childParentData.get$previousSibling());
      childParentData.set$previousSibling(null);
      childParentData.set$nextSibling(null);
      --_this.ContainerRenderObjectMixin__childCount;
    },
    remove$1: function(_, child) {
      H.assertSubtypeOfRuntimeType(child, H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 0));
      this._removeFromChildList$1(child);
      this.dropChild$1(child);
    },
    move$2$after: function(child, after) {
      var _this = this,
        t1 = H.getRuntimeTypeArgument(_this, "ContainerRenderObjectMixin", 0);
      H.assertSubtypeOfRuntimeType(child, t1);
      H.assertSubtypeOfRuntimeType(after, t1);
      H.assertHelper(child !== _this);
      H.assertHelper(after !== _this);
      H.assertHelper(child != after);
      H.assertHelper(child._node$_parent === _this);
      if (H.assertSubtypeOfRuntimeType(child.parentData, H.getRuntimeTypeArgument(_this, "ContainerRenderObjectMixin", 1)).get$previousSibling() == after)
        return;
      _this._removeFromChildList$1(child);
      _this._insertIntoChildList$2$after(child, after);
      _this.markNeedsLayout$0();
    },
    redepthChildren$0: function() {
      var t1,
        child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 1); child != null;) {
        this.redepthChild$1(child);
        child = H.assertSubtypeOfRuntimeType(child.parentData, t1).get$nextSibling();
      }
    },
    visitChildren$1: function(visitor) {
      var child, t1;
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [K.RenderObject]});
      child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 1); child != null;) {
        visitor.call$1(child);
        child = H.assertSubtypeOfRuntimeType(child.parentData, t1).get$nextSibling();
      }
    },
    debugDescribeChildren$0: function() {
      var t1, count, t2,
        children = H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]),
        child = this.ContainerRenderObjectMixin__firstChild;
      if (child != null)
        for (t1 = H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 1), count = 1; true;) {
          t2 = "child " + count;
          child.toString;
          C.JSArray_methods.add$1(children, new Y._DiagnosticableTreeNode(child, t2, true, true, null));
          if (child == this.ContainerRenderObjectMixin__lastChild)
            break;
          ++count;
          child = H.assertSubtypeOfRuntimeType(child.parentData, t1).get$nextSibling();
        }
      return children;
    },
    set$_firstChild: function(_firstChild) {
      this.ContainerRenderObjectMixin__firstChild = H.assertSubtypeOfRuntimeType(_firstChild, H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 0));
    },
    set$_lastChild: function(_lastChild) {
      this.ContainerRenderObjectMixin__lastChild = H.assertSubtypeOfRuntimeType(_lastChild, H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 0));
    }
  };
  K.ContainerRenderObjectMixin_debugValidateChild_closure.prototype = {
    call$0: function() {
      var t4,
        t1 = this.child,
        t2 = this.$this,
        t3 = H.getRuntimeTypeArgument(t2, "ContainerRenderObjectMixin", 0);
      if (!H.checkSubtypeOfRuntimeType(t1, t3)) {
        t4 = J.getInterceptor$(t1);
        throw H.wrapException(U.FlutterError$("A " + H.getRuntimeType(t2).toString$0(0) + " expected a child of type " + H.TypeImpl$(t3).toString$0(0) + " but received a child of type " + t4.get$runtimeType(t1).toString$0(0) + ".\nRenderObjects expect specific types of children because they coordinate with their children during layout and paint. For example, a RenderSliver cannot be the child of a RenderBox because a RenderSliver does not understand the RenderBox layout protocol.\n\nThe " + H.getRuntimeType(t2).toString$0(0) + " that expected a " + H.TypeImpl$(t3).toString$0(0) + " child was created by:\n  " + H.S(t2.debugCreator) + "\n\nThe " + t4.get$runtimeType(t1).toString$0(0) + " that did not match the expected child type was created by:\n  " + H.S(t1.debugCreator) + "\n"));
      }
      return true;
    },
    $signature: 0
  };
  K.FlutterErrorDetailsForRendering.prototype = {
    get$renderObject: function() {
      return this.renderObject;
    }
  };
  K._SemanticsFragment.prototype = {
    get$abortsWalk: function() {
      return false;
    }
  };
  K._ContainerSemanticsFragment.prototype = {
    addAll$1: function(_, fragments) {
      C.JSArray_methods.addAll$1(this.interestingFragments, H.assertSubtype(fragments, "$isIterable", [K._InterestingSemanticsFragment], "$asIterable"));
    },
    get$interestingFragments: function() {
      return this.interestingFragments;
    }
  };
  K._InterestingSemanticsFragment.prototype = {
    get$interestingFragments: function() {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var $async$goto = 0, $async$handler = 1, $async$currentError;
        return function $async$get$interestingFragments($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return $async$self;
              case 2:
                // after yield
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, K._InterestingSemanticsFragment);
    },
    addTags$1: function(tags) {
      return;
    }
  };
  K._RootSemanticsFragment.prototype = {
    compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect: function($async$elevationAdjustment, $async$parentPaintClipRect, $async$parentSemanticsClipRect) {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var elevationAdjustment = $async$elevationAdjustment,
          parentPaintClipRect = $async$parentPaintClipRect,
          parentSemanticsClipRect = $async$parentSemanticsClipRect;
        var $async$goto = 0, $async$handler = 1, $async$currentError, t2, t3, t4, t5, node, children, _i, fragment, t1;
        return function $async$compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self._object$_tagsForChildren;
                H.assertHelper(t1 == null || t1._collection$_length === 0);
                H.assertHelper(parentSemanticsClipRect == null);
                H.assertHelper(parentPaintClipRect == null);
                t1 = $async$self._ancestorChain;
                H.assertHelper(t1.length === 1);
                H.assertHelper(elevationAdjustment === 0);
                t2 = C.JSArray_methods.get$first(t1);
                if (t2._semantics == null) {
                  t3 = C.JSArray_methods.get$first(t1).get$showOnScreen();
                  t4 = C.JSArray_methods.get$first(t1);
                  t4 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t4), "$isPipelineOwner")._semanticsOwner;
                  t5 = $.$get$SemanticsNode__kEmptyConfig();
                  t5 = new A.SemanticsNode(null, 0, t3, C.Rect_0_0_0_0, t5._isMergingSemanticsOfDescendants, t5._actions, t5._customSemanticsActions, t5._actionsAsBits, t5._flags, t5._label, t5._semantics$_value, t5._decreasedValue, t5._increasedValue, t5._hint, t5._elevation, t5._thickness, t5._textDirection);
                  t5.attach$1(t4);
                  t2._semantics = t5;
                }
                node = C.JSArray_methods.get$first(t1)._semantics;
                t2 = node._semantics$_transform;
                t3 = new E.Matrix4(new Float64Array(16));
                t3.setIdentity$0();
                H.assertHelper(T.MatrixUtils_matrixEquals(t2, t3));
                H.assertHelper(node.parentSemanticsClipRect == null);
                H.assertHelper(node.parentPaintClipRect == null);
                node.set$rect(C.JSArray_methods.get$first(t1).get$semanticBounds());
                children = H.setRuntimeTypeInfo([], [A.SemanticsNode]);
                for (t1 = $async$self._object$_children, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
                  fragment = t1[_i];
                  H.assertHelper(fragment.get$config() == null);
                  C.JSArray_methods.addAll$1(children, fragment.compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect(0, parentPaintClipRect, parentSemanticsClipRect));
                }
                node.updateWith$2$childrenInInversePaintOrder$config(children, null);
                if (!node._isMergedIntoParent) {
                  t1 = node._semantics$_rect;
                  t1 = t1.get$isEmpty(t1);
                } else
                  t1 = false;
                H.assertHelper(!t1 || children.length === 0);
                $async$goto = 2;
                return node;
              case 2:
                // after yield
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, A.SemanticsNode);
    },
    get$config: function() {
      return;
    },
    markAsExplicit$0: function() {
    },
    addAll$1: function(_, fragments) {
      C.JSArray_methods.addAll$1(this._object$_children, H.assertSubtype(fragments, "$isIterable", [K._InterestingSemanticsFragment], "$asIterable"));
    }
  };
  K._SwitchableSemanticsFragment.prototype = {
    compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect: function($async$elevationAdjustment, $async$parentPaintClipRect, $async$parentSemanticsClipRect) {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var elevationAdjustment = $async$elevationAdjustment,
          parentPaintClipRect = $async$parentPaintClipRect,
          parentSemanticsClipRect = $async$parentSemanticsClipRect;
        var $async$goto = 0, $async$handler = 2, $async$currentError, t1, t2, t3, _i, fragment, t4, t5, geometry, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, node, children;
        return function $async$compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = !$async$self._isExplicit ? 3 : 4;
                break;
              case 3:
                // then
                t1 = $async$self._ancestorChain;
                C.JSArray_methods.get$first(t1)._semantics = null;
                t2 = $async$self._object$_children, t3 = t2.length, _i = 0;
              case 5:
                // for condition
                if (!(_i < t2.length)) {
                  // goto after for
                  $async$goto = 7;
                  break;
                }
                fragment = t2[_i];
                t4 = C.JSArray_methods.get$first(t1);
                t5 = fragment._ancestorChain;
                H.assertHelper(J.$eq$(t4, C.JSArray_methods.get$last(t5)));
                C.JSArray_methods.addAll$1(t5, C.JSArray_methods.sublist$1(t1, 1));
                $async$goto = 8;
                return P._IterationMarker_yieldStar(fragment.compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect(elevationAdjustment + $async$self._config._elevation, parentPaintClipRect, parentSemanticsClipRect));
              case 8:
                // after yield
              case 6:
                // for update
                t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i;
                // goto for condition
                $async$goto = 5;
                break;
              case 7:
                // after for
                // goto return
                $async$goto = 1;
                break;
              case 4:
                // join
                t1 = $async$self._ancestorChain;
                if (t1.length > 1) {
                  geometry = new K._SemanticsGeometry();
                  geometry._computeValues$3(parentSemanticsClipRect, parentPaintClipRect, t1);
                } else
                  geometry = null;
                t2 = $async$self._mergeIntoParent;
                t3 = !t2;
                if (t3) {
                  if (geometry == null)
                    t4 = null;
                  else {
                    t4 = geometry._rect;
                    t4 = t4.get$isEmpty(t4);
                  }
                  t4 = t4 === true;
                } else
                  t4 = false;
                if (t4) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t4 = C.JSArray_methods.get$first(t1);
                if (t4._semantics == null) {
                  t5 = C.JSArray_methods.get$first(t1).get$showOnScreen();
                  t6 = $.$get$SemanticsNode__kEmptyConfig();
                  t7 = t6._isMergingSemanticsOfDescendants;
                  t8 = t6._actions;
                  t9 = t6._customSemanticsActions;
                  t10 = t6._actionsAsBits;
                  t11 = t6._flags;
                  t12 = t6._label;
                  t13 = t6._semantics$_value;
                  t14 = t6._decreasedValue;
                  t15 = t6._increasedValue;
                  t16 = t6._hint;
                  t17 = t6._elevation;
                  t18 = t6._thickness;
                  t6 = t6._textDirection;
                  t19 = ($.SemanticsNode__lastIdentifier + 1) % 65535;
                  $.SemanticsNode__lastIdentifier = t19;
                  t4._semantics = new A.SemanticsNode(null, t19, t5, C.Rect_0_0_0_0, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t6);
                }
                node = C.JSArray_methods.get$first(t1)._semantics;
                node.set$isMergedIntoParent(t2);
                node.set$tags($async$self._object$_tagsForChildren);
                node.elevationAdjustment = elevationAdjustment;
                if (elevationAdjustment !== 0) {
                  $async$self._ensureConfigIsWritable$0();
                  t2 = $async$self._config;
                  t2.set$elevation(t2._elevation + elevationAdjustment);
                }
                if (geometry != null) {
                  H.assertHelper(t1.length > 1);
                  node.set$rect(geometry._rect);
                  node.set$transform(geometry._object$_transform);
                  node.parentSemanticsClipRect = geometry._semanticsClipRect;
                  node.parentPaintClipRect = geometry._paintClipRect;
                  if (t3 && geometry._markAsHidden) {
                    $async$self._ensureConfigIsWritable$0();
                    $async$self._config._setFlag$2(C.SemanticsFlag_8192, true);
                  }
                }
                children = H.setRuntimeTypeInfo([], [A.SemanticsNode]);
                for (t2 = $async$self._object$_children, t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
                  fragment = t2[_i];
                  t4 = node.parentSemanticsClipRect;
                  C.JSArray_methods.addAll$1(children, fragment.compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect(0, node.parentPaintClipRect, t4));
                }
                t2 = $async$self._config;
                if (t2._isSemanticBoundary)
                  C.JSArray_methods.get$first(t1).assembleSemanticsNode$3(node, $async$self._config, children);
                else
                  node.updateWith$2$childrenInInversePaintOrder$config(children, t2);
                $async$goto = 9;
                return node;
              case 9:
                // after yield
              case 1:
                // return
                return P._IterationMarker_endOfIteration();
              case 2:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, A.SemanticsNode);
    },
    get$config: function() {
      return this._isExplicit ? null : this._config;
    },
    addAll$1: function(_, fragments) {
      var t1, t2, _i, fragment, _this = this;
      H.assertSubtype(fragments, "$isIterable", [K._InterestingSemanticsFragment], "$asIterable");
      for (t1 = fragments.length, t2 = _this._object$_children, _i = 0; _i < fragments.length; fragments.length === t1 || (0, H.throwConcurrentModificationError)(fragments), ++_i) {
        fragment = fragments[_i];
        C.JSArray_methods.add$1(t2, fragment);
        if (fragment.get$config() == null)
          continue;
        if (!_this._isConfigWritable) {
          _this._config = _this._config.copy$0();
          _this._isConfigWritable = true;
        }
        _this._config.absorb$1(fragment.get$config());
      }
    },
    _ensureConfigIsWritable$0: function() {
      var _this = this;
      if (!_this._isConfigWritable) {
        _this._config = _this._config.copy$0();
        _this._isConfigWritable = true;
      }
    },
    markAsExplicit$0: function() {
      this._isExplicit = true;
    }
  };
  K._AbortingSemanticsFragment.prototype = {
    get$abortsWalk: function() {
      return true;
    },
    get$config: function() {
      return;
    },
    addAll$1: function(_, fragments) {
      H.assertSubtype(fragments, "$isIterable", [K._InterestingSemanticsFragment], "$asIterable");
      H.assertHelper(false);
    },
    compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect: function($async$elevationAdjustment, $async$parentPaintClipRect, $async$parentSemanticsClipRect) {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var elevationAdjustment = $async$elevationAdjustment,
          parentPaintClipRect = $async$parentPaintClipRect,
          parentSemanticsClipRect = $async$parentSemanticsClipRect;
        var $async$goto = 0, $async$handler = 1, $async$currentError;
        return function $async$compileChildren$3$elevationAdjustment$parentPaintClipRect$parentSemanticsClipRect($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return C.JSArray_methods.get$first($async$self._ancestorChain)._semantics;
              case 2:
                // after yield
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, A.SemanticsNode);
    },
    markAsExplicit$0: function() {
    }
  };
  K._SemanticsGeometry.prototype = {
    _computeValues$3: function(parentSemanticsClipRect, parentPaintClipRect, ancestors) {
      var t1, index, $parent, child, owner, t2, paintRect, _this = this;
      H.assertSubtype(ancestors, "$isList", [K.RenderObject], "$asList");
      H.assertHelper(ancestors.length > 1);
      t1 = new E.Matrix4(new Float64Array(16));
      t1.setIdentity$0();
      _this._object$_transform = t1;
      _this._semanticsClipRect = parentSemanticsClipRect;
      _this._paintClipRect = parentPaintClipRect;
      for (index = ancestors.length - 1; index > 0;) {
        t1 = ancestors.length;
        if (index >= t1)
          return H.ioore(ancestors, index);
        $parent = ancestors[index];
        --index;
        if (index >= t1)
          return H.ioore(ancestors, index);
        child = ancestors[index];
        t1 = K._SemanticsGeometry__intersectRects(_this._semanticsClipRect, $parent.describeApproximatePaintClip$1(child));
        _this._semanticsClipRect = t1;
        _this._semanticsClipRect = K._SemanticsGeometry__transformRect(t1, $parent, child);
        _this._paintClipRect = K._SemanticsGeometry__transformRect(_this._paintClipRect, $parent, child);
        $parent.applyPaintTransform$2(child, _this._object$_transform);
      }
      owner = C.JSArray_methods.get$first(ancestors);
      t1 = _this._semanticsClipRect;
      t1 = t1 == null ? owner.get$semanticBounds() : t1.intersect$1(owner.get$semanticBounds());
      _this._rect = t1;
      t2 = _this._paintClipRect;
      if (t2 != null) {
        paintRect = t2.intersect$1(t1);
        if (paintRect.get$isEmpty(paintRect)) {
          t1 = _this._rect;
          t1 = !t1.get$isEmpty(t1);
        } else
          t1 = false;
        _this._markAsHidden = t1;
        if (!t1)
          _this._rect = paintRect;
      }
    }
  };
  K._RenderObject_AbstractNode_DiagnosticableTreeMixin.prototype = {};
  Q.TextOverflow.prototype = {
    toString$0: function(_) {
      return this._paragraph$_name;
    }
  };
  Q.RenderParagraph.prototype = {
    set$text: function(value) {
      var _this = this,
        t1 = _this._paragraph$_textPainter;
      switch (t1._text.compareTo$1(0, value)) {
        case C.RenderComparison_0:
        case C.RenderComparison_1:
          return;
        case C.RenderComparison_2:
          t1.set$text(value);
          _this.markNeedsPaint$0();
          _this.markNeedsSemanticsUpdate$0();
          break;
        case C.RenderComparison_3:
          t1.set$text(value);
          _this._overflowShader = null;
          _this.markNeedsLayout$0();
          break;
      }
    },
    set$textAlign: function(value) {
      var t1 = this._paragraph$_textPainter;
      if (t1._textAlign === value)
        return;
      t1.set$textAlign(value);
      this.markNeedsPaint$0();
    },
    set$textDirection: function(value) {
      var t1;
      H.assertHelper(value != null);
      t1 = this._paragraph$_textPainter;
      if (t1._text_painter$_textDirection == value)
        return;
      t1.set$textDirection(value);
      this.markNeedsLayout$0();
    },
    set$softWrap: function(value) {
      if (this._softWrap === value)
        return;
      this._softWrap = value;
      this.markNeedsLayout$0();
    },
    set$overflow: function(value) {
      var t1, _this = this;
      if (_this._paragraph$_overflow === value)
        return;
      _this._paragraph$_overflow = value;
      t1 = value === C.TextOverflow_2 ? "\u2026" : null;
      _this._paragraph$_textPainter.set$ellipsis(t1);
      _this.markNeedsLayout$0();
    },
    set$textScaleFactor: function(value) {
      var t1 = this._paragraph$_textPainter;
      if (t1._textScaleFactor === value)
        return;
      t1.set$textScaleFactor(value);
      this._overflowShader = null;
      this.markNeedsLayout$0();
    },
    set$maxLines: function(value) {
      var t1 = this._paragraph$_textPainter,
        t2 = t1._maxLines;
      if (t2 == null ? value == null : t2 === value)
        return;
      t1.set$maxLines(value);
      this._overflowShader = null;
      this.markNeedsLayout$0();
    },
    set$locale: function(value) {
      var t1 = this._paragraph$_textPainter;
      if (J.$eq$(t1._text_painter$_locale, value))
        return;
      t1.set$locale(value);
      this._overflowShader = null;
      this.markNeedsLayout$0();
    },
    set$strutStyle: function(value) {
      return;
    },
    _layoutText$2$maxWidth$minWidth: function(maxWidth, minWidth) {
      var t1 = this._softWrap || this._paragraph$_overflow === C.TextOverflow_2 ? maxWidth : 1 / 0;
      this._paragraph$_textPainter.layout$2$maxWidth$minWidth(t1, minWidth);
    },
    computeDistanceToActualBaseline$1: function(baseline) {
      var t1, t2, _this = this;
      H.assertHelper(!H.boolConversionCheck(_this.get$debugNeedsLayout()));
      H.assertHelper(K.RenderObject.prototype.get$constraints.call(_this) != null);
      H.assertHelper(K.RenderObject.prototype.get$constraints.call(_this).debugAssertIsValid$0());
      t1 = K.RenderObject.prototype.get$constraints.call(_this);
      t2 = t1.minWidth;
      _this._layoutText$2$maxWidth$minWidth(t1.maxWidth, t2);
      return _this._paragraph$_textPainter.computeDistanceToActualBaseline$1(baseline);
    },
    hitTestSelf$1: function(position) {
      return true;
    },
    handleEvent$2: function($event, entry) {
      var t1, t2, _this = this;
      H.interceptedTypeCheck(entry, "$isBoxHitTestEntry");
      _this.debugHandleEvent$2($event, entry);
      if (!($event instanceof F.PointerDownEvent))
        return;
      t1 = K.RenderObject.prototype.get$constraints.call(_this);
      t2 = t1.minWidth;
      _this._layoutText$2$maxWidth$minWidth(t1.maxWidth, t2);
      _this._paragraph$_textPainter.getPositionForOffset$1(entry.localPosition);
    },
    performLayout$0: function() {
      var t1 = K.RenderObject.prototype.get$constraints.call(this),
        t2 = t1.minWidth;
      this._layoutText$2$maxWidth$minWidth(t1.maxWidth, t2);
      t2 = this._paragraph$_textPainter;
      H.assertHelper(!t2._text_painter$_needsLayout);
      t2.get$width();
      t2.get$height();
    },
    paint$2: function(context, offset) {
      var canvas, t3, t4, bounds, paint, _this = this,
        t1 = K.RenderObject.prototype.get$constraints.call(_this),
        t2 = t1.minWidth;
      _this._layoutText$2$maxWidth$minWidth(t1.maxWidth, t2);
      canvas = context.get$canvas();
      H.assertHelper(new Q.RenderParagraph_paint_closure(_this, canvas, offset).call$0());
      if (_this._needsClipping) {
        t1 = _this.get$size();
        t2 = offset._dx;
        t3 = offset._dy;
        t4 = t1._dx;
        t1 = t1._dy;
        if (typeof t2 !== "number")
          return t2.$add();
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (typeof t3 !== "number")
          return t3.$add();
        if (typeof t1 !== "number")
          return H.iae(t1);
        bounds = new P.Rect(t2, t3, t2 + t4, t3 + t1);
        if (_this._overflowShader != null)
          canvas.saveLayer$2(bounds, new P.Paint(new DataView(new ArrayBuffer(75))));
        else
          canvas.save$0();
        canvas.clipRect$1(bounds);
      }
      _this._paragraph$_textPainter.paint$2(canvas, offset);
      if (_this._needsClipping) {
        if (_this._overflowShader != null) {
          canvas.translate$2(offset._dx, offset._dy);
          paint = new P.Paint(new DataView(new ArrayBuffer(75)));
          paint.set$blendMode(C.BlendMode_13);
          paint.set$shader(_this._overflowShader);
          t1 = _this.get$size();
          t2 = t1._dx;
          t1 = t1._dy;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (typeof t1 !== "number")
            return H.iae(t1);
          canvas.drawRect$2(new P.Rect(0, 0, 0 + t2, 0 + t1), paint);
        }
        canvas.restore$0();
      }
    },
    getBoxesForSelection$1: function(selection) {
      var t1, t2, _this = this;
      H.assertHelper(!H.boolConversionCheck(_this.get$debugNeedsLayout()));
      t1 = K.RenderObject.prototype.get$constraints.call(_this);
      t2 = t1.minWidth;
      _this._layoutText$2$maxWidth$minWidth(t1.maxWidth, t2);
      return _this._paragraph$_textPainter.getBoxesForSelection$1(selection);
    },
    describeSemanticsConfiguration$1: function(config) {
      var t2, t3, _this = this, t1 = {};
      _this.super$RenderObject$describeSemanticsConfiguration(config);
      t2 = _this._recognizerOffsets;
      C.JSArray_methods.set$length(t2, 0);
      C.JSArray_methods.set$length(_this._paragraph$_recognizers, 0);
      t1.offset = 0;
      t3 = _this._paragraph$_textPainter;
      t3._text.visitTextSpan$1(new Q.RenderParagraph_describeSemanticsConfiguration_closure(t1, _this));
      if (t2.length !== 0) {
        config.explicitChildNodes = true;
        config._isSemanticBoundary = true;
      } else {
        config.set$label(t3._text.toPlainText$0());
        config._textDirection = t3._text_painter$_textDirection;
        config._hasBeenAnnotated = true;
      }
    },
    assembleSemanticsNode$3: function(node, config, children) {
      var t2, t3, newChildren, rawLabel, buildSemanticsConfig, current, i, j, start, t4, end, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, node0, configuration, _this = this, _null = null, _box_0 = {},
        t1 = A.SemanticsNode;
      H.assertSubtype(children, "$isIterable", [t1], "$asIterable");
      t2 = _this._recognizerOffsets;
      H.assertHelper(t2.length !== 0);
      H.assertHelper((t2.length & 1) === 0);
      t3 = _this._paragraph$_recognizers;
      H.assertHelper(t3.length !== 0);
      H.assertHelper(children.length === 0);
      newChildren = H.setRuntimeTypeInfo([], [t1]);
      t1 = _this._paragraph$_textPainter;
      rawLabel = t1._text.toPlainText$0();
      _box_0.order = -1;
      _box_0.currentDirection = t1._text_painter$_textDirection;
      _box_0.currentRect = null;
      buildSemanticsConfig = new Q.RenderParagraph_assembleSemanticsNode_buildSemanticsConfig(_box_0, _this, rawLabel);
      for (current = 0, i = 0, j = 0; t1 = t2.length, i < t1; i += 2, ++j, current = end) {
        start = t2[i];
        t4 = i + 1;
        if (t4 >= t1)
          return H.ioore(t2, t4);
        end = t2[t4];
        if (current !== start) {
          t1 = $.$get$SemanticsNode__kEmptyConfig();
          t4 = t1._isMergingSemanticsOfDescendants;
          t5 = t1._actions;
          t6 = t1._customSemanticsActions;
          t7 = t1._actionsAsBits;
          t8 = t1._flags;
          t9 = t1._label;
          t10 = t1._semantics$_value;
          t11 = t1._decreasedValue;
          t12 = t1._increasedValue;
          t13 = t1._hint;
          t14 = t1._elevation;
          t15 = t1._thickness;
          t1 = t1._textDirection;
          t16 = ($.SemanticsNode__lastIdentifier + 1) % 65535;
          $.SemanticsNode__lastIdentifier = t16;
          node0 = new A.SemanticsNode(_null, t16, _null, C.Rect_0_0_0_0, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t1);
          node0.updateWith$1$config(buildSemanticsConfig.call$2(current, start));
          t1 = _box_0.currentRect;
          H.assertHelper(t1 != null);
          if (!node0._semantics$_rect.$eq(0, t1)) {
            node0._semantics$_rect = t1;
            node0._markDirty$0();
          }
          C.JSArray_methods.add$1(newChildren, node0);
        }
        t1 = $.$get$SemanticsNode__kEmptyConfig();
        t4 = t1._isMergingSemanticsOfDescendants;
        t5 = t1._actions;
        t6 = t1._customSemanticsActions;
        t7 = t1._actionsAsBits;
        t8 = t1._flags;
        t9 = t1._label;
        t10 = t1._semantics$_value;
        t11 = t1._decreasedValue;
        t12 = t1._increasedValue;
        t13 = t1._hint;
        t14 = t1._elevation;
        t15 = t1._thickness;
        t1 = t1._textDirection;
        t16 = ($.SemanticsNode__lastIdentifier + 1) % 65535;
        $.SemanticsNode__lastIdentifier = t16;
        node0 = new A.SemanticsNode(_null, t16, _null, C.Rect_0_0_0_0, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t1);
        configuration = buildSemanticsConfig.call$2(start, end);
        if (j >= t3.length)
          return H.ioore(t3, j);
        H.assertHelper(false);
        node0.updateWith$1$config(configuration);
        t1 = _box_0.currentRect;
        H.assertHelper(t1 != null);
        if (!node0._semantics$_rect.$eq(0, t1)) {
          node0._semantics$_rect = t1;
          node0._markDirty$0();
        }
        C.JSArray_methods.add$1(newChildren, node0);
      }
      t1 = rawLabel.length;
      if (current < t1) {
        t2 = $.$get$SemanticsNode__kEmptyConfig();
        t3 = t2._isMergingSemanticsOfDescendants;
        t4 = t2._actions;
        t5 = t2._customSemanticsActions;
        t6 = t2._actionsAsBits;
        t7 = t2._flags;
        t8 = t2._label;
        t9 = t2._semantics$_value;
        t10 = t2._decreasedValue;
        t11 = t2._increasedValue;
        t12 = t2._hint;
        t13 = t2._elevation;
        t14 = t2._thickness;
        t2 = t2._textDirection;
        t15 = ($.SemanticsNode__lastIdentifier + 1) % 65535;
        $.SemanticsNode__lastIdentifier = t15;
        node0 = new A.SemanticsNode(_null, t15, _null, C.Rect_0_0_0_0, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t2);
        node0.updateWith$1$config(buildSemanticsConfig.call$2(current, t1));
        node0.set$rect(_box_0.currentRect);
        C.JSArray_methods.add$1(newChildren, node0);
      }
      node.updateWith$2$childrenInInversePaintOrder$config(newChildren, config);
    },
    debugDescribeChildren$0: function() {
      var t1 = this._paragraph$_textPainter._text;
      t1.toString;
      return H.setRuntimeTypeInfo([new Y._DiagnosticableTreeNode(t1, "text", true, true, C.DiagnosticsTreeStyle_3)], [Y.DiagnosticsNode]);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _this = this, _null = null;
      _this.super$RenderBox$debugFillProperties(properties);
      t1 = _this._paragraph$_textPainter;
      t2 = t1._textAlign;
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, new Y.EnumProperty(_null, _null, _null, _null, false, t2, C.C__NoDefaultValue, C.DiagnosticLevel_3, "textAlign", true, true, C.DiagnosticsTreeStyle_5, [P.TextAlign]));
      t2 = t1._text_painter$_textDirection;
      C.JSArray_methods.add$1(t3, new Y.EnumProperty(_null, _null, _null, _null, false, t2, C.C__NoDefaultValue, C.DiagnosticLevel_3, "textDirection", true, true, C.DiagnosticsTreeStyle_5, [P.TextDirection]));
      C.JSArray_methods.add$1(t3, Y.FlagProperty$("softWrap", _null, "no wrapping except at line break characters", "wrapping at box width", C.DiagnosticLevel_3, true, _this._softWrap));
      t2 = _this._paragraph$_overflow;
      C.JSArray_methods.add$1(t3, new Y.EnumProperty(_null, _null, _null, _null, false, t2, C.C__NoDefaultValue, C.DiagnosticLevel_3, "overflow", true, true, C.DiagnosticsTreeStyle_5, [Q.TextOverflow]));
      C.JSArray_methods.add$1(t3, Y.DoubleProperty$("textScaleFactor", t1._textScaleFactor, 1, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("locale", t1._text_painter$_locale, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Locale));
      C.JSArray_methods.add$1(t3, Y.IntProperty$("maxLines", t1._maxLines, C.C__NoDefaultValue, "unlimited", C.DiagnosticLevel_3, _null));
    }
  };
  Q.RenderParagraph_paint_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  Q.RenderParagraph_describeSemanticsConfiguration_closure.prototype = {
    call$1: function(span) {
      var t1 = this._box_0;
      t1.offset = t1.offset + span.text.length;
      return true;
    },
    $signature: 28
  };
  Q.RenderParagraph_assembleSemanticsNode_buildSemanticsConfig.prototype = {
    call$2: function(start, end) {
      this.$this.getBoxesForSelection$1(X.TextSelection$(start, end));
    },
    $signature: 97
  };
  L.RenderPerformanceOverlay.prototype = {
    set$optionsMask: function(value) {
      if (value === this._optionsMask)
        return;
      this._optionsMask = value;
      this.markNeedsPaint$0();
    },
    set$rasterizerThreshold: function(value) {
      if (value === this._rasterizerThreshold)
        return;
      this._rasterizerThreshold = value;
      this.markNeedsPaint$0();
    },
    get$sizedByParent: function() {
      return true;
    },
    get$alwaysNeedsCompositing: function() {
      return true;
    },
    get$_intrinsicHeight: function() {
      var t1 = this._optionsMask,
        result = (t1 | 1) >>> 0 > 0 || (t1 | 2) >>> 0 > 0 ? 80 : 0;
      return (t1 | 4) >>> 0 > 0 || (t1 | 8) >>> 0 > 0 ? result + 80 : result;
    },
    performResize$0: function() {
      this.set$size(K.RenderObject.prototype.get$constraints.call(this).constrain$1(new P.Size(1 / 0, this.get$_intrinsicHeight())));
    },
    paint$2: function(context, offset) {
      var t1, t2, t3, t4, t5, t6, _this = this;
      H.assertHelper(!_this._needsCompositingBitsUpdate);
      H.assertHelper(_this._needsCompositing);
      t1 = offset._dx;
      t2 = offset._dy;
      t3 = _this.get$size()._dx;
      t4 = _this.get$size()._dy;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (typeof t2 !== "number")
        return t2.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = _this._optionsMask;
      t6 = _this._rasterizerThreshold;
      context.stopRecordingIfNeeded$0();
      context.appendLayer$1(new T.PerformanceOverlayLayer(new P.Rect(t1, t2, t1 + t3, t2 + t4), t5, t6, false, false));
    }
  };
  E.RenderProxyBox.prototype = {
    $asRenderObjectWithChildMixin: function() {
      return [S.RenderBox];
    }
  };
  E.RenderProxyBoxMixin.prototype = {
    setupParentData$1: function(child) {
      if (!(child.parentData instanceof K.ParentData))
        child.parentData = new K.ParentData();
    },
    performLayout$0: function() {
      var _this = this,
        t1 = _this.RenderObjectWithChildMixin__child;
      if (t1 != null) {
        t1.layout$2$parentUsesSize(_this.get$constraints(), true);
        _this.set$size(_this.RenderObjectWithChildMixin__child.get$size());
      } else
        _this.performResize$0();
    },
    hitTestChildren$2$position: function(result, position) {
      var t1 = this.RenderObjectWithChildMixin__child;
      t1 = t1 == null ? null : t1.hitTest$2$position(result, position);
      return t1 === true;
    },
    applyPaintTransform$2: function(child, transform) {
    },
    paint$2: function(context, offset) {
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        context.paintChild$2(t1, offset);
    }
  };
  E.HitTestBehavior.prototype = {
    toString$0: function(_) {
      return this._proxy_box$_name;
    }
  };
  E.RenderProxyBoxWithHitTestBehavior.prototype = {
    hitTest$2$position: function(result, position) {
      var hitTarget, _this = this;
      if (_this.get$size().contains$1(0, position)) {
        hitTarget = _this.hitTestChildren$2$position(result, position) || _this.behavior === C.HitTestBehavior_1;
        if (hitTarget || _this.behavior === C.HitTestBehavior_2)
          C.JSArray_methods.add$1(result._path, new S.BoxHitTestEntry(position, _this));
      } else
        hitTarget = false;
      return hitTarget;
    },
    hitTestSelf$1: function(position) {
      return this.behavior === C.HitTestBehavior_1;
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$RenderBox$debugFillProperties(properties);
      t1 = this.behavior;
      C.JSArray_methods.add$1(properties.properties, new Y.EnumProperty(_null, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, "behavior", true, true, C.DiagnosticsTreeStyle_5, [E.HitTestBehavior]));
    }
  };
  E.RenderConstrainedBox.prototype = {
    set$additionalConstraints: function(value) {
      H.assertHelper(value != null);
      H.assertHelper(value.debugAssertIsValid$0());
      if (J.$eq$(this._additionalConstraints, value))
        return;
      this._additionalConstraints = value;
      this.markNeedsLayout$0();
    },
    performLayout$0: function() {
      var _this = this,
        t1 = _this.RenderObjectWithChildMixin__child,
        t2 = _this._additionalConstraints;
      if (t1 != null) {
        t1.layout$2$parentUsesSize(t2.enforce$1(K.RenderObject.prototype.get$constraints.call(_this)), true);
        _this.set$size(_this.RenderObjectWithChildMixin__child.get$size());
      } else
        _this.set$size(t2.enforce$1(K.RenderObject.prototype.get$constraints.call(_this)).constrain$1(C.Size_0_0));
    },
    debugPaintSize$2: function(context, offset) {
      this.super$RenderBox$debugPaintSize(context, offset);
      H.assertHelper(new E.RenderConstrainedBox_debugPaintSize_closure(this, context, offset).call$0());
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$RenderBox$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("additionalConstraints", this._additionalConstraints, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, S.BoxConstraints);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  E.RenderConstrainedBox_debugPaintSize_closure.prototype = {
    call$0: function() {
      var paint, t3, t4, t5,
        t1 = this.$this,
        t2 = t1.RenderObjectWithChildMixin__child;
      if (t2 != null) {
        t2 = t2.get$size();
        t2 = t2.get$isEmpty(t2);
      } else
        t2 = true;
      if (t2) {
        paint = new P.Paint(new DataView(new ArrayBuffer(75)));
        paint.set$color(C.Color_2425393296);
        t2 = this.context.get$canvas();
        t3 = this.offset;
        t1 = t1.get$size();
        t4 = t3._dx;
        t3 = t3._dy;
        t5 = t1._dx;
        t1 = t1._dy;
        if (typeof t4 !== "number")
          return t4.$add();
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (typeof t3 !== "number")
          return t3.$add();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2.drawRect$2(new P.Rect(t4, t3, t4 + t5, t3 + t1), paint);
      }
      return true;
    },
    $signature: 0
  };
  E.RenderLimitedBox.prototype = {
    set$maxWidth: function(value) {
      if (this._maxWidth === value)
        return;
      this._maxWidth = value;
      this.markNeedsLayout$0();
    },
    set$maxHeight: function(value) {
      if (this._maxHeight === value)
        return;
      this._maxHeight = value;
      this.markNeedsLayout$0();
    },
    _limitConstraints$1: function(constraints) {
      var t3, t4,
        t1 = constraints.minWidth,
        t2 = constraints.maxWidth;
      if (typeof t2 !== "number")
        return t2.$lt();
      if (!(t2 < 1 / 0))
        t2 = constraints.constrainWidth$1(this._maxWidth);
      t3 = constraints.minHeight;
      t4 = constraints.maxHeight;
      if (typeof t4 !== "number")
        return t4.$lt();
      if (!(t4 < 1 / 0))
        t4 = constraints.constrainHeight$1(this._maxHeight);
      return new S.BoxConstraints(t1, t2, t3, t4);
    },
    performLayout$0: function() {
      var _this = this,
        t1 = _this.RenderObjectWithChildMixin__child;
      if (t1 != null) {
        t1.layout$2$parentUsesSize(_this._limitConstraints$1(K.RenderObject.prototype.get$constraints.call(_this)), true);
        _this.set$size(K.RenderObject.prototype.get$constraints.call(_this).constrain$1(_this.RenderObjectWithChildMixin__child.get$size()));
      } else
        _this.set$size(_this._limitConstraints$1(K.RenderObject.prototype.get$constraints.call(_this)).constrain$1(C.Size_0_0));
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$RenderBox$debugFillProperties(properties);
      t1 = Y.DoubleProperty$("maxWidth", this._maxWidth, 1 / 0, _null, C.DiagnosticLevel_3, true, _null, _null);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("maxHeight", this._maxHeight, 1 / 0, _null, C.DiagnosticLevel_3, true, _null, _null));
    }
  };
  E.RenderOpacity.prototype = {
    get$alwaysNeedsCompositing: function() {
      if (this.RenderObjectWithChildMixin__child != null) {
        var t1 = this._alpha;
        t1 = t1 !== 0 && t1 !== 255;
      } else
        t1 = false;
      return t1;
    },
    set$opacity: function(value) {
      var didNeedCompositing, t1, _this = this;
      H.assertHelper(value != null);
      if (typeof value !== "number")
        return value.$ge();
      H.assertHelper(value >= 0 && value <= 1);
      if (_this._proxy_box$_opacity === value)
        return;
      didNeedCompositing = _this.get$alwaysNeedsCompositing();
      t1 = _this._alpha;
      _this._proxy_box$_opacity = value;
      _this._alpha = C.JSNumber_methods.round$0(value * 255);
      if (didNeedCompositing !== _this.get$alwaysNeedsCompositing())
        _this.markNeedsCompositingBitsUpdate$0();
      _this.markNeedsPaint$0();
      if (t1 !== 0 !== (_this._alpha !== 0))
        _this.markNeedsSemanticsUpdate$0();
    },
    set$alwaysIncludeSemantics: function(value) {
      return;
    },
    paint$2: function(context, offset) {
      var t2, _this = this,
        t1 = _this.RenderObjectWithChildMixin__child;
      if (t1 != null) {
        t2 = _this._alpha;
        if (t2 === 0)
          return;
        if (t2 === 255) {
          context.paintChild$2(t1, offset);
          return;
        }
        H.assertHelper(!_this._needsCompositingBitsUpdate);
        H.assertHelper(_this._needsCompositing);
        context.pushLayer$3(new T.OpacityLayer(_this._alpha, offset), E.RenderProxyBoxMixin.prototype.get$paint.call(_this), C.Offset_0_0);
      }
    },
    visitChildrenForSemantics$1: function(visitor) {
      var t1, t2;
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [K.RenderObject]});
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t2 = this._alpha !== 0 || false;
      else
        t2 = false;
      if (t2)
        visitor.call$1(t1);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null,
        _s22_ = "alwaysIncludeSemantics";
      this.super$RenderBox$debugFillProperties(properties);
      t1 = Y.DoubleProperty$("opacity", this._proxy_box$_opacity, C.C__NoDefaultValue, _null, C.DiagnosticLevel_3, true, _null, _null);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.FlagProperty$(_s22_, _null, _null, _s22_, C.DiagnosticLevel_3, false, false));
    }
  };
  E.RenderAnimatedOpacity.prototype = {
    get$alwaysNeedsCompositing: function() {
      return this.RenderObjectWithChildMixin__child != null && H.boolConversionCheck(this._currentlyNeedsCompositing);
    },
    set$opacity: function(value) {
      var t1, _this = this;
      H.assertSubtype(value, "$isAnimation", [P.double], "$asAnimation");
      H.assertHelper(value != null);
      t1 = _this._proxy_box$_opacity;
      if (t1 == value)
        return;
      if (_this._node$_owner != null && t1 != null)
        t1.removeListener$1(_this.get$_updateOpacity());
      _this.set$_proxy_box$_opacity(value);
      if (_this._node$_owner != null)
        _this._proxy_box$_opacity.addListener$1(_this.get$_updateOpacity());
      _this._updateOpacity$0();
    },
    set$alwaysIncludeSemantics: function(value) {
      return;
    },
    attach$1: function(owner) {
      var _this = this;
      _this.super$_RenderProxyBox_RenderBox_RenderObjectWithChildMixin$attach(H.interceptedTypeCheck(owner, "$isPipelineOwner"));
      _this._proxy_box$_opacity.addListener$1(_this.get$_updateOpacity());
      _this._updateOpacity$0();
    },
    detach$0: function() {
      this._proxy_box$_opacity.removeListener$1(this.get$_updateOpacity());
      this.super$_RenderProxyBox_RenderBox_RenderObjectWithChildMixin$detach();
    },
    _updateOpacity$0: function() {
      var didNeedCompositing, _this = this,
        oldAlpha = _this._alpha,
        t1 = _this._alpha = C.JSNumber_methods.round$0(J.clamp$2$n(_this._proxy_box$_opacity.get$value(), 0, 1) * 255);
      if (oldAlpha !== t1) {
        didNeedCompositing = _this._currentlyNeedsCompositing;
        t1 = t1 > 0 && t1 < 255;
        _this._currentlyNeedsCompositing = t1;
        if (_this.RenderObjectWithChildMixin__child != null && didNeedCompositing !== t1)
          _this.markNeedsCompositingBitsUpdate$0();
        _this.markNeedsPaint$0();
        if (oldAlpha === 0 || _this._alpha === 0)
          _this.markNeedsSemanticsUpdate$0();
      }
    },
    paint$2: function(context, offset) {
      var t2, _this = this,
        t1 = _this.RenderObjectWithChildMixin__child;
      if (t1 != null) {
        t2 = _this._alpha;
        if (t2 === 0)
          return;
        if (t2 === 255) {
          context.paintChild$2(t1, offset);
          return;
        }
        H.assertHelper(!_this._needsCompositingBitsUpdate);
        H.assertHelper(_this._needsCompositing);
        context.pushLayer$3(new T.OpacityLayer(_this._alpha, offset), E.RenderProxyBoxMixin.prototype.get$paint.call(_this), C.Offset_0_0);
      }
    },
    visitChildrenForSemantics$1: function(visitor) {
      var t1, t2;
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [K.RenderObject]});
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t2 = this._alpha !== 0 || false;
      else
        t2 = false;
      if (t2)
        visitor.call$1(t1);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null,
        _s22_ = "alwaysIncludeSemantics";
      this.super$RenderBox$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("opacity", this._proxy_box$_opacity, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, [X.Animation, P.double]);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.FlagProperty$(_s22_, _null, _null, _s22_, C.DiagnosticLevel_3, false, false));
    },
    set$_proxy_box$_opacity: function(_opacity) {
      this._proxy_box$_opacity = H.assertSubtype(_opacity, "$isAnimation", [P.double], "$asAnimation");
    }
  };
  E.CustomClipper.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    }
  };
  E.ShapeBorderClipper.prototype = {
    shouldReclip$1: function(oldClipper) {
      H.assertSubtype(oldClipper, "$isCustomClipper", [P.Path], "$asCustomClipper");
      if (!new H.TypeImpl(H.getRti(oldClipper)).$eq(0, C.Type_ShapeBorderClipper_QWG))
        return true;
      return !J.$eq$(oldClipper.shape, this.shape) || oldClipper.textDirection != this.textDirection;
    },
    $asCustomClipper: function() {
      return [P.Path];
    }
  };
  E._RenderCustomClip.prototype = {
    set$clipper: function(newClipper) {
      var t1, t2, _this = this;
      H.assertSubtype(newClipper, "$isCustomClipper", [H.getRuntimeTypeArgument(_this, "_RenderCustomClip", 0)], "$asCustomClipper");
      t1 = _this._clipper;
      if (t1 == newClipper)
        return;
      _this.set$_clipper(newClipper);
      t2 = newClipper == null;
      H.assertHelper(!t2 || t1 != null);
      if (t2 || t1 == null || !new H.TypeImpl(H.getRti(newClipper)).$eq(0, new H.TypeImpl(H.getRti(t1))) || newClipper.shouldReclip$1(t1))
        _this._markNeedsClip$0();
      _this._node$_owner != null;
    },
    attach$1: function(owner) {
      this.super$_RenderProxyBox_RenderBox_RenderObjectWithChildMixin$attach(H.interceptedTypeCheck(owner, "$isPipelineOwner"));
    },
    detach$0: function() {
      this.super$_RenderProxyBox_RenderBox_RenderObjectWithChildMixin$detach();
    },
    _markNeedsClip$0: function() {
      this.set$_clip(null);
      this.markNeedsPaint$0();
      this.markNeedsSemanticsUpdate$0();
    },
    performLayout$0: function() {
      var _this = this,
        oldSize = _this._size != null ? _this.get$size() : null;
      _this.super$RenderProxyBoxMixin$performLayout();
      if (!J.$eq$(oldSize, _this.get$size()))
        _this.set$_clip(null);
    },
    _updateClip$0: function() {
      var t1, t2, t3, t4, _this = this;
      if (_this._clip == null) {
        t1 = _this._clipper;
        if (t1 == null)
          t1 = null;
        else {
          t2 = _this.get$size();
          t3 = t1.shape;
          t4 = t2._dx;
          t2 = t2._dy;
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (typeof t2 !== "number")
            return H.iae(t2);
          t1 = t3.getOuterPath$2$textDirection(new P.Rect(0, 0, 0 + t4, 0 + t2), t1.textDirection);
        }
        _this.set$_clip(t1 == null ? _this.get$_defaultClip() : t1);
      }
    },
    describeApproximatePaintClip$1: function(child) {
      var t1, t2;
      if (this._clipper == null)
        t1 = null;
      else {
        t1 = this.get$size();
        t2 = t1._dx;
        t1 = t1._dy;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = new P.Rect(0, 0, 0 + t2, 0 + t1);
      }
      if (t1 == null) {
        t1 = this.get$size();
        t2 = t1._dx;
        t1 = t1._dy;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = new P.Rect(0, 0, 0 + t2, 0 + t1);
      }
      return t1;
    },
    debugPaintSize$2: function(context, offset) {
      H.assertHelper(new E._RenderCustomClip_debugPaintSize_closure(this).call$0());
    },
    set$_clipper: function(_clipper) {
      this._clipper = H.assertSubtype(_clipper, "$isCustomClipper", [H.getRuntimeTypeArgument(this, "_RenderCustomClip", 0)], "$asCustomClipper");
    },
    set$_clip: function(_clip) {
      this._clip = H.assertSubtypeOfRuntimeType(_clip, H.getRuntimeTypeArgument(this, "_RenderCustomClip", 0));
    }
  };
  E._RenderCustomClip_debugPaintSize_closure.prototype = {
    call$0: function() {
      var t2, _null = null,
        t1 = this.$this;
      if (t1._debugPaint == null) {
        t2 = new P.Paint(new DataView(new ArrayBuffer(75)));
        t2.set$shader(P.Gradient$linear(C.Offset_0_0, C.Offset_10_10, H.setRuntimeTypeInfo([C.Color_0, C.Color_4294902015, C.Color_4294902015, C.Color_0], [P.Color]), H.setRuntimeTypeInfo([0.25, 0.25, 0.75, 0.75], [P.double]), C.TileMode_1));
        t2.set$strokeWidth(2);
        t2.set$style(C.PaintingStyle_1);
        t1._debugPaint = t2;
      }
      if (t1._debugText == null) {
        t2 = U.TextPainter$(_null, _null, _null, _null, C.TextSpan_vxj, C.TextAlign_4, C.TextDirection_0, 1);
        t2.layout$0();
        t1._debugText = t2;
      }
      return true;
    },
    $signature: 0
  };
  E.RenderClipRect.prototype = {
    get$_defaultClip: function() {
      var t1 = this.get$size(),
        t2 = t1._dx;
      t1 = t1._dy;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return new P.Rect(0, 0, 0 + t2, 0 + t1);
    },
    hitTest$2$position: function(result, position) {
      var _this = this;
      if (_this._clipper != null) {
        _this._updateClip$0();
        H.assertHelper(_this._clip != null);
        if (!_this._clip.contains$1(0, position))
          return false;
      }
      return _this.super$RenderBox$hitTest(result, position);
    },
    paint$2: function(context, offset) {
      var _this = this;
      if (_this.RenderObjectWithChildMixin__child != null) {
        _this._updateClip$0();
        H.assertHelper(!_this._needsCompositingBitsUpdate);
        context.pushClipRect$5$clipBehavior(_this._needsCompositing, offset, _this._clip, E.RenderProxyBoxMixin.prototype.get$paint.call(_this), _this.clipBehavior);
      }
    },
    debugPaintSize$2: function(context, offset) {
      H.assertHelper(new E.RenderClipRect_debugPaintSize_closure(this, context, offset).call$0());
    },
    $asRenderObjectWithChildMixin: function() {
      return [S.RenderBox];
    },
    $as_RenderCustomClip: function() {
      return [P.Rect];
    }
  };
  E.RenderClipRect_debugPaintSize_closure.prototype = {
    call$0: function() {
      var t2, t3, t4, t5, t6,
        t1 = this.$this;
      if (t1.RenderObjectWithChildMixin__child != null) {
        t2 = this.context;
        t3 = this.offset;
        t1.super$_RenderCustomClip$debugPaintSize(t2, t3);
        t2.get$canvas().drawRect$2(t1._clip.shift$1(t3), t1._debugPaint);
        t4 = t1._debugText;
        t2 = t2.get$canvas();
        t5 = t1._clip;
        t6 = t5.right;
        t5 = t5.left;
        if (typeof t6 !== "number")
          return t6.$sub();
        if (typeof t5 !== "number")
          return H.iae(t5);
        t1 = t1._debugText._text.style.fontSize;
        if (typeof t1 !== "number")
          return t1.$negate();
        t4.paint$2(t2, t3.$add(0, new P.Offset((t6 - t5) / 8, -t1 * 1.1)));
      }
      return true;
    },
    $signature: 0
  };
  E.RenderClipPath.prototype = {
    get$_defaultClip: function() {
      var t1 = new P.Path();
      H.throwExpression(P.UnimplementedError$(null));
      this.get$size();
      t1.addRect$1(null);
      return t1;
    },
    hitTest$2$position: function(result, position) {
      var _this = this;
      if (_this._clipper != null) {
        _this._updateClip$0();
        H.assertHelper(_this._clip != null);
        if (!_this._clip.contains$1(0, position))
          return false;
      }
      return _this.super$RenderBox$hitTest(result, position);
    },
    paint$2: function(context, offset) {
      var t1, t2, t3, _this = this;
      if (_this.RenderObjectWithChildMixin__child != null) {
        _this._updateClip$0();
        H.assertHelper(!_this._needsCompositingBitsUpdate);
        t1 = _this._needsCompositing;
        t2 = _this.get$size();
        t3 = t2._dx;
        t2 = t2._dy;
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (typeof t2 !== "number")
          return H.iae(t2);
        context.pushClipPath$6$clipBehavior(t1, offset, new P.Rect(0, 0, 0 + t3, 0 + t2), _this._clip, E.RenderProxyBoxMixin.prototype.get$paint.call(_this), _this.clipBehavior);
      }
    },
    debugPaintSize$2: function(context, offset) {
      H.assertHelper(new E.RenderClipPath_debugPaintSize_closure(this, context, offset).call$0());
    },
    $asRenderObjectWithChildMixin: function() {
      return [S.RenderBox];
    },
    $as_RenderCustomClip: function() {
      return [P.Path];
    }
  };
  E.RenderClipPath_debugPaintSize_closure.prototype = {
    call$0: function() {
      var t2, t3,
        t1 = this.$this;
      if (t1.RenderObjectWithChildMixin__child != null) {
        t2 = this.context;
        t3 = this.offset;
        t1.super$_RenderCustomClip$debugPaintSize(t2, t3);
        t2.get$canvas().drawPath$2(t1._clip.shift$1(t3), t1._debugPaint);
      }
      return true;
    },
    $signature: 0
  };
  E._RenderPhysicalModelBase.prototype = {
    set$elevation: function(value) {
      H.assertHelper(value != null && value >= 0);
      if (this._proxy_box$_elevation == value)
        return;
      this._proxy_box$_elevation = value;
      this.markNeedsPaint$0();
    },
    set$shadowColor: function(value) {
      H.assertHelper(value != null);
      if (J.$eq$(this._proxy_box$_shadowColor, value))
        return;
      this._proxy_box$_shadowColor = value;
      this.markNeedsPaint$0();
    },
    set$color: function(value) {
      H.assertHelper(value != null);
      if (J.$eq$(this._proxy_box$_color, value))
        return;
      this._proxy_box$_color = value;
      this.markNeedsPaint$0();
    },
    get$alwaysNeedsCompositing: function() {
      return true;
    },
    describeSemanticsConfiguration$1: function(config) {
      this.super$RenderObject$describeSemanticsConfiguration(config);
      config.set$elevation(this._proxy_box$_elevation);
    },
    debugFillProperties$1: function(description) {
      var t1, t2, _this = this, _null = null;
      _this.super$RenderBox$debugFillProperties(description);
      t1 = Y.DoubleProperty$("elevation", _this._proxy_box$_elevation, C.C__NoDefaultValue, _null, C.DiagnosticLevel_3, true, _null, _null);
      t2 = description.properties;
      C.JSArray_methods.add$1(t2, t1);
      t1 = P.Color;
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("color", _this._proxy_box$_color, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("shadowColor", _this._proxy_box$_color, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
    }
  };
  E.RenderPhysicalModel.prototype = {
    set$shape: function(value) {
      if (this._proxy_box$_shape === value)
        return;
      this._proxy_box$_shape = value;
      this._markNeedsClip$0();
    },
    set$borderRadius: function(value) {
      if (J.$eq$(this._proxy_box$_borderRadius, value))
        return;
      this._proxy_box$_borderRadius = value;
      this._markNeedsClip$0();
    },
    get$_defaultClip: function() {
      var t1, t2, t3, t4, _this = this;
      H.assertHelper(_this._size != null);
      switch (_this._proxy_box$_shape) {
        case C.BoxShape_0:
          t1 = _this._proxy_box$_borderRadius;
          if (t1 == null)
            t1 = C.BorderRadius_tLn;
          t2 = _this.get$size();
          t3 = t2._dx;
          t2 = t2._dy;
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (typeof t2 !== "number")
            return H.iae(t2);
          return t1.toRRect$1(new P.Rect(0, 0, 0 + t3, 0 + t2));
        case C.BoxShape_1:
          t1 = _this.get$size();
          t2 = t1._dx;
          t1 = t1._dy;
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = 0 + t2;
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = 0 + t1;
          t3 = (t2 - 0) / 2;
          t4 = (t1 - 0) / 2;
          return new P.RRect(0, 0, t2, t1, t3, t4, t3, t4, t3, t4, t3, t4);
      }
      return;
    },
    hitTest$2$position: function(result, position) {
      var _this = this;
      if (_this._clipper != null) {
        _this._updateClip$0();
        H.assertHelper(_this._clip != null);
        if (!_this._clip.contains$1(0, position))
          return false;
      }
      return _this.super$RenderBox$hitTest(result, position);
    },
    paint$2: function(context, offset) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, offsetRRect;
      if (this.RenderObjectWithChildMixin__child != null) {
        this._updateClip$0();
        t1 = this._clip;
        t2 = t1.left;
        t3 = offset._dx;
        if (typeof t2 !== "number")
          return t2.$add();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t4 = t1.top;
        t5 = offset._dy;
        if (typeof t4 !== "number")
          return t4.$add();
        if (typeof t5 !== "number")
          return H.iae(t5);
        t6 = t1.right;
        if (typeof t6 !== "number")
          return t6.$add();
        t7 = t1.bottom;
        if (typeof t7 !== "number")
          return t7.$add();
        t8 = t1.tlRadiusX;
        t9 = t1.tlRadiusY;
        t10 = t1.trRadiusX;
        t11 = t1.trRadiusY;
        offsetRRect = P.RRect$_raw(t1.blRadiusX, t1.blRadiusY, t7 + t5, t1.brRadiusX, t1.brRadiusY, t2 + t3, t6 + t3, t8, t9, t4 + t5, t10, t11);
        P.Rect$fromLTRB(offsetRRect.left, offsetRRect.top, offsetRRect.right, offsetRRect.bottom);
        H.throwExpression(P.UnimplementedError$(null));
        new P.Path().addRRect$1(offsetRRect);
      }
    },
    debugFillProperties$1: function(description) {
      var t1, t2, _null = null;
      this.super$_RenderPhysicalModelBase$debugFillProperties(description);
      t1 = Y.DiagnosticsProperty$("shape", this._proxy_box$_shape, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, F.BoxShape);
      t2 = description.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("borderRadius", this._proxy_box$_borderRadius, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.BorderRadius));
    },
    $asRenderObjectWithChildMixin: function() {
      return [S.RenderBox];
    },
    $as_RenderCustomClip: function() {
      return [P.RRect];
    },
    $as_RenderPhysicalModelBase: function() {
      return [P.RRect];
    }
  };
  E.RenderPhysicalShape.prototype = {
    get$_defaultClip: function() {
      var t1 = new P.Path();
      H.throwExpression(P.UnimplementedError$(null));
      this.get$size();
      t1.addRect$1(null);
      return t1;
    },
    hitTest$2$position: function(result, position) {
      var _this = this;
      if (_this._clipper != null) {
        _this._updateClip$0();
        H.assertHelper(_this._clip != null);
        if (!_this._clip.contains$1(0, position))
          return false;
      }
      return _this.super$RenderBox$hitTest(result, position);
    },
    paint$2: function(context, offset) {
      var t1, t2, t3, t4, _this = this;
      if (_this.RenderObjectWithChildMixin__child != null) {
        _this._updateClip$0();
        t1 = _this.get$size();
        t2 = offset._dx;
        t3 = offset._dy;
        t4 = t1._dx;
        t1 = t1._dy;
        if (typeof t2 !== "number")
          return t2.$add();
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (typeof t3 !== "number")
          return t3.$add();
        if (typeof t1 !== "number")
          return H.iae(t1);
        _this._clip.shift$1(offset);
      }
    },
    debugFillProperties$1: function(description) {
      var t1, _null = null;
      this.super$_RenderPhysicalModelBase$debugFillProperties(description);
      t1 = Y.DiagnosticsProperty$("clipper", this._clipper, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, [E.CustomClipper, P.Path]);
      C.JSArray_methods.add$1(description.properties, t1);
    },
    $asRenderObjectWithChildMixin: function() {
      return [S.RenderBox];
    },
    $as_RenderCustomClip: function() {
      return [P.Path];
    },
    $as_RenderPhysicalModelBase: function() {
      return [P.Path];
    }
  };
  E.DecorationPosition.prototype = {
    toString$0: function(_) {
      return this._proxy_box$_name;
    }
  };
  E.RenderDecoratedBox.prototype = {
    set$decoration: function(value) {
      var t1, _this = this;
      H.assertHelper(value != null);
      if (J.$eq$(value, _this._decoration))
        return;
      t1 = _this._painter;
      if (t1 != null)
        t1.dispose$0();
      _this._painter = null;
      _this._decoration = value;
      _this.markNeedsPaint$0();
    },
    set$position: function(value) {
      if (value === this._proxy_box$_position)
        return;
      this._proxy_box$_position = value;
      this.markNeedsPaint$0();
    },
    set$configuration: function(value) {
      if (value.$eq(0, this._configuration))
        return;
      this._configuration = value;
      this.markNeedsPaint$0();
    },
    detach$0: function() {
      var _this = this,
        t1 = _this._painter;
      if (t1 != null)
        t1.dispose$0();
      _this._painter = null;
      _this.super$_RenderProxyBox_RenderBox_RenderObjectWithChildMixin$detach();
      _this.markNeedsPaint$0();
    },
    hitTestSelf$1: function(position) {
      return this._decoration.hitTest$3$textDirection(this.get$size(), position, this._configuration.textDirection);
    },
    paint$2: function(context, offset) {
      var t2, t3, filledConfiguration, _this = this, t1 = {};
      H.assertHelper(_this.get$size()._dx != null);
      H.assertHelper(_this.get$size()._dy != null);
      if (_this._painter == null)
        _this._painter = _this._decoration.createBoxPainter$1(_this.get$markNeedsPaint());
      t2 = _this._configuration;
      t3 = _this.get$size();
      if (t3 == null)
        t3 = t2.size;
      filledConfiguration = new M.ImageConfiguration(t2.bundle, t2.devicePixelRatio, t2.locale, t2.textDirection, t3, t2.platform);
      if (_this._proxy_box$_position === C.DecorationPosition_0) {
        t1.debugSaveCount = null;
        H.assertHelper(new E.RenderDecoratedBox_paint_closure(t1, context).call$0());
        _this._painter.paint$3(context.get$canvas(), offset, filledConfiguration);
        H.assertHelper(new E.RenderDecoratedBox_paint_closure0(t1, _this, context).call$0());
        if (_this._decoration.get$isComplex())
          context.setIsComplexHint$0();
      }
      _this.super$RenderProxyBoxMixin$paint(context, offset);
      if (_this._proxy_box$_position === C.DecorationPosition_1) {
        _this._painter.paint$3(context.get$canvas(), offset, filledConfiguration);
        if (_this._decoration.get$isComplex())
          context.setIsComplexHint$0();
      }
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$RenderBox$debugFillProperties(properties);
      t1 = this._decoration;
      t1.toString;
      t1 = Y.DiagnosticableNode$("decoration", _null, t1, Y.Diagnosticable);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("configuration", this._configuration, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, M.ImageConfiguration));
    }
  };
  E.RenderDecoratedBox_paint_closure.prototype = {
    call$0: function() {
      this._box_0.debugSaveCount = this.context.get$canvas().getSaveCount$0();
      return true;
    },
    $signature: 0
  };
  E.RenderDecoratedBox_paint_closure0.prototype = {
    call$0: function() {
      var t2,
        t1 = this.context;
      t1.get$canvas().getSaveCount$0();
      t2 = this.$this;
      t2 = U.FlutterError$(J.get$runtimeType$(t2._decoration).toString$0(0) + " painter had mismatching save and restore calls.\nBefore painting the decoration, the canvas save count was " + H.S(this._box_0.debugSaveCount) + ". After painting it, the canvas save count was " + H.S(t1.get$canvas().getSaveCount$0()) + ". Every call to save() or saveLayer() must be matched by a call to restore().\nThe decoration was:\n  " + H.S(t2._decoration) + "\nThe painter was:\n  " + H.S(t2._painter));
      throw H.wrapException(t2);
    },
    $signature: 0
  };
  E.RenderTransform.prototype = {
    set$origin: function(value) {
      return;
    },
    set$alignment: function(value) {
      var _this = this;
      if (J.$eq$(_this._proxy_box$_alignment, value))
        return;
      _this._proxy_box$_alignment = value;
      _this.markNeedsPaint$0();
      _this.markNeedsSemanticsUpdate$0();
    },
    set$textDirection: function(value) {
      var _this = this;
      if (_this._proxy_box$_textDirection == value)
        return;
      _this._proxy_box$_textDirection = value;
      _this.markNeedsPaint$0();
      _this.markNeedsSemanticsUpdate$0();
    },
    set$transform: function(value) {
      var t1, _this = this;
      H.assertHelper(value != null);
      if (J.$eq$(_this._transform, value))
        return;
      t1 = new E.Matrix4(new Float64Array(16));
      t1.setFrom$1(value);
      _this._transform = t1;
      _this.markNeedsPaint$0();
      _this.markNeedsSemanticsUpdate$0();
    },
    get$_effectiveTransform: function() {
      var result, t1, t2, centerX, centerY, translation, _this = this,
        resolvedAlignment = _this._proxy_box$_alignment;
      if (resolvedAlignment == null)
        resolvedAlignment = null;
      if (resolvedAlignment == null)
        return _this._transform;
      result = new E.Matrix4(new Float64Array(16));
      result.setIdentity$0();
      t1 = _this.get$size();
      t2 = t1._dx;
      if (typeof t2 !== "number")
        return t2.$div();
      centerX = t2 / 2;
      t1 = t1._dy;
      if (typeof t1 !== "number")
        return t1.$div();
      centerY = t1 / 2;
      t1 = resolvedAlignment.x;
      if (typeof t1 !== "number")
        return t1.$mul();
      t1 = centerX + t1 * centerX;
      t2 = resolvedAlignment.y;
      if (typeof t2 !== "number")
        return t2.$mul();
      t2 = centerY + t2 * centerY;
      translation = new P.Offset(t1, t2);
      result.translate$2(t1, t2);
      result.multiply$1(_this._transform);
      t1 = translation._dx;
      if (typeof t1 !== "number")
        return t1.$negate();
      t2 = translation._dy;
      if (typeof t2 !== "number")
        return t2.$negate();
      result.translate$2(-t1, -t2);
      return result;
    },
    hitTest$2$position: function(result, position) {
      return this.hitTestChildren$2$position(result, position);
    },
    hitTestChildren$2$position: function(result, position) {
      var inverse;
      if (this.transformHitTests) {
        inverse = E.Matrix4_tryInvert(this.get$_effectiveTransform());
        if (inverse == null)
          return false;
        position = T.MatrixUtils_transformPoint(inverse, position);
      }
      return this.super$RenderProxyBoxMixin$hitTestChildren(result, position);
    },
    paint$2: function(context, offset) {
      var transform, childOffset, t1, t2, t3, t4, effectiveTransform, _this = this;
      if (_this.RenderObjectWithChildMixin__child != null) {
        transform = _this.get$_effectiveTransform();
        childOffset = T.MatrixUtils_getAsTranslation(transform);
        if (childOffset == null) {
          H.assertHelper(!_this._needsCompositingBitsUpdate);
          t1 = _this._needsCompositing;
          t2 = E.RenderProxyBoxMixin.prototype.get$paint.call(_this);
          t3 = offset._dx;
          t4 = offset._dy;
          effectiveTransform = E.Matrix4_Matrix4$translationValues(t3, t4, 0);
          effectiveTransform.multiply$1(transform);
          if (typeof t3 !== "number")
            return t3.$negate();
          if (typeof t4 !== "number")
            return t4.$negate();
          effectiveTransform.translate$2(-t3, -t4);
          if (H.boolConversionCheck(t1))
            context.pushLayer$4$childPaintBounds(new T.TransformLayer(effectiveTransform, C.Offset_0_0), t2, offset, T.MatrixUtils_inverseTransformRect(effectiveTransform, context.estimatedBounds));
          else {
            t1 = context.get$canvas();
            t1.save$0();
            t1.transform$1(effectiveTransform._m4storage);
            t2.call$2(context, offset);
            context.get$canvas().restore$0();
          }
        } else
          _this.super$RenderProxyBoxMixin$paint(context, offset.$add(0, childOffset));
      }
    },
    applyPaintTransform$2: function(child, transform) {
      H.interceptedTypeCheck(child, "$isRenderBox");
      transform.multiply$1(this.get$_effectiveTransform());
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$RenderBox$debugFillProperties(properties);
      t1 = T.TransformProperty$("transform matrix", _this._transform, C.C__NoDefaultValue, true);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("origin", _this._origin, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Offset));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("alignment", _this._proxy_box$_alignment, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.Alignment));
      t1 = _this._proxy_box$_textDirection;
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, "textDirection", true, true, C.DiagnosticsTreeStyle_5, [P.TextDirection]));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("transformHitTests", _this.transformHitTests, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.bool));
    }
  };
  E.RenderFractionalTranslation.prototype = {
    set$translation: function(value) {
      H.assertHelper(value != null);
      if (J.$eq$(this._translation, value))
        return;
      this._translation = value;
      this.markNeedsPaint$0();
    },
    hitTest$2$position: function(result, position) {
      return this.hitTestChildren$2$position(result, position);
    },
    hitTestChildren$2$position: function(result, position) {
      var t1, t2, t3, t4, t5, t6, _this = this;
      H.assertHelper(!H.boolConversionCheck(_this.get$debugNeedsLayout()));
      if (_this.transformHitTests) {
        t1 = position._dx;
        t2 = _this._translation._dx;
        t3 = _this.get$size()._dx;
        if (typeof t2 !== "number")
          return t2.$mul();
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (typeof t1 !== "number")
          return t1.$sub();
        t4 = position._dy;
        t5 = _this._translation._dy;
        t6 = _this.get$size()._dy;
        if (typeof t5 !== "number")
          return t5.$mul();
        if (typeof t6 !== "number")
          return H.iae(t6);
        if (typeof t4 !== "number")
          return t4.$sub();
        position = new P.Offset(t1 - t2 * t3, t4 - t5 * t6);
      }
      return _this.super$RenderProxyBoxMixin$hitTestChildren(result, position);
    },
    paint$2: function(context, offset) {
      var t1, t2, t3, t4, t5, t6, _this = this;
      H.assertHelper(!H.boolConversionCheck(_this.get$debugNeedsLayout()));
      if (_this.RenderObjectWithChildMixin__child != null) {
        t1 = offset._dx;
        t2 = _this._translation._dx;
        t3 = _this.get$size()._dx;
        if (typeof t2 !== "number")
          return t2.$mul();
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (typeof t1 !== "number")
          return t1.$add();
        t4 = offset._dy;
        t5 = _this._translation._dy;
        t6 = _this.get$size()._dy;
        if (typeof t5 !== "number")
          return t5.$mul();
        if (typeof t6 !== "number")
          return H.iae(t6);
        if (typeof t4 !== "number")
          return t4.$add();
        _this.super$RenderProxyBoxMixin$paint(context, new P.Offset(t1 + t2 * t3, t4 + t5 * t6));
      }
    },
    applyPaintTransform$2: function(child, transform) {
      var t1, t2, t3, t4, _this = this;
      H.interceptedTypeCheck(child, "$isRenderBox");
      t1 = _this._translation._dx;
      t2 = _this.get$size()._dx;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = _this._translation._dy;
      t4 = _this.get$size()._dy;
      if (typeof t3 !== "number")
        return t3.$mul();
      if (typeof t4 !== "number")
        return H.iae(t4);
      transform.translate$2(t1 * t2, t3 * t4);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$RenderBox$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("translation", this._translation, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Offset);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("transformHitTests", this.transformHitTests, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.bool));
    }
  };
  E.RenderPointerListener.prototype = {
    attach$1: function(owner) {
      var t1;
      this.super$_RenderProxyBox_RenderBox_RenderObjectWithChildMixin$attach(H.interceptedTypeCheck(owner, "$isPipelineOwner"));
      t1 = this._hoverAnnotation;
      if (t1 != null)
        $.RendererBinding__instance.RendererBinding__mouseTracker.attachAnnotation$1(t1);
    },
    detach$0: function() {
      var t1 = this._hoverAnnotation;
      if (t1 != null)
        $.RendererBinding__instance.RendererBinding__mouseTracker.detachAnnotation$1(t1);
      this.super$_RenderProxyBox_RenderBox_RenderObjectWithChildMixin$detach();
    },
    paint$2: function(context, offset) {
      var _this = this,
        t1 = _this._hoverAnnotation;
      if (t1 != null)
        context.pushLayer$3(T.AnnotatedRegionLayer$(t1, offset, _this.get$size(), Y.MouseTrackerAnnotation), E.RenderProxyBoxMixin.prototype.get$paint.call(_this), offset);
      _this.super$RenderProxyBoxMixin$paint(context, offset);
    },
    performResize$0: function() {
      var t1 = K.RenderObject.prototype.get$constraints.call(this);
      this.set$size(new P.Size(t1.constrainWidth$0(), t1.constrainHeight$0()));
    },
    handleEvent$2: function($event, entry) {
      var t1, t2, _this = this;
      _this.debugHandleEvent$2($event, entry);
      t1 = J.getInterceptor$($event);
      if (!!t1.$isPointerDownEvent)
        return _this.onPointerDown.call$1($event);
      t2 = _this.onPointerUp;
      if (t2 != null && !!t1.$isPointerUpEvent)
        return t2.call$1($event);
      t2 = _this.onPointerCancel;
      if (t2 != null && !!t1.$isPointerCancelEvent)
        return t2.call$1($event);
    },
    debugFillProperties$1: function(properties) {
      var t1, listeners;
      this.super$RenderProxyBoxWithHitTestBehavior$debugFillProperties(properties);
      t1 = P.String;
      listeners = H.setRuntimeTypeInfo([], [t1]);
      C.JSArray_methods.add$1(listeners, "down");
      if (this.onPointerUp != null)
        C.JSArray_methods.add$1(listeners, "up");
      if (this.onPointerCancel != null)
        C.JSArray_methods.add$1(listeners, "cancel");
      if (listeners.length === 0)
        C.JSArray_methods.add$1(listeners, "<none>");
      t1 = Y.IterableProperty$("listeners", listeners, C.C__NoDefaultValue, "[]", C.DiagnosticLevel_3, C.DiagnosticsTreeStyle_5, t1);
      C.JSArray_methods.add$1(properties.properties, t1);
    },
    set$onPointerDown: function(onPointerDown) {
      this.onPointerDown = H.functionTypeCheck(onPointerDown, {func: 1, ret: -1, args: [F.PointerDownEvent]});
    },
    set$onPointerMove: function(onPointerMove) {
      this.onPointerMove = H.functionTypeCheck(onPointerMove, {func: 1, ret: -1, args: [F.PointerMoveEvent]});
    },
    set$onPointerUp: function(onPointerUp) {
      this.onPointerUp = H.functionTypeCheck(onPointerUp, {func: 1, ret: -1, args: [F.PointerUpEvent]});
    },
    set$onPointerCancel: function(onPointerCancel) {
      this.onPointerCancel = H.functionTypeCheck(onPointerCancel, {func: 1, ret: -1, args: [F.PointerCancelEvent]});
    },
    set$onPointerSignal: function(onPointerSignal) {
      this.onPointerSignal = H.functionTypeCheck(onPointerSignal, {func: 1, ret: -1, args: [F.PointerSignalEvent]});
    }
  };
  E.RenderRepaintBoundary.prototype = {
    get$isRepaintBoundary: function() {
      return true;
    },
    debugRegisterRepaintBoundaryPaint$2$includedChild$includedParent: function(includedChild, includedParent) {
      H.assertHelper(new E.RenderRepaintBoundary_debugRegisterRepaintBoundaryPaint_closure(this, includedParent, includedChild).call$0());
    },
    debugFillProperties$1: function(properties) {
      var t1 = {};
      this.super$RenderBox$debugFillProperties(properties);
      t1.inReleaseMode = true;
      H.assertHelper(new E.RenderRepaintBoundary_debugFillProperties_closure(t1, this, properties).call$0());
      if (t1.inReleaseMode) {
        t1 = Y.DiagnosticsNode_DiagnosticsNode$message("(run in checked mode to collect repaint boundary statistics)", C.DiagnosticsTreeStyle_5);
        C.JSArray_methods.add$1(properties.properties, t1);
      }
    }
  };
  E.RenderRepaintBoundary_debugRegisterRepaintBoundaryPaint_closure.prototype = {
    call$0: function() {
      var t1 = this.includedParent && this.includedChild,
        t2 = this.$this;
      if (t1)
        ++t2._debugSymmetricPaintCount;
      else
        ++t2._debugAsymmetricPaintCount;
      return true;
    },
    $signature: 0
  };
  E.RenderRepaintBoundary_debugFillProperties_closure.prototype = {
    call$0: function() {
      var t1, t2, t3, t4, fraction, diagnosis, _this = this;
      _this._box_0.inReleaseMode = false;
      t1 = _this.$this;
      t2 = t1._debugSymmetricPaintCount;
      t3 = t1._debugAsymmetricPaintCount;
      t4 = t2 + t3;
      if (t4 === 0) {
        t1 = Y.MessageProperty$("usefulness ratio", "no metrics collected yet (never painted)");
        C.JSArray_methods.add$1(_this.properties.properties, t1);
      } else {
        fraction = t3 / t4;
        if (t4 < 5)
          diagnosis = "insufficient data to draw conclusion (less than five repaints)";
        else if (fraction > 0.9)
          diagnosis = "this is an outstandingly useful repaint boundary and should definitely be kept";
        else if (fraction > 0.5)
          diagnosis = "this is a useful repaint boundary and should be kept";
        else if (fraction > 0.3)
          diagnosis = "this repaint boundary is probably useful, but maybe it would be more useful in tandem with adding more repaint boundaries elsewhere";
        else if (fraction > 0.1)
          diagnosis = "this repaint boundary does sometimes show value, though currently not that often";
        else
          diagnosis = t3 === 0 ? "this repaint boundary is astoundingly ineffectual and should be removed" : "this repaint boundary is not very effective and should probably be removed";
        t1 = "" + t2 + " bad vs " + t1._debugAsymmetricPaintCount + " good";
        t2 = _this.properties.properties;
        C.JSArray_methods.add$1(t2, new Y.PercentProperty("useful", null, null, null, t1, false, fraction, C.C__NoDefaultValue, C.DiagnosticLevel_3, "metrics", true, true, C.DiagnosticsTreeStyle_5));
        C.JSArray_methods.add$1(t2, Y.MessageProperty$("diagnosis", diagnosis));
      }
      return true;
    },
    $signature: 0
  };
  E.RenderIgnorePointer.prototype = {
    set$ignoring: function(value) {
      var _this = this;
      if (value === _this._ignoring)
        return;
      _this._ignoring = value;
      if (_this._ignoringSemantics == null)
        _this.markNeedsSemanticsUpdate$0();
    },
    set$ignoringSemantics: function(value) {
      var _this = this,
        oldEffectiveValue = _this._ignoringSemantics;
      if (value == oldEffectiveValue)
        return;
      if (oldEffectiveValue == null)
        oldEffectiveValue = _this._ignoring;
      _this._ignoringSemantics = value;
      if (oldEffectiveValue !== (value == null ? _this._ignoring : value))
        _this.markNeedsSemanticsUpdate$0();
    },
    hitTest$2$position: function(result, position) {
      return this._ignoring ? false : this.super$RenderBox$hitTest(result, position);
    },
    visitChildrenForSemantics$1: function(visitor) {
      var t1, t2;
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [K.RenderObject]});
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null) {
        t2 = this._ignoringSemantics;
        t2 = !(t2 == null ? this._ignoring : t2);
      } else
        t2 = false;
      if (t2)
        visitor.call$1(t1);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, t4, _this = this, _null = null;
      _this.super$RenderBox$debugFillProperties(properties);
      t1 = P.bool;
      t2 = Y.DiagnosticsProperty$("ignoring", _this._ignoring, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t2);
      t2 = _this._ignoringSemantics;
      t4 = t2 == null;
      if (t4)
        t2 = _this._ignoring;
      if (t4) {
        t4 = _this._ignoring;
        t4 = "implicitly " + t4;
      } else
        t4 = _null;
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("ignoringSemantics", t2, C.C__NoDefaultValue, t4, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
    }
  };
  E.RenderOffstage.prototype = {
    set$offstage: function(value) {
      var _this = this;
      if (value === _this._proxy_box$_offstage)
        return;
      _this._proxy_box$_offstage = value;
      _this.markNeedsLayout$0();
      _this.markParentNeedsLayout$0();
    },
    computeDistanceToActualBaseline$1: function(baseline) {
      if (this._proxy_box$_offstage)
        return;
      return this.super$_RenderProxyBox_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin$computeDistanceToActualBaseline(baseline);
    },
    get$sizedByParent: function() {
      return this._proxy_box$_offstage;
    },
    performResize$0: function() {
      H.assertHelper(this._proxy_box$_offstage);
      var t1 = K.RenderObject.prototype.get$constraints.call(this);
      this.set$size(new P.Size(t1.constrainWidth$1(0), t1.constrainHeight$1(0)));
    },
    performLayout$0: function() {
      var t1, _this = this;
      if (_this._proxy_box$_offstage) {
        t1 = _this.RenderObjectWithChildMixin__child;
        if (t1 != null)
          t1.layout$1(K.RenderObject.prototype.get$constraints.call(_this));
      } else
        _this.super$RenderProxyBoxMixin$performLayout();
    },
    hitTest$2$position: function(result, position) {
      return !this._proxy_box$_offstage && this.super$RenderBox$hitTest(result, position);
    },
    paint$2: function(context, offset) {
      if (this._proxy_box$_offstage)
        return;
      this.super$RenderProxyBoxMixin$paint(context, offset);
    },
    visitChildrenForSemantics$1: function(visitor) {
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [K.RenderObject]});
      if (this._proxy_box$_offstage)
        return;
      this.super$RenderObject$visitChildrenForSemantics(visitor);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$RenderBox$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("offstage", this._proxy_box$_offstage, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.bool);
      C.JSArray_methods.add$1(properties.properties, t1);
    },
    debugDescribeChildren$0: function() {
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 == null)
        return H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]);
      return H.setRuntimeTypeInfo([new Y._DiagnosticableTreeNode(t1, "child", true, true, this._proxy_box$_offstage ? C.DiagnosticsTreeStyle_1 : C.DiagnosticsTreeStyle_0)], [Y.DiagnosticsNode]);
    }
  };
  E.RenderAbsorbPointer.prototype = {
    set$absorbing: function(value) {
      H.boolTypeCheck(value);
      if (this._absorbing == value)
        return;
      this._absorbing = value;
      this.markNeedsSemanticsUpdate$0();
    },
    set$ignoringSemantics: function(value) {
      return;
    },
    hitTest$2$position: function(result, position) {
      return H.boolConversionCheck(this._absorbing) ? this.get$size().contains$1(0, position) : this.super$RenderBox$hitTest(result, position);
    },
    visitChildrenForSemantics$1: function(visitor) {
      var t1, t2;
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [K.RenderObject]});
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null) {
        t2 = this._absorbing;
        t2 = !H.boolConversionCheck(t2);
      } else
        t2 = false;
      if (t2)
        visitor.call$1(t1);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, t4, _null = null;
      this.super$RenderBox$debugFillProperties(properties);
      t1 = P.bool;
      t2 = Y.DiagnosticsProperty$("absorbing", this._absorbing, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t2);
      t2 = this._absorbing;
      t4 = "implicitly " + H.S(t2);
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("ignoringSemantics", t2, C.C__NoDefaultValue, t4, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
    }
  };
  E.RenderSemanticsGestureHandler.prototype = {
    set$onTap: function(value) {
      var t1, _this = this;
      H.functionTypeCheck(value, {func: 1, ret: -1});
      if (J.$eq$(_this._proxy_box$_onTap, value))
        return;
      t1 = _this._proxy_box$_onTap;
      _this.set$_proxy_box$_onTap(value);
      if (value != null !== (t1 != null))
        _this.markNeedsSemanticsUpdate$0();
    },
    set$onLongPress: function(value) {
      var t1, _this = this;
      H.functionTypeCheck(value, {func: 1, ret: -1});
      if (J.$eq$(_this._proxy_box$_onLongPress, value))
        return;
      t1 = _this._proxy_box$_onLongPress;
      _this.set$_proxy_box$_onLongPress(value);
      if (value != null !== (t1 != null))
        _this.markNeedsSemanticsUpdate$0();
    },
    get$onHorizontalDragUpdate: function() {
      return this._onHorizontalDragUpdate;
    },
    set$onHorizontalDragUpdate: function(value) {
      var t1, _this = this;
      H.functionTypeCheck(value, {func: 1, ret: -1, args: [O.DragUpdateDetails]});
      if (J.$eq$(_this._onHorizontalDragUpdate, value))
        return;
      t1 = _this._onHorizontalDragUpdate;
      _this.set$_onHorizontalDragUpdate(value);
      if (value != null !== (t1 != null))
        _this.markNeedsSemanticsUpdate$0();
    },
    get$onVerticalDragUpdate: function() {
      return this._onVerticalDragUpdate;
    },
    set$onVerticalDragUpdate: function(value) {
      var t1, _this = this;
      H.functionTypeCheck(value, {func: 1, ret: -1, args: [O.DragUpdateDetails]});
      if (J.$eq$(_this._onVerticalDragUpdate, value))
        return;
      t1 = _this._onVerticalDragUpdate;
      _this.set$_onVerticalDragUpdate(value);
      if (value != null !== (t1 != null))
        _this.markNeedsSemanticsUpdate$0();
    },
    describeSemanticsConfiguration$1: function(config) {
      var t1, _this = this;
      _this.super$RenderObject$describeSemanticsConfiguration(config);
      if (_this._proxy_box$_onTap != null && _this._isValidAction$1(C.SemanticsAction_1)) {
        t1 = _this._proxy_box$_onTap;
        config.toString;
        H.functionTypeCheck(t1, {func: 1, ret: -1});
        config._addArgumentlessAction$2(C.SemanticsAction_1, t1);
        config.set$_onTap(t1);
      }
      if (_this._proxy_box$_onLongPress != null && _this._isValidAction$1(C.SemanticsAction_2)) {
        t1 = _this._proxy_box$_onLongPress;
        config.toString;
        H.functionTypeCheck(t1, {func: 1, ret: -1});
        config._addArgumentlessAction$2(C.SemanticsAction_2, t1);
        config.set$_onLongPress(t1);
      }
      if (_this._onHorizontalDragUpdate != null) {
        if (_this._isValidAction$1(C.SemanticsAction_8)) {
          config.toString;
          t1 = H.functionTypeCheck(_this.get$_performSemanticScrollRight(), {func: 1, ret: -1});
          config._addArgumentlessAction$2(C.SemanticsAction_8, t1);
          config.set$_semantics$_onScrollRight(t1);
        }
        if (_this._isValidAction$1(C.SemanticsAction_4)) {
          config.toString;
          t1 = H.functionTypeCheck(_this.get$_performSemanticScrollLeft(), {func: 1, ret: -1});
          config._addArgumentlessAction$2(C.SemanticsAction_4, t1);
          config.set$_semantics$_onScrollLeft(t1);
        }
      }
      if (_this._onVerticalDragUpdate != null) {
        if (_this._isValidAction$1(C.SemanticsAction_16)) {
          config.toString;
          t1 = H.functionTypeCheck(_this.get$_performSemanticScrollUp(), {func: 1, ret: -1});
          config._addArgumentlessAction$2(C.SemanticsAction_16, t1);
          config.set$_semantics$_onScrollUp(t1);
        }
        if (_this._isValidAction$1(C.SemanticsAction_32)) {
          config.toString;
          t1 = H.functionTypeCheck(_this.get$_performSemanticScrollDown(), {func: 1, ret: -1});
          config._addArgumentlessAction$2(C.SemanticsAction_32, t1);
          config.set$_semantics$_onScrollDown(t1);
        }
      }
    },
    _isValidAction$1: function(action) {
      return true;
    },
    _performSemanticScrollLeft$0: function() {
      var t1, primaryDelta, _this = this;
      if (_this._onHorizontalDragUpdate != null) {
        t1 = _this.get$size()._dx;
        if (typeof t1 !== "number")
          return t1.$mul();
        primaryDelta = t1 * -0.8;
        t1 = _this.get$size().center$1(C.Offset_0_0);
        _this.onHorizontalDragUpdate$1(O.DragUpdateDetails$(new P.Offset(primaryDelta, 0), T.MatrixUtils_transformPoint(_this.getTransformTo$1(null), t1), primaryDelta, null));
      }
    },
    _performSemanticScrollRight$0: function() {
      var t1, primaryDelta, _this = this;
      if (_this._onHorizontalDragUpdate != null) {
        t1 = _this.get$size()._dx;
        if (typeof t1 !== "number")
          return t1.$mul();
        primaryDelta = t1 * 0.8;
        t1 = _this.get$size().center$1(C.Offset_0_0);
        _this.onHorizontalDragUpdate$1(O.DragUpdateDetails$(new P.Offset(primaryDelta, 0), T.MatrixUtils_transformPoint(_this.getTransformTo$1(null), t1), primaryDelta, null));
      }
    },
    _performSemanticScrollUp$0: function() {
      var t1, primaryDelta, _this = this;
      if (_this._onVerticalDragUpdate != null) {
        t1 = _this.get$size()._dy;
        if (typeof t1 !== "number")
          return t1.$mul();
        primaryDelta = t1 * -0.8;
        t1 = _this.get$size().center$1(C.Offset_0_0);
        _this.onVerticalDragUpdate$1(O.DragUpdateDetails$(new P.Offset(0, primaryDelta), T.MatrixUtils_transformPoint(_this.getTransformTo$1(null), t1), primaryDelta, null));
      }
    },
    _performSemanticScrollDown$0: function() {
      var t1, primaryDelta, _this = this;
      if (_this._onVerticalDragUpdate != null) {
        t1 = _this.get$size()._dy;
        if (typeof t1 !== "number")
          return t1.$mul();
        primaryDelta = t1 * 0.8;
        t1 = _this.get$size().center$1(C.Offset_0_0);
        _this.onVerticalDragUpdate$1(O.DragUpdateDetails$(new P.Offset(0, primaryDelta), T.MatrixUtils_transformPoint(_this.getTransformTo$1(null), t1), primaryDelta, null));
      }
    },
    debugFillProperties$1: function(properties) {
      var t1, gestures, _this = this;
      _this.super$RenderBox$debugFillProperties(properties);
      t1 = P.String;
      gestures = H.setRuntimeTypeInfo([], [t1]);
      if (_this._proxy_box$_onTap != null)
        C.JSArray_methods.add$1(gestures, "tap");
      if (_this._proxy_box$_onLongPress != null)
        C.JSArray_methods.add$1(gestures, "long press");
      if (_this._onHorizontalDragUpdate != null)
        C.JSArray_methods.add$1(gestures, "horizontal scroll");
      if (_this._onVerticalDragUpdate != null)
        C.JSArray_methods.add$1(gestures, "vertical scroll");
      if (gestures.length === 0)
        C.JSArray_methods.add$1(gestures, "<none>");
      t1 = Y.IterableProperty$("gestures", gestures, C.C__NoDefaultValue, "[]", C.DiagnosticLevel_3, C.DiagnosticsTreeStyle_5, t1);
      C.JSArray_methods.add$1(properties.properties, t1);
    },
    set$_proxy_box$_onTap: function(_onTap) {
      this._proxy_box$_onTap = H.functionTypeCheck(_onTap, {func: 1, ret: -1});
    },
    set$_proxy_box$_onLongPress: function(_onLongPress) {
      this._proxy_box$_onLongPress = H.functionTypeCheck(_onLongPress, {func: 1, ret: -1});
    },
    set$_onHorizontalDragUpdate: function(_onHorizontalDragUpdate) {
      this._onHorizontalDragUpdate = H.functionTypeCheck(_onHorizontalDragUpdate, {func: 1, ret: -1, args: [O.DragUpdateDetails]});
    },
    set$_onVerticalDragUpdate: function(_onVerticalDragUpdate) {
      this._onVerticalDragUpdate = H.functionTypeCheck(_onVerticalDragUpdate, {func: 1, ret: -1, args: [O.DragUpdateDetails]});
    },
    onHorizontalDragUpdate$1: function(arg0) {
      return this.get$onHorizontalDragUpdate().call$1(arg0);
    },
    onVerticalDragUpdate$1: function(arg0) {
      return this.get$onVerticalDragUpdate().call$1(arg0);
    }
  };
  E.RenderSemanticsAnnotations.prototype = {
    set$container: function(value) {
      if (this._container === value)
        return;
      this._container = value;
      this.markNeedsSemanticsUpdate$0();
    },
    set$explicitChildNodes: function(value) {
      if (this._explicitChildNodes === value)
        return;
      this._explicitChildNodes = value;
      this.markNeedsSemanticsUpdate$0();
    },
    set$excludeSemantics: function(value) {
      return;
    },
    set$checked: function(value) {
      return;
    },
    set$enabled: function(value) {
      if (this._enabled == value)
        return;
      this._enabled = value;
      this.markNeedsSemanticsUpdate$0();
    },
    set$selected: function(value) {
      return;
    },
    set$button: function(value) {
      if (this._button == value)
        return;
      this._button = value;
      this.markNeedsSemanticsUpdate$0();
    },
    set$header: function(value) {
      if (this._header == value)
        return;
      this._header = value;
      this.markNeedsSemanticsUpdate$0();
    },
    set$textField: function(value) {
      return;
    },
    set$focused: function(value) {
      return;
    },
    set$inMutuallyExclusiveGroup: function(value) {
      return;
    },
    set$obscured: function(value) {
      return;
    },
    set$scopesRoute: function(value) {
      if (this._scopesRoute == value)
        return;
      this._scopesRoute = value;
      this.markNeedsSemanticsUpdate$0();
    },
    set$namesRoute: function(value) {
      if (this._namesRoute == value)
        return;
      this._namesRoute = value;
      this.markNeedsSemanticsUpdate$0();
    },
    set$hidden: function(value) {
      return;
    },
    set$image: function(value) {
      return;
    },
    set$liveRegion: function(value) {
      return;
    },
    set$toggled: function(value) {
      return;
    },
    set$label: function(value) {
      if (this._proxy_box$_label == value)
        return;
      this._proxy_box$_label = value;
      this.markNeedsSemanticsUpdate$0();
    },
    set$value: function(value) {
      return;
    },
    set$increasedValue: function(value) {
      return;
    },
    set$decreasedValue: function(value) {
      return;
    },
    set$hint: function(value) {
      return;
    },
    set$hintOverrides: function(value) {
      if (J.$eq$(this._proxy_box$_hintOverrides, value))
        return;
      this._proxy_box$_hintOverrides = value;
      this.markNeedsSemanticsUpdate$0();
    },
    set$textDirection: function(value) {
      if (this._proxy_box$_textDirection == value)
        return;
      this._proxy_box$_textDirection = value;
      this.markNeedsSemanticsUpdate$0();
    },
    set$sortKey: function(value) {
      return;
    },
    set$onTap: function(handler) {
      return;
    },
    get$onDismiss: function() {
      return this._onDismiss;
    },
    set$onDismiss: function(handler) {
      var t1, _this = this;
      H.functionTypeCheck(handler, {func: 1, ret: -1});
      if (J.$eq$(_this._onDismiss, handler))
        return;
      t1 = _this._onDismiss;
      _this.set$_onDismiss(handler);
      if (handler != null === (t1 != null))
        _this.markNeedsSemanticsUpdate$0();
    },
    set$onLongPress: function(handler) {
      return;
    },
    set$onScrollLeft: function(handler) {
      return;
    },
    set$onScrollRight: function(handler) {
      return;
    },
    set$onScrollUp: function(handler) {
      return;
    },
    set$onScrollDown: function(handler) {
      return;
    },
    set$onIncrease: function(handler) {
      return;
    },
    set$onDecrease: function(handler) {
      return;
    },
    set$onCopy: function(handler) {
      return;
    },
    set$onCut: function(handler) {
      return;
    },
    set$onPaste: function(handler) {
      return;
    },
    set$onMoveCursorForwardByCharacter: function(handler) {
      return;
    },
    set$onMoveCursorBackwardByCharacter: function(handler) {
      return;
    },
    set$onMoveCursorForwardByWord: function(handler) {
      return;
    },
    set$onMoveCursorBackwardByWord: function(handler) {
      return;
    },
    set$onSetSelection: function(handler) {
      return;
    },
    set$onDidGainAccessibilityFocus: function(handler) {
      return;
    },
    set$onDidLoseAccessibilityFocus: function(handler) {
      return;
    },
    set$customSemanticsActions: function(value) {
      return;
    },
    visitChildrenForSemantics$1: function(visitor) {
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [K.RenderObject]});
      this.super$RenderObject$visitChildrenForSemantics(visitor);
    },
    describeSemanticsConfiguration$1: function(config) {
      var t1, t2, _this = this;
      _this.super$RenderObject$describeSemanticsConfiguration(config);
      t1 = _this._container;
      H.assertHelper(!config._isMergingSemanticsOfDescendants || t1);
      config._isSemanticBoundary = t1;
      t1 = config.explicitChildNodes = _this._explicitChildNodes;
      t2 = _this._scopesRoute === true;
      if (H.assertTest(t2 && t1 || !t2))
        H.assertThrow("explicitChildNodes must be set to true if scopes route is true");
      t1 = _this._enabled;
      if (t1 != null) {
        config._setFlag$2(C.SemanticsFlag_64, true);
        config._setFlag$2(C.SemanticsFlag_128, t1);
      }
      t1 = _this._button;
      if (t1 != null)
        config._setFlag$2(C.SemanticsFlag_8, t1);
      t1 = _this._header;
      if (t1 != null)
        config._setFlag$2(C.SemanticsFlag_512, t1);
      t1 = _this._proxy_box$_label;
      if (t1 != null)
        config.set$label(t1);
      _this._proxy_box$_hintOverrides != null;
      t1 = _this._scopesRoute;
      if (t1 != null)
        config._setFlag$2(C.SemanticsFlag_2048, t1);
      t1 = _this._namesRoute;
      if (t1 != null)
        config._setFlag$2(C.SemanticsFlag_4096, t1);
      t1 = _this._proxy_box$_textDirection;
      if (t1 != null) {
        config._textDirection = t1;
        config._hasBeenAnnotated = true;
      }
      if (_this._onDismiss != null) {
        t1 = H.functionTypeCheck(_this.get$_performDismiss(), {func: 1, ret: -1});
        config._addArgumentlessAction$2(C.SemanticsAction_262144, t1);
        config.set$_semantics$_onDismiss(t1);
      }
    },
    _performDismiss$0: function() {
      if (this._onDismiss != null)
        this.onDismiss$0();
    },
    set$_onDismiss: function(_onDismiss) {
      this._onDismiss = H.functionTypeCheck(_onDismiss, {func: 1, ret: -1});
    },
    onDismiss$0: function() {
      return this.get$onDismiss().call$0();
    }
  };
  E.RenderBlockSemantics.prototype = {
    set$blocking: function(value) {
      return;
    },
    describeSemanticsConfiguration$1: function(config) {
      this.super$RenderObject$describeSemanticsConfiguration(config);
      config.isBlockingSemanticsOfPreviouslyPaintedNodes = true;
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$RenderBox$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("blocking", true, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.bool);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  E.RenderMergeSemantics.prototype = {
    describeSemanticsConfiguration$1: function(config) {
      this.super$RenderObject$describeSemanticsConfiguration(config);
      config._hasBeenAnnotated = config._isMergingSemanticsOfDescendants = config._isSemanticBoundary = true;
    }
  };
  E.RenderExcludeSemantics.prototype = {
    set$excluding: function(value) {
      if (value === this._excluding)
        return;
      this._excluding = value;
      this.markNeedsSemanticsUpdate$0();
    },
    visitChildrenForSemantics$1: function(visitor) {
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [K.RenderObject]});
      if (this._excluding)
        return;
      this.super$RenderObject$visitChildrenForSemantics(visitor);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$RenderBox$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("excluding", this._excluding, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.bool);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  E.RenderAnnotatedRegion.prototype = {
    set$value: function(newValue) {
      var _this = this;
      H.assertSubtypeOfRuntimeType(newValue, H.getTypeArgumentByIndex(_this, 0));
      if (_this._proxy_box$_value.$eq(0, newValue))
        return;
      _this.set$_proxy_box$_value(newValue);
      _this.markNeedsPaint$0();
    },
    set$sized: function(value) {
      return;
    },
    paint$2: function(context, offset) {
      var _this = this,
        t1 = _this._proxy_box$_value,
        t2 = _this.get$size();
      context.pushLayer$3(T.AnnotatedRegionLayer$(t1, offset, t2, H.getTypeArgumentByIndex(_this, 0)), E.RenderProxyBoxMixin.prototype.get$paint.call(_this), offset);
    },
    set$_proxy_box$_value: function(_value) {
      this._proxy_box$_value = H.assertSubtypeOfRuntimeType(_value, H.getTypeArgumentByIndex(this, 0));
    },
    get$alwaysNeedsCompositing: function() {
      return true;
    }
  };
  E._RenderProxyBox_RenderBox_RenderObjectWithChildMixin.prototype = {
    attach$1: function(owner) {
      var t1;
      H.interceptedTypeCheck(owner, "$isPipelineOwner");
      this.super$RenderObject$attach(owner);
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.attach$1(owner);
    },
    detach$0: function() {
      this.super$AbstractNode$detach();
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.detach$0();
    },
    set$_object$_child: function(_child) {
      this.RenderObjectWithChildMixin__child = H.assertSubtypeOfRuntimeType(_child, H.getRuntimeTypeArgument(this, "RenderObjectWithChildMixin", 0));
    }
  };
  E._RenderProxyBox_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin.prototype = {
    computeDistanceToActualBaseline$1: function(baseline) {
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        return t1.getDistanceToActualBaseline$1(baseline);
      return this.super$RenderBox$computeDistanceToActualBaseline(baseline);
    }
  };
  T.RenderShiftedBox.prototype = {
    computeDistanceToActualBaseline$1: function(baseline) {
      var result, childParentData, t1, _this = this;
      if (_this.RenderObjectWithChildMixin__child != null) {
        H.assertHelper(!H.boolConversionCheck(_this.get$debugNeedsLayout()));
        result = _this.RenderObjectWithChildMixin__child.getDistanceToActualBaseline$1(baseline);
        childParentData = H.interceptedTypeCheck(_this.RenderObjectWithChildMixin__child.parentData, "$isBoxParentData");
        if (result != null) {
          t1 = childParentData.offset._dy;
          if (typeof t1 !== "number")
            return H.iae(t1);
          result += t1;
        }
      } else
        result = _this.super$RenderBox$computeDistanceToActualBaseline(baseline);
      return result;
    },
    paint$2: function(context, offset) {
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        context.paintChild$2(t1, H.interceptedTypeCheck(t1.parentData, "$isBoxParentData").offset.$add(0, offset));
    },
    hitTestChildren$2$position: function(result, position) {
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        return t1.hitTest$2$position(result, position.$sub(0, H.interceptedTypeCheck(t1.parentData, "$isBoxParentData").offset));
      return false;
    },
    $asRenderObjectWithChildMixin: function() {
      return [S.RenderBox];
    }
  };
  T.RenderPadding.prototype = {
    _shifted_box$_resolve$0: function() {
      var t1, _this = this;
      if (_this._resolvedPadding != null)
        return;
      t1 = _this._padding.resolve$1(_this._shifted_box$_textDirection);
      _this._resolvedPadding = t1;
      H.assertHelper(t1.get$isNonNegative());
    },
    set$padding: function(value) {
      var _this = this;
      H.assertHelper(value != null);
      H.assertHelper(value.get$isNonNegative());
      if (J.$eq$(_this._padding, value))
        return;
      _this._padding = value;
      _this._resolvedPadding = null;
      _this.markNeedsLayout$0();
    },
    set$textDirection: function(value) {
      var _this = this;
      if (_this._shifted_box$_textDirection == value)
        return;
      _this._shifted_box$_textDirection = value;
      _this._resolvedPadding = null;
      _this.markNeedsLayout$0();
    },
    performLayout$0: function() {
      var t1, t2, t3, t4, t5, horizontal, vertical, deflatedMinWidth, deflatedMinHeight, childParentData, t6, t7, _this = this;
      _this._shifted_box$_resolve$0();
      H.assertHelper(_this._resolvedPadding != null);
      if (_this.RenderObjectWithChildMixin__child == null) {
        t1 = K.RenderObject.prototype.get$constraints.call(_this);
        t2 = _this._resolvedPadding;
        t3 = t2.left;
        t4 = t2.right;
        if (typeof t3 !== "number")
          return t3.$add();
        if (typeof t4 !== "number")
          return H.iae(t4);
        t5 = t2.top;
        t2 = t2.bottom;
        if (typeof t5 !== "number")
          return t5.$add();
        if (typeof t2 !== "number")
          return H.iae(t2);
        _this.set$size(t1.constrain$1(new P.Size(t3 + t4, t5 + t2)));
        return;
      }
      t1 = K.RenderObject.prototype.get$constraints.call(_this);
      t2 = _this._resolvedPadding;
      t1.toString;
      H.assertHelper(t2 != null);
      H.assertHelper(t1.debugAssertIsValid$0());
      horizontal = t2.get$horizontal();
      t3 = t2.get$_top();
      t2 = t2.get$_bottom();
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      vertical = t3 + t2;
      t2 = t1.minWidth;
      if (typeof t2 !== "number")
        return t2.$sub();
      deflatedMinWidth = Math.max(0, t2 - horizontal);
      t2 = t1.minHeight;
      if (typeof t2 !== "number")
        return t2.$sub();
      deflatedMinHeight = Math.max(0, t2 - vertical);
      t2 = t1.maxWidth;
      if (typeof t2 !== "number")
        return t2.$sub();
      t2 = Math.max(deflatedMinWidth, t2 - horizontal);
      t1 = t1.maxHeight;
      if (typeof t1 !== "number")
        return t1.$sub();
      t1 = Math.max(deflatedMinHeight, t1 - vertical);
      _this.RenderObjectWithChildMixin__child.layout$2$parentUsesSize(new S.BoxConstraints(deflatedMinWidth, t2, deflatedMinHeight, t1), true);
      t1 = _this.RenderObjectWithChildMixin__child;
      childParentData = H.interceptedTypeCheck(t1.parentData, "$isBoxParentData");
      t2 = _this._resolvedPadding;
      t3 = t2.left;
      childParentData.offset = new P.Offset(t3, t2.top);
      t2 = K.RenderObject.prototype.get$constraints.call(_this);
      t1 = t1.get$size()._dx;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t1 !== "number")
        return H.iae(t1);
      t4 = _this._resolvedPadding;
      t5 = t4.right;
      if (typeof t5 !== "number")
        return H.iae(t5);
      t4 = t4.top;
      t6 = _this.RenderObjectWithChildMixin__child.get$size()._dy;
      if (typeof t4 !== "number")
        return t4.$add();
      if (typeof t6 !== "number")
        return H.iae(t6);
      t7 = _this._resolvedPadding.bottom;
      if (typeof t7 !== "number")
        return H.iae(t7);
      _this.set$size(t2.constrain$1(new P.Size(t3 + t1 + t5, t4 + t6 + t7)));
    },
    debugPaintSize$2: function(context, offset) {
      this.super$RenderBox$debugPaintSize(context, offset);
      H.assertHelper(new T.RenderPadding_debugPaintSize_closure(this, offset, context).call$0());
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$RenderBox$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("padding", this._padding, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, V.EdgeInsetsGeometry);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      t1 = this._shifted_box$_textDirection;
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, "textDirection", true, true, C.DiagnosticsTreeStyle_5, [P.TextDirection]));
    }
  };
  T.RenderPadding_debugPaintSize_closure.prototype = {
    call$0: function() {
      var t5, outerRect,
        t1 = this.offset,
        t2 = this.$this,
        t3 = t2.get$size(),
        t4 = t1._dx;
      t1 = t1._dy;
      t5 = t3._dx;
      t3 = t3._dy;
      if (typeof t4 !== "number")
        return t4.$add();
      if (typeof t5 !== "number")
        return H.iae(t5);
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t3 !== "number")
        return H.iae(t3);
      outerRect = new P.Rect(t4, t1, t4 + t5, t1 + t3);
      t3 = this.context.get$canvas();
      E.debugPaintPadding(t3, outerRect, t2.RenderObjectWithChildMixin__child != null ? t2._resolvedPadding.deflateRect$1(outerRect) : null);
      return true;
    },
    $signature: 0
  };
  T.RenderAligningShiftedBox.prototype = {
    _shifted_box$_resolve$0: function() {
      var _this = this;
      if (_this._resolvedAlignment != null)
        return;
      _this._resolvedAlignment = _this._alignment.resolve$1(_this._shifted_box$_textDirection);
    },
    set$alignment: function(value) {
      var _this = this;
      H.assertHelper(value != null);
      if (J.$eq$(_this._alignment, value))
        return;
      _this._alignment = value;
      _this._resolvedAlignment = null;
      _this.markNeedsLayout$0();
    },
    set$textDirection: function(value) {
      var _this = this;
      if (_this._shifted_box$_textDirection == value)
        return;
      _this._shifted_box$_textDirection = value;
      _this._resolvedAlignment = null;
      _this.markNeedsLayout$0();
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$RenderBox$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("alignment", this._alignment, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.AlignmentGeometry);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      t1 = this._shifted_box$_textDirection;
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, t1, _null, C.DiagnosticLevel_3, "textDirection", true, true, C.DiagnosticsTreeStyle_5, [P.TextDirection]));
    }
  };
  T.RenderPositionedBox.prototype = {
    set$widthFactor: function(value) {
      H.assertHelper(value == null || value >= 0);
      if (this._widthFactor == value)
        return;
      this._widthFactor = value;
      this.markNeedsLayout$0();
    },
    set$heightFactor: function(value) {
      H.assertHelper(value == null || value >= 0);
      if (this._heightFactor == value)
        return;
      this._heightFactor = value;
      this.markNeedsLayout$0();
    },
    performLayout$0: function() {
      var t2, t3, t4, _this = this,
        shrinkWrapWidth = _this._widthFactor != null || K.RenderObject.prototype.get$constraints.call(_this).maxWidth === 1 / 0,
        shrinkWrapHeight = _this._heightFactor != null || K.RenderObject.prototype.get$constraints.call(_this).maxHeight === 1 / 0,
        t1 = _this.RenderObjectWithChildMixin__child;
      if (t1 != null) {
        t1.layout$2$parentUsesSize(K.RenderObject.prototype.get$constraints.call(_this).loosen$0(), true);
        t1 = K.RenderObject.prototype.get$constraints.call(_this);
        if (shrinkWrapWidth) {
          t2 = _this.RenderObjectWithChildMixin__child.get$size()._dx;
          t3 = _this._widthFactor;
          if (t3 == null)
            t3 = 1;
          if (typeof t2 !== "number")
            return t2.$mul();
          t3 = t2 * t3;
          t2 = t3;
        } else
          t2 = 1 / 0;
        if (shrinkWrapHeight) {
          t3 = _this.RenderObjectWithChildMixin__child.get$size()._dy;
          t4 = _this._heightFactor;
          if (t4 == null)
            t4 = 1;
          if (typeof t3 !== "number")
            return t3.$mul();
          t4 = t3 * t4;
          t3 = t4;
        } else
          t3 = 1 / 0;
        _this.set$size(t1.constrain$1(new P.Size(t2, t3)));
        _this._shifted_box$_resolve$0();
        H.assertHelper(_this.RenderObjectWithChildMixin__child != null);
        H.assertHelper(!H.boolConversionCheck(_this.RenderObjectWithChildMixin__child.get$debugNeedsLayout()));
        H.assertHelper(_this.RenderObjectWithChildMixin__child._size != null);
        H.assertHelper(_this._size != null);
        H.assertHelper(_this._resolvedAlignment != null);
        H.interceptedTypeCheck(_this.RenderObjectWithChildMixin__child.parentData, "$isBoxParentData").offset = _this._resolvedAlignment.alongOffset$1(H.interceptedTypeCheck(_this.get$size().$sub(0, _this.RenderObjectWithChildMixin__child.get$size()), "$isOffset"));
      } else {
        t1 = K.RenderObject.prototype.get$constraints.call(_this);
        t2 = shrinkWrapWidth ? 0 : 1 / 0;
        _this.set$size(t1.constrain$1(new P.Size(t2, shrinkWrapHeight ? 0 : 1 / 0)));
      }
    },
    debugPaintSize$2: function(context, offset) {
      this.super$RenderBox$debugPaintSize(context, offset);
      H.assertHelper(new T.RenderPositionedBox_debugPaintSize_closure(this, offset, context).call$0());
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$RenderAligningShiftedBox$debugFillProperties(properties);
      t1 = Y.DoubleProperty$("widthFactor", this._widthFactor, C.C__NoDefaultValue, "expand", C.DiagnosticLevel_3, true, _null, _null);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("heightFactor", this._heightFactor, C.C__NoDefaultValue, "expand", C.DiagnosticLevel_3, true, _null, _null));
    }
  };
  T.RenderPositionedBox_debugPaintSize_closure.prototype = {
    call$0: function() {
      var paint, t3, t4, t5,
        t1 = this.$this,
        t2 = t1.RenderObjectWithChildMixin__child;
      if (t2 != null) {
        t2 = t2.get$size();
        t2 = !t2.get$isEmpty(t2);
      } else
        t2 = false;
      if (t2) {
        paint = new P.Paint(new DataView(new ArrayBuffer(75)));
        paint.set$style(C.PaintingStyle_1);
        paint.set$strokeWidth(1);
        paint.set$color(C.Color_4294967040);
        H.throwExpression(P.UnimplementedError$(null));
      } else {
        paint = new P.Paint(new DataView(new ArrayBuffer(75)));
        paint.set$color(C.Color_2425393296);
        t2 = this.context.get$canvas();
        t3 = this.offset;
        t1 = t1.get$size();
        t4 = t3._dx;
        t3 = t3._dy;
        t5 = t1._dx;
        t1 = t1._dy;
        if (typeof t4 !== "number")
          return t4.$add();
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (typeof t3 !== "number")
          return t3.$add();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2.drawRect$2(new P.Rect(t4, t3, t4 + t5, t3 + t1), paint);
      }
      return true;
    },
    $signature: 0
  };
  T.SingleChildLayoutDelegate.prototype = {
    getSize$1: function(constraints) {
      return new P.Size(constraints.constrainWidth$0(), constraints.constrainHeight$0());
    }
  };
  T.RenderCustomSingleChildLayoutBox.prototype = {
    set$delegate: function(newDelegate) {
      var _this = this,
        t1 = _this._delegate;
      if (t1 === newDelegate)
        return;
      if (!new H.TypeImpl(H.getRti(newDelegate)).$eq(0, new H.TypeImpl(H.getRti(t1))) || newDelegate.shouldRelayout$1(t1))
        _this.markNeedsLayout$0();
      _this._delegate = newDelegate;
      _this._node$_owner != null;
    },
    attach$1: function(owner) {
      this.super$_RenderShiftedBox_RenderBox_RenderObjectWithChildMixin$attach(H.interceptedTypeCheck(owner, "$isPipelineOwner"));
    },
    detach$0: function() {
      this.super$_RenderShiftedBox_RenderBox_RenderObjectWithChildMixin$detach();
    },
    performLayout$0: function() {
      var childConstraints, t2, t3, t4, childParentData, _this = this,
        t1 = K.RenderObject.prototype.get$constraints.call(_this);
      _this.set$size(t1.constrain$1(_this._delegate.getSize$1(t1)));
      if (_this.RenderObjectWithChildMixin__child != null) {
        childConstraints = _this._delegate.getConstraintsForChild$1(K.RenderObject.prototype.get$constraints.call(_this));
        H.assertHelper(childConstraints.debugAssertIsValid$1$isAppliedConstraint(true));
        t1 = _this.RenderObjectWithChildMixin__child;
        t2 = childConstraints.minWidth;
        t3 = childConstraints.maxWidth;
        if (typeof t2 !== "number")
          return t2.$ge();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t3 = t2 >= t3;
        if (t3) {
          t2 = childConstraints.minHeight;
          t4 = childConstraints.maxHeight;
          if (typeof t2 !== "number")
            return t2.$ge();
          if (typeof t4 !== "number")
            return H.iae(t4);
          t4 = t2 >= t4;
          t2 = t4;
        } else
          t2 = false;
        t1.layout$2$parentUsesSize(childConstraints, !t2);
        childParentData = H.interceptedTypeCheck(_this.RenderObjectWithChildMixin__child.parentData, "$isBoxParentData");
        t2 = _this._delegate;
        t1 = _this.get$size();
        if (t3) {
          t3 = childConstraints.minHeight;
          t4 = childConstraints.maxHeight;
          if (typeof t3 !== "number")
            return t3.$ge();
          if (typeof t4 !== "number")
            return H.iae(t4);
          t4 = t3 >= t4;
          t3 = t4;
        } else
          t3 = false;
        childParentData.offset = t2.getPositionForChild$2(t1, t3 ? new P.Size(childConstraints.constrainWidth$1(0), childConstraints.constrainHeight$1(0)) : _this.RenderObjectWithChildMixin__child.get$size());
      }
    }
  };
  T._RenderShiftedBox_RenderBox_RenderObjectWithChildMixin.prototype = {
    attach$1: function(owner) {
      var t1;
      H.interceptedTypeCheck(owner, "$isPipelineOwner");
      this.super$RenderObject$attach(owner);
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.attach$1(owner);
    },
    detach$0: function() {
      this.super$AbstractNode$detach();
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.detach$0();
    },
    set$_object$_child: function(_child) {
      this.RenderObjectWithChildMixin__child = H.assertSubtypeOfRuntimeType(_child, H.getRuntimeTypeArgument(this, "RenderObjectWithChildMixin", 0));
    }
  };
  K.RelativeRect.prototype = {
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!(other instanceof K.RelativeRect))
        return false;
      return _this.left == other.left && _this.top == other.top && _this.right === other.right && _this.bottom === other.bottom;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.left, _this.top, _this.right, _this.bottom, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t2, _this = this,
        t1 = _this.left;
      t1 = "RelativeRect.fromLTRB(" + H.S(t1 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t1, 1)) + ", ";
      t2 = _this.top;
      t1 = t1 + H.S(t2 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t2, 1)) + ", ";
      t2 = C.JSNumber_methods.toStringAsFixed$1(_this.right, 1);
      t1 = t1 + t2 + ", ";
      t2 = C.JSNumber_methods.toStringAsFixed$1(_this.bottom, 1);
      return t1 + t2 + ")";
    }
  };
  K.StackParentData.prototype = {
    get$isPositioned: function() {
      var _this = this;
      return _this.top != null || _this.right != null || _this.bottom != null || _this.left != null || _this.width != null || false;
    },
    toString$0: function(_) {
      var _this = this,
        values = H.setRuntimeTypeInfo([], [P.String]),
        t1 = _this.top;
      if (t1 != null)
        C.JSArray_methods.add$1(values, "top=" + H.S(t1));
      t1 = _this.right;
      if (t1 != null)
        C.JSArray_methods.add$1(values, "right=" + H.S(t1));
      t1 = _this.bottom;
      if (t1 != null)
        C.JSArray_methods.add$1(values, "bottom=" + H.S(t1));
      t1 = _this.left;
      if (t1 != null)
        C.JSArray_methods.add$1(values, "left=" + H.S(t1));
      t1 = _this.width;
      if (t1 != null)
        C.JSArray_methods.add$1(values, "width=" + H.S(t1));
      if (values.length === 0)
        C.JSArray_methods.add$1(values, "not positioned");
      C.JSArray_methods.add$1(values, _this.super$BoxParentData$toString(0));
      return C.JSArray_methods.join$1(values, "; ");
    },
    $asContainerParentDataMixin: function() {
      return [S.RenderBox];
    },
    $as_ContainerBoxParentData_BoxParentData_ContainerParentDataMixin: function() {
      return [S.RenderBox];
    }
  };
  K.StackFit.prototype = {
    toString$0: function(_) {
      return this._stack$_name;
    }
  };
  K.Overflow.prototype = {
    toString$0: function(_) {
      return this._stack$_name;
    }
  };
  K.RenderStack.prototype = {
    setupParentData$1: function(child) {
      H.interceptedTypeCheck(child, "$isRenderBox");
      if (!(child.parentData instanceof K.StackParentData))
        child.parentData = new K.StackParentData(null, null, C.Offset_0_0);
    },
    _stack$_resolve$0: function() {
      var _this = this;
      if (_this._stack$_resolvedAlignment != null)
        return;
      _this._stack$_resolvedAlignment = _this._stack$_alignment.resolve$1(_this._stack$_textDirection);
    },
    set$alignment: function(value) {
      var _this = this;
      if (_this._stack$_alignment.$eq(0, value))
        return;
      _this._stack$_alignment = value;
      _this._stack$_resolvedAlignment = null;
      _this.markNeedsLayout$0();
    },
    set$textDirection: function(value) {
      var _this = this;
      if (_this._stack$_textDirection == value)
        return;
      _this._stack$_textDirection = value;
      _this._stack$_resolvedAlignment = null;
      _this.markNeedsLayout$0();
    },
    computeDistanceToActualBaseline$1: function(baseline) {
      return this.defaultComputeDistanceToHighestActualBaseline$1(baseline);
    },
    performLayout$0: function() {
      var t1, t2, width, height, nonPositionedConstraints, child, hasNonPositionedChildren, childParentData, childSize, t3, childConstraints, x, y, _this = this;
      _this._stack$_resolve$0();
      H.assertHelper(_this._stack$_resolvedAlignment != null);
      _this._hasVisualOverflow = false;
      if (_this.ContainerRenderObjectMixin__childCount === 0) {
        t1 = K.RenderObject.prototype.get$constraints.call(_this);
        _this.set$size(new P.Size(t1.constrainWidth$0(), t1.constrainHeight$0()));
        t1 = _this.get$size();
        t2 = t1._dx;
        t2.toString;
        if (isFinite(t2)) {
          t1 = t1._dy;
          t1.toString;
          t1 = isFinite(t1);
        } else
          t1 = false;
        H.assertHelper(t1);
        return;
      }
      width = K.RenderObject.prototype.get$constraints.call(_this).minWidth;
      height = K.RenderObject.prototype.get$constraints.call(_this).minHeight;
      switch (_this._fit) {
        case C.StackFit_0:
          nonPositionedConstraints = K.RenderObject.prototype.get$constraints.call(_this).loosen$0();
          break;
        case C.StackFit_1:
          t1 = K.RenderObject.prototype.get$constraints.call(_this);
          nonPositionedConstraints = S.BoxConstraints$tight(new P.Size(t1.constrainWidth$0(), t1.constrainHeight$0()));
          break;
        case C.StackFit_2:
          nonPositionedConstraints = K.RenderObject.prototype.get$constraints.call(_this);
          break;
        default:
          nonPositionedConstraints = null;
      }
      H.assertHelper(nonPositionedConstraints != null);
      child = _this.ContainerRenderObjectMixin__firstChild;
      for (hasNonPositionedChildren = false; child != null;) {
        childParentData = H.interceptedTypeCheck(child.parentData, "$isStackParentData");
        if (!childParentData.get$isPositioned()) {
          child.layout$2$parentUsesSize(nonPositionedConstraints, true);
          childSize = child.get$size();
          t1 = childSize._dx;
          width = Math.max(H.checkNum(width), H.checkNum(t1));
          t1 = childSize._dy;
          height = Math.max(H.checkNum(height), H.checkNum(t1));
          hasNonPositionedChildren = true;
        }
        child = childParentData.ContainerParentDataMixin_nextSibling;
      }
      if (hasNonPositionedChildren) {
        _this.set$size(new P.Size(width, height));
        H.assertHelper(_this.get$size()._dx === K.RenderObject.prototype.get$constraints.call(_this).constrainWidth$1(width));
        H.assertHelper(_this.get$size()._dy === K.RenderObject.prototype.get$constraints.call(_this).constrainHeight$1(height));
      } else {
        t1 = K.RenderObject.prototype.get$constraints.call(_this);
        _this.set$size(new P.Size(t1.constrainWidth$0(), t1.constrainHeight$0()));
      }
      t1 = _this.get$size();
      t2 = t1._dx;
      t2.toString;
      if (isFinite(t2)) {
        t1 = t1._dy;
        t1.toString;
        t1 = isFinite(t1);
      } else
        t1 = false;
      H.assertHelper(t1);
      child = _this.ContainerRenderObjectMixin__firstChild;
      for (; child != null;) {
        childParentData = H.interceptedTypeCheck(child.parentData, "$isStackParentData");
        if (!childParentData.get$isPositioned())
          childParentData.offset = _this._stack$_resolvedAlignment.alongOffset$1(H.interceptedTypeCheck(_this.get$size().$sub(0, child.get$size()), "$isOffset"));
        else {
          if (childParentData.left != null && childParentData.right != null) {
            t1 = _this.get$size()._dx;
            t2 = childParentData.right;
            if (typeof t1 !== "number")
              return t1.$sub();
            if (typeof t2 !== "number")
              return H.iae(t2);
            t3 = childParentData.left;
            if (typeof t3 !== "number")
              return H.iae(t3);
            childConstraints = C.BoxConstraints_mlX0.tighten$1$width(t1 - t2 - t3);
          } else {
            t1 = childParentData.width;
            childConstraints = t1 != null ? C.BoxConstraints_mlX0.tighten$1$width(t1) : C.BoxConstraints_mlX0;
          }
          if (childParentData.top != null && childParentData.bottom != null) {
            t1 = _this.get$size()._dy;
            t2 = childParentData.bottom;
            if (typeof t1 !== "number")
              return t1.$sub();
            if (typeof t2 !== "number")
              return H.iae(t2);
            t3 = childParentData.top;
            if (typeof t3 !== "number")
              return H.iae(t3);
            childConstraints = childConstraints.tighten$1$height(t1 - t2 - t3);
          }
          child.layout$2$parentUsesSize(childConstraints, true);
          x = childParentData.left;
          if (!(x != null))
            if (childParentData.right != null) {
              t1 = _this.get$size()._dx;
              t2 = childParentData.right;
              if (typeof t1 !== "number")
                return t1.$sub();
              if (typeof t2 !== "number")
                return H.iae(t2);
              t3 = child.get$size()._dx;
              if (typeof t3 !== "number")
                return H.iae(t3);
              x = t1 - t2 - t3;
            } else
              x = _this._stack$_resolvedAlignment.alongOffset$1(H.interceptedTypeCheck(_this.get$size().$sub(0, child.get$size()), "$isOffset"))._dx;
          if (typeof x !== "number")
            return x.$lt();
          if (!(x < 0)) {
            t1 = child.get$size()._dx;
            if (typeof t1 !== "number")
              return H.iae(t1);
            t2 = _this.get$size()._dx;
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = x + t1 > t2;
            t1 = t2;
          } else
            t1 = true;
          if (t1)
            _this._hasVisualOverflow = true;
          y = childParentData.top;
          if (!(y != null))
            if (childParentData.bottom != null) {
              t1 = _this.get$size()._dy;
              t2 = childParentData.bottom;
              if (typeof t1 !== "number")
                return t1.$sub();
              if (typeof t2 !== "number")
                return H.iae(t2);
              t3 = child.get$size()._dy;
              if (typeof t3 !== "number")
                return H.iae(t3);
              y = t1 - t2 - t3;
            } else
              y = _this._stack$_resolvedAlignment.alongOffset$1(H.interceptedTypeCheck(_this.get$size().$sub(0, child.get$size()), "$isOffset"))._dy;
          if (typeof y !== "number")
            return y.$lt();
          if (!(y < 0)) {
            t1 = child.get$size()._dy;
            if (typeof t1 !== "number")
              return H.iae(t1);
            t2 = _this.get$size()._dy;
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = y + t1 > t2;
            t1 = t2;
          } else
            t1 = true;
          if (t1)
            _this._hasVisualOverflow = true;
          childParentData.offset = new P.Offset(x, y);
        }
        H.assertHelper(child.parentData === childParentData);
        child = childParentData.ContainerParentDataMixin_nextSibling;
      }
    },
    hitTestChildren$2$position: function(result, position) {
      return this.defaultHitTestChildren$2$position(result, position);
    },
    paintStack$2: function(context, offset) {
      this.defaultPaint$2(context, offset);
    },
    paint$2: function(context, offset) {
      var t1, t2, t3, _this = this;
      if (_this._overflow === C.Overflow_1 && _this._hasVisualOverflow) {
        H.assertHelper(!_this._needsCompositingBitsUpdate);
        t1 = _this._needsCompositing;
        t2 = _this.get$size();
        t3 = t2._dx;
        t2 = t2._dy;
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (typeof t2 !== "number")
          return H.iae(t2);
        context.pushClipRect$4(t1, offset, new P.Rect(0, 0, 0 + t3, 0 + t2), _this.get$paintStack());
      } else
        _this.defaultPaint$2(context, offset);
    },
    describeApproximatePaintClip$1: function(child) {
      var t1, t2;
      if (this._hasVisualOverflow) {
        t1 = this.get$size();
        t2 = t1._dx;
        t1 = t1._dy;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = new P.Rect(0, 0, 0 + t2, 0 + t1);
      } else
        t1 = null;
      return t1;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$RenderBox$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("alignment", _this._stack$_alignment, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.AlignmentGeometry);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      t1 = _this._stack$_textDirection;
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, t1, C.C__NoDefaultValue, C.DiagnosticLevel_3, "textDirection", true, true, C.DiagnosticsTreeStyle_5, [P.TextDirection]));
      t1 = _this._fit;
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, t1, C.C__NoDefaultValue, C.DiagnosticLevel_3, "fit", true, true, C.DiagnosticsTreeStyle_5, [K.StackFit]));
      t1 = _this._overflow;
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, t1, C.C__NoDefaultValue, C.DiagnosticLevel_3, "overflow", true, true, C.DiagnosticsTreeStyle_5, [K.Overflow]));
    },
    $asRenderBoxContainerDefaultsMixin: function() {
      return [S.RenderBox, K.StackParentData];
    },
    $asContainerRenderObjectMixin: function() {
      return [S.RenderBox, K.StackParentData];
    }
  };
  K._RenderStack_RenderBox_ContainerRenderObjectMixin.prototype = {
    attach$1: function(owner) {
      var child;
      H.interceptedTypeCheck(owner, "$isPipelineOwner");
      this.super$RenderObject$attach(owner);
      child = this.ContainerRenderObjectMixin__firstChild;
      for (; child != null;) {
        child.attach$1(owner);
        child = H.interceptedTypeCheck(child.parentData, "$isStackParentData").ContainerParentDataMixin_nextSibling;
      }
    },
    detach$0: function() {
      this.super$AbstractNode$detach();
      var child = this.ContainerRenderObjectMixin__firstChild;
      for (; child != null;) {
        child.detach$0();
        child = H.interceptedTypeCheck(child.parentData, "$isStackParentData").ContainerParentDataMixin_nextSibling;
      }
    },
    set$_firstChild: function(_firstChild) {
      this.ContainerRenderObjectMixin__firstChild = H.assertSubtypeOfRuntimeType(_firstChild, H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 0));
    },
    set$_lastChild: function(_lastChild) {
      this.ContainerRenderObjectMixin__lastChild = H.assertSubtypeOfRuntimeType(_lastChild, H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 0));
    }
  };
  K._RenderStack_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin.prototype = {};
  A.ViewConfiguration.prototype = {
    toString$0: function(_) {
      return this.size.toString$0(0) + " at " + this.devicePixelRatio + "x";
    }
  };
  A.RenderView.prototype = {
    get$size: function() {
      return this._view$_size;
    },
    set$configuration: function(value) {
      var t1, _this = this;
      if (_this._view$_configuration === value)
        return;
      _this._view$_configuration = value;
      t1 = _this._updateMatricesAndCreateNewRootLayer$0();
      H.assertHelper(t1._node$_owner != null);
      H.assertHelper(_this._node$_owner != null);
      H.assertHelper(!(_this._node$_parent instanceof K.RenderObject));
      H.assertHelper(!H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isPipelineOwner")._debugDoingPaint);
      _this.get$isRepaintBoundary();
      H.assertHelper(_this._layer != null);
      _this._layer.detach$0();
      _this._layer = t1;
      _this.markNeedsPaint$0();
      H.assertHelper(_this._rootTransform != null);
      _this.markNeedsLayout$0();
    },
    _updateMatricesAndCreateNewRootLayer$0: function() {
      var rootLayer, _this = this,
        t1 = _this._view$_configuration.devicePixelRatio,
        t2 = new Float64Array(16),
        t3 = new E.Matrix4(t2);
      t2[15] = 1;
      t2[10] = 1;
      t2[5] = t1;
      t2[0] = t1;
      _this._rootTransform = t3;
      rootLayer = new T.TransformLayer(t3, C.Offset_0_0);
      rootLayer.attach$1(_this);
      H.assertHelper(_this._rootTransform != null);
      return rootLayer;
    },
    debugAssertDoesMeetConstraints$0: function() {
      H.assertHelper(false);
    },
    performResize$0: function() {
      H.assertHelper(false);
    },
    performLayout$0: function() {
      var t1, t2, _this = this;
      H.assertHelper(_this._rootTransform != null);
      t1 = _this._view$_size = _this._view$_configuration.size;
      t2 = t1._dx;
      t2.toString;
      if (isFinite(t2)) {
        t1 = t1._dy;
        t1.toString;
        t1 = isFinite(t1);
      } else
        t1 = false;
      H.assertHelper(t1);
      t1 = _this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.layout$1(S.BoxConstraints$tight(_this._view$_size));
    },
    hitTest$2$position: function(result, position) {
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.hitTest$2$position(result, position);
      C.JSArray_methods.add$1(result._path, new O.HitTestEntry(this));
      return true;
    },
    get$isRepaintBoundary: function() {
      return true;
    },
    paint$2: function(context, offset) {
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        context.paintChild$2(t1, offset);
    },
    applyPaintTransform$2: function(child, transform) {
      H.interceptedTypeCheck(child, "$isRenderBox");
      H.assertHelper(this._rootTransform != null);
      transform.multiply$1(this._rootTransform);
      this.super$RenderObject$applyPaintTransform(child, transform);
    },
    compositeFrame$0: function() {
      var builder, scene;
      P.Timeline_startSync("Compositing", C.Map_9aZ6I, null);
      try {
        builder = new P.SceneBuilder();
        this.get$isRepaintBoundary();
        H.assertHelper(!this._needsPaint);
        scene = this._layer.buildScene$1(builder);
      } finally {
        P.Timeline_finishSync();
      }
    },
    get$paintBounds: function() {
      var t1 = this._view$_size.$mul(0, this._view$_configuration.devicePixelRatio),
        t2 = t1._dx;
      t1 = t1._dy;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return new P.Rect(0, 0, 0 + t2, 0 + t1);
    },
    get$semanticBounds: function() {
      var t1, t2, t3;
      H.assertHelper(this._rootTransform != null);
      t1 = this._rootTransform;
      t2 = this._view$_size;
      t3 = t2._dx;
      t2 = t2._dy;
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return T.MatrixUtils_transformRect(t1, new P.Rect(0, 0, 0 + t3, 0 + t2));
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      H.assertHelper(new A.RenderView_debugFillProperties_closure(properties).call$0());
      this._window.toString;
      t1 = Y.DiagnosticsProperty$("window size", C.Size_0_0, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, "in physical pixels", P.Size);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("device pixel ratio", 1, C.C__NoDefaultValue, _null, C.DiagnosticLevel_3, true, "physical pixels per logical pixel", _null));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("configuration", this._view$_configuration, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, "in logical pixels", A.ViewConfiguration));
    },
    $asRenderObjectWithChildMixin: function() {
      return [S.RenderBox];
    }
  };
  A.RenderView_debugFillProperties_closure.prototype = {
    call$0: function() {
      var t1 = Y.DiagnosticsNode_DiagnosticsNode$message("debug mode enabled - " + H.S($.$get$Platform__operatingSystem()), C.DiagnosticsTreeStyle_5);
      C.JSArray_methods.add$1(this.properties.properties, t1);
      return true;
    },
    $signature: 0
  };
  A._RenderView_RenderObject_RenderObjectWithChildMixin.prototype = {
    attach$1: function(owner) {
      var t1;
      H.interceptedTypeCheck(owner, "$isPipelineOwner");
      this.super$RenderObject$attach(owner);
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.attach$1(owner);
    },
    detach$0: function() {
      this.super$AbstractNode$detach();
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.detach$0();
    },
    set$_object$_child: function(_child) {
      this.RenderObjectWithChildMixin__child = H.assertSubtypeOfRuntimeType(_child, H.getRuntimeTypeArgument(this, "RenderObjectWithChildMixin", 0));
    }
  };
  N.ViewportOffset.prototype = {};
  N._TaskEntry.prototype = {
    _TaskEntry$4: function(task, priority, debugLabel, flow, $T) {
      H.assertHelper(new N._TaskEntry_closure(this).call$0());
      this.set$completer(new P._AsyncCompleter(new P._Future($.Zone__current, [$T]), [$T]));
    },
    run$0: function() {
      P.Timeline_timeSync("Scheduled Task", new N._TaskEntry_run_closure(this), null, P.Null);
    },
    set$completer: function(completer) {
      this.completer = H.assertSubtype(completer, "$isCompleter", this.$ti, "$asCompleter");
    }
  };
  N._TaskEntry_closure.prototype = {
    call$0: function() {
      this.$this.debugStack = P.StackTrace_current();
      return true;
    },
    $signature: 0
  };
  N._TaskEntry_run_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1.completer.complete$1(t1.task.call$0());
    },
    $signature: 2
  };
  N._FrameCallbackEntry.prototype = {
    _FrameCallbackEntry$2$rescheduling: function(callback, rescheduling) {
      H.assertHelper(new N._FrameCallbackEntry_closure(this, rescheduling).call$0());
    }
  };
  N._FrameCallbackEntry_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (this.rescheduling) {
        H.assertHelper(new N._FrameCallbackEntry__closure().call$0());
        t1.debugStack = $._FrameCallbackEntry_debugCurrentCallbackStack;
      } else
        t1.debugStack = P.StackTrace_current();
      return true;
    },
    $signature: 0
  };
  N._FrameCallbackEntry__closure.prototype = {
    call$0: function() {
      if ($._FrameCallbackEntry_debugCurrentCallbackStack == null)
        throw H.wrapException(U.FlutterError$('scheduleFrameCallback called with rescheduling true, but no callback is in scope.\nThe "rescheduling" argument should only be set to true if the callback is being reregistered from within the callback itself, and only then if the callback itself is entirely synchronous. If this is the initial registration of the callback, or if the callback is asynchronous, then do not use the "rescheduling" argument.'));
      return true;
    },
    $signature: 0
  };
  N.SchedulerPhase.prototype = {
    toString$0: function(_) {
      return this._name;
    }
  };
  N.SchedulerBinding.prototype = {
    handleAppLifecycleStateChanged$1: function(state) {
      H.assertHelper(state != null);
      this.SchedulerBinding__lifecycleState = state;
      switch (state) {
        case C.AppLifecycleState_0:
        case C.AppLifecycleState_1:
          this._setFramesEnabledState$1(true);
          break;
        case C.AppLifecycleState_2:
        case C.AppLifecycleState_3:
          this._setFramesEnabledState$1(false);
          break;
      }
    },
    _handleLifecycleMessage$1: function(message) {
      return this._handleLifecycleMessage$body$SchedulerBinding(H.stringTypeCheck(message));
    },
    _handleLifecycleMessage$body$SchedulerBinding: function(message) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this;
      var $async$_handleLifecycleMessage$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self.handleAppLifecycleStateChanged$1(N.SchedulerBinding__parseAppLifecycleMessage(message));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_handleLifecycleMessage$1, $async$completer);
    },
    _ensureEventLoopCallback$0: function() {
      var _this = this;
      H.assertHelper(_this._lockCount <= 0);
      H.assertHelper(_this.SchedulerBinding__taskQueue._length !== 0);
      if (_this.SchedulerBinding__hasRequestedAnEventLoopCallback)
        return;
      _this.SchedulerBinding__hasRequestedAnEventLoopCallback = true;
      P.Timer_Timer(C.Duration_0, _this.get$_runTasks());
    },
    _runTasks$0: function() {
      this.SchedulerBinding__hasRequestedAnEventLoopCallback = false;
      if (this.handleEventLoopCallback$0())
        this._ensureEventLoopCallback$0();
    },
    handleEventLoopCallback$0: function() {
      var entry, exception, exceptionStack, t4, t5, newLength, last, exception0, _this = this,
        _s15_ = "No such element",
        t1 = {},
        t2 = _this.SchedulerBinding__taskQueue,
        t3 = t2._length === 0;
      if (t3 || _this._lockCount > 0)
        return false;
      if (t3)
        H.throwExpression(P.StateError$(_s15_));
      t3 = t2._priority_queue$_queue;
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      entry = t3[0];
      t3 = entry.priority;
      if (H.boolConversionCheck(_this.SchedulerBinding_schedulingStrategy.call$2$priority$scheduler(t3, _this))) {
        try {
          t3 = t2._length;
          if (t3 === 0)
            H.throwExpression(P.StateError$(_s15_));
          t4 = t2._priority_queue$_queue;
          t5 = t4.length;
          if (0 >= t5)
            return H.ioore(t4, 0);
          newLength = t3 - 1;
          if (newLength < 0 || newLength >= t5)
            return H.ioore(t4, newLength);
          last = t4[newLength];
          C.JSArray_methods.$indexSet(t4, newLength, null);
          t2._length = newLength;
          if (newLength > 0)
            t2._bubbleDown$2(last, 0);
          entry.run$0();
        } catch (exception0) {
          exception = H.unwrapException(exception0);
          exceptionStack = H.getTraceFromException(exception0);
          t1.callbackStack = null;
          H.assertHelper(new N.SchedulerBinding_handleEventLoopCallback_closure(t1, entry).call$0());
          t1 = t1.callbackStack == null ? null : new N.SchedulerBinding_handleEventLoopCallback_closure0(t1);
          U.FlutterError_reportError(U.FlutterErrorDetails$("during a task callback", exception, t1, "scheduler library", false, exceptionStack));
        }
        return t2._length !== 0;
      }
      return false;
    },
    get$endOfFrame: function() {
      var t1, _this = this;
      if (_this.SchedulerBinding__nextFrameCompleter == null) {
        if (_this.SchedulerBinding__schedulerPhase === C.SchedulerPhase_0)
          _this.scheduleFrame$0();
        t1 = -1;
        _this.set$_nextFrameCompleter(new P._AsyncCompleter(new P._Future($.Zone__current, [t1]), [t1]));
        C.JSArray_methods.add$1(_this.SchedulerBinding__postFrameCallbacks, H.functionTypeCheck(new N.SchedulerBinding_endOfFrame_closure(_this), {func: 1, ret: -1, args: [P.Duration]}));
      }
      return _this.SchedulerBinding__nextFrameCompleter.future;
    },
    _setFramesEnabledState$1: function(enabled) {
      if (this.SchedulerBinding__framesEnabled === enabled)
        return;
      this.SchedulerBinding__framesEnabled = enabled;
      if (enabled)
        this.scheduleFrame$0();
    },
    ensureVisualUpdate$0: function() {
      switch (this.SchedulerBinding__schedulerPhase) {
        case C.SchedulerPhase_0:
        case C.SchedulerPhase_4:
          this.scheduleFrame$0();
          return;
        case C.SchedulerPhase_1:
        case C.SchedulerPhase_2:
        case C.SchedulerPhase_3:
          return;
      }
    },
    scheduleFrame$0: function() {
      if (this.SchedulerBinding__hasScheduledFrame || !this.SchedulerBinding__framesEnabled)
        return;
      H.assertHelper(new N.SchedulerBinding_scheduleFrame_closure(this).call$0());
      $.$get$window().scheduleFrame$0();
    },
    scheduleForcedFrame$0: function() {
      if (this.SchedulerBinding__hasScheduledFrame)
        return;
      H.assertHelper(new N.SchedulerBinding_scheduleForcedFrame_closure(this).call$0());
      $.$get$window().scheduleFrame$0();
    },
    scheduleWarmUpFrame$0: function() {
      var hadScheduledFrame, _this = this;
      if (_this.SchedulerBinding__warmUpFrame || _this.SchedulerBinding__schedulerPhase !== C.SchedulerPhase_0)
        return;
      _this.SchedulerBinding__warmUpFrame = true;
      P.Timeline_startSync("Warm-up frame", null, null);
      hadScheduledFrame = _this.SchedulerBinding__hasScheduledFrame;
      P.Timer_Timer(C.Duration_0, new N.SchedulerBinding_scheduleWarmUpFrame_closure(_this));
      P.Timer_Timer(C.Duration_0, new N.SchedulerBinding_scheduleWarmUpFrame_closure0(_this, hadScheduledFrame));
      _this.lockEvents$1(new N.SchedulerBinding_scheduleWarmUpFrame_closure1(_this));
    },
    resetEpoch$0: function() {
      var _this = this;
      _this.SchedulerBinding__epochStart = _this._adjustForEpoch$1(_this.SchedulerBinding__lastRawTimeStamp);
      _this.SchedulerBinding__firstRawTimeStampInEpoch = null;
    },
    _adjustForEpoch$1: function(rawTimeStamp) {
      return P.Duration$(C.JSDouble_methods.round$0(0 / $._timeDilation) + this.SchedulerBinding__epochStart._duration, 0, 0);
    },
    _handleBeginFrame$1: function(rawTimeStamp) {
      var _this = this;
      if (_this.SchedulerBinding__warmUpFrame) {
        H.assertHelper(!_this.SchedulerBinding__ignoreNextEngineDrawFrame);
        _this.SchedulerBinding__ignoreNextEngineDrawFrame = true;
        return;
      }
      _this.handleBeginFrame$1(rawTimeStamp);
    },
    _handleDrawFrame$0: function() {
      if (this.SchedulerBinding__ignoreNextEngineDrawFrame) {
        this.SchedulerBinding__ignoreNextEngineDrawFrame = false;
        return;
      }
      this.handleDrawFrame$0();
    },
    handleBeginFrame$1: function(rawTimeStamp) {
      var callbacks, t1, _this = this;
      P.Timeline_startSync("Frame", C.Map_9aZ6I, null);
      _this.SchedulerBinding__firstRawTimeStampInEpoch = rawTimeStamp;
      t1 = _this.SchedulerBinding__lastRawTimeStamp;
      _this.SchedulerBinding__currentFrameTimeStamp = _this._adjustForEpoch$1(t1);
      ++_this.SchedulerBinding__profileFrameNumber;
      t1 = _this.SchedulerBinding__profileFrameStopwatch;
      t1.reset$0();
      t1.start$0();
      H.assertHelper(new N.SchedulerBinding_handleBeginFrame_closure(_this, rawTimeStamp).call$0());
      H.assertHelper(_this.SchedulerBinding__schedulerPhase === C.SchedulerPhase_0);
      _this.SchedulerBinding__hasScheduledFrame = false;
      try {
        P.Timeline_startSync("Animate", C.Map_9aZ6I, null);
        _this.SchedulerBinding__schedulerPhase = C.SchedulerPhase_1;
        callbacks = _this.SchedulerBinding__transientCallbacks;
        _this.set$_transientCallbacks(P.LinkedHashMap_LinkedHashMap$_empty(P.int, N._FrameCallbackEntry));
        J.forEach$1$ax(callbacks, new N.SchedulerBinding_handleBeginFrame_closure0(_this));
        _this.SchedulerBinding__removedIds.clear$0(0);
      } finally {
        _this.SchedulerBinding__schedulerPhase = C.SchedulerPhase_2;
      }
    },
    handleDrawFrame$0: function() {
      var callback, localPostFrameCallbacks, callback0, t1, t2, _i, _this = this;
      H.assertHelper(_this.SchedulerBinding__schedulerPhase === C.SchedulerPhase_2);
      P.Timeline_finishSync();
      try {
        _this.SchedulerBinding__schedulerPhase = C.SchedulerPhase_3;
        for (t1 = _this.SchedulerBinding__persistentCallbacks, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          callback = t1[_i];
          _this._invokeFrameCallback$2(callback, _this.SchedulerBinding__currentFrameTimeStamp);
        }
        _this.SchedulerBinding__schedulerPhase = C.SchedulerPhase_4;
        t1 = _this.SchedulerBinding__postFrameCallbacks;
        localPostFrameCallbacks = P.List_List$from(t1, true, {func: 1, ret: -1, args: [P.Duration]});
        C.JSArray_methods.set$length(t1, 0);
        for (t1 = localPostFrameCallbacks, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          callback0 = t1[_i];
          _this._invokeFrameCallback$2(callback0, _this.SchedulerBinding__currentFrameTimeStamp);
        }
      } finally {
        _this.SchedulerBinding__schedulerPhase = C.SchedulerPhase_0;
        P.Timeline_finishSync();
        t1 = _this.SchedulerBinding__profileFrameStopwatch;
        t1.stop$0();
        P.postEvent("Flutter.Frame", P.LinkedHashMap_LinkedHashMap$_literal(["number", _this.SchedulerBinding__profileFrameNumber, "startTime", _this.SchedulerBinding__currentFrameTimeStamp._duration, "elapsed", t1.get$elapsedMicroseconds()], P.String, null));
        H.assertHelper(new N.SchedulerBinding_handleDrawFrame_closure(_this).call$0());
        _this.SchedulerBinding__currentFrameTimeStamp = null;
      }
    },
    _invokeFrameCallback$3: function(callback, timeStamp, callbackStack) {
      var exception, exceptionStack, exception0, t1;
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.Duration]});
      H.assertHelper(callback != null);
      H.assertHelper($._FrameCallbackEntry_debugCurrentCallbackStack == null);
      H.assertHelper(new N.SchedulerBinding__invokeFrameCallback_closure(callbackStack).call$0());
      try {
        callback.call$1(timeStamp);
      } catch (exception0) {
        exception = H.unwrapException(exception0);
        exceptionStack = H.getTraceFromException(exception0);
        t1 = callbackStack == null ? null : new N.SchedulerBinding__invokeFrameCallback_closure0(callbackStack);
        U.FlutterError_reportError(U.FlutterErrorDetails$("during a scheduler callback", exception, t1, "scheduler library", false, exceptionStack));
      }
      H.assertHelper(new N.SchedulerBinding__invokeFrameCallback_closure1().call$0());
    },
    _invokeFrameCallback$2: function(callback, timeStamp) {
      return this._invokeFrameCallback$3(callback, timeStamp, null);
    },
    set$_transientCallbacks: function(_transientCallbacks) {
      this.SchedulerBinding__transientCallbacks = H.assertSubtype(_transientCallbacks, "$isMap", [P.int, N._FrameCallbackEntry], "$asMap");
    },
    set$_nextFrameCompleter: function(_nextFrameCompleter) {
      this.SchedulerBinding__nextFrameCompleter = H.assertSubtype(_nextFrameCompleter, "$isCompleter", [-1], "$asCompleter");
    }
  };
  N.SchedulerBinding_handleEventLoopCallback_closure.prototype = {
    call$0: function() {
      this._box_0.callbackStack = this.entry.debugStack;
      return true;
    },
    $signature: 0
  };
  N.SchedulerBinding_handleEventLoopCallback_closure0.prototype = {
    call$1: function(information) {
      information._contents += "\nThis exception was thrown in the context of a task callback. When the task callback was _registered_ (as opposed to when the exception was thrown), this was the stack:\n";
      C.JSArray_methods.forEach$1(U.FlutterError_defaultStackFilter(H.setRuntimeTypeInfo(C.JSString_methods.trimRight$0(J.toString$0$(this._box_0.callbackStack)).split("\n"), [P.String])), information.get$writeln());
    },
    $signature: 3
  };
  N.SchedulerBinding_endOfFrame_closure.prototype = {
    call$1: function(timeStamp) {
      var t1;
      H.interceptedTypeCheck(timeStamp, "$isDuration");
      t1 = this.$this;
      t1.SchedulerBinding__nextFrameCompleter.complete$0();
      t1.set$_nextFrameCompleter(null);
    },
    $signature: 34
  };
  N.SchedulerBinding_scheduleFrame_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  N.SchedulerBinding_scheduleForcedFrame_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  N.SchedulerBinding_scheduleWarmUpFrame_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      H.assertHelper(t1.SchedulerBinding__warmUpFrame);
      t1.handleBeginFrame$1(null);
    },
    $signature: 2
  };
  N.SchedulerBinding_scheduleWarmUpFrame_closure0.prototype = {
    call$0: function() {
      var t1 = this.$this;
      H.assertHelper(t1.SchedulerBinding__warmUpFrame);
      t1.handleDrawFrame$0();
      t1.resetEpoch$0();
      t1.SchedulerBinding__warmUpFrame = false;
      if (this.hadScheduledFrame)
        t1.scheduleFrame$0();
    },
    $signature: 2
  };
  N.SchedulerBinding_scheduleWarmUpFrame_closure1.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait($async$self.$this.get$endOfFrame(), $async$call$0);
            case 2:
              // returning from await.
              P.Timeline_finishSync();
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 25
  };
  N.SchedulerBinding_handleBeginFrame_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  N.SchedulerBinding_handleBeginFrame_closure0.prototype = {
    call$2: function(id, callbackEntry) {
      var t1;
      H.intTypeCheck(id);
      H.interceptedTypeCheck(callbackEntry, "$is_FrameCallbackEntry");
      t1 = this.$this;
      if (!t1.SchedulerBinding__removedIds.contains$1(0, id))
        t1._invokeFrameCallback$3(callbackEntry.callback, t1.SchedulerBinding__currentFrameTimeStamp, callbackEntry.debugStack);
    },
    $signature: 100
  };
  N.SchedulerBinding_handleDrawFrame_closure.prototype = {
    call$0: function() {
      this.$this.SchedulerBinding__debugBanner = null;
      return true;
    },
    $signature: 0
  };
  N.SchedulerBinding__invokeFrameCallback_closure.prototype = {
    call$0: function() {
      $._FrameCallbackEntry_debugCurrentCallbackStack = this.callbackStack;
      return true;
    },
    $signature: 0
  };
  N.SchedulerBinding__invokeFrameCallback_closure0.prototype = {
    call$1: function(information) {
      information._contents += "\nThis exception was thrown in the context of a scheduler callback. When the scheduler callback was _registered_ (as opposed to when the exception was thrown), this was the stack:\n";
      C.JSArray_methods.forEach$1(U.FlutterError_defaultStackFilter(H.setRuntimeTypeInfo(C.JSString_methods.trimRight$0(this.callbackStack.toString$0(0)).split("\n"), [P.String])), information.get$writeln());
    },
    $signature: 3
  };
  N.SchedulerBinding__invokeFrameCallback_closure1.prototype = {
    call$0: function() {
      $._FrameCallbackEntry_debugCurrentCallbackStack = null;
      return true;
    },
    $signature: 0
  };
  M.Ticker.prototype = {
    Ticker$2$debugLabel: function(_onTick, debugLabel) {
      H.assertHelper(new M.Ticker_closure(this).call$0());
    },
    set$muted: function(value) {
      var t1, _this = this;
      if (value === _this._muted)
        return;
      _this._muted = value;
      if (value)
        _this.unscheduleTick$0();
      else {
        t1 = _this._future != null && _this._animationId == null;
        if (t1)
          _this.scheduleTick$0();
      }
    },
    get$isTicking: function() {
      if (this._future == null)
        return false;
      if (this._muted)
        return false;
      var t1 = $.SchedulerBinding__instance;
      if (t1.SchedulerBinding__framesEnabled)
        return true;
      if (t1.SchedulerBinding__schedulerPhase !== C.SchedulerPhase_0)
        return true;
      return false;
    },
    start$0: function() {
      var t1, t2, _this = this;
      H.assertHelper(new M.Ticker_start_closure(_this).call$0());
      H.assertHelper(_this._startTime == null);
      t1 = -1;
      _this._future = new M.TickerFuture(new P._AsyncCompleter(new P._Future($.Zone__current, [t1]), [t1]));
      if (!_this._muted)
        t1 = _this._animationId == null;
      else
        t1 = false;
      if (t1)
        _this.scheduleTick$0();
      t1 = $.SchedulerBinding__instance;
      t2 = t1.SchedulerBinding__schedulerPhase.index;
      if (t2 > 0 && t2 < 4) {
        H.assertHelper(t1.SchedulerBinding__currentFrameTimeStamp != null);
        _this._startTime = t1.SchedulerBinding__currentFrameTimeStamp;
      }
      return _this._future;
    },
    stop$1$canceled: function(canceled) {
      var _this = this,
        t1 = _this._future;
      if (t1 == null)
        return;
      _this._startTime = _this._future = null;
      _this.unscheduleTick$0();
      if (canceled)
        t1._cancel$1(_this);
      else
        t1._ticker$_complete$0();
    },
    _ticker$_tick$1: function(timeStamp) {
      var t1, _this = this;
      H.assertHelper(_this.get$isTicking());
      H.assertHelper(_this._animationId != null);
      _this._animationId = null;
      t1 = _this._startTime;
      if (t1 == null)
        t1 = _this._startTime = timeStamp;
      _this._onTick.call$1(new P.Duration(timeStamp._duration - t1._duration));
      if (!_this._muted && _this._future != null && _this._animationId == null)
        _this.scheduleTick$1$rescheduling(true);
    },
    scheduleTick$1$rescheduling: function(rescheduling) {
      var t1, t2, t3, _this = this;
      H.assertHelper(_this._animationId == null);
      H.assertHelper(!_this._muted && _this._future != null && _this._animationId == null);
      t1 = $.SchedulerBinding__instance;
      t1.toString;
      t2 = H.functionTypeCheck(_this.get$_ticker$_tick(), {func: 1, ret: -1, args: [P.Duration]});
      t1.scheduleFrame$0();
      t3 = ++t1.SchedulerBinding__nextFrameCallbackId;
      t1.SchedulerBinding__transientCallbacks.$indexSet(0, t3, N._FrameCallbackEntry$(t2, rescheduling));
      _this._animationId = t1.SchedulerBinding__nextFrameCallbackId;
    },
    scheduleTick$0: function() {
      return this.scheduleTick$1$rescheduling(false);
    },
    unscheduleTick$0: function() {
      var t2, _this = this,
        t1 = _this._animationId;
      if (t1 != null) {
        t2 = $.SchedulerBinding__instance;
        t2.toString;
        H.assertHelper(t1 > 0);
        t2.SchedulerBinding__transientCallbacks.remove$1(0, t1);
        t2.SchedulerBinding__removedIds.add$1(0, t1);
        t1 = _this._animationId = null;
      }
      H.assertHelper(!(!_this._muted && _this._future != null && t1 == null));
    },
    dispose$0: function() {
      var _this = this,
        t1 = _this._future;
      if (t1 != null) {
        _this._future = null;
        _this.unscheduleTick$0();
        t1._cancel$1(_this);
      }
      H.assertHelper(new M.Ticker_dispose_closure(_this).call$0());
    },
    toString$1$debugIncludeStack: function(_, debugIncludeStack) {
      var t1,
        buffer = new P.StringBuffer("");
      buffer._contents = new H.TypeImpl(H.getRti(this)).toString$0(0) + "(";
      H.assertHelper(new M.Ticker_toString_closure(this, buffer).call$0());
      buffer._contents += ")";
      H.assertHelper(new M.Ticker_toString_closure0(this, debugIncludeStack, buffer).call$0());
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    toString$0: function($receiver) {
      return this.toString$1$debugIncludeStack($receiver, false);
    }
  };
  M.Ticker_closure.prototype = {
    call$0: function() {
      this.$this._debugCreationStack = P.StackTrace_current();
      return true;
    },
    $signature: 0
  };
  M.Ticker_start_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (t1._future != null)
        throw H.wrapException(U.FlutterError$("A ticker was started twice.\nA ticker that is already active cannot be started again without first stopping it.\nThe affected ticker was: " + t1.toString$1$debugIncludeStack(0, true)));
      return true;
    },
    $signature: 0
  };
  M.Ticker_dispose_closure.prototype = {
    call$0: function() {
      this.$this._startTime = C.Duration_0;
      return true;
    },
    $signature: 0
  };
  M.Ticker_toString_closure.prototype = {
    call$0: function() {
      this.buffer._contents += this.$this.debugLabel;
      return true;
    },
    $signature: 0
  };
  M.Ticker_toString_closure0.prototype = {
    call$0: function() {
      var t1, t2;
      if (this.debugIncludeStack) {
        t1 = this.buffer;
        t1._contents += "\n";
        t2 = this.$this;
        t1._contents += "The stack trace when the " + new H.TypeImpl(H.getRti(t2)).toString$0(0) + " was actually created was:\n";
        C.JSArray_methods.forEach$1(U.FlutterError_defaultStackFilter(H.setRuntimeTypeInfo(C.JSString_methods.trimRight$0(J.toString$0$(t2._debugCreationStack)).split("\n"), [P.String])), t1.get$writeln());
      }
      return true;
    },
    $signature: 0
  };
  M.TickerFuture.prototype = {
    _ticker$_complete$0: function() {
      H.assertHelper(this._completed == null);
      this._completed = true;
      this._primaryCompleter.complete$1(null);
    },
    _cancel$1: function(ticker) {
      H.assertHelper(this._completed == null);
      this._completed = false;
    },
    then$1$2$onError: function(f, onError, $E) {
      return this._primaryCompleter.future.then$1$2$onError(H.functionTypeCheck(H.functionTypeCheck(f, {func: 1, args: [-1]}), {func: 1, ret: {futureOr: 1, type: $E}, args: [-1]}), onError, $E);
    },
    then$1$1: function(f, $E) {
      return this.then$1$2$onError(f, null, $E);
    },
    whenComplete$1: function(action) {
      return this._primaryCompleter.future.whenComplete$1(H.functionTypeCheck(action, {func: 1}));
    },
    toString$0: function(_) {
      var _this = this,
        t1 = _this.get$runtimeType(_this).toString$0(0) + "#" + Y.shortHash(_this) + "(",
        t2 = _this._completed;
      if (t2 == null)
        t2 = "active";
      else
        t2 = t2 ? "complete" : "canceled";
      return t1 + t2 + ")";
    },
    $isFuture: 1,
    $asFuture: function() {
      return [-1];
    }
  };
  N.SemanticsBinding.prototype = {
    handleAccessibilityFeaturesChanged$0: function() {
      $.$get$window().toString;
      this.SemanticsBinding__accessibilityFeatures = null;
    },
    get$disableAnimations: function() {
      var t1 = {};
      t1.value = this.SemanticsBinding__accessibilityFeatures.get$disableAnimations();
      H.assertHelper(new N.SemanticsBinding_disableAnimations_closure(t1).call$0());
      return t1.value;
    }
  };
  N.SemanticsBinding_disableAnimations_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  A.SemanticsTag.prototype = {};
  A.CustomSemanticsAction.prototype = {};
  A.SemanticsData.prototype = {
    toStringShort$0: function() {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, actionSummary, t4, t5, t6, customSemanticsActionSummary, flagSummary, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("rect", _this.rect, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_5, _null, P.Rect);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, T.TransformProperty$("transform", _this.transform, _null, false));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("elevation", _this.elevation, 0, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("thickness", _this.thickness, 0, _null, C.DiagnosticLevel_3, true, _null, _null));
      t1 = P.String;
      t3 = [t1];
      actionSummary = H.setRuntimeTypeInfo([], t3);
      for (t4 = C.Map_EC0yd.get$values(), t4 = t4.get$iterator(t4), t5 = _this.actions; t4.moveNext$0();) {
        t6 = t4.get$current();
        if ((t5 & t6.index) !== 0)
          C.JSArray_methods.add$1(actionSummary, Y.describeEnum(t6));
      }
      t4 = _this.customSemanticsActionIds;
      t5 = H.getTypeArgumentByIndex(t4, 0);
      customSemanticsActionSummary = new H.MappedListIterable(t4, H.functionTypeCheck(new A.SemanticsData_debugFillProperties_closure(), {func: 1, ret: t1, args: [t5]}), [t5, t1]).toList$0(0);
      C.JSArray_methods.add$1(t2, Y.IterableProperty$("actions", actionSummary, C.C__NoDefaultValue, _null, C.DiagnosticLevel_3, C.DiagnosticsTreeStyle_5, t1));
      C.JSArray_methods.add$1(t2, Y.IterableProperty$("customActions", customSemanticsActionSummary, C.C__NoDefaultValue, _null, C.DiagnosticLevel_3, C.DiagnosticsTreeStyle_5, t1));
      flagSummary = H.setRuntimeTypeInfo([], t3);
      for (t3 = C.Map_uSfdF.get$values(), t3 = t3.get$iterator(t3), t4 = _this.flags; t3.moveNext$0();) {
        t5 = t3.get$current();
        if ((t4 & t5.index) !== 0)
          C.JSArray_methods.add$1(flagSummary, Y.describeEnum(t5));
      }
      C.JSArray_methods.add$1(t2, Y.IterableProperty$("flags", flagSummary, C.C__NoDefaultValue, _null, C.DiagnosticLevel_3, C.DiagnosticsTreeStyle_5, t1));
      C.JSArray_methods.add$1(t2, Y.StringProperty$("label", _this.label, "", true, true));
      C.JSArray_methods.add$1(t2, Y.StringProperty$("value", _this.value, "", true, true));
      C.JSArray_methods.add$1(t2, Y.StringProperty$("increasedValue", _this.increasedValue, "", true, true));
      C.JSArray_methods.add$1(t2, Y.StringProperty$("decreasedValue", _this.decreasedValue, "", true, true));
      C.JSArray_methods.add$1(t2, Y.StringProperty$("hint", _this.hint, "", true, true));
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, _this.textDirection, _null, C.DiagnosticLevel_3, "textDirection", true, true, C.DiagnosticsTreeStyle_5, [P.TextDirection]));
      C.JSArray_methods.add$1(t2, Y.IntProperty$("platformViewId", _this.platformViewId, _null, _null, C.DiagnosticLevel_3, _null));
      C.JSArray_methods.add$1(t2, Y.IntProperty$("scrollChildren", _this.scrollChildCount, _null, _null, C.DiagnosticLevel_3, _null));
      C.JSArray_methods.add$1(t2, Y.IntProperty$("scrollIndex", _this.scrollIndex, _null, _null, C.DiagnosticLevel_3, _null));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("scrollExtentMin", _this.scrollExtentMin, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("scrollPosition", _this.scrollPosition, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("scrollExtentMax", _this.scrollExtentMax, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
    },
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (!(other instanceof A.SemanticsData))
        return false;
      if (other.flags === _this.flags)
        if (other.actions === _this.actions)
          if (other.label === _this.label)
            if (other.value == _this.value)
              if (other.increasedValue == _this.increasedValue)
                if (other.decreasedValue == _this.decreasedValue)
                  if (other.hint === _this.hint)
                    if (other.textDirection == _this.textDirection)
                      if (other.rect.$eq(0, _this.rect))
                        if (S.setEquals(other.tags, _this.tags, A.SemanticsTag))
                          t1 = J.$eq$(other.transform, _this.transform) && other.elevation === _this.elevation && other.thickness === _this.thickness && A.SemanticsData__sortedListsEqual(other.customSemanticsActionIds, _this.customSemanticsActionIds);
                        else
                          t1 = false;
                      else
                        t1 = false;
                    else
                      t1 = false;
                  else
                    t1 = false;
                else
                  t1 = false;
              else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(P.hashValues(_this.flags, _this.actions, _this.label, _this.value, _this.increasedValue, _this.decreasedValue, _this.hint, _this.textDirection, _this.rect, _this.tags, _this.textSelection, _this.scrollChildCount, _this.scrollIndex, _this.scrollPosition, _this.scrollExtentMax, _this.scrollExtentMin, _this.platformViewId, _this.transform, _this.elevation, _this.thickness), P.hashList(_this.customSemanticsActionIds), C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    }
  };
  A.SemanticsData_debugFillProperties_closure.prototype = {
    call$1: function(actionId) {
      $.CustomSemanticsAction__actions.$index(0, H.intTypeCheck(actionId)).toString;
      return;
    },
    $signature: 27
  };
  A._SemanticsDiagnosticableNode.prototype = {
    getChildren$0: function() {
      var t1 = this.value.debugDescribeChildren$1$childOrder(this.childOrder);
      return t1;
    },
    $asDiagnosticableNode: function() {
      return [A.SemanticsNode];
    }
  };
  A.SemanticsHintOverrides.prototype = {};
  A.SemanticsProperties.prototype = {
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      t1 = P.bool;
      t2 = Y.DiagnosticsProperty$("checked", _this.checked, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t2);
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("selected", _this.selected, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t3, Y.StringProperty$("label", _this.label, "", true, true));
      C.JSArray_methods.add$1(t3, Y.StringProperty$("value", _this.value, C.C__NoDefaultValue, true, true));
      C.JSArray_methods.add$1(t3, Y.StringProperty$("hint", _this.hint, C.C__NoDefaultValue, true, true));
      C.JSArray_methods.add$1(t3, new Y.EnumProperty(_null, _null, _null, _null, false, _this.textDirection, _null, C.DiagnosticLevel_3, "textDirection", true, true, C.DiagnosticsTreeStyle_5, [P.TextDirection]));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("sortKey", _this.sortKey, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, A.SemanticsSortKey));
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("hintOverrides", _this.hintOverrides, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, A.SemanticsHintOverrides));
    },
    toStringShort$0: function() {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    }
  };
  A.SemanticsNode.prototype = {
    set$transform: function(value) {
      if (!T.MatrixUtils_matrixEquals(this._semantics$_transform, value)) {
        this._semantics$_transform = T.MatrixUtils_isIdentity(value) ? null : value;
        this._markDirty$0();
      }
    },
    set$rect: function(value) {
      H.assertHelper(value != null);
      if (!this._semantics$_rect.$eq(0, value)) {
        this._semantics$_rect = value;
        this._markDirty$0();
      }
    },
    set$isMergedIntoParent: function(value) {
      if (this._isMergedIntoParent === value)
        return;
      this._isMergedIntoParent = value;
      this._markDirty$0();
    },
    _replaceChildren$1: function(newChildren) {
      var t1, t2, _i, child, t3, t4, sawChange, i, _this = this;
      H.assertSubtype(newChildren, "$isList", [A.SemanticsNode], "$asList");
      H.assertHelper(!C.JSArray_methods.any$1(newChildren, new A.SemanticsNode__replaceChildren_closure(_this)));
      H.assertHelper(new A.SemanticsNode__replaceChildren_closure0(_this, newChildren).call$0());
      H.assertHelper(new A.SemanticsNode__replaceChildren_closure1(newChildren).call$0());
      t1 = _this._semantics$_children;
      if (t1 != null)
        for (t2 = t1.length, _i = 0; _i < t2; ++_i)
          t1[_i]._dead = true;
      for (t1 = newChildren.length, _i = 0; _i < newChildren.length; newChildren.length === t1 || (0, H.throwConcurrentModificationError)(newChildren), ++_i) {
        child = newChildren[_i];
        if (!child._isMergedIntoParent) {
          t2 = child._semantics$_rect;
          t3 = t2.left;
          t4 = t2.right;
          if (typeof t3 !== "number")
            return t3.$ge();
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (!(t3 >= t4)) {
            t3 = t2.top;
            t2 = t2.bottom;
            if (typeof t3 !== "number")
              return t3.$ge();
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = t3 >= t2;
          } else
            t2 = true;
        } else
          t2 = false;
        if (H.assertTest(!t2))
          H.assertThrow("Child " + H.S(child) + " is invisible and should not be added as a child of " + _this.toString$0(0) + ".");
        child._dead = false;
      }
      t1 = _this._semantics$_children;
      if (t1 != null)
        for (t2 = t1.length, sawChange = false, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          child = t1[_i];
          if (child._dead) {
            if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(child), "$isSemanticsNode") === _this)
              _this.dropChild$1(child);
            sawChange = true;
          }
        }
      else
        sawChange = false;
      for (t1 = newChildren.length, _i = 0; _i < newChildren.length; newChildren.length === t1 || (0, H.throwConcurrentModificationError)(newChildren), ++_i) {
        child = newChildren[_i];
        if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(child), "$isSemanticsNode") !== _this) {
          if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(child), "$isSemanticsNode") != null) {
            t2 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(child), "$isSemanticsNode");
            if (t2 != null)
              t2.dropChild$1(child);
          }
          H.assertHelper(child._node$_owner == null);
          _this.adoptChild$1(child);
          sawChange = true;
        }
      }
      if (!sawChange && _this._semantics$_children != null) {
        H.assertHelper(newChildren.length === _this._semantics$_children.length);
        for (t1 = _this._semantics$_children, t2 = t1.length, t3 = newChildren.length, i = 0; i < t2; ++i) {
          t4 = t1[i].id;
          if (i >= t3)
            return H.ioore(newChildren, i);
          if (t4 !== newChildren[i].id) {
            sawChange = true;
            break;
          }
        }
      }
      _this.set$_semantics$_children(newChildren);
      if (sawChange)
        _this._markDirty$0();
    },
    get$hasChildren: function() {
      var t1 = this._semantics$_children;
      t1 = t1 == null ? null : t1.length !== 0;
      return t1 === true;
    },
    _visitDescendants$1: function(visitor) {
      var t1, t2, _i, child;
      H.functionTypeCheck(visitor, {func: 1, ret: P.bool, args: [A.SemanticsNode]});
      t1 = this._semantics$_children;
      if (t1 != null)
        for (t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          child = t1[_i];
          if (!H.boolConversionCheck(visitor.call$1(child)) || !child._visitDescendants$1(visitor))
            return false;
        }
      return true;
    },
    get$owner: function() {
      return H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(this), "$isSemanticsOwner");
    },
    get$parent: function() {
      return H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(this), "$isSemanticsNode");
    },
    redepthChildren$0: function() {
      var t1 = this._semantics$_children;
      if (t1 != null)
        C.JSArray_methods.forEach$1(t1, this.get$redepthChild());
    },
    attach$1: function(owner) {
      var t1, t2, _i, _this = this;
      H.interceptedTypeCheck(owner, "$isSemanticsOwner");
      _this.super$AbstractNode$attach(owner);
      t1 = owner._nodes;
      t2 = _this.id;
      H.assertHelper(!t1.containsKey$1(t2));
      t1.$indexSet(0, t2, _this);
      owner._detachedNodes.remove$1(0, _this);
      if (_this._semantics$_dirty) {
        _this._semantics$_dirty = false;
        _this._markDirty$0();
      }
      t1 = _this._semantics$_children;
      if (t1 != null)
        for (t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          t1[_i].attach$1(owner);
    },
    detach$0: function() {
      var t2, _i, child, _this = this,
        t1 = _this.id;
      H.assertHelper(H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isSemanticsOwner")._nodes.containsKey$1(t1));
      H.assertHelper(!H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isSemanticsOwner")._detachedNodes.contains$1(0, _this));
      H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isSemanticsOwner")._nodes.remove$1(0, t1);
      H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isSemanticsOwner")._detachedNodes.add$1(0, _this);
      _this.super$AbstractNode$detach();
      H.assertHelper(H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isSemanticsOwner") == null);
      t1 = _this._semantics$_children;
      if (t1 != null)
        for (t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          child = t1[_i];
          if (H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(child), "$isSemanticsNode") === _this)
            child.detach$0();
        }
      _this._markDirty$0();
    },
    _markDirty$0: function() {
      var _this = this;
      if (_this._semantics$_dirty)
        return;
      _this._semantics$_dirty = true;
      if (_this._node$_owner != null) {
        H.assertHelper(!H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isSemanticsOwner")._detachedNodes.contains$1(0, _this));
        H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isSemanticsOwner")._semantics$_dirtyNodes.add$1(0, _this);
      }
    },
    updateWith$2$childrenInInversePaintOrder$config: function(childrenInInversePaintOrder, config) {
      var t1, _this = this;
      H.assertSubtype(childrenInInversePaintOrder, "$isList", [A.SemanticsNode], "$asList");
      if (config == null)
        config = $.$get$SemanticsNode__kEmptyConfig();
      if (_this._label === config._label)
        if (_this._hint === config._hint)
          if (_this._elevation === config._elevation)
            if (_this._thickness === config._thickness)
              if (_this._decreasedValue === config._decreasedValue)
                if (_this._semantics$_value === config._semantics$_value)
                  if (_this._increasedValue === config._increasedValue)
                    if (_this._flags === config._flags)
                      if (_this._textDirection == config._textDirection)
                        if (_this._sortKey == config._sortKey)
                          if (_this._actionsAsBits === config._actionsAsBits)
                            t1 = _this._mergeAllDescendantsIntoThisNode !== config._isMergingSemanticsOfDescendants;
                          else
                            t1 = true;
                        else
                          t1 = true;
                      else
                        t1 = true;
                    else
                      t1 = true;
                  else
                    t1 = true;
                else
                  t1 = true;
              else
                t1 = true;
            else
              t1 = true;
          else
            t1 = true;
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        _this._markDirty$0();
      _this._label = config._label;
      _this._decreasedValue = config._decreasedValue;
      _this._semantics$_value = config._semantics$_value;
      _this._increasedValue = config._increasedValue;
      _this._hint = config._hint;
      _this._hintOverrides = config._hintOverrides;
      _this._elevation = config._elevation;
      _this._thickness = config._thickness;
      _this._flags = config._flags;
      _this._textDirection = config._textDirection;
      _this._sortKey = config._sortKey;
      _this.set$_actions(P.LinkedHashMap_LinkedHashMap$from(config._actions, P.SemanticsAction, {func: 1, ret: -1, args: [,]}));
      _this.set$_customSemanticsActions(P.LinkedHashMap_LinkedHashMap$from(config._customSemanticsActions, A.CustomSemanticsAction, {func: 1, ret: -1}));
      _this._actionsAsBits = config._actionsAsBits;
      _this._textSelection = config._textSelection;
      _this._scrollPosition = config._scrollPosition;
      _this._scrollExtentMax = config._scrollExtentMax;
      _this._scrollExtentMin = config._scrollExtentMin;
      _this._mergeAllDescendantsIntoThisNode = config._isMergingSemanticsOfDescendants;
      _this._scrollChildCount = config._scrollChildCount;
      _this._scrollIndex = config._scrollIndex;
      _this.indexInParent = config._indexInParent;
      _this._platformViewId = config._platformViewId;
      _this._replaceChildren$1(childrenInInversePaintOrder == null ? C.List_empty2 : childrenInInversePaintOrder);
      if (H.assertTest(!_this._actions.containsKey$1(C.SemanticsAction_64) || _this._semantics$_value === "" === (_this._increasedValue === "")))
        H.assertThrow('A SemanticsNode with action "increase" needs to be annotated with either both "value" and "increasedValue" or neither');
      if (H.assertTest(!_this._actions.containsKey$1(C.SemanticsAction_128) || _this._semantics$_value === "" === (_this._decreasedValue === "")))
        H.assertThrow('A SemanticsNode with action "increase" needs to be annotated with either both "value" and "decreasedValue" or neither');
    },
    updateWith$1$config: function(config) {
      return this.updateWith$2$childrenInInversePaintOrder$config(null, config);
    },
    getSemanticsData$0: function() {
      var t1, elevation, customSemanticsActionIds, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, _this = this, _box_0 = {};
      _box_0.flags = _this._flags;
      _box_0.actions = _this._actionsAsBits;
      _box_0.label = _this._label;
      _box_0.hint = _this._hint;
      _box_0.value = _this._semantics$_value;
      _box_0.increasedValue = _this._increasedValue;
      _box_0.decreasedValue = _this._decreasedValue;
      _box_0.textDirection = _this._textDirection;
      t1 = _this.tags;
      _box_0.mergedTags = t1 == null ? null : P.LinkedHashSet_LinkedHashSet$from(t1, A.SemanticsTag);
      _box_0.textSelection = _this._textSelection;
      _box_0.scrollChildCount = _this._scrollChildCount;
      _box_0.scrollIndex = _this._scrollIndex;
      _box_0.scrollPosition = _this._scrollPosition;
      _box_0.scrollExtentMax = _this._scrollExtentMax;
      _box_0.scrollExtentMin = _this._scrollExtentMin;
      _box_0.platformViewId = _this._platformViewId;
      elevation = _this._elevation;
      _box_0.thickness = _this._thickness;
      customSemanticsActionIds = P.LinkedHashSet_LinkedHashSet$_empty(P.int);
      for (t1 = _this._customSemanticsActions.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
        customSemanticsActionIds.add$1(0, A.CustomSemanticsAction_getIdentifier(t1.get$current()));
      _this._hintOverrides != null;
      if (_this._mergeAllDescendantsIntoThisNode)
        _this._visitDescendants$1(new A.SemanticsNode_getSemanticsData_closure(_box_0, _this, customSemanticsActionIds));
      t1 = _box_0.flags;
      t2 = _box_0.actions;
      t3 = _box_0.label;
      t4 = _box_0.value;
      t5 = _box_0.increasedValue;
      t6 = _box_0.decreasedValue;
      t7 = _box_0.hint;
      t8 = _box_0.textDirection;
      t9 = _this._semantics$_rect;
      t10 = _this._semantics$_transform;
      t11 = _box_0.thickness;
      t12 = _box_0.mergedTags;
      t13 = _box_0.textSelection;
      t14 = _box_0.scrollChildCount;
      t15 = _box_0.scrollIndex;
      t16 = _box_0.scrollPosition;
      t17 = _box_0.scrollExtentMax;
      t18 = _box_0.scrollExtentMin;
      t19 = _box_0.platformViewId;
      t20 = customSemanticsActionIds.toList$0(0);
      C.JSArray_methods.sort$0(t20);
      return new A.SemanticsData(t1, t2, t3, t4, t5, t6, t7, t8, t13, t14, t15, t16, t17, t18, t19, t9, t12, t10, elevation, t11, t20);
    },
    _addToUpdate$2: function(builder, customSemanticsActionIdsUpdate) {
      var data, childrenInTraversalOrder, childrenInHitTestOrder, childCount, sortedChildren, t1, t2, i, t3, customSemanticsActionIds, _this = this;
      H.assertSubtype(customSemanticsActionIdsUpdate, "$isSet", [P.int], "$asSet");
      H.assertHelper(_this._semantics$_dirty);
      data = _this.getSemanticsData$0();
      if (!_this.get$hasChildren() || _this._mergeAllDescendantsIntoThisNode) {
        childrenInTraversalOrder = $.$get$SemanticsNode__kEmptyChildList();
        childrenInHitTestOrder = childrenInTraversalOrder;
      } else {
        childCount = _this._semantics$_children.length;
        sortedChildren = _this._childrenInTraversalOrder$0();
        childrenInTraversalOrder = new Int32Array(childCount);
        for (t1 = sortedChildren.length, t2 = childrenInTraversalOrder.length, i = 0; i < childCount; ++i) {
          if (i >= t1)
            return H.ioore(sortedChildren, i);
          t3 = sortedChildren[i].id;
          if (i >= t2)
            return H.ioore(childrenInTraversalOrder, i);
          childrenInTraversalOrder[i] = t3;
        }
        childrenInHitTestOrder = new Int32Array(childCount);
        for (i = childCount - 1, t1 = _this._semantics$_children, t2 = childrenInHitTestOrder.length; i >= 0; --i) {
          t3 = childCount - i - 1;
          if (t3 < 0 || t3 >= t1.length)
            return H.ioore(t1, t3);
          t3 = t1[t3].id;
          if (i >= t2)
            return H.ioore(childrenInHitTestOrder, i);
          childrenInHitTestOrder[i] = t3;
        }
      }
      t1 = data.customSemanticsActionIds;
      t2 = t1.length;
      if (t2 !== 0) {
        customSemanticsActionIds = new Int32Array(t2);
        for (i = 0; i < t1.length; ++i) {
          C.NativeInt32List_methods.$indexSet(customSemanticsActionIds, i, t1[i]);
          if (i >= t1.length)
            return H.ioore(t1, i);
          customSemanticsActionIdsUpdate.add$1(0, t1[i]);
        }
      } else
        customSemanticsActionIds = null;
      t1 = data.transform;
      t1 = t1 == null ? null : t1._m4storage;
      if (t1 == null)
        t1 = $.$get$SemanticsNode__kIdentityTransform();
      t2 = customSemanticsActionIds == null ? $.$get$SemanticsNode__kEmptyCustomSemanticsActionsList() : customSemanticsActionIds;
      builder.updateNode$24$actions$additionalActions$childrenInHitTestOrder$childrenInTraversalOrder$decreasedValue$elevation$flags$hint$id$increasedValue$label$platformViewId$rect$scrollChildren$scrollExtentMax$scrollExtentMin$scrollIndex$scrollPosition$textDirection$textSelectionBase$textSelectionExtent$thickness$transform$value(data.actions, t2, childrenInHitTestOrder, childrenInTraversalOrder, data.decreasedValue, data.elevation, data.flags, data.hint, _this.id, data.increasedValue, data.label, -1, data.rect, 0, 0 / 0, 0 / 0, 0, 0 / 0, data.textDirection, -1, -1, data.thickness, t1, data.value);
    },
    _childrenInTraversalOrder$0: function() {
      var t1, childrenInDefaultOrder, everythingSorted, sortNodes, lastSortKey, position, child, sortKey, isCompatibleWithPreviousSortKey, t2,
        inheritedTextDirection = this._textDirection,
        ancestor = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(this), "$isSemanticsNode");
      while (true) {
        t1 = inheritedTextDirection == null;
        if (!(t1 && ancestor != null))
          break;
        inheritedTextDirection = ancestor._textDirection;
        ancestor = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(ancestor), "$isSemanticsNode");
      }
      childrenInDefaultOrder = this._semantics$_children;
      if (!t1)
        childrenInDefaultOrder = A._childrenInDefaultOrder(childrenInDefaultOrder, inheritedTextDirection);
      t1 = [A._TraversalSortNode];
      everythingSorted = H.setRuntimeTypeInfo([], t1);
      sortNodes = H.setRuntimeTypeInfo([], t1);
      for (t1 = H.getTypeArgumentByIndex(sortNodes, 0), lastSortKey = null, position = 0; position < childrenInDefaultOrder.length; ++position) {
        child = childrenInDefaultOrder[position];
        sortKey = child._sortKey;
        lastSortKey = position > 0 ? childrenInDefaultOrder[position - 1]._sortKey : null;
        if (position !== 0)
          if (J.get$runtimeType$(sortKey).$eq(0, J.get$runtimeType$(lastSortKey))) {
            if (sortKey != null)
              lastSortKey.name;
            isCompatibleWithPreviousSortKey = true;
          } else
            isCompatibleWithPreviousSortKey = false;
        else
          isCompatibleWithPreviousSortKey = true;
        if (!isCompatibleWithPreviousSortKey && sortNodes.length !== 0) {
          if (lastSortKey != null) {
            t2 = sortNodes.length - 1;
            if (t2 - 0 <= 32)
              H.Sort__insertionSort(sortNodes, 0, t2, J._interceptors_JSArray__compareAny$closure(), t1);
            else
              H.Sort__dualPivotQuicksort(sortNodes, 0, t2, J._interceptors_JSArray__compareAny$closure(), t1);
          }
          C.JSArray_methods.addAll$1(everythingSorted, sortNodes);
          C.JSArray_methods.set$length(sortNodes, 0);
        }
        C.JSArray_methods.add$1(sortNodes, new A._TraversalSortNode(child, sortKey, position));
      }
      if (lastSortKey != null)
        C.JSArray_methods.sort$0(sortNodes);
      C.JSArray_methods.addAll$1(everythingSorted, sortNodes);
      t1 = A.SemanticsNode;
      t2 = H.getTypeArgumentByIndex(everythingSorted, 0);
      return new H.MappedListIterable(everythingSorted, H.functionTypeCheck(new A.SemanticsNode__childrenInTraversalOrder_closure(), {func: 1, ret: t1, args: [t2]}), [t2, t1]).toList$0(0);
    },
    sendEvent$1: function($event) {
      if (this._node$_owner == null)
        return;
      C.BasicMessageChannel_8hp.send$1($event.toMap$1$nodeId(this.id));
    },
    toStringShort$0: function() {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "#" + this.id;
    },
    debugFillProperties$1: function(properties) {
      var inDirtyNodes, t1, hideOwner, t2, offset, scale, description, t3, t4, matrix, actions, customSemanticsActions, _this = this, _null = null;
      _this.super$DiagnosticableTreeMixin$debugFillProperties(properties);
      if (_this._semantics$_dirty) {
        inDirtyNodes = H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isSemanticsOwner") != null && H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isSemanticsOwner")._semantics$_dirtyNodes.contains$1(0, _this);
        t1 = Y.FlagProperty$("inDirtyNodes", _null, "STALE", "dirty", C.DiagnosticLevel_3, false, inDirtyNodes);
        C.JSArray_methods.add$1(properties.properties, t1);
        hideOwner = inDirtyNodes;
      } else
        hideOwner = true;
      t1 = H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(_this), "$isSemanticsOwner");
      t2 = hideOwner ? C.DiagnosticLevel_0 : C.DiagnosticLevel_3;
      t2 = Y.DiagnosticsProperty$("owner", t1, C.C__NoDefaultValue, _null, _null, _null, t2, false, true, true, C.DiagnosticsTreeStyle_5, _null, A.SemanticsOwner);
      t1 = properties.properties;
      C.JSArray_methods.add$1(t1, t2);
      C.JSArray_methods.add$1(t1, Y.FlagProperty$("isMergedIntoParent", _null, _null, "merged up \u2b06\ufe0f", C.DiagnosticLevel_3, false, _this._isMergedIntoParent));
      C.JSArray_methods.add$1(t1, Y.FlagProperty$("mergeAllDescendantsIntoThisNode", _null, _null, "merge boundary \u26d4\ufe0f", C.DiagnosticLevel_3, false, _this._mergeAllDescendantsIntoThisNode));
      t2 = _this._semantics$_transform;
      offset = t2 != null ? T.MatrixUtils_getAsTranslation(t2) : _null;
      if (offset != null)
        C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("rect", _this._semantics$_rect.shift$1(offset), C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_5, _null, P.Rect));
      else {
        t2 = _this._semantics$_transform;
        scale = t2 != null ? T.MatrixUtils_getAsScale(t2) : _null;
        if (scale != null)
          description = _this._semantics$_rect.toString$0(0) + " scaled by " + C.JSNumber_methods.toStringAsFixed$1(scale, 1) + "x";
        else {
          t2 = _this._semantics$_transform;
          if (t2 != null && !T.MatrixUtils_isIdentity(t2)) {
            t2 = P.String;
            t3 = H.setRuntimeTypeInfo(J.toString$0$(_this._semantics$_transform).split("\n"), [t2]);
            t3 = H.SubListIterable$(t3, 0, 4, H.getTypeArgumentByIndex(t3, 0));
            t4 = H.getTypeArgumentByIndex(t3, 0);
            matrix = new H.MappedListIterable(t3, H.functionTypeCheck(new A.SemanticsNode_debugFillProperties_closure(), {func: 1, ret: t2, args: [t4]}), [t4, t2]).join$1(0, "; ");
            description = _this._semantics$_rect.toString$0(0) + " with transform [" + matrix + "]";
          } else
            description = _null;
        }
        C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("rect", _this._semantics$_rect, C.C__NoDefaultValue, description, _null, _null, C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_5, _null, P.Rect));
      }
      t2 = _this._actions.get$keys();
      t3 = P.String;
      t4 = H.getRuntimeTypeArgument(t2, "Iterable", 0);
      t4 = H.MappedIterable_MappedIterable(t2, H.functionTypeCheck(new A.SemanticsNode_debugFillProperties_closure0(), {func: 1, ret: t3, args: [t4]}), t4, t3);
      actions = P.List_List$from(t4, true, H.getRuntimeTypeArgument(t4, "Iterable", 0));
      C.JSArray_methods.sort$0(actions);
      t4 = _this._customSemanticsActions.get$keys();
      t2 = H.getRuntimeTypeArgument(t4, "Iterable", 0);
      t2 = H.MappedIterable_MappedIterable(t4, H.functionTypeCheck(new A.SemanticsNode_debugFillProperties_closure1(), {func: 1, ret: t3, args: [t2]}), t2, t3);
      customSemanticsActions = P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "Iterable", 0));
      C.JSArray_methods.add$1(t1, Y.IterableProperty$("actions", actions, C.C__NoDefaultValue, _null, C.DiagnosticLevel_3, C.DiagnosticsTreeStyle_5, t3));
      C.JSArray_methods.add$1(t1, Y.IterableProperty$("customActions", customSemanticsActions, C.C__NoDefaultValue, _null, C.DiagnosticLevel_3, C.DiagnosticsTreeStyle_5, t3));
      t2 = C.Map_uSfdF.get$values();
      t4 = H.getRuntimeTypeArgument(t2, "Iterable", 0);
      C.JSArray_methods.add$1(t1, Y.IterableProperty$("flags", P.List_List$from(new H.MappedIterable(new H.WhereIterable(t2, H.functionTypeCheck(new A.SemanticsNode_debugFillProperties_closure2(_this), {func: 1, ret: P.bool, args: [t4]}), [t4]), H.functionTypeCheck(new A.SemanticsNode_debugFillProperties_closure3(), {func: 1, ret: t3, args: [t4]}), [t4, t3]), true, t3), C.C__NoDefaultValue, _null, C.DiagnosticLevel_3, C.DiagnosticsTreeStyle_5, t3));
      if (!_this._isMergedIntoParent) {
        t2 = _this._semantics$_rect;
        t2 = t2.get$isEmpty(t2);
      } else
        t2 = false;
      C.JSArray_methods.add$1(t1, Y.FlagProperty$("isInvisible", _null, _null, "invisible", C.DiagnosticLevel_3, false, t2));
      C.JSArray_methods.add$1(t1, Y.FlagProperty$("isHidden", _null, _null, "HIDDEN", C.DiagnosticLevel_3, false, (_this._flags & 8192) !== 0));
      C.JSArray_methods.add$1(t1, Y.StringProperty$("label", _this._label, "", true, true));
      C.JSArray_methods.add$1(t1, Y.StringProperty$("value", _this._semantics$_value, "", true, true));
      C.JSArray_methods.add$1(t1, Y.StringProperty$("increasedValue", _this._increasedValue, "", true, true));
      C.JSArray_methods.add$1(t1, Y.StringProperty$("decreasedValue", _this._decreasedValue, "", true, true));
      C.JSArray_methods.add$1(t1, Y.StringProperty$("hint", _this._hint, "", true, true));
      t2 = _this._textDirection;
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, t2, _null, C.DiagnosticLevel_3, "textDirection", true, true, C.DiagnosticsTreeStyle_5, [P.TextDirection]));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("sortKey", _this._sortKey, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, A.SemanticsSortKey));
      C.JSArray_methods.add$1(t1, Y.IntProperty$("platformViewId", _this._platformViewId, _null, _null, C.DiagnosticLevel_3, _null));
      C.JSArray_methods.add$1(t1, Y.IntProperty$("scrollChildren", _this._scrollChildCount, _null, _null, C.DiagnosticLevel_3, _null));
      C.JSArray_methods.add$1(t1, Y.IntProperty$("scrollIndex", _this._scrollIndex, _null, _null, C.DiagnosticLevel_3, _null));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("scrollExtentMin", _this._scrollExtentMin, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("scrollPosition", _this._scrollPosition, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("scrollExtentMax", _this._scrollExtentMax, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("elevation", _this._elevation, 0, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("thicknes", _this._thickness, 0, _null, C.DiagnosticLevel_3, true, _null, _null));
    },
    toDiagnosticsNode$3$childOrder$name$style: function(childOrder, $name, style) {
      return new A._SemanticsDiagnosticableNode(childOrder, this, $name, true, true, style);
    },
    toDiagnosticsNode$1$style: function(style) {
      return this.toDiagnosticsNode$3$childOrder$name$style(C.DebugSemanticsDumpOrder_1, null, style);
    },
    toDiagnosticsNode$0: function() {
      return this.toDiagnosticsNode$3$childOrder$name$style(C.DebugSemanticsDumpOrder_1, null, C.DiagnosticsTreeStyle_0);
    },
    toDiagnosticsNode$2$name$style: function($name, style) {
      return this.toDiagnosticsNode$3$childOrder$name$style(C.DebugSemanticsDumpOrder_1, $name, style);
    },
    debugDescribeChildren$1$childOrder: function(childOrder) {
      var t3,
        t1 = this.debugListChildrenInOrder$1(childOrder),
        t2 = Y.DiagnosticsNode;
      t1.toString;
      t3 = H.getTypeArgumentByIndex(t1, 0);
      return new H.MappedListIterable(t1, H.functionTypeCheck(new A.SemanticsNode_debugDescribeChildren_closure(childOrder), {func: 1, ret: t2, args: [t3]}), [t3, t2]).toList$0(0);
    },
    debugDescribeChildren$0: function() {
      return this.debugDescribeChildren$1$childOrder(C.DebugSemanticsDumpOrder_0);
    },
    debugListChildrenInOrder$1: function(childOrder) {
      var t1 = this._semantics$_children;
      if (t1 == null)
        return C.List_empty2;
      switch (childOrder) {
        case C.DebugSemanticsDumpOrder_0:
          return t1;
        case C.DebugSemanticsDumpOrder_1:
          return this._childrenInTraversalOrder$0();
      }
      H.assertHelper(false);
      return;
    },
    set$_semantics$_children: function(_children) {
      this._semantics$_children = H.assertSubtype(_children, "$isList", [A.SemanticsNode], "$asList");
    },
    set$_debugPreviousSnapshot: function(_debugPreviousSnapshot) {
      this._debugPreviousSnapshot = H.assertSubtype(_debugPreviousSnapshot, "$isList", [A.SemanticsNode], "$asList");
    },
    set$_actions: function(_actions) {
      this._actions = H.assertSubtype(_actions, "$isMap", [P.SemanticsAction, {func: 1, ret: -1, args: [,]}], "$asMap");
    },
    set$_customSemanticsActions: function(_customSemanticsActions) {
      this._customSemanticsActions = H.assertSubtype(_customSemanticsActions, "$isMap", [A.CustomSemanticsAction, {func: 1, ret: -1}], "$asMap");
    },
    set$tags: function(tags) {
      this.tags = H.assertSubtype(tags, "$isSet", [A.SemanticsTag], "$asSet");
    },
    $isDiagnosticable: 1,
    $isDiagnosticableTree: 1
  };
  A.SemanticsNode__replaceChildren_closure.prototype = {
    call$1: function(child) {
      return H.interceptedTypeCheck(child, "$isSemanticsNode") === this.$this;
    },
    $signature: 16
  };
  A.SemanticsNode__replaceChildren_closure0.prototype = {
    call$0: function() {
      var mutationErrors, t3, t4, i, ancestor, _box_0 = {},
        t1 = this.newChildren,
        t2 = this.$this;
      if (t1 === t2._semantics$_children) {
        mutationErrors = new P.StringBuffer("");
        t3 = t1.length;
        t4 = t2._debugPreviousSnapshot.length;
        if (t3 !== t4)
          mutationErrors._contents = "The list's length has changed from " + t4 + " to " + t1.length + ".\n";
        else
          for (i = 0; i < t1.length; ++i) {
            t3 = t1[i];
            t4 = t2._debugPreviousSnapshot;
            if (i >= t4.length)
              return H.ioore(t4, i);
            t4 = t4[i];
            if (t3 == null ? t4 != null : t3 !== t4) {
              t3 = "Child node at position " + i + " was replaced:\nPrevious child: ";
              if (i >= t1.length)
                return H.ioore(t1, i);
              t3 = t3 + H.S(t1[i]) + "\nNew child: ";
              t4 = t2._debugPreviousSnapshot;
              if (i >= t4.length)
                return H.ioore(t4, i);
              mutationErrors._contents += t3 + H.S(t4[i]) + "\n\n";
            }
          }
        if (mutationErrors._contents.length !== 0)
          throw H.wrapException(U.FlutterError$("Failed to replace child semantics nodes because the list of `SemanticsNode`s was mutated.\nInstead of mutating the existing list, create a new list containing the desired `SemanticsNode`s.\nError details:\n" + mutationErrors.toString$0(0)));
      }
      H.assertHelper(!C.JSArray_methods.any$1(t1, new A.SemanticsNode__replaceChildren__closure()) || t2._mergeAllDescendantsIntoThisNode || t2._isMergedIntoParent);
      t2.set$_debugPreviousSnapshot(P.List_List$from(t1, true, A.SemanticsNode));
      _box_0.ancestor = t2;
      for (; H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(t2), "$isSemanticsNode") instanceof A.SemanticsNode; t2 = ancestor) {
        ancestor = H.interceptedTypeCheck(B.AbstractNode.prototype.get$parent.call(t2), "$isSemanticsNode");
        _box_0.ancestor = ancestor;
      }
      H.assertHelper(!C.JSArray_methods.any$1(t1, new A.SemanticsNode__replaceChildren__closure0(_box_0)));
      return true;
    },
    $signature: 0
  };
  A.SemanticsNode__replaceChildren__closure.prototype = {
    call$1: function(node) {
      return H.interceptedTypeCheck(node, "$isSemanticsNode")._isMergedIntoParent;
    },
    $signature: 16
  };
  A.SemanticsNode__replaceChildren__closure0.prototype = {
    call$1: function(child) {
      return H.interceptedTypeCheck(child, "$isSemanticsNode") == this._box_0.ancestor;
    },
    $signature: 16
  };
  A.SemanticsNode__replaceChildren_closure1.prototype = {
    call$0: function() {
      var t1, t2, _i,
        seenChildren = P.LinkedHashSet_LinkedHashSet$_empty(A.SemanticsNode);
      for (t1 = this.newChildren, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        H.assertHelper(seenChildren.add$1(0, t1[_i]));
      return true;
    },
    $signature: 0
  };
  A.SemanticsNode_getSemanticsData_closure.prototype = {
    call$1: function(node) {
      var t1, t2, t3;
      H.assertHelper(node._isMergedIntoParent);
      t1 = this._box_0;
      t1.flags = t1.flags | node._flags;
      t1.actions = t1.actions | node._actionsAsBits;
      if (t1.textDirection == null)
        t1.textDirection = node._textDirection;
      t1.textSelection = node._textSelection;
      t1.scrollChildCount = node._scrollChildCount;
      t1.scrollIndex = node._scrollIndex;
      t1.scrollPosition = node._scrollPosition;
      t1.scrollExtentMax = node._scrollExtentMax;
      t1.scrollExtentMin = node._scrollExtentMin;
      t1.platformViewId = node._platformViewId;
      t2 = t1.value;
      if (t2 === "" || t2 == null)
        t1.value = node._semantics$_value;
      t2 = t1.increasedValue;
      if (t2 === "" || t2 == null)
        t1.increasedValue = node._increasedValue;
      t2 = t1.decreasedValue;
      if (t2 === "" || t2 == null)
        t1.decreasedValue = node._decreasedValue;
      t2 = node.tags;
      if (t2 != null) {
        t3 = t1.mergedTags;
        (t3 == null ? t1.mergedTags = P.LinkedHashSet_LinkedHashSet$_empty(A.SemanticsTag) : t3).addAll$1(0, t2);
      }
      if (node._customSemanticsActions != null)
        for (t2 = this.$this._customSemanticsActions.get$keys(), t2 = t2.get$iterator(t2), t3 = this.customSemanticsActionIds; t2.moveNext$0();)
          t3.add$1(0, A.CustomSemanticsAction_getIdentifier(t2.get$current()));
      node._hintOverrides != null;
      t2 = t1.label;
      t3 = t1.textDirection;
      t1.label = A._concatStrings(node._label, node._textDirection, t2, t3);
      t3 = t1.hint;
      t2 = t1.textDirection;
      t1.hint = A._concatStrings(node._hint, node._textDirection, t3, t2);
      t1.thickness = Math.max(t1.thickness, node._thickness + node._elevation);
      return true;
    },
    $signature: 16
  };
  A.SemanticsNode__childrenInTraversalOrder_closure.prototype = {
    call$1: function(sortNode) {
      return H.interceptedTypeCheck(sortNode, "$is_TraversalSortNode").node;
    },
    $signature: 102
  };
  A.SemanticsNode_debugFillProperties_closure.prototype = {
    call$1: function(line) {
      return J.substring$1$s(H.stringTypeCheck(line), 4);
    },
    $signature: 56
  };
  A.SemanticsNode_debugFillProperties_closure0.prototype = {
    call$1: function(action) {
      return Y.describeEnum(H.interceptedTypeCheck(action, "$isSemanticsAction"));
    },
    $signature: 103
  };
  A.SemanticsNode_debugFillProperties_closure1.prototype = {
    call$1: function(action) {
      H.interceptedTypeCheck(action, "$isCustomSemanticsAction").toString;
      return;
    },
    $signature: 104
  };
  A.SemanticsNode_debugFillProperties_closure2.prototype = {
    call$1: function(flag) {
      H.interceptedTypeCheck(flag, "$isSemanticsFlag");
      return (this.$this._flags & flag.index) !== 0;
    },
    $signature: 105
  };
  A.SemanticsNode_debugFillProperties_closure3.prototype = {
    call$1: function(flag) {
      return J.substring$1$s(J.toString$0$(H.interceptedTypeCheck(flag, "$isSemanticsFlag")), 14);
    },
    $signature: 106
  };
  A.SemanticsNode_debugDescribeChildren_closure.prototype = {
    call$1: function(node) {
      H.interceptedTypeCheck(node, "$isSemanticsNode");
      node.toString;
      return new A._SemanticsDiagnosticableNode(this.childOrder, node, null, true, true, C.DiagnosticsTreeStyle_0);
    },
    $signature: 107
  };
  A._BoxEdge.prototype = {
    compareTo$1: function(_, other) {
      var t1 = this.offset,
        t2 = H.interceptedTypeCheck(other, "$is_BoxEdge").offset;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return C.JSNumber_methods.toInt$0(J.get$sign$in(t1 - t2));
    },
    $isComparable: 1,
    $asComparable: function() {
      return [A._BoxEdge];
    }
  };
  A._SemanticsSortGroup.prototype = {
    compareTo$1: function(_, other) {
      var t1 = this.startOffset,
        t2 = H.interceptedTypeCheck(other, "$is_SemanticsSortGroup").startOffset;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return C.JSNumber_methods.toInt$0(J.get$sign$in(t1 - t2));
    },
    sortedWithinVerticalGroup$0: function() {
      var t1, t2, _i, child, t3, t4, t5, t6, horizontalGroups, group, depth, edge, result,
        edges = H.setRuntimeTypeInfo([], [A._BoxEdge]);
      for (t1 = this.nodes, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        child = t1[_i];
        t3 = child._semantics$_rect;
        t4 = t3.left;
        if (typeof t4 !== "number")
          return t4.$sub();
        t5 = t3.top;
        if (typeof t5 !== "number")
          return t5.$sub();
        t6 = t3.right;
        if (typeof t6 !== "number")
          return t6.$add();
        t3 = t3.bottom;
        if (typeof t3 !== "number")
          return t3.$add();
        C.JSArray_methods.add$1(edges, new A._BoxEdge(true, A._pointInParentCoordinates(child, new P.Offset(t4 - -0.1, t5 - -0.1))._dx, child));
        C.JSArray_methods.add$1(edges, new A._BoxEdge(false, A._pointInParentCoordinates(child, new P.Offset(t6 + -0.1, t3 + -0.1))._dx, child));
      }
      C.JSArray_methods.sort$0(edges);
      horizontalGroups = H.setRuntimeTypeInfo([], [A._SemanticsSortGroup]);
      for (t1 = edges.length, t2 = this.textDirection, t3 = [A.SemanticsNode], group = null, depth = 0, _i = 0; _i < edges.length; edges.length === t1 || (0, H.throwConcurrentModificationError)(edges), ++_i) {
        edge = edges[_i];
        if (edge.isLeadingEdge) {
          ++depth;
          if (group == null)
            group = new A._SemanticsSortGroup(edge.offset, t2, H.setRuntimeTypeInfo([], t3));
          C.JSArray_methods.add$1(group.nodes, edge.node);
        } else
          --depth;
        if (depth === 0) {
          C.JSArray_methods.add$1(horizontalGroups, group);
          group = null;
        }
      }
      C.JSArray_methods.sort$0(horizontalGroups);
      if (t2 === C.TextDirection_0)
        horizontalGroups = new H.ReversedListIterable(horizontalGroups, [H.getTypeArgumentByIndex(horizontalGroups, 0)]).toList$0(0);
      result = H.setRuntimeTypeInfo([], t3);
      for (t1 = horizontalGroups.length, _i = 0; _i < horizontalGroups.length; horizontalGroups.length === t1 || (0, H.throwConcurrentModificationError)(horizontalGroups), ++_i)
        C.JSArray_methods.addAll$1(result, horizontalGroups[_i].sortedWithinKnot$0());
      return result;
    },
    sortedWithinKnot$0: function() {
      var t3, t4, nodeMap, edges, t5, t6, t7, _i, node, t8, t9, t10, t11, center, _i0, nextNode, t12, t13, t14, nextCenter, direction, isLtrAndForward, isRtlAndForward, sortedIds, startNodes,
        t1 = this.nodes,
        t2 = t1.length;
      if (t2 <= 1)
        return t1;
      t3 = P.int;
      t4 = A.SemanticsNode;
      nodeMap = P.LinkedHashMap_LinkedHashMap$_empty(t3, t4);
      edges = P.LinkedHashMap_LinkedHashMap$_empty(t3, t3);
      for (t5 = this.textDirection, t6 = t5 === C.TextDirection_0, t5 = t5 === C.TextDirection_1, t7 = t2, _i = 0; _i < t7; t11 === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i, t7 = t11) {
        if (_i >= t7)
          return H.ioore(t1, _i);
        node = t1[_i];
        t7 = node.id;
        nodeMap.$indexSet(0, t7, node);
        t8 = node._semantics$_rect;
        t9 = t8.left;
        t10 = t8.right;
        if (typeof t10 !== "number")
          return t10.$sub();
        if (typeof t9 !== "number")
          return H.iae(t9);
        t11 = t8.top;
        t8 = t8.bottom;
        if (typeof t8 !== "number")
          return t8.$sub();
        if (typeof t11 !== "number")
          return H.iae(t11);
        center = A._pointInParentCoordinates(node, new P.Offset(t9 + (t10 - t9) / 2, t11 + (t8 - t11) / 2));
        for (t8 = t1.length, t9 = center._dx, t10 = center._dy, _i0 = 0; t11 = t1.length, _i0 < t11; t1.length === t8 || (0, H.throwConcurrentModificationError)(t1), ++_i0) {
          nextNode = t1[_i0];
          if (node === nextNode || edges.$index(0, nextNode.id) === t7)
            continue;
          t11 = nextNode._semantics$_rect;
          t12 = t11.left;
          t13 = t11.right;
          if (typeof t13 !== "number")
            return t13.$sub();
          if (typeof t12 !== "number")
            return H.iae(t12);
          t14 = t11.top;
          t11 = t11.bottom;
          if (typeof t11 !== "number")
            return t11.$sub();
          if (typeof t14 !== "number")
            return H.iae(t14);
          nextCenter = A._pointInParentCoordinates(nextNode, new P.Offset(t12 + (t13 - t12) / 2, t14 + (t11 - t14) / 2));
          t14 = nextCenter._dx;
          if (typeof t14 !== "number")
            return t14.$sub();
          if (typeof t9 !== "number")
            return H.iae(t9);
          t11 = nextCenter._dy;
          if (typeof t11 !== "number")
            return t11.$sub();
          if (typeof t10 !== "number")
            return H.iae(t10);
          direction = Math.atan2(t11 - t10, t14 - t9);
          isLtrAndForward = t5 && -0.7853981633974483 < direction && direction < 2.356194490192345;
          if (t6)
            isRtlAndForward = direction < -2.356194490192345 || direction > 2.356194490192345;
          else
            isRtlAndForward = false;
          if (isLtrAndForward || isRtlAndForward)
            edges.$indexSet(0, t7, nextNode.id);
        }
      }
      sortedIds = H.setRuntimeTypeInfo([], [t3]);
      startNodes = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
      C.JSArray_methods.sort$1(startNodes, new A._SemanticsSortGroup_sortedWithinKnot_closure());
      t1 = H.getTypeArgumentByIndex(startNodes, 0);
      new H.MappedListIterable(startNodes, H.functionTypeCheck(new A._SemanticsSortGroup_sortedWithinKnot_closure0(), {func: 1, ret: t3, args: [t1]}), [t1, t3]).forEach$1(0, new A._SemanticsSortGroup_sortedWithinKnot_search(P.LinkedHashSet_LinkedHashSet$_empty(t3), edges, sortedIds));
      t3 = H.getTypeArgumentByIndex(sortedIds, 0);
      t4 = new H.MappedListIterable(sortedIds, H.functionTypeCheck(new A._SemanticsSortGroup_sortedWithinKnot_closure1(nodeMap), {func: 1, ret: t4, args: [t3]}), [t3, t4]).toList$0(0);
      return new H.ReversedListIterable(t4, [H.getTypeArgumentByIndex(t4, 0)]).toList$0(0);
    },
    $asComparable: function() {
      return [A._SemanticsSortGroup];
    }
  };
  A._SemanticsSortGroup_sortedWithinKnot_closure.prototype = {
    call$2: function(a, b) {
      var t1, aTopLeft, bTopLeft, verticalDiff;
      H.interceptedTypeCheck(a, "$isSemanticsNode");
      H.interceptedTypeCheck(b, "$isSemanticsNode");
      t1 = a._semantics$_rect;
      aTopLeft = A._pointInParentCoordinates(a, new P.Offset(t1.left, t1.top));
      t1 = b._semantics$_rect;
      bTopLeft = A._pointInParentCoordinates(b, new P.Offset(t1.left, t1.top));
      verticalDiff = J.compareTo$1$ns(aTopLeft._dy, bTopLeft._dy);
      if (verticalDiff !== 0)
        return -verticalDiff;
      return -J.compareTo$1$ns(aTopLeft._dx, bTopLeft._dx);
    },
    $signature: 35
  };
  A._SemanticsSortGroup_sortedWithinKnot_search.prototype = {
    call$1: function(id) {
      var t1, _this = this;
      H.intTypeCheck(id);
      t1 = _this.visitedIds;
      if (t1.contains$1(0, id))
        return;
      t1.add$1(0, id);
      t1 = _this.edges;
      if (t1.containsKey$1(id))
        _this.call$1(t1.$index(0, id));
      C.JSArray_methods.add$1(_this.sortedIds, id);
    },
    $signature: 42
  };
  A._SemanticsSortGroup_sortedWithinKnot_closure0.prototype = {
    call$1: function(node) {
      return H.interceptedTypeCheck(node, "$isSemanticsNode").id;
    },
    $signature: 109
  };
  A._SemanticsSortGroup_sortedWithinKnot_closure1.prototype = {
    call$1: function(id) {
      return this.nodeMap.$index(0, H.intTypeCheck(id));
    },
    $signature: 110
  };
  A._TraversalSortNode.prototype = {
    compareTo$1: function(_, other) {
      var t1, t2;
      H.interceptedTypeCheck(other, "$is_TraversalSortNode");
      t1 = this.sortKey;
      if (t1 != null)
        t2 = (other == null ? null : other.sortKey) == null;
      else
        t2 = true;
      if (t2)
        return this.position - other.position;
      return t1.compareTo$1(0, other.sortKey);
    },
    $isComparable: 1,
    $asComparable: function() {
      return [A._TraversalSortNode];
    }
  };
  A.SemanticsOwner.prototype = {};
  A.SemanticsOwner_sendSemanticsUpdate_closure.prototype = {
    call$1: function(node) {
      return !this.$this._detachedNodes.contains$1(0, H.interceptedTypeCheck(node, "$isSemanticsNode"));
    },
    $signature: 16
  };
  A.SemanticsOwner_sendSemanticsUpdate_closure0.prototype = {
    call$2: function(a, b) {
      H.interceptedTypeCheck(a, "$isSemanticsNode");
      H.interceptedTypeCheck(b, "$isSemanticsNode");
      return a._node$_depth - b._node$_depth;
    },
    $signature: 35
  };
  A.SemanticsOwner_sendSemanticsUpdate_closure1.prototype = {
    call$2: function(a, b) {
      H.interceptedTypeCheck(a, "$isSemanticsNode");
      H.interceptedTypeCheck(b, "$isSemanticsNode");
      return a._node$_depth - b._node$_depth;
    },
    $signature: 35
  };
  A.SemanticsOwner__getSemanticsActionHandlerForId_closure.prototype = {
    call$1: function(node) {
      if (node._actions.containsKey$1(this.action)) {
        this._box_0.result = node;
        return false;
      }
      return true;
    },
    $signature: 16
  };
  A.SemanticsConfiguration.prototype = {
    _addAction$2: function(action, handler) {
      var _this = this;
      _this._actions.$indexSet(0, action, H.functionTypeCheck(handler, {func: 1, ret: -1, args: [,]}));
      _this._actionsAsBits = _this._actionsAsBits | action.index;
      _this._hasBeenAnnotated = true;
    },
    _addArgumentlessAction$2: function(action, handler) {
      H.functionTypeCheck(handler, {func: 1, ret: -1});
      H.assertHelper(handler != null);
      this._addAction$2(action, new A.SemanticsConfiguration__addArgumentlessAction_closure(handler));
    },
    set$onMoveCursorForwardByCharacter: function(value) {
      H.functionTypeCheck(value, {func: 1, ret: -1, args: [P.bool]});
      this._addAction$2(C.SemanticsAction_512, new A.SemanticsConfiguration_onMoveCursorForwardByCharacter_closure(value));
      this.set$_semantics$_onMoveCursorForwardByCharacter(value);
    },
    set$onMoveCursorBackwardByCharacter: function(value) {
      H.functionTypeCheck(value, {func: 1, ret: -1, args: [P.bool]});
      this._addAction$2(C.SemanticsAction_1024, new A.SemanticsConfiguration_onMoveCursorBackwardByCharacter_closure(value));
      this.set$_semantics$_onMoveCursorBackwardByCharacter(value);
    },
    set$onSetSelection: function(value) {
      H.functionTypeCheck(value, {func: 1, ret: -1, args: [X.TextSelection]});
      this._addAction$2(C.SemanticsAction_2048, new A.SemanticsConfiguration_onSetSelection_closure(value));
      this.set$_semantics$_onSetSelection(value);
    },
    set$sortKey: function(value) {
      H.assertHelper(value != null);
      this._sortKey = value;
      this._hasBeenAnnotated = true;
    },
    set$label: function(label) {
      H.assertHelper(label != null);
      this._label = label;
      this._hasBeenAnnotated = true;
    },
    set$value: function(value) {
      H.assertHelper(false);
      this._semantics$_value = value;
      this._hasBeenAnnotated = true;
    },
    set$decreasedValue: function(decreasedValue) {
      H.assertHelper(false);
      this._decreasedValue = decreasedValue;
      this._hasBeenAnnotated = true;
    },
    set$increasedValue: function(increasedValue) {
      H.assertHelper(false);
      this._increasedValue = increasedValue;
      this._hasBeenAnnotated = true;
    },
    set$hint: function(hint) {
      H.assertHelper(false);
      this._hint = hint;
      this._hasBeenAnnotated = true;
    },
    set$elevation: function(value) {
      H.assertHelper(value != null && value >= 0);
      if (value === this._elevation)
        return;
      this._elevation = value;
      this._hasBeenAnnotated = true;
    },
    _setFlag$2: function(flag, value) {
      var t1, t2, _this = this;
      H.boolConversionCheck(value);
      t1 = _this._flags;
      t2 = flag.index;
      if (value)
        _this._flags = t1 | t2;
      else
        _this._flags = t1 & ~t2;
      _this._hasBeenAnnotated = true;
    },
    isCompatibleWith$1: function(other) {
      var t1, _this = this;
      if (other == null || !other._hasBeenAnnotated || !_this._hasBeenAnnotated)
        return true;
      if ((_this._actionsAsBits & other._actionsAsBits) !== 0)
        return false;
      if ((_this._flags & other._flags) !== 0)
        return false;
      if (_this._semantics$_value.length !== 0)
        t1 = other._semantics$_value.length !== 0;
      else
        t1 = false;
      if (t1)
        return false;
      return true;
    },
    absorb$1: function(child) {
      var t1, t2, _this = this;
      H.assertHelper(!_this.explicitChildNodes);
      if (!child._hasBeenAnnotated)
        return;
      _this._actions.addAll$1(0, child._actions);
      _this._customSemanticsActions.addAll$1(0, child._customSemanticsActions);
      _this._actionsAsBits = _this._actionsAsBits | child._actionsAsBits;
      _this._flags = _this._flags | child._flags;
      _this._textSelection = child._textSelection;
      _this._scrollPosition = child._scrollPosition;
      _this._scrollExtentMax = child._scrollExtentMax;
      _this._scrollExtentMin = child._scrollExtentMin;
      if (_this._hintOverrides == null)
        _this._hintOverrides = child._hintOverrides;
      _this._indexInParent = child._indexInParent;
      _this._scrollIndex = child._scrollIndex;
      _this._scrollChildCount = child._scrollChildCount;
      _this._platformViewId = child._platformViewId;
      t1 = _this._textDirection;
      if (t1 == null) {
        t1 = _this._textDirection = child._textDirection;
        _this._hasBeenAnnotated = true;
      }
      if (_this._sortKey == null)
        _this._sortKey = child._sortKey;
      t2 = _this._label;
      _this._label = A._concatStrings(child._label, child._textDirection, t2, t1);
      if (_this._decreasedValue === "" || false)
        _this._decreasedValue = child._decreasedValue;
      if (_this._semantics$_value === "" || false)
        _this._semantics$_value = child._semantics$_value;
      if (_this._increasedValue === "" || false)
        _this._increasedValue = child._increasedValue;
      t1 = _this._hint;
      t2 = _this._textDirection;
      _this._hint = A._concatStrings(child._hint, child._textDirection, t1, t2);
      _this._thickness = Math.max(_this._thickness, child._thickness + child._elevation);
      _this._hasBeenAnnotated = _this._hasBeenAnnotated || child._hasBeenAnnotated;
    },
    copy$0: function() {
      var _this = this,
        t1 = P.LinkedHashMap_LinkedHashMap$_empty(P.SemanticsAction, {func: 1, ret: -1, args: [,]}),
        t2 = new A.SemanticsConfiguration(t1, P.LinkedHashMap_LinkedHashMap$_empty(A.CustomSemanticsAction, {func: 1, ret: -1}));
      t2._isSemanticBoundary = _this._isSemanticBoundary;
      t2.explicitChildNodes = _this.explicitChildNodes;
      t2.isBlockingSemanticsOfPreviouslyPaintedNodes = _this.isBlockingSemanticsOfPreviouslyPaintedNodes;
      t2._hasBeenAnnotated = _this._hasBeenAnnotated;
      t2._isMergingSemanticsOfDescendants = _this._isMergingSemanticsOfDescendants;
      t2._textDirection = _this._textDirection;
      t2._sortKey = _this._sortKey;
      t2._label = _this._label;
      t2._increasedValue = _this._increasedValue;
      t2._semantics$_value = _this._semantics$_value;
      t2._decreasedValue = _this._decreasedValue;
      t2._hint = _this._hint;
      t2._hintOverrides = _this._hintOverrides;
      t2._elevation = _this._elevation;
      t2._thickness = _this._thickness;
      t2._flags = _this._flags;
      t2.set$_tagsForChildren(_this._tagsForChildren);
      t2._textSelection = _this._textSelection;
      t2._scrollPosition = _this._scrollPosition;
      t2._scrollExtentMax = _this._scrollExtentMax;
      t2._scrollExtentMin = _this._scrollExtentMin;
      t2._actionsAsBits = _this._actionsAsBits;
      t2._indexInParent = _this._indexInParent;
      t2._scrollIndex = _this._scrollIndex;
      t2._scrollChildCount = _this._scrollChildCount;
      t2._platformViewId = _this._platformViewId;
      t1.addAll$1(0, _this._actions);
      t2._customSemanticsActions.addAll$1(0, _this._customSemanticsActions);
      return t2;
    },
    set$_onTap: function(_onTap) {
      this._onTap = H.functionTypeCheck(_onTap, {func: 1, ret: -1});
    },
    set$_onLongPress: function(_onLongPress) {
      this._onLongPress = H.functionTypeCheck(_onLongPress, {func: 1, ret: -1});
    },
    set$_semantics$_onScrollLeft: function(_onScrollLeft) {
      H.functionTypeCheck(_onScrollLeft, {func: 1, ret: -1});
    },
    set$_semantics$_onDismiss: function(_onDismiss) {
      H.functionTypeCheck(_onDismiss, {func: 1, ret: -1});
    },
    set$_semantics$_onScrollRight: function(_onScrollRight) {
      H.functionTypeCheck(_onScrollRight, {func: 1, ret: -1});
    },
    set$_semantics$_onScrollUp: function(_onScrollUp) {
      H.functionTypeCheck(_onScrollUp, {func: 1, ret: -1});
    },
    set$_semantics$_onScrollDown: function(_onScrollDown) {
      H.functionTypeCheck(_onScrollDown, {func: 1, ret: -1});
    },
    set$_semantics$_onIncrease: function(_onIncrease) {
      H.functionTypeCheck(_onIncrease, {func: 1, ret: -1});
    },
    set$_semantics$_onDecrease: function(_onDecrease) {
      H.functionTypeCheck(_onDecrease, {func: 1, ret: -1});
    },
    set$_semantics$_onCopy: function(_onCopy) {
      H.functionTypeCheck(_onCopy, {func: 1, ret: -1});
    },
    set$_semantics$_onCut: function(_onCut) {
      H.functionTypeCheck(_onCut, {func: 1, ret: -1});
    },
    set$_semantics$_onPaste: function(_onPaste) {
      H.functionTypeCheck(_onPaste, {func: 1, ret: -1});
    },
    set$_semantics$_onMoveCursorForwardByCharacter: function(_onMoveCursorForwardByCharacter) {
      H.functionTypeCheck(_onMoveCursorForwardByCharacter, {func: 1, ret: -1, args: [P.bool]});
    },
    set$_semantics$_onMoveCursorBackwardByCharacter: function(_onMoveCursorBackwardByCharacter) {
      H.functionTypeCheck(_onMoveCursorBackwardByCharacter, {func: 1, ret: -1, args: [P.bool]});
    },
    set$_semantics$_onSetSelection: function(_onSetSelection) {
      H.functionTypeCheck(_onSetSelection, {func: 1, ret: -1, args: [X.TextSelection]});
    },
    set$_semantics$_onDidGainAccessibilityFocus: function(_onDidGainAccessibilityFocus) {
      H.functionTypeCheck(_onDidGainAccessibilityFocus, {func: 1, ret: -1});
    },
    set$_semantics$_onDidLoseAccessibilityFocus: function(_onDidLoseAccessibilityFocus) {
      H.functionTypeCheck(_onDidLoseAccessibilityFocus, {func: 1, ret: -1});
    },
    set$_tagsForChildren: function(_tagsForChildren) {
      this._tagsForChildren = H.assertSubtype(_tagsForChildren, "$isSet", [A.SemanticsTag], "$asSet");
    }
  };
  A.SemanticsConfiguration__addArgumentlessAction_closure.prototype = {
    call$1: function(args) {
      H.assertHelper(args == null);
      this.handler.call$0();
    },
    $signature: 12
  };
  A.SemanticsConfiguration_onMoveCursorForwardByCharacter_closure.prototype = {
    call$1: function(args) {
      H.boolTypeCheck(args);
      H.assertHelper(args != null);
      this.value.call$1(args);
    },
    $signature: 12
  };
  A.SemanticsConfiguration_onMoveCursorBackwardByCharacter_closure.prototype = {
    call$1: function(args) {
      H.boolTypeCheck(args);
      H.assertHelper(args != null);
      this.value.call$1(args);
    },
    $signature: 12
  };
  A.SemanticsConfiguration_onSetSelection_closure.prototype = {
    call$1: function(args) {
      H.assertSubtype(args, "$isMap", [P.String, P.int], "$asMap");
      H.assertHelper(args != null && args.$index(0, "base") != null && args.$index(0, "extent") != null);
      this.value.call$1(X.TextSelection$(args.$index(0, "base"), args.$index(0, "extent")));
    },
    $signature: 12
  };
  A.DebugSemanticsDumpOrder.prototype = {
    toString$0: function(_) {
      return this._semantics$_name;
    }
  };
  A.SemanticsSortKey.prototype = {$isComparable: 1,
    $asComparable: function() {
      return [A.SemanticsSortKey];
    }
  };
  A._SemanticsNode_AbstractNode_DiagnosticableTreeMixin.prototype = {};
  E.SemanticsEvent.prototype = {
    toMap$1$nodeId: function(nodeId) {
      var $event = P.LinkedHashMap_LinkedHashMap$_literal(["type", this.type, "data", this.getDataMap$0()], P.String, null);
      if (nodeId != null)
        $event.$indexSet(0, "nodeId", nodeId);
      return $event;
    },
    toMap$0: function() {
      return this.toMap$1$nodeId(null);
    },
    toString$0: function(_) {
      var _i, key,
        pairs = H.setRuntimeTypeInfo([], [P.String]),
        dataMap = this.getDataMap$0(),
        t1 = dataMap.get$keys(),
        sortedKeys = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "Iterable", 0));
      C.JSArray_methods.sort$0(sortedKeys);
      for (t1 = sortedKeys.length, _i = 0; _i < sortedKeys.length; sortedKeys.length === t1 || (0, H.throwConcurrentModificationError)(sortedKeys), ++_i) {
        key = sortedKeys[_i];
        C.JSArray_methods.add$1(pairs, H.S(key) + ": " + H.S(dataMap.$index(0, key)));
      }
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(" + C.JSArray_methods.join$1(pairs, ", ") + ")";
    }
  };
  E.TooltipSemanticsEvent.prototype = {
    getDataMap$0: function() {
      return P.LinkedHashMap_LinkedHashMap$_literal(["message", this.message], P.String, null);
    }
  };
  E.LongPressSemanticsEvent.prototype = {
    getDataMap$0: function() {
      return C.Map_empty1;
    }
  };
  E.TapSemanticEvent.prototype = {
    getDataMap$0: function() {
      return C.Map_empty1;
    }
  };
  Q.AssetBundle.prototype = {
    loadString$2$cache: function(key, cache) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this, t1, data;
      var $async$loadString$2$cache = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self.load$1(key), $async$loadString$2$cache);
            case 3:
              // returning from await.
              data = $async$result;
              if (data == null)
                throw H.wrapException(U.FlutterError$("Unable to load asset: " + key));
              t1 = data.byteLength;
              if (typeof t1 !== "number") {
                $async$returnValue = t1.$lt();
                // goto return
                $async$goto = 1;
                break;
              }
              if (t1 < 10240) {
                t1 = data.buffer;
                t1.toString;
                $async$returnValue = C.C_Utf8Codec.decode$1(H.NativeUint8List_NativeUint8List$view(t1, 0, null));
                // goto return
                $async$goto = 1;
                break;
              }
              $async$returnValue = F.compute(Q.asset_bundle_AssetBundle__utf8decode$closure(), data, 'UTF8 decode for "' + key + '"', P.ByteData, P.String);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$loadString$2$cache, $async$completer);
    },
    toString$0: function(_) {
      return this.get$runtimeType(this).toString$0(0) + "#" + Y.shortHash(this) + "()";
    }
  };
  Q.CachingAssetBundle.prototype = {
    loadString$2$cache: function(key, cache) {
      return this.super$AssetBundle$loadString(key, true);
    }
  };
  Q.PlatformAssetBundle.prototype = {
    load$1: function(key) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.ByteData),
        $async$returnValue, port, isFile, t2, hasAuthority, path, asset, t1, scheme, userInfo, host;
      var $async$load$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = P._Uri__uriEncode(C.List_gnE, key, C.C_Utf8Codec, false);
              scheme = P._Uri__makeScheme(null, 0, 0);
              userInfo = P._Uri__makeUserInfo(null, 0, 0);
              host = P._Uri__makeHost(null, 0, 0, false);
              P._Uri__makeQuery(null, 0, 0, null);
              P._Uri__makeFragment(null, 0, 0);
              port = P._Uri__makePort(null, scheme);
              isFile = scheme === "file";
              if (host == null)
                t2 = userInfo.length !== 0 || port != null || isFile;
              else
                t2 = false;
              if (t2)
                host = "";
              t2 = host == null;
              hasAuthority = !t2;
              path = P._Uri__makePath(t1, 0, t1.length, null, scheme, hasAuthority);
              t1 = scheme.length === 0;
              if (t1 && t2 && !C.JSString_methods.startsWith$1(path, "/"))
                path = P._Uri__normalizeRelativePath(path, !t1 || hasAuthority);
              else
                path = P._Uri__removeDotSegments(path);
              t2 && C.JSString_methods.startsWith$1(path, "//") ? "" : host;
              t1 = C.C_Utf8Encoder.convert$1(path).buffer;
              t1.toString;
              $async$goto = 3;
              return P._asyncAwait(B.BinaryMessages_send("flutter/assets", H.NativeByteData_NativeByteData$view(t1, 0, null)), $async$load$1);
            case 3:
              // returning from await.
              asset = $async$result;
              if (asset == null)
                throw H.wrapException(U.FlutterError$("Unable to load asset: " + key));
              $async$returnValue = asset;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$load$1, $async$completer);
    }
  };
  N.ServicesBinding.prototype = {
    _addLicenses$0: function() {
      var $async$_addLicenses$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$currentError = $async$result;
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = P.String;
              t2 = new P._Future($.Zone__current, [t1]);
              rawLicenses = new P._AsyncCompleter(t2, [t1]);
              P.Timer_Timer(C.Duration_0, new N.ServicesBinding__addLicenses_closure(rawLicenses));
              $async$goto = 3;
              return P._asyncStarHelper(t2, $async$_addLicenses$0, $async$controller);
            case 3:
              // returning from await.
              t2 = [P.List, F.LicenseEntry];
              t1 = new P._Future($.Zone__current, [t2]);
              P.Timer_Timer(C.Duration_0, new N.ServicesBinding__addLicenses_closure0(new P._AsyncCompleter(t1, [t2]), rawLicenses));
              $async$goto = 4;
              return P._asyncStarHelper(t1, $async$_addLicenses$0, $async$controller);
            case 4:
              // returning from await.
              $async$temp1 = P;
              $async$goto = 6;
              return P._asyncStarHelper(t1, $async$_addLicenses$0, $async$controller);
            case 6:
              // returning from await.
              $async$goto = 5;
              $async$nextWhenCanceled = [1];
              return P._asyncStarHelper(P._IterationMarker_yieldStar($async$temp1.Stream_Stream$fromIterable($async$result, F.LicenseEntry)), $async$_addLicenses$0, $async$controller);
            case 5:
              // after yield
            case 1:
              // return
              return P._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return P._asyncStarHelper($async$currentError, 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = P._makeAsyncStarStreamController($async$_addLicenses$0, F.LicenseEntry),
        $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], t1, t2, rawLicenses, $async$temp1;
      return P._streamOfController($async$controller);
    },
    evict$1: function(asset) {
      var t1 = $.$get$rootBundle();
      t1._stringCache.remove$1(0, asset);
      t1._structuredDataCache.remove$1(0, asset);
    }
  };
  N.ServicesBinding__addLicenses_closure.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self.rawLicenses.complete$1($.$get$rootBundle().loadString$2$cache("LICENSE", false));
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 25
  };
  N.ServicesBinding__addLicenses_closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, $async$temp1, $async$temp2, $async$temp3;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = $async$self.parsedLicenses;
              $async$temp2 = F;
              $async$temp3 = N.binding1_ServicesBinding__parseLicenses$closure();
              $async$goto = 2;
              return P._asyncAwait($async$self.rawLicenses.future, $async$call$0);
            case 2:
              // returning from await.
              $async$temp1.complete$1($async$temp2.compute($async$temp3, $async$result, "parseLicenses", P.String, [P.List, F.LicenseEntry]));
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 25
  };
  G.LogicalKeyboardKey.prototype = {
    get$hashCode: function(_) {
      return C.JSInt_methods.get$hashCode(this.keyId);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(this))))
        return false;
      return this.keyId === H.interceptedTypeCheck(other, "$isLogicalKeyboardKey").keyId;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this;
      _this.super$Diagnosticable$debugFillProperties(properties);
      t1 = Y.StringProperty$("keyId", "0x" + C.JSString_methods.padLeft$2(C.JSInt_methods.toRadixString$1(_this.keyId, 16), 8, "0"), C.C__NoDefaultValue, true, true);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.StringProperty$("keyLabel", _this.keyLabel, C.C__NoDefaultValue, true, true));
      C.JSArray_methods.add$1(t2, Y.StringProperty$("debugName", _this.debugName, null, true, true));
    }
  };
  G.PhysicalKeyboardKey.prototype = {
    get$hashCode: function(_) {
      return C.JSInt_methods.get$hashCode(this.usbHidUsage);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(this))))
        return false;
      return this.usbHidUsage === H.interceptedTypeCheck(other, "$isPhysicalKeyboardKey").usbHidUsage;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2;
      this.super$Diagnosticable$debugFillProperties(properties);
      t1 = Y.StringProperty$("usbHidUsage", "0x" + C.JSString_methods.padLeft$2(C.JSInt_methods.toRadixString$1(this.usbHidUsage, 16), 8, "0"), C.C__NoDefaultValue, true, true);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.StringProperty$("debugName", this.debugName, null, true, true));
    }
  };
  F.MethodCall.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(" + this.method + ", " + H.S(this.$arguments) + ")";
    }
  };
  F.PlatformException.prototype = {
    toString$0: function(_) {
      return "PlatformException(" + H.S(this.code) + ", " + H.S(this.message) + ", " + H.S(this.details) + ")";
    },
    $isException: 1
  };
  F.MissingPluginException.prototype = {
    toString$0: function(_) {
      return "MissingPluginException(" + this.message + ")";
    },
    $isException: 1
  };
  U.StringCodec.prototype = {
    decodeMessage$1: function(message) {
      var t1, t2, t3;
      H.interceptedTypeCheck(message, "$isByteData");
      if (message == null)
        return;
      t1 = message.buffer;
      t2 = message.byteOffset;
      t3 = message.byteLength;
      t1.toString;
      return new P.Utf8Decoder(false).convert$1(H.NativeUint8List_NativeUint8List$view(t1, t2, t3));
    },
    encodeMessage$1: function(message) {
      var t1;
      H.stringTypeCheck(message);
      if (message == null)
        return;
      t1 = C.C_Utf8Encoder.convert$1(message).buffer;
      t1.toString;
      return H.NativeByteData_NativeByteData$view(t1, 0, null);
    },
    $isMessageCodec: 1,
    $asMessageCodec: function() {
      return [P.String];
    }
  };
  U.JSONMessageCodec.prototype = {
    encodeMessage$1: function(message) {
      if (message == null)
        return;
      return C.C_StringCodec.encodeMessage$1(C.C_JsonCodec.encode$1(message));
    },
    decodeMessage$1: function(message) {
      H.interceptedTypeCheck(message, "$isByteData");
      if (message == null)
        return message;
      return C.C_JsonCodec.decode$1(C.C_StringCodec.decodeMessage$1(message));
    },
    $isMessageCodec: 1,
    $asMessageCodec: function() {
    }
  };
  U.JSONMethodCodec.prototype = {
    decodeMethodCall$1: function(methodCall) {
      var method, $arguments, _null = null,
        decoded = C.C_JSONMessageCodec.decodeMessage$1(methodCall);
      if (!J.getInterceptor$(decoded).$isMap)
        throw H.wrapException(P.FormatException$("Expected method call Map, got " + H.S(decoded), _null, _null));
      method = decoded.$index(0, "method");
      $arguments = decoded.$index(0, "args");
      if (typeof method === "string")
        return new F.MethodCall(method, $arguments);
      throw H.wrapException(P.FormatException$("Invalid method call: " + decoded.toString$0(0), _null, _null));
    },
    decodeEnvelope$1: function(envelope) {
      var t2, t3, _null = null,
        decoded = C.C_JSONMessageCodec.decodeMessage$1(envelope),
        t1 = J.getInterceptor$(decoded);
      if (!t1.$isList)
        throw H.wrapException(P.FormatException$("Expected envelope List, got " + H.S(decoded), _null, _null));
      if (t1.get$length(decoded) === 1)
        return t1.$index(decoded, 0);
      if (t1.get$length(decoded) === 3) {
        t2 = t1.$index(decoded, 0);
        if (typeof t2 === "string")
          if (t1.$index(decoded, 1) != null) {
            t2 = t1.$index(decoded, 1);
            t2 = typeof t2 === "string";
          } else
            t2 = true;
        else
          t2 = false;
      } else
        t2 = false;
      if (t2) {
        t2 = H.stringTypeCheck(t1.$index(decoded, 0));
        t3 = H.stringTypeCheck(t1.$index(decoded, 1));
        throw H.wrapException(F.PlatformException$(t2, t1.$index(decoded, 2), t3));
      }
      throw H.wrapException(P.FormatException$("Invalid envelope: " + H.S(decoded), _null, _null));
    },
    encodeErrorEnvelope$3$code$details$message: function(code, details, message) {
      H.assertHelper(code != null);
      return C.C_JSONMessageCodec.encodeMessage$1([code, message, details]);
    },
    $isMethodCodec: 1
  };
  U.StandardMessageCodec.prototype = {
    encodeMessage$1: function(message) {
      var buffer;
      if (message == null)
        return;
      buffer = G.WriteBuffer$();
      this.writeValue$2(buffer, message);
      return buffer.done$0();
    },
    decodeMessage$1: function(message) {
      var buffer, result, t1, t2;
      H.interceptedTypeCheck(message, "$isByteData");
      if (message == null)
        return;
      buffer = new G.ReadBuffer(message);
      result = this.readValue$1(buffer);
      t1 = buffer._serialization$_position;
      t2 = message.byteLength;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 < t2)
        throw H.wrapException(C.FormatException_oCg);
      return result;
    },
    writeValue$2: function(buffer, value) {
      var t1, t2, t3, bytes, t4, _this = this;
      if (value == null) {
        t1 = buffer._serialization$_buffer;
        t1.toString;
        t1._typed_buffers$_add$1(H.assertSubtypeOfRuntimeType(0, H.getRuntimeTypeArgument(t1, "_TypedDataBuffer", 0)));
      } else if (typeof value === "boolean") {
        t1 = value ? 1 : 2;
        t2 = buffer._serialization$_buffer;
        t2.toString;
        t2._typed_buffers$_add$1(H.assertSubtypeOfRuntimeType(t1, H.getRuntimeTypeArgument(t2, "_TypedDataBuffer", 0)));
      } else if (typeof value === "number" && Math.floor(value) === value) {
        t1 = -2147483648 <= value && value <= 2147483647;
        t2 = buffer._serialization$_buffer;
        t3 = H.getRuntimeTypeArgument(t2, "_TypedDataBuffer", 0);
        if (t1) {
          t2.toString;
          t2._typed_buffers$_add$1(H.assertSubtypeOfRuntimeType(3, t3));
          buffer._eightBytes.setInt32(0, value, C.C_Endian === $.$get$Endian_host());
          buffer._serialization$_buffer.addAll$3(0, buffer._eightBytesAsList, 0, 4);
        } else {
          t2.toString;
          t2._typed_buffers$_add$1(H.assertSubtypeOfRuntimeType(4, t3));
          C.NativeByteData_methods.setInt64$3(buffer._eightBytes, 0, value, $.$get$Endian_host());
        }
      } else if (typeof value === "number") {
        t1 = buffer._serialization$_buffer;
        t1.toString;
        t1._typed_buffers$_add$1(H.assertSubtypeOfRuntimeType(6, H.getRuntimeTypeArgument(t1, "_TypedDataBuffer", 0)));
        buffer._alignTo$1(8);
        buffer._eightBytes.setFloat64(0, value, C.C_Endian === $.$get$Endian_host());
        buffer._serialization$_buffer.addAll$1(0, buffer._eightBytesAsList);
      } else if (typeof value === "string") {
        t1 = buffer._serialization$_buffer;
        t1.toString;
        t1._typed_buffers$_add$1(H.assertSubtypeOfRuntimeType(7, H.getRuntimeTypeArgument(t1, "_TypedDataBuffer", 0)));
        bytes = C.C_Utf8Encoder.convert$1(value);
        _this.writeSize$2(buffer, bytes.length);
        buffer._serialization$_buffer.addAll$1(0, bytes);
      } else {
        t1 = J.getInterceptor$(value);
        if (!!t1.$isUint8List) {
          t1 = buffer._serialization$_buffer;
          t1.toString;
          t1._typed_buffers$_add$1(H.assertSubtypeOfRuntimeType(8, H.getRuntimeTypeArgument(t1, "_TypedDataBuffer", 0)));
          _this.writeSize$2(buffer, value.length);
          buffer._serialization$_buffer.addAll$1(0, value);
        } else if (!!t1.$isInt32List) {
          t1 = buffer._serialization$_buffer;
          t1.toString;
          t1._typed_buffers$_add$1(H.assertSubtypeOfRuntimeType(9, H.getRuntimeTypeArgument(t1, "_TypedDataBuffer", 0)));
          t1 = value.length;
          _this.writeSize$2(buffer, t1);
          buffer._alignTo$1(4);
          t2 = buffer._serialization$_buffer;
          t3 = value.buffer;
          t4 = value.byteOffset;
          t3.toString;
          t2.addAll$1(0, H.NativeUint8List_NativeUint8List$view(t3, t4, 4 * t1));
        } else if (!!t1.$isFloat64List) {
          t1 = buffer._serialization$_buffer;
          t1.toString;
          t1._typed_buffers$_add$1(H.assertSubtypeOfRuntimeType(11, H.getRuntimeTypeArgument(t1, "_TypedDataBuffer", 0)));
          t1 = value.length;
          _this.writeSize$2(buffer, t1);
          buffer._alignTo$1(8);
          t2 = buffer._serialization$_buffer;
          t3 = value.buffer;
          t4 = value.byteOffset;
          t3.toString;
          t2.addAll$1(0, H.NativeUint8List_NativeUint8List$view(t3, t4, 8 * t1));
        } else if (!!t1.$isList) {
          t2 = buffer._serialization$_buffer;
          t2.toString;
          t2._typed_buffers$_add$1(H.assertSubtypeOfRuntimeType(12, H.getRuntimeTypeArgument(t2, "_TypedDataBuffer", 0)));
          _this.writeSize$2(buffer, t1.get$length(value));
          for (t1 = t1.get$iterator(value); t1.moveNext$0();)
            _this.writeValue$2(buffer, t1.get$current());
        } else if (!!t1.$isMap) {
          t1 = buffer._serialization$_buffer;
          t1.toString;
          t1._typed_buffers$_add$1(H.assertSubtypeOfRuntimeType(13, H.getRuntimeTypeArgument(t1, "_TypedDataBuffer", 0)));
          _this.writeSize$2(buffer, value.get$length(value));
          value.forEach$1(0, new U.StandardMessageCodec_writeValue_closure(_this, buffer));
        } else
          throw H.wrapException(P.ArgumentError$value(value, null, null));
      }
    },
    readValue$1: function(buffer) {
      var t1 = buffer._serialization$_position,
        t2 = buffer.data.byteLength;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 >= t2)
        throw H.wrapException(C.FormatException_oCg);
      return this.readValueOfType$2(buffer.getUint8$0(0), buffer);
    },
    readValueOfType$2: function(type, buffer) {
      var value, $length, t1, t2, t3, list, result, i, t4, _this = this;
      switch (type) {
        case 0:
          return;
        case 1:
          return true;
        case 2:
          return false;
        case 3:
          value = buffer.data.getInt32(buffer._serialization$_position, C.C_Endian === $.$get$Endian_host());
          buffer._serialization$_position += 4;
          return value;
        case 4:
          return buffer.getInt64$0(0);
        case 6:
          buffer._alignTo$1(8);
          value = buffer.data.getFloat64(buffer._serialization$_position, C.C_Endian === $.$get$Endian_host());
          buffer._serialization$_position += 8;
          return value;
        case 5:
        case 7:
          return new P.Utf8Decoder(false).convert$1(buffer.getUint8List$1(_this.readSize$1(buffer)));
        case 8:
          return buffer.getUint8List$1(_this.readSize$1(buffer));
        case 9:
          $length = _this.readSize$1(buffer);
          buffer._alignTo$1(4);
          t1 = buffer.data;
          t2 = t1.buffer;
          t1 = t1.byteOffset;
          t3 = buffer._serialization$_position;
          if (typeof t1 !== "number")
            return t1.$add();
          t3 = t1 + t3;
          t2.toString;
          H._checkViewArguments(t2, t3, $length);
          list = $length == null ? new Int32Array(t2, t3) : new Int32Array(t2, t3, $length);
          t1 = buffer._serialization$_position;
          if (typeof $length !== "number")
            return H.iae($length);
          buffer._serialization$_position = t1 + 4 * $length;
          return list;
        case 10:
          return buffer.getInt64List$1(_this.readSize$1(buffer));
        case 11:
          $length = _this.readSize$1(buffer);
          buffer._alignTo$1(8);
          t1 = buffer.data;
          t2 = t1.buffer;
          t1 = t1.byteOffset;
          t3 = buffer._serialization$_position;
          if (typeof t1 !== "number")
            return t1.$add();
          t3 = t1 + t3;
          t2.toString;
          H._checkViewArguments(t2, t3, $length);
          list = $length == null ? new Float64Array(t2, t3) : new Float64Array(t2, t3, $length);
          t1 = buffer._serialization$_position;
          if (typeof $length !== "number")
            return H.iae($length);
          buffer._serialization$_position = t1 + 8 * $length;
          return list;
        case 12:
          $length = _this.readSize$1(buffer);
          if (typeof $length !== "number")
            return H.iae($length);
          result = new Array($length);
          result.fixed$length = Array;
          for (t1 = buffer.data, i = 0; i < $length; ++i) {
            t2 = buffer._serialization$_position;
            t3 = t1.byteLength;
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (t2 >= t3)
              H.throwExpression(C.FormatException_oCg);
            buffer._serialization$_position = t2 + 1;
            C.JSArray_methods.$indexSet(result, i, _this.readValueOfType$2(t1.getUint8(t2), buffer));
          }
          return result;
        case 13:
          $length = _this.readSize$1(buffer);
          result = P.LinkedHashMap__makeEmpty();
          if (typeof $length !== "number")
            return H.iae($length);
          t1 = buffer.data;
          i = 0;
          for (; i < $length; ++i) {
            t2 = buffer._serialization$_position;
            t3 = t1.byteLength;
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (t2 >= t3)
              H.throwExpression(C.FormatException_oCg);
            buffer._serialization$_position = t2 + 1;
            t2 = _this.readValueOfType$2(t1.getUint8(t2), buffer);
            t3 = buffer._serialization$_position;
            t4 = t1.byteLength;
            if (typeof t4 !== "number")
              return H.iae(t4);
            if (t3 >= t4)
              H.throwExpression(C.FormatException_oCg);
            buffer._serialization$_position = t3 + 1;
            result.$indexSet(0, t2, _this.readValueOfType$2(t1.getUint8(t3), buffer));
          }
          return result;
        default:
          throw H.wrapException(C.FormatException_oCg);
      }
    },
    writeSize$2: function(buffer, value) {
      var t1, t2;
      H.assertHelper(0 <= value && value <= 4294967295);
      if (value < 254) {
        t1 = buffer._serialization$_buffer;
        t1.toString;
        t1._typed_buffers$_add$1(H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(t1, "_TypedDataBuffer", 0)));
      } else {
        t1 = buffer._serialization$_buffer;
        t2 = H.getRuntimeTypeArgument(t1, "_TypedDataBuffer", 0);
        if (value <= 65535) {
          t1.toString;
          t1._typed_buffers$_add$1(H.assertSubtypeOfRuntimeType(254, t2));
          buffer._eightBytes.setUint16(0, value, C.C_Endian === $.$get$Endian_host());
          buffer._serialization$_buffer.addAll$3(0, buffer._eightBytesAsList, 0, 2);
        } else {
          t1.toString;
          t1._typed_buffers$_add$1(H.assertSubtypeOfRuntimeType(255, t2));
          buffer._eightBytes.setUint32(0, value, C.C_Endian === $.$get$Endian_host());
          buffer._serialization$_buffer.addAll$3(0, buffer._eightBytesAsList, 0, 4);
        }
      }
    },
    readSize$1: function(buffer) {
      var value = buffer.getUint8$0(0);
      switch (value) {
        case 254:
          value = buffer.data.getUint16(buffer._serialization$_position, C.C_Endian === $.$get$Endian_host());
          buffer._serialization$_position += 2;
          return value;
        case 255:
          value = buffer.data.getUint32(buffer._serialization$_position, C.C_Endian === $.$get$Endian_host());
          buffer._serialization$_position += 4;
          return value;
        default:
          return value;
      }
    },
    $isMessageCodec: 1,
    $asMessageCodec: function() {
    }
  };
  U.StandardMessageCodec_writeValue_closure.prototype = {
    call$2: function(key, value) {
      var t1 = this.$this,
        t2 = this.buffer;
      t1.writeValue$2(t2, key);
      t1.writeValue$2(t2, value);
    },
    $signature: 21
  };
  A.BasicMessageChannel.prototype = {
    send$1: function(message) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      return this.send$body$BasicMessageChannel(H.assertSubtypeOfRuntimeType(message, t1), t1);
    },
    send$body$BasicMessageChannel: function(message, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$self = this, t1, $async$temp1;
      var $async$send$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.codec;
              $async$temp1 = t1;
              $async$goto = 3;
              return P._asyncAwait(B.BinaryMessages_send($async$self.name, t1.encodeMessage$1(message)), $async$send$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.decodeMessage$1($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$send$1, $async$completer);
    },
    setMessageHandler$1: function(handler) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      B.BinaryMessages_setMessageHandler(this.name, new A.BasicMessageChannel_setMessageHandler_closure(this, H.functionTypeCheck(handler, {func: 1, ret: [P.Future, t1], args: [t1]})));
    }
  };
  A.BasicMessageChannel_setMessageHandler_closure.prototype = {
    call$1: function(message) {
      return this.$call$body$BasicMessageChannel_setMessageHandler_closure(H.interceptedTypeCheck(message, "$isByteData"));
    },
    $call$body$BasicMessageChannel_setMessageHandler_closure: function(message) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.ByteData),
        $async$returnValue, $async$self = this, t1, $async$temp1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this.codec;
              $async$temp1 = t1;
              $async$goto = 3;
              return P._asyncAwait($async$self.handler.call$1(t1.decodeMessage$1(message)), $async$call$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.encodeMessage$1($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 47
  };
  A.MethodChannel.prototype = {
    invokeMethod$1$2: function(method, $arguments, $T) {
      return this.invokeMethod$body$MethodChannel(method, $arguments, $T, $T);
    },
    invokeMethod$body$MethodChannel: function(method, $arguments, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$self = this, t1, result;
      var $async$invokeMethod$1$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.name;
              $async$goto = 3;
              return P._asyncAwait(B.BinaryMessages_send(t1, C.C_JSONMessageCodec.encodeMessage$1(P.LinkedHashMap_LinkedHashMap$_literal(["method", method, "args", $arguments], P.String, null))), $async$invokeMethod$1$2);
            case 3:
              // returning from await.
              result = $async$result;
              if (result == null)
                throw H.wrapException(new F.MissingPluginException("No implementation found for method " + method + " on channel " + t1));
              $async$returnValue = H.assertSubtypeOfRuntimeType($async$self.codec.decodeEnvelope$1(result), $T);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$invokeMethod$1$2, $async$completer);
    },
    setMethodCallHandler$1: function(handler) {
      H.functionTypeCheck(handler, {func: 1, ret: [P.Future,,], args: [F.MethodCall]});
      B.BinaryMessages_setMessageHandler(this.name, new A.MethodChannel_setMethodCallHandler_closure(this, handler));
    },
    _handleAsMethodCall$2: function(message, handler) {
      H.functionTypeCheck(handler, {func: 1, ret: [P.Future,,], args: [F.MethodCall]});
      return this._handleAsMethodCall$body$MethodChannel(message, handler);
    },
    _handleAsMethodCall$body$MethodChannel: function(message, handler) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.ByteData),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, e, e0, t2, exception, t3, t1, $call, $async$exception, $async$temp1;
      var $async$_handleAsMethodCall$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.codec;
              $call = t1.decodeMethodCall$1(message);
              $async$handler = 4;
              $async$temp1 = C.C_JSONMessageCodec;
              $async$goto = 7;
              return P._asyncAwait(handler.call$1($call), $async$_handleAsMethodCall$2);
            case 7:
              // returning from await.
              t2 = $async$temp1.encodeMessage$1([$async$result]);
              $async$returnValue = t2;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              t2 = H.unwrapException($async$exception);
              t3 = J.getInterceptor$(t2);
              if (!!t3.$isPlatformException) {
                e = t2;
                t2 = e.code;
                t3 = e.message;
                $async$returnValue = t1.encodeErrorEnvelope$3$code$details$message(t2, e.details, t3);
                // goto return
                $async$goto = 1;
                break;
              } else if (!!t3.$isMissingPluginException) {
                // goto return
                $async$goto = 1;
                break;
              } else {
                e0 = t2;
                t1 = t1.encodeErrorEnvelope$3$code$details$message("error", null, J.toString$0$(e0));
                $async$returnValue = t1;
                // goto return
                $async$goto = 1;
                break;
              }
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_handleAsMethodCall$2, $async$completer);
    }
  };
  A.MethodChannel_setMethodCallHandler_closure.prototype = {
    call$1: function(message) {
      return this.$this._handleAsMethodCall$2(H.interceptedTypeCheck(message, "$isByteData"), this.handler);
    },
    $signature: 47
  };
  A.OptionalMethodChannel.prototype = {
    invokeMethod$1$2: function(method, $arguments, $T) {
      return this.invokeMethod$body$OptionalMethodChannel(method, $arguments, $T, $T);
    },
    invokeMethod$1$1: function(method, $T) {
      return this.invokeMethod$1$2(method, null, $T);
    },
    invokeMethod$body$OptionalMethodChannel: function(method, $arguments, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, result, exception, $async$exception;
      var $async$invokeMethod$1$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 4;
              $async$goto = 7;
              return P._asyncAwait($async$self.super$MethodChannel$invokeMethod(method, $arguments, $T), $async$invokeMethod$1$2);
            case 7:
              // returning from await.
              result = $async$result;
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              if (H.unwrapException($async$exception) instanceof F.MissingPluginException) {
                // goto return
                $async$goto = 1;
                break;
              } else
                throw $async$exception;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$invokeMethod$1$2, $async$completer);
    }
  };
  B.BinaryMessages__sendPlatformMessage_closure.prototype = {
    call$1: function(reply) {
      var exception, stack, exception0;
      try {
        this.completer.complete$1(reply);
      } catch (exception0) {
        exception = H.unwrapException(exception0);
        stack = H.getTraceFromException(exception0);
        U.FlutterError_reportError(U.FlutterErrorDetails$("during a platform message response callback", exception, null, "services library", false, stack));
      }
    },
    $signature: 113
  };
  B.KeyboardSide.prototype = {
    toString$0: function(_) {
      return this._raw_keyboard$_name;
    }
  };
  B.ModifierKey.prototype = {
    toString$0: function(_) {
      return this._raw_keyboard$_name;
    }
  };
  B.RawKeyEventData.prototype = {
    get$modifiersPressed: function() {
      var _i, key,
        result = P.LinkedHashMap_LinkedHashMap$_empty(B.ModifierKey, B.KeyboardSide);
      for (_i = 0; _i < 9; ++_i) {
        key = C.List_0[_i];
        if (this.isModifierPressed$1(key))
          result.$indexSet(0, key, this.getModifierSide$1(key));
      }
      return result;
    }
  };
  B.RawKeyEvent.prototype = {};
  B.RawKeyDownEvent.prototype = {};
  B.RawKeyUpEvent.prototype = {};
  B.RawKeyboard.prototype = {
    _handleKeyEvent$1: function(message) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$returnValue, $async$self = this, t1, t2, t3, _i, listener, $event;
      var $async$_handleKeyEvent$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $event = B.RawKeyEvent_RawKeyEvent$fromMessage(H.assertSubtype(message, "$isMap", [P.String, null], "$asMap"));
              if (!!$event.$isRawKeyDownEvent)
                $async$self._keysPressed.add$1(0, $event.data.get$logicalKey());
              if (!!$event.$isRawKeyUpEvent)
                $async$self._keysPressed.remove$1(0, $event.data.get$logicalKey());
              t1 = $async$self._listeners;
              if (t1.length === 0) {
                // goto return
                $async$goto = 1;
                break;
              }
              for (t2 = P.List_List$from(t1, true, {func: 1, ret: -1, args: [B.RawKeyEvent]}), t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
                listener = t2[_i];
                if (C.JSArray_methods.contains$1(t1, listener))
                  listener.call$1($event);
              }
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_handleKeyEvent$1, $async$completer);
    }
  };
  Q.RawKeyEventDataAndroid.prototype = {
    get$keyLabel: function() {
      var t1 = this.plainCodePoint;
      return t1 === 0 ? null : H.Primitives_stringFromCharCode(t1 & 2147483647);
    },
    get$logicalKey: function() {
      var keyId, t2, newKey, _this = this,
        t1 = _this.keyCode,
        numPadKey = C.Map_uS2jN.$index(0, t1);
      if (numPadKey != null)
        return numPadKey;
      if (_this.get$keyLabel() != null && _this.get$keyLabel().length !== 0 && !G.LogicalKeyboardKey_isControlCharacter(_this.get$keyLabel())) {
        keyId = 0 | _this.plainCodePoint & 2147483647 & 4294967295;
        t1 = C.Map_yHIsn.$index(0, keyId);
        if (t1 == null) {
          t1 = _this.get$keyLabel();
          t2 = "Key " + _this.get$keyLabel().toUpperCase();
          t1 = new G.LogicalKeyboardKey(keyId, t2, t1);
        }
        return t1;
      }
      newKey = C.Map_0rYGk.$index(0, t1);
      if (newKey != null)
        return newKey;
      t2 = "Unknown Android key code " + t1;
      newKey = new G.LogicalKeyboardKey((8589934592 | t1 | 1099511627776) >>> 0, t2, null);
      return newKey;
    },
    _raw_keyboard_android$_isLeftRightModifierPressed$4: function(side, anyMask, leftMask, rightMask) {
      var t1 = this.metaState;
      if ((t1 & anyMask) === 0)
        return false;
      switch (side) {
        case C.KeyboardSide_0:
          return true;
        case C.KeyboardSide_3:
          return (t1 & leftMask) !== 0 && (t1 & rightMask) !== 0;
        case C.KeyboardSide_1:
          return (t1 & leftMask) !== 0;
        case C.KeyboardSide_2:
          return (t1 & rightMask) !== 0;
      }
      return false;
    },
    isModifierPressed$1: function(key) {
      var _this = this;
      switch (key) {
        case C.ModifierKey_0:
          return _this._raw_keyboard_android$_isLeftRightModifierPressed$4(C.KeyboardSide_0, 4096, 8192, 16384);
        case C.ModifierKey_1:
          return _this._raw_keyboard_android$_isLeftRightModifierPressed$4(C.KeyboardSide_0, 1, 64, 128);
        case C.ModifierKey_2:
          return _this._raw_keyboard_android$_isLeftRightModifierPressed$4(C.KeyboardSide_0, 2, 16, 32);
        case C.ModifierKey_3:
          return _this._raw_keyboard_android$_isLeftRightModifierPressed$4(C.KeyboardSide_0, 65536, 131072, 262144);
        case C.ModifierKey_4:
          return (_this.metaState & 1048576) !== 0;
        case C.ModifierKey_5:
          return (_this.metaState & 2097152) !== 0;
        case C.ModifierKey_6:
          return (_this.metaState & 4194304) !== 0;
        case C.ModifierKey_7:
          return (_this.metaState & 8) !== 0;
        case C.ModifierKey_8:
          return (_this.metaState & 4) !== 0;
      }
      return false;
    },
    getModifierSide$1: function(key) {
      var t1 = new Q.RawKeyEventDataAndroid_getModifierSide_findSide(this);
      switch (key) {
        case C.ModifierKey_0:
          return t1.call$2(8192, 16384);
        case C.ModifierKey_1:
          return t1.call$2(64, 128);
        case C.ModifierKey_2:
          return t1.call$2(16, 32);
        case C.ModifierKey_3:
          return t1.call$2(131072, 262144);
        case C.ModifierKey_4:
        case C.ModifierKey_5:
        case C.ModifierKey_6:
        case C.ModifierKey_7:
        case C.ModifierKey_8:
          return C.KeyboardSide_3;
      }
      H.assertThrow("Not handling " + H.S(key) + " type properly.");
      return;
    },
    toString$0: function(_) {
      var _this = this;
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(keyLabel: " + H.S(_this.get$keyLabel()) + " flags: " + _this.flags + ", codePoint: " + _this.codePoint + ", keyCode: " + _this.keyCode + ", scanCode: " + _this.scanCode + ", metaState: " + _this.metaState + ", modifiers down: " + _this.get$modifiersPressed().toString$0(0) + ")";
    }
  };
  Q.RawKeyEventDataAndroid_getModifierSide_findSide.prototype = {
    call$2: function(leftMask, rightMask) {
      var combinedMask = leftMask | rightMask,
        combined = this.$this.metaState & combinedMask;
      if (combined === leftMask)
        return C.KeyboardSide_1;
      else if (combined === rightMask)
        return C.KeyboardSide_2;
      else if (combined === combinedMask)
        return C.KeyboardSide_3;
      return;
    },
    $signature: 48
  };
  Q.RawKeyEventDataFuchsia.prototype = {
    get$logicalKey: function() {
      var t2, t3, newKey,
        t1 = this.codePoint;
      if (t1 !== 0) {
        t2 = H.Primitives_stringFromCharCode(t1);
        t3 = H.Primitives_stringFromCharCode(t1);
        t3 = "Key " + t3;
        return new G.LogicalKeyboardKey((0 | t1 & 4294967295) >>> 0, t3, t2);
      }
      t1 = this.hidUsage;
      newKey = C.Map_yHIsn.$index(0, (t1 | 4294967296) >>> 0);
      if (newKey != null)
        return newKey;
      t2 = "Ephemeral Fuchsia key code " + t1;
      newKey = new G.LogicalKeyboardKey((12884901888 | t1 | 1099511627776) >>> 0, t2, null);
      return newKey;
    },
    _raw_keyboard_fuchsia$_isLeftRightModifierPressed$4: function(side, anyMask, leftMask, rightMask) {
      var t1 = this.modifiers;
      if ((t1 & anyMask) === 0)
        return false;
      switch (side) {
        case C.KeyboardSide_0:
          return true;
        case C.KeyboardSide_3:
          return (t1 & leftMask) !== 0 && (t1 & rightMask) !== 0;
        case C.KeyboardSide_1:
          return (t1 & leftMask) !== 0;
        case C.KeyboardSide_2:
          return (t1 & rightMask) !== 0;
      }
      return false;
    },
    isModifierPressed$1: function(key) {
      var _this = this;
      switch (key) {
        case C.ModifierKey_0:
          return _this._raw_keyboard_fuchsia$_isLeftRightModifierPressed$4(C.KeyboardSide_0, 24, 8, 16);
        case C.ModifierKey_1:
          return _this._raw_keyboard_fuchsia$_isLeftRightModifierPressed$4(C.KeyboardSide_0, 6, 2, 4);
        case C.ModifierKey_2:
          return _this._raw_keyboard_fuchsia$_isLeftRightModifierPressed$4(C.KeyboardSide_0, 96, 32, 64);
        case C.ModifierKey_3:
          return _this._raw_keyboard_fuchsia$_isLeftRightModifierPressed$4(C.KeyboardSide_0, 384, 128, 256);
        case C.ModifierKey_4:
          return (_this.modifiers & 1) !== 0;
        case C.ModifierKey_5:
        case C.ModifierKey_6:
        case C.ModifierKey_7:
        case C.ModifierKey_8:
          return false;
      }
      return false;
    },
    getModifierSide$1: function(key) {
      var t1 = new Q.RawKeyEventDataFuchsia_getModifierSide_findSide(this);
      switch (key) {
        case C.ModifierKey_0:
          return t1.call$3(8, 16, 24);
        case C.ModifierKey_1:
          return t1.call$3(2, 4, 6);
        case C.ModifierKey_2:
          return t1.call$3(32, 64, 96);
        case C.ModifierKey_3:
          return t1.call$3(128, 256, 384);
        case C.ModifierKey_4:
          return (this.modifiers & 1) === 0 ? null : C.KeyboardSide_3;
        case C.ModifierKey_5:
        case C.ModifierKey_6:
        case C.ModifierKey_7:
        case C.ModifierKey_8:
          return;
      }
      H.assertThrow("Not handling " + H.S(key) + " type properly.");
      return;
    },
    toString$0: function(_) {
      var _this = this;
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(hidUsage: " + _this.hidUsage + ", codePoint: " + _this.codePoint + ", modifiers: " + _this.modifiers + ", modifiers down: " + _this.get$modifiersPressed().toString$0(0) + ")";
    }
  };
  Q.RawKeyEventDataFuchsia_getModifierSide_findSide.prototype = {
    call$3: function(leftMask, rightMask, combinedMask) {
      var combined = this.$this.modifiers & combinedMask;
      if (combined === leftMask)
        return C.KeyboardSide_1;
      else if (combined === rightMask)
        return C.KeyboardSide_2;
      else if (combined === combinedMask)
        return C.KeyboardSide_3;
      return;
    },
    $signature: 116
  };
  O.RawKeyEventDataLinux.prototype = {
    get$logicalKey: function() {
      var t2, t3, t4, keyId, newKey, _null = null,
        t1 = this.keyCode,
        numPadKey = C.Map_s3kmC.$index(0, t1);
      if (numPadKey != null)
        return numPadKey;
      t2 = this.codePoint;
      t3 = t2 === 0;
      if ((t3 ? _null : H.Primitives_stringFromCharCode(t2)) != null)
        t4 = !G.LogicalKeyboardKey_isControlCharacter(t3 ? _null : H.Primitives_stringFromCharCode(t2));
      else
        t4 = false;
      if (t4) {
        keyId = (0 | t2 & 4294967295) >>> 0;
        t1 = C.Map_yHIsn.$index(0, keyId);
        if (t1 == null) {
          t1 = t3 ? _null : H.Primitives_stringFromCharCode(t2);
          t2 = t3 ? _null : H.Primitives_stringFromCharCode(t2);
          t2 = "Key " + t2.toUpperCase();
          t1 = new G.LogicalKeyboardKey(keyId, t2, t1);
        }
        return t1;
      }
      newKey = C.Map_ifV1A.$index(0, t1);
      if (newKey != null)
        return newKey;
      t2 = "Unknown key code " + t1;
      newKey = new G.LogicalKeyboardKey((25769803776 | t1 | 1099511627776) >>> 0, t2, _null);
      return newKey;
    },
    isModifierPressed$1: function(key) {
      return this.keyHelper.isModifierPressed$3$side(key, this.modifiers, C.KeyboardSide_0);
    },
    getModifierSide$1: function(key) {
      return this.keyHelper.getModifierSide$1(key);
    },
    toString$0: function(_) {
      var _this = this,
        t1 = new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(keyLabel: ",
        t2 = _this.codePoint;
      return t1 + H.S(t2 === 0 ? null : H.Primitives_stringFromCharCode(t2)) + ", keyCode: " + _this.keyCode + ", scanCode: " + _this.scanCode + ", codePoint: " + t2 + ", modifiers: " + _this.modifiers + ", modifiers down: " + _this.get$modifiersPressed().toString$0(0) + ")";
    }
  };
  O.KeyHelper.prototype = {};
  O.GLFWKeyHelper.prototype = {
    isModifierPressed$3$side: function(key, modifiers, side) {
      switch (key) {
        case C.ModifierKey_0:
          return (modifiers & 2) !== 0;
        case C.ModifierKey_1:
          return (modifiers & 1) !== 0;
        case C.ModifierKey_2:
          return (modifiers & 4) !== 0;
        case C.ModifierKey_3:
          return (modifiers & 8) !== 0;
        case C.ModifierKey_4:
          return (modifiers & 16) !== 0;
        case C.ModifierKey_5:
          return (modifiers & 32) !== 0;
        case C.ModifierKey_7:
        case C.ModifierKey_8:
        case C.ModifierKey_6:
          return false;
      }
      return false;
    },
    getModifierSide$1: function(key) {
      switch (key) {
        case C.ModifierKey_0:
        case C.ModifierKey_1:
        case C.ModifierKey_2:
        case C.ModifierKey_3:
          return C.KeyboardSide_0;
        case C.ModifierKey_4:
        case C.ModifierKey_5:
        case C.ModifierKey_7:
        case C.ModifierKey_8:
        case C.ModifierKey_6:
          return C.KeyboardSide_3;
      }
      H.assertThrow("Not handling " + H.S(key) + " type properly.");
      return;
    }
  };
  O._GLFWKeyHelper_Object_KeyHelper.prototype = {};
  B.RawKeyEventDataMacOs.prototype = {
    get$physicalKey: function() {
      var t1 = C.Map_QtQ1t.$index(0, this.keyCode);
      return t1 == null ? C.PhysicalKeyboardKey_0_None : t1;
    },
    get$logicalKey: function() {
      var t2, t3, t4, t5, codeUnit, keyId, _this = this, _null = null,
        t1 = _this.keyCode,
        numPadKey = C.Map_F1QoB.$index(0, t1);
      if (numPadKey != null)
        return numPadKey;
      t2 = _this.charactersIgnoringModifiers;
      t3 = t2.length;
      t4 = t3 === 0;
      if ((t4 ? _null : t2) != null)
        t5 = !G.LogicalKeyboardKey_isControlCharacter(t4 ? _null : t2);
      else
        t5 = false;
      if (t5) {
        H.assertHelper(t3 <= 2);
        codeUnit = C.JSString_methods._codeUnitAt$1(t2, 0);
        keyId = (0 | (t3 === 2 ? codeUnit << 16 | C.JSString_methods._codeUnitAt$1(t2, 1) : codeUnit) & 4294967295) >>> 0;
        t1 = C.Map_yHIsn.$index(0, keyId);
        if (t1 == null) {
          t1 = t4 ? _null : t2;
          if (t4)
            t2 = _null;
          t2 = "Key " + t2.toUpperCase();
          t1 = new G.LogicalKeyboardKey(keyId, t2, t1);
        }
        return t1;
      }
      if (!_this.get$physicalKey().$eq(0, C.PhysicalKeyboardKey_0_None)) {
        keyId = (_this.get$physicalKey().usbHidUsage | 4294967296) >>> 0;
        t1 = C.Map_yHIsn.$index(0, keyId);
        if (t1 == null) {
          t1 = _this.get$physicalKey();
          t1 = new G.LogicalKeyboardKey(keyId, _this.get$physicalKey().debugName, t1.debugName);
        }
        return t1;
      }
      t2 = "Unknown macOS key code " + t1;
      return new G.LogicalKeyboardKey((21474836480 | t1 | 1099511627776) >>> 0, t2, _null);
    },
    _isLeftRightModifierPressed$4: function(side, anyMask, leftMask, rightMask) {
      var t1 = this.modifiers;
      if ((t1 & anyMask) === 0)
        return false;
      switch (side) {
        case C.KeyboardSide_0:
          return true;
        case C.KeyboardSide_3:
          return (t1 & leftMask) !== 0 && (t1 & rightMask) !== 0;
        case C.KeyboardSide_1:
          return (t1 & leftMask) !== 0;
        case C.KeyboardSide_2:
          return (t1 & rightMask) !== 0;
      }
      return false;
    },
    isModifierPressed$1: function(key) {
      var _this = this,
        independentModifier = _this.modifiers & 4294901760;
      switch (key) {
        case C.ModifierKey_0:
          return _this._isLeftRightModifierPressed$4(C.KeyboardSide_0, independentModifier & 262144, 1, 8192);
        case C.ModifierKey_1:
          return _this._isLeftRightModifierPressed$4(C.KeyboardSide_0, independentModifier & 131072, 2, 4);
        case C.ModifierKey_2:
          return _this._isLeftRightModifierPressed$4(C.KeyboardSide_0, independentModifier & 524288, 32, 64);
        case C.ModifierKey_3:
          return _this._isLeftRightModifierPressed$4(C.KeyboardSide_0, independentModifier & 1048576, 8, 16);
        case C.ModifierKey_4:
          return (independentModifier & 65536) !== 0;
        case C.ModifierKey_5:
          return (independentModifier & 2097152) !== 0;
        case C.ModifierKey_7:
          return (independentModifier & 8388608) !== 0;
        case C.ModifierKey_8:
        case C.ModifierKey_6:
          return false;
      }
      return false;
    },
    getModifierSide$1: function(key) {
      var t1 = new B.RawKeyEventDataMacOs_getModifierSide_findSide(this);
      switch (key) {
        case C.ModifierKey_0:
          return t1.call$2(1, 8192);
        case C.ModifierKey_1:
          return t1.call$2(2, 4);
        case C.ModifierKey_2:
          return t1.call$2(32, 64);
        case C.ModifierKey_3:
          return t1.call$2(8, 16);
        case C.ModifierKey_4:
        case C.ModifierKey_5:
        case C.ModifierKey_6:
        case C.ModifierKey_7:
        case C.ModifierKey_8:
          return C.KeyboardSide_3;
      }
      H.assertThrow("Not handling " + H.S(key) + " type properly.");
      return;
    },
    toString$0: function(_) {
      var _this = this,
        t1 = new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(keyLabel: ",
        t2 = _this.charactersIgnoringModifiers;
      return t1 + H.S(t2.length === 0 ? null : t2) + ", keyCode: " + _this.keyCode + ", characters: " + _this.characters + ", unmodifiedCharacters: " + t2 + ", modifiers: " + _this.modifiers + ", modifiers down: " + _this.get$modifiersPressed().toString$0(0) + ")";
    }
  };
  B.RawKeyEventDataMacOs_getModifierSide_findSide.prototype = {
    call$2: function(leftMask, rightMask) {
      var combinedMask = leftMask | rightMask,
        combined = this.$this.modifiers & combinedMask;
      if (combined === leftMask)
        return C.KeyboardSide_1;
      else if (combined === rightMask)
        return C.KeyboardSide_2;
      else if (combined === combinedMask)
        return C.KeyboardSide_3;
      return;
    },
    $signature: 48
  };
  X.ApplicationSwitcherDescription.prototype = {};
  X.SystemUiOverlayStyle.prototype = {
    _toMap$0: function() {
      var t2, t3, t4, _this = this, _null = null,
        t1 = _this.systemNavigationBarColor;
      t1 = t1 == null ? _null : t1.value;
      t2 = _this.statusBarBrightness;
      t2 = t2 == null ? _null : t2._ui$_name;
      t3 = _this.statusBarIconBrightness;
      t3 = t3 == null ? _null : t3._ui$_name;
      t4 = _this.systemNavigationBarIconBrightness;
      return P.LinkedHashMap_LinkedHashMap$_literal(["systemNavigationBarColor", t1, "systemNavigationBarDividerColor", null, "statusBarColor", null, "statusBarBrightness", t2, "statusBarIconBrightness", t3, "systemNavigationBarIconBrightness", t4 == null ? _null : t4._ui$_name], P.String, _null);
    },
    toString$0: function(_) {
      return P.MapBase_mapToString(this._toMap$0());
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.systemNavigationBarColor, _this.systemNavigationBarDividerColor, _this.statusBarColor, _this.statusBarBrightness, _this.statusBarIconBrightness, _this.systemNavigationBarIconBrightness, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isSystemUiOverlayStyle");
      if (J.$eq$(other.systemNavigationBarColor, _this.systemNavigationBarColor))
        t1 = other.statusBarIconBrightness == _this.statusBarIconBrightness && other.statusBarBrightness == _this.statusBarBrightness && other.systemNavigationBarIconBrightness == _this.systemNavigationBarIconBrightness;
      else
        t1 = false;
      return t1;
    }
  };
  V.SystemSoundType.prototype = {
    toString$0: function(_) {
      return this._system_sound$_name;
    }
  };
  X.TextRange.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!(other instanceof X.TextRange))
        return false;
      return other.start == this.start && other.end == this.end;
    },
    get$hashCode: function(_) {
      return P.hashValues(J.get$hashCode$(this.start), J.get$hashCode$(this.end), C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      return "TextRange(start: " + H.S(this.start) + ", end: " + H.S(this.end) + ")";
    }
  };
  X.TextSelection.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(baseOffset: " + H.S(this.baseOffset) + ", extentOffset: " + H.S(this.extentOffset) + ", affinity: " + C.TextAffinity_1.toString$0(0) + ", isDirectional: false)";
    },
    $eq: function(_, other) {
      var t1;
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!(other instanceof X.TextSelection))
        return false;
      if (other.baseOffset == this.baseOffset)
        if (other.extentOffset == this.extentOffset)
          t1 = true;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return P.hashValues(J.get$hashCode$(this.baseOffset), J.get$hashCode$(this.extentOffset), H.Primitives_objectHashCode(C.TextAffinity_1), C.JSBool_methods.get$hashCode(false), C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    }
  };
  X.AnnotatedRegion.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new E.RenderAnnotatedRegion(this.value, true, null, this.$ti);
      t1.get$isRepaintBoundary();
      t1._needsCompositing = true;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.assertSubtype(renderObject, "$isRenderAnnotatedRegion", this.$ti, "$asRenderAnnotatedRegion");
      renderObject.set$value(this.value);
      renderObject.set$sized(true);
    }
  };
  S.WidgetsApp.prototype = {
    createState$0: function() {
      return new S._WidgetsAppState(C._StateLifecycle_0);
    },
    onGenerateRoute$1: function(arg0) {
      return this.onGenerateRoute.call$1(arg0);
    },
    pageRouteBuilder$2: function(arg0, arg1) {
      return this.pageRouteBuilder.call$2(arg0, arg1);
    },
    onUnknownRoute$1: function(arg0) {
      return this.onUnknownRoute.call$1(arg0);
    },
    builder$2: function(arg0, arg1) {
      return this.builder.call$2(arg0, arg1);
    }
  };
  S._WidgetsAppState.prototype = {
    initState$0: function() {
      var _this = this;
      _this.super$State$initState();
      _this._app$_updateNavigator$0();
      $.WidgetsBinding__instance.toString;
      $.$get$window().toString;
      _this._app$_locale = _this._resolveLocales$2(null, _this._widget.supportedLocales);
      C.JSArray_methods.add$1($.WidgetsBinding__instance.WidgetsBinding__observers, _this);
    },
    didUpdateWidget$1: function(oldWidget) {
      H.interceptedTypeCheck(oldWidget, "$isWidgetsApp");
      this.super$State$didUpdateWidget(oldWidget);
      this._widget.navigatorKey;
      oldWidget.navigatorKey;
    },
    dispose$0: function() {
      C.JSArray_methods.remove$1($.WidgetsBinding__instance.WidgetsBinding__observers, this);
      this.super$State$dispose();
    },
    didChangeAppLifecycleState$1: function(state) {
    },
    didHaveMemoryPressure$0: function() {
    },
    _app$_updateNavigator$0: function() {
      this._widget.navigatorKey;
      this.set$_navigator(new N.GlobalObjectKey(this, [K.NavigatorState]));
    },
    _onGenerateRoute$1: function(settings) {
      var $name, t1, pageContentBuilder, route, _this = this;
      H.interceptedTypeCheck(settings, "$isRouteSettings");
      $name = settings.name;
      if ($name === "/") {
        _this._widget.home;
        t1 = true;
      } else
        t1 = false;
      pageContentBuilder = t1 ? new S._WidgetsAppState__onGenerateRoute_closure(_this) : _this._widget.routes.$index(0, $name);
      if (pageContentBuilder != null) {
        t1 = _this._widget;
        route = t1.pageRouteBuilder$2(settings, pageContentBuilder);
        if (H.assertTest(route != null))
          H.assertThrow("The pageRouteBuilder for WidgetsApp must return a valid non-null Route.");
        return route;
      }
      _this._widget.onGenerateRoute;
      return;
    },
    _onUnknownRoute$1: function(settings) {
      var result;
      H.interceptedTypeCheck(settings, "$isRouteSettings");
      H.assertHelper(new S._WidgetsAppState__onUnknownRoute_closure(this, settings).call$0());
      result = this._widget.onUnknownRoute$1(settings);
      H.assertHelper(new S._WidgetsAppState__onUnknownRoute_closure0(this, result, settings).call$0());
      return result;
    },
    didPopRoute$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this, t1, $navigator;
      var $async$didPopRoute$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              H.assertHelper($async$self._element != null);
              t1 = $async$self._navigator;
              $navigator = t1 == null ? null : t1.get$currentState();
              if ($navigator == null) {
                $async$returnValue = false;
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return P._asyncAwait($navigator.maybePop$1$0(P.Object), $async$didPopRoute$0);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$didPopRoute$0, $async$completer);
    },
    didPushRoute$1: function(route) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this, t1, $navigator;
      var $async$didPushRoute$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              H.assertHelper($async$self._element != null);
              t1 = $async$self._navigator;
              $navigator = t1 == null ? null : t1.get$currentState();
              if ($navigator == null) {
                $async$returnValue = false;
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = P.Object;
              $navigator.push$1$1($navigator._routeNamed$1$2$arguments(route, null, t1), t1);
              $async$returnValue = true;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$didPushRoute$1, $async$completer);
    },
    _resolveLocales$2: function(preferredLocales, supportedLocales) {
      var t1 = P.Locale;
      H.assertSubtype(preferredLocales, "$isList", [t1], "$asList");
      H.assertSubtype(supportedLocales, "$isIterable", [t1], "$asIterable");
      t1 = this._widget;
      t1.localeResolutionCallback;
      return S._WidgetsAppState_basicLocaleListResolution(preferredLocales, supportedLocales);
    },
    didChangeLocales$1: function(locales) {
      var _this = this,
        newLocale = _this._resolveLocales$2(locales, _this._widget.supportedLocales);
      if (!newLocale.$eq(0, _this._app$_locale))
        _this.setState$1(new S._WidgetsAppState_didChangeLocales_closure(_this, newLocale));
    },
    get$_app$_localizationsDelegates: function() {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var $async$goto = 0, $async$handler = 1, $async$currentError;
        return function $async$get$_app$_localizationsDelegates($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._IterationMarker_yieldStar($async$self._widget.localizationsDelegates);
              case 2:
                // after yield
                $async$goto = 3;
                return C.C__WidgetsLocalizationsDelegate;
              case 3:
                // after yield
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, [L.LocalizationsDelegate,,]);
    },
    didChangeAccessibilityFeatures$0: function() {
      this.setState$1(new S._WidgetsAppState_didChangeAccessibilityFeatures_closure());
    },
    didChangeMetrics$0: function() {
      this.setState$1(new S._WidgetsAppState_didChangeMetrics_closure());
    },
    didChangeTextScaleFactor$0: function() {
      this.setState$1(new S._WidgetsAppState_didChangeTextScaleFactor_closure());
    },
    didChangePlatformBrightness$0: function() {
      this.setState$1(new S._WidgetsAppState_didChangePlatformBrightness_closure());
    },
    _debugCheckLocalizations$1: function(appLocale) {
      H.assertHelper(new S._WidgetsAppState__debugCheckLocalizations_closure(this, appLocale).call$0());
      return true;
    },
    build$1: function(context) {
      var t2, t3, result, performanceOverlay, t4, title, appLocale, t5, t6, t7, t8, _this = this, _null = null, t1 = {};
      t1.navigator = null;
      t2 = _this._navigator;
      if (t2 != null) {
        $.WidgetsBinding__instance.toString;
        t3 = $.$get$window();
        t3.get$defaultRouteName();
        $.WidgetsBinding__instance.toString;
        t3 = t3.get$defaultRouteName();
        t1.navigator = new K.Navigator(t3, _this.get$_onGenerateRoute(), _this.get$_onUnknownRoute(), _this._widget.navigatorObservers, t2);
      }
      t1.result = null;
      t2 = _this._widget;
      t2.builder;
      result = T.Builder$(new S._WidgetsAppState_build_closure(t1, _this));
      t1.result = result;
      result = L.DefaultTextStyle$(result, _null, C.TextOverflow_0, true, t2.textStyle, _null);
      t1.result = result;
      t2.showPerformanceOverlay;
      t3 = $.WidgetsApp_showPerformanceOverlayOverride;
      if (t3) {
        t2.checkerboardOffscreenLayers;
        performanceOverlay = new L.PerformanceOverlay(15, false, false, _null);
      } else {
        t2.checkerboardOffscreenLayers;
        performanceOverlay = _null;
      }
      if (performanceOverlay != null)
        t1.result = T.Stack$(C.AlignmentDirectional_m1_m1, H.setRuntimeTypeInfo([result, T.Positioned$(_null, performanceOverlay, _null, _null, 0, 0, 0, _null)], [N.Widget]), C.StackFit_0);
      _this._widget.showSemanticsDebugger;
      H.assertHelper(new S._WidgetsAppState_build_closure0(t1, _this).call$0());
      t2 = _this._widget;
      t3 = t2.title;
      t4 = t2.color;
      title = U.Title$(t1.result, t4, t3);
      t2.locale;
      appLocale = _this._app$_locale;
      _this._debugCheckLocalizations$1(appLocale);
      $.WidgetsBinding__instance.toString;
      $.$get$window().toString;
      t1 = C.Size_0_0.$div(0, 1);
      t2 = V.EdgeInsets$fromWindowPadding(C.WindowPadding_0_0_0_0, 1);
      t3 = V.EdgeInsets$fromWindowPadding(C.WindowPadding_0_0_0_0, 1);
      t4 = _null.get$accessibleNavigation();
      t5 = _null.get$invertColors();
      t6 = _null.get$disableAnimations();
      t7 = _null.get$boldText();
      t8 = _this.get$_app$_localizationsDelegates();
      return F.MediaQuery$(L.Localizations$(title, P.List_List$from(t8, true, H.getTypeArgumentByIndex(t8, 0)), appLocale), new F.MediaQueryData(t1, 1, 1, C.Brightness_1, t3, t2, false, t4, t5, t6, t7), _null);
    },
    set$_navigator: function(_navigator) {
      this._navigator = H.assertSubtype(_navigator, "$isGlobalKey", [K.NavigatorState], "$asGlobalKey");
    },
    $isWidgetsBindingObserver: 1,
    $asState: function() {
      return [S.WidgetsApp];
    }
  };
  S._WidgetsAppState__onGenerateRoute_closure.prototype = {
    call$1: function(context) {
      H.interceptedTypeCheck(context, "$isBuildContext");
      return this.$this._widget.home;
    },
    $signature: 11
  };
  S._WidgetsAppState__onUnknownRoute_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._widget.onUnknownRoute;
      t1 = U.FlutterError$("Could not find a generator for route " + H.S(this.settings) + " in the " + H.getRuntimeType(t1).toString$0(0) + '.\nGenerators for routes are searched for in the following order:\n 1. For the "/" route, the "home" property, if non-null, is used.\n 2. Otherwise, the "routes" table is used, if it has an entry for the route.\n 3. Otherwise, onGenerateRoute is called. It should return a non-null value for any valid route not handled by "home" and "routes".\n 4. Finally if all else fails onUnknownRoute is called.\nUnfortunately, onUnknownRoute was not set.');
      throw H.wrapException(t1);
    },
    $signature: 0
  };
  S._WidgetsAppState__onUnknownRoute_closure0.prototype = {
    call$0: function() {
      if (this.result == null)
        throw H.wrapException(U.FlutterError$("The onUnknownRoute callback returned null.\nWhen the " + H.getRuntimeType(this.$this).toString$0(0) + " requested the route " + H.S(this.settings) + " from its onUnknownRoute callback, the callback returned null. Such callbacks must never return null."));
      return true;
    },
    $signature: 0
  };
  S._WidgetsAppState_didChangeLocales_closure.prototype = {
    call$0: function() {
      this.$this._app$_locale = this.newLocale;
    },
    $signature: 2
  };
  S._WidgetsAppState_didChangeAccessibilityFeatures_closure.prototype = {
    call$0: function() {
    },
    $signature: 2
  };
  S._WidgetsAppState_didChangeMetrics_closure.prototype = {
    call$0: function() {
    },
    $signature: 2
  };
  S._WidgetsAppState_didChangeTextScaleFactor_closure.prototype = {
    call$0: function() {
    },
    $signature: 2
  };
  S._WidgetsAppState_didChangePlatformBrightness_closure.prototype = {
    call$0: function() {
    },
    $signature: 2
  };
  S._WidgetsAppState__debugCheckLocalizations_closure.prototype = {
    call$0: function() {
      var unsupportedTypes, message,
        _s22_ = "CupertinoLocalizations",
        t1 = this.$this,
        t2 = t1.get$_app$_localizationsDelegates(),
        t3 = P.Type,
        t4 = H.getTypeArgumentByIndex(t2, 0);
      t3 = H.MappedIterable_MappedIterable(t2, H.functionTypeCheck(new S._WidgetsAppState__debugCheckLocalizations__closure(), {func: 1, ret: t3, args: [t4]}), t4, t3);
      unsupportedTypes = P.LinkedHashSet_LinkedHashSet$from(t3, H.getRuntimeTypeArgument(t3, "Iterable", 0));
      for (t1 = t1.get$_app$_localizationsDelegates(), t1 = new P._SyncStarIterator(t1._outerHelper(), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.appLocale; t1.moveNext$0();) {
        t3 = t1.get$current();
        t3.toString;
        t4 = H.getRuntimeTypeArgument(t3, "LocalizationsDelegate", 0);
        if (!unsupportedTypes.contains$1(0, new H.TypeImpl(t4)))
          continue;
        if (t3.isSupported$1(t2))
          unsupportedTypes.remove$1(0, new H.TypeImpl(t4));
      }
      if (unsupportedTypes._collection$_length === 0)
        return true;
      t1 = P.String;
      t3 = H.getTypeArgumentByIndex(unsupportedTypes, 0);
      if (S.listEquals(P.List_List$from(new H.EfficientLengthMappedIterable(unsupportedTypes, H.functionTypeCheck(new S._WidgetsAppState__debugCheckLocalizations__closure0(), {func: 1, ret: t1, args: [t3]}), [t3, t1]), true, t1), H.setRuntimeTypeInfo([_s22_], [t1]), t1))
        return true;
      message = new P.StringBuffer("");
      t1 = C.JSString_methods.$mul("\u2550", 8) + "\n";
      message._contents = t1;
      message._contents = t1 + ("Warning: This application's locale, " + H.S(t2) + ", is not supported by all of its\nlocalization delegates.\n");
      for (t1 = P._LinkedHashSetIterator$(unsupportedTypes, unsupportedTypes._collection$_modifications, H.getTypeArgumentByIndex(unsupportedTypes, 0)); t1.moveNext$0();) {
        t3 = t1._collection$_current;
        if (J.toString$0$(t3) === _s22_)
          continue;
        message._contents += "> A " + H.S(t3) + " delegate that supports the " + H.S(t2) + " locale was not found.\n";
      }
      t1 = message._contents += "See https://flutter.dev/tutorials/internationalization/ for more\ninformation about configuring an app's locale, supportedLocales,\nand localizationsDelegates parameters.\n";
      t1 = message._contents = t1 + (C.JSString_methods.$mul("\u2550", 8) + "\n");
      D.print__debugPrintThrottled$closure().call$1(t1.charCodeAt(0) == 0 ? t1 : t1);
      return true;
    },
    $signature: 0
  };
  S._WidgetsAppState__debugCheckLocalizations__closure.prototype = {
    call$1: function(delegate) {
      H.interceptedTypeCheck(delegate, "$isLocalizationsDelegate");
      delegate.toString;
      return new H.TypeImpl(H.getRuntimeTypeArgument(delegate, "LocalizationsDelegate", 0));
    },
    $signature: 118
  };
  S._WidgetsAppState__debugCheckLocalizations__closure0.prototype = {
    call$1: function(type) {
      return J.toString$0$(H.interceptedTypeCheck(type, "$isType"));
    },
    $signature: 119
  };
  S._WidgetsAppState_build_closure.prototype = {
    call$1: function(context) {
      H.interceptedTypeCheck(context, "$isBuildContext");
      return this.$this._widget.builder$2(context, this._box_0.navigator);
    },
    $signature: 11
  };
  S._WidgetsAppState_build_closure0.prototype = {
    call$0: function() {
      var t2,
        t1 = this.$this._widget;
      t1.toString;
      t2 = $.WidgetsApp_debugShowWidgetInspectorOverride;
      if (t2) {
        t2 = this._box_0;
        t2.result = new N.WidgetInspector(t2.result, t1.inspectorSelectButtonBuilder, null);
      }
      t1.debugShowCheckedModeBanner;
      t1 = $.WidgetsApp_debugAllowBannerOverride;
      if (t1) {
        t1 = this._box_0;
        t1.result = new A.CheckedModeBanner(t1.result, null);
      }
      return true;
    },
    $signature: 0
  };
  L.KeepAliveNotification.prototype = {};
  L.KeepAliveHandle.prototype = {};
  L.AutomaticKeepAliveClientMixin.prototype = {
    _ensureKeepAlive$0: function() {
      H.assertHelper(this.AutomaticKeepAliveClientMixin__keepAliveHandle == null);
      var t1 = {func: 1, ret: -1};
      this.AutomaticKeepAliveClientMixin__keepAliveHandle = new L.KeepAliveHandle(new R.ObserverList(H.setRuntimeTypeInfo([], [t1]), [t1]));
      t1 = this._element;
      if (t1 != null)
        t1.visitAncestorElements$1(new L.KeepAliveNotification().get$visitAncestor());
    },
    updateKeepAlive$0: function() {
      var t1, _this = this;
      if (_this.get$wantKeepAlive()) {
        if (_this.AutomaticKeepAliveClientMixin__keepAliveHandle == null)
          _this._ensureKeepAlive$0();
      } else {
        t1 = _this.AutomaticKeepAliveClientMixin__keepAliveHandle;
        if (t1 != null) {
          t1.notifyListeners$0();
          _this.AutomaticKeepAliveClientMixin__keepAliveHandle = null;
        }
      }
    },
    build$1: function(context) {
      if (this.get$wantKeepAlive() && this.AutomaticKeepAliveClientMixin__keepAliveHandle == null)
        this._ensureKeepAlive$0();
      return;
    }
  };
  A.BannerLocation.prototype = {
    toString$0: function(_) {
      return this._banner$_name;
    }
  };
  A.BannerPainter.prototype = {
    paint$2: function(canvas, size) {
      var t1, t2, t3, t4, _this = this, _null = null;
      if (!_this._prepared) {
        _this._paintShadow = C.BoxShadow_y5m.toPaint$0();
        t1 = new P.Paint(new DataView(new ArrayBuffer(75)));
        t1.set$color(_this.color);
        _this._paintBanner = t1;
        _this._textPainter = U.TextPainter$(_null, _null, _null, _null, Q.TextSpan$(_null, _this.textStyle, _this.message), C.TextAlign_2, _this.textDirection, 1);
        _this._prepared = true;
      }
      canvas.translate$2(_this._translationX$1(size._dx), _this._translationY$1(size._dy));
      canvas.rotate$1(_this.get$_rotation());
      t1 = $.$get$_kRect();
      canvas.drawRect$2(t1, _this._paintShadow);
      canvas.drawRect$2(t1, _this._paintBanner);
      _this._textPainter.layout$2$maxWidth$minWidth(80, 80);
      t2 = _this._textPainter;
      t3 = t1.left;
      t4 = t1.top;
      t1 = t1.bottom;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t4 !== "number")
        return H.iae(t4);
      C.JSNumber_methods.$sub(t1 - t4, t2.get$height());
      t2.paint$2(canvas, new P.Offset(t3, t4).$add(0, _null));
    },
    shouldRepaint$1: function(oldDelegate) {
      var _this = this;
      H.interceptedTypeCheck(oldDelegate, "$isBannerPainter");
      return _this.message !== oldDelegate.message || _this.location !== oldDelegate.location || !_this.color.$eq(0, oldDelegate.color) || !_this.textStyle.$eq(0, oldDelegate.textStyle);
    },
    hitTest$1: function(position) {
      return false;
    },
    _translationX$1: function(width) {
      var t1 = this.layoutDirection;
      H.assertHelper(t1 != null);
      switch (t1) {
        case C.TextDirection_0:
          switch (this.location) {
            case C.BannerLocation_3:
              return 48.484;
            case C.BannerLocation_1:
              return 0;
            case C.BannerLocation_2:
              if (typeof width !== "number")
                return width.$sub();
              return width - 48.484;
            case C.BannerLocation_0:
              return width;
          }
          break;
        case C.TextDirection_1:
          switch (this.location) {
            case C.BannerLocation_3:
              if (typeof width !== "number")
                return width.$sub();
              return width - 48.484;
            case C.BannerLocation_1:
              return width;
            case C.BannerLocation_2:
              return 48.484;
            case C.BannerLocation_0:
              return 0;
          }
          break;
      }
      return;
    },
    _translationY$1: function(height) {
      switch (this.location) {
        case C.BannerLocation_2:
        case C.BannerLocation_3:
          if (typeof height !== "number")
            return height.$sub();
          return height - 48.484;
        case C.BannerLocation_0:
        case C.BannerLocation_1:
          return 0;
      }
      return;
    },
    get$_rotation: function() {
      var t1 = this.layoutDirection;
      H.assertHelper(t1 != null);
      switch (t1) {
        case C.TextDirection_0:
          switch (this.location) {
            case C.BannerLocation_2:
            case C.BannerLocation_1:
              return -0.7853981633974483;
            case C.BannerLocation_3:
            case C.BannerLocation_0:
              return 0.7853981633974483;
          }
          break;
        case C.TextDirection_1:
          switch (this.location) {
            case C.BannerLocation_2:
            case C.BannerLocation_1:
              return 0.7853981633974483;
            case C.BannerLocation_3:
            case C.BannerLocation_0:
              return -0.7853981633974483;
          }
          break;
      }
      return;
    }
  };
  A.Banner.prototype = {
    build$1: function(context) {
      var t1, _this = this;
      E.debugCheckHasDirectionality(context);
      t1 = T.Directionality_of(context);
      return T.CustomPaint$(_this.child, new A.BannerPainter(_this.message, _this.textDirection, _this.location, t1, C.Color_2696354844, C.TextStyle_K13), null);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      t1 = Y.StringProperty$("message", _this.message, C.C__NoDefaultValue, true, false);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      t1 = [P.TextDirection];
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, _this.textDirection, _null, C.DiagnosticLevel_3, "textDirection", true, true, C.DiagnosticsTreeStyle_5, t1));
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, _this.location, C.C__NoDefaultValue, C.DiagnosticLevel_3, "location", true, true, C.DiagnosticsTreeStyle_5, [A.BannerLocation]));
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, _null, _null, C.DiagnosticLevel_3, "layoutDirection", true, true, C.DiagnosticsTreeStyle_5, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("color", C.Color_2696354844, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_5, _null, P.Color));
      C.TextStyle_K13.debugFillProperties$2$prefix(properties, "text ");
    }
  };
  A.CheckedModeBanner.prototype = {
    build$1: function(context) {
      var t1 = {};
      t1.result = this.child;
      H.assertHelper(new A.CheckedModeBanner_build_closure(t1).call$0());
      return t1.result;
    },
    debugFillProperties$1: function(properties) {
      var t1 = {};
      this.super$Widget$debugFillProperties(properties);
      t1.message = "disabled";
      H.assertHelper(new A.CheckedModeBanner_debugFillProperties_closure(t1).call$0());
      t1 = Y.DiagnosticsNode_DiagnosticsNode$message(t1.message, C.DiagnosticsTreeStyle_5);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  A.CheckedModeBanner_build_closure.prototype = {
    call$0: function() {
      var t1 = this._box_0;
      t1.result = new A.Banner(t1.result, "DEBUG", C.TextDirection_1, C.BannerLocation_1, null);
      return true;
    },
    $signature: 0
  };
  A.CheckedModeBanner_debugFillProperties_closure.prototype = {
    call$0: function() {
      this._box_0.message = '"DEBUG"';
      return true;
    },
    $signature: 0
  };
  T.Directionality.prototype = {
    updateShouldNotify$1: function(oldWidget) {
      return this.textDirection !== H.interceptedTypeCheck(oldWidget, "$isDirectionality").textDirection;
    },
    debugFillProperties$1: function(properties) {
      var _null = null;
      this.super$Widget$debugFillProperties(properties);
      C.JSArray_methods.add$1(properties.properties, new Y.EnumProperty(_null, _null, _null, _null, false, this.textDirection, C.C__NoDefaultValue, C.DiagnosticLevel_3, "textDirection", true, true, C.DiagnosticsTreeStyle_5, [P.TextDirection]));
    }
  };
  T.Opacity.prototype = {
    createRenderObject$1: function(context) {
      var t2,
        t1 = this.opacity;
      if (typeof t1 !== "number")
        return t1.$mul();
      t1 = new E.RenderOpacity(C.JSNumber_methods.round$0(t1 * 255), t1, false, null);
      t1.get$isRepaintBoundary();
      t2 = t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = t2;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderOpacity");
      renderObject.set$opacity(this.opacity);
      renderObject.set$alwaysIncludeSemantics(false);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null,
        _s22_ = "alwaysIncludeSemantics";
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DoubleProperty$("opacity", this.opacity, C.C__NoDefaultValue, _null, C.DiagnosticLevel_3, true, _null, _null);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.FlagProperty$(_s22_, _null, _null, _s22_, C.DiagnosticLevel_3, false, false));
    }
  };
  T.CustomPaint.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new V.RenderCustomPaint(this.painter, this.foregroundPainter, C.Size_0_0, false, false, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderCustomPaint");
      renderObject.set$painter(this.painter);
      renderObject.set$foregroundPainter(this.foregroundPainter);
      renderObject.set$preferredSize(C.Size_0_0);
      renderObject.willChange = renderObject.isComplex = false;
    },
    didUnmountRenderObject$1: function(renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderCustomPaint");
      renderObject.set$painter(null);
      renderObject.set$foregroundPainter(null);
    }
  };
  T.ClipRect.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new E.RenderClipRect(null, C.Clip_1, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderClipRect").set$clipper(null);
    },
    didUnmountRenderObject$1: function(renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderClipRect").set$clipper(null);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("clipper", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, [E.CustomClipper, P.Rect]);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  T.ClipPath.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new E.RenderClipPath(this.clipper, this.clipBehavior, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderClipPath").set$clipper(this.clipper);
    },
    didUnmountRenderObject$1: function(renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderClipPath").set$clipper(null);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("clipper", this.clipper, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, [E.CustomClipper, P.Path]);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  T.PhysicalModel.prototype = {
    createRenderObject$1: function(context) {
      var _this = this,
        t1 = new E.RenderPhysicalModel(_this.shape, _this.borderRadius, _this.elevation, _this.shadowColor, _this.color, null, _this.clipBehavior, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = true;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      var _this = this;
      H.interceptedTypeCheck(renderObject, "$isRenderPhysicalModel");
      renderObject.set$shape(_this.shape);
      renderObject.set$borderRadius(_this.borderRadius);
      renderObject.set$elevation(_this.elevation);
      renderObject.set$color(_this.color);
      renderObject.set$shadowColor(_this.shadowColor);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      t1 = properties.properties;
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.shape, C.C__NoDefaultValue, C.DiagnosticLevel_3, "shape", true, true, C.DiagnosticsTreeStyle_5, [F.BoxShape]));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("borderRadius", _this.borderRadius, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.BorderRadius));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("elevation", _this.elevation, C.C__NoDefaultValue, _null, C.DiagnosticLevel_3, true, _null, _null));
      t2 = P.Color;
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("color", _this.color, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t2));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("shadowColor", _this.shadowColor, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t2));
    }
  };
  T.PhysicalShape.prototype = {
    createRenderObject$1: function(context) {
      var _this = this,
        t1 = new E.RenderPhysicalShape(_this.elevation, _this.shadowColor, _this.color, _this.clipper, _this.clipBehavior, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = true;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      var _this = this;
      H.interceptedTypeCheck(renderObject, "$isRenderPhysicalShape");
      renderObject.set$clipper(_this.clipper);
      renderObject.set$elevation(_this.elevation);
      renderObject.set$color(_this.color);
      renderObject.set$shadowColor(_this.shadowColor);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("clipper", _this.clipper, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, [E.CustomClipper, P.Path]);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("elevation", _this.elevation, C.C__NoDefaultValue, _null, C.DiagnosticLevel_3, true, _null, _null));
      t1 = P.Color;
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("color", _this.color, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("shadowColor", _this.shadowColor, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
    }
  };
  T.Transform.prototype = {
    createRenderObject$1: function(context) {
      var t1 = T.Directionality_of(context),
        t2 = new E.RenderTransform(this.transformHitTests, null);
      t2.get$isRepaintBoundary();
      t2.get$alwaysNeedsCompositing();
      t2._needsCompositing = false;
      t2.set$child(null);
      t2.set$transform(this.transform);
      t2.set$alignment(this.alignment);
      t2.set$textDirection(t1);
      t2.set$origin(null);
      return t2;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderTransform");
      renderObject.set$transform(this.transform);
      renderObject.set$origin(null);
      renderObject.set$alignment(this.alignment);
      renderObject.set$textDirection(T.Directionality_of(context));
      renderObject.transformHitTests = this.transformHitTests;
    }
  };
  T.FractionalTranslation.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new E.RenderFractionalTranslation(this.translation, this.transformHitTests, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderFractionalTranslation");
      renderObject.set$translation(this.translation);
      renderObject.transformHitTests = this.transformHitTests;
    }
  };
  T.Padding.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new T.RenderPadding(this.padding, T.Directionality_of(context), null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderPadding");
      renderObject.set$padding(this.padding);
      renderObject.set$textDirection(T.Directionality_of(context));
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("padding", this.padding, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, V.EdgeInsetsGeometry);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  T.Align.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new T.RenderPositionedBox(this.widthFactor, this.heightFactor, this.alignment, T.Directionality_of(context), null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderPositionedBox");
      renderObject.set$alignment(this.alignment);
      renderObject.set$widthFactor(this.widthFactor);
      renderObject.set$heightFactor(this.heightFactor);
      renderObject.set$textDirection(T.Directionality_of(context));
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("alignment", _this.alignment, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.AlignmentGeometry);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("widthFactor", _this.widthFactor, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("heightFactor", _this.heightFactor, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
    }
  };
  T.Center.prototype = {};
  T.CustomSingleChildLayout.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new T.RenderCustomSingleChildLayoutBox(this.delegate, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderCustomSingleChildLayoutBox").set$delegate(this.delegate);
    }
  };
  T.LayoutId.prototype = {
    applyParentData$1: function(renderObject) {
      var parentData, t1, targetParent;
      H.assertHelper(renderObject.parentData instanceof B.MultiChildLayoutParentData);
      parentData = H.interceptedTypeCheck(renderObject.parentData, "$isMultiChildLayoutParentData");
      t1 = this.id;
      if (parentData.id !== t1) {
        parentData.id = t1;
        targetParent = renderObject._node$_parent;
        if (targetParent instanceof K.RenderObject)
          targetParent.markNeedsLayout$0();
      }
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("id", this.id, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Object);
      C.JSArray_methods.add$1(properties.properties, t1);
    },
    $asParentDataWidget: function() {
      return [T.CustomMultiChildLayout];
    }
  };
  T.CustomMultiChildLayout.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new B.RenderCustomMultiChildLayoutBox(this.delegate, 0, null, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.addAll$1(0, null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderCustomMultiChildLayoutBox").set$delegate(this.delegate);
    }
  };
  T.SizedBox.prototype = {
    createRenderObject$1: function(context) {
      return E.RenderConstrainedBox$(S.BoxConstraints$tightFor(this.height, this.width));
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderConstrainedBox").set$additionalConstraints(S.BoxConstraints$tightFor(this.height, this.width));
    },
    toStringShort$0: function() {
      var type, _this = this,
        t1 = _this.width;
      if (t1 === 1 / 0 && _this.height === 1 / 0)
        type = new H.TypeImpl(H.getRti(_this)).toString$0(0) + ".expand";
      else
        type = t1 === 0 && _this.height === 0 ? new H.TypeImpl(H.getRti(_this)).toString$0(0) + ".shrink" : new H.TypeImpl(H.getRti(_this)).toString$0(0);
      t1 = _this.key;
      return t1 == null ? type : type + "-" + t1.toString$0(0);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, level, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      t1 = _this.width;
      if (!(t1 === 1 / 0 && _this.height === 1 / 0))
        t2 = t1 === 0 && _this.height === 0;
      else
        t2 = true;
      level = t2 ? C.DiagnosticLevel_0 : C.DiagnosticLevel_3;
      t1 = Y.DoubleProperty$("width", t1, _null, _null, level, true, _null, _null);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("height", _this.height, _null, _null, level, true, _null, _null));
    }
  };
  T.ConstrainedBox.prototype = {
    createRenderObject$1: function(context) {
      return E.RenderConstrainedBox$(this.constraints);
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderConstrainedBox").set$additionalConstraints(this.constraints);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("constraints", this.constraints, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_5, _null, S.BoxConstraints);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  T.LimitedBox.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new E.RenderLimitedBox(this.maxWidth, this.maxHeight, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderLimitedBox");
      renderObject.set$maxWidth(this.maxWidth);
      renderObject.set$maxHeight(this.maxHeight);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DoubleProperty$("maxWidth", this.maxWidth, 1 / 0, _null, C.DiagnosticLevel_3, true, _null, _null);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("maxHeight", this.maxHeight, 1 / 0, _null, C.DiagnosticLevel_3, true, _null, _null));
    }
  };
  T.Offstage.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new E.RenderOffstage(this.offstage, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderOffstage").set$offstage(this.offstage);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("offstage", this.offstage, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.bool);
      C.JSArray_methods.add$1(properties.properties, t1);
    },
    createElement$0: function() {
      var t1 = ($.Element__nextHashCode + 1) % 16777215;
      $.Element__nextHashCode = t1;
      return new T._OffstageElement(t1, this, C._ElementLifecycle_0);
    }
  };
  T._OffstageElement.prototype = {
    get$widget: function() {
      return H.interceptedTypeCheck(N.SingleChildRenderObjectElement.prototype.get$widget.call(this), "$isOffstage");
    }
  };
  T.Stack.prototype = {
    createRenderObject$1: function(context) {
      var t1 = T.Directionality_of(context);
      t1 = new K.RenderStack(this.alignment, t1, this.fit, C.Overflow_1, 0, null, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.addAll$1(0, null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      var t1;
      H.interceptedTypeCheck(renderObject, "$isRenderStack");
      renderObject.set$alignment(this.alignment);
      t1 = T.Directionality_of(context);
      renderObject.set$textDirection(t1);
      t1 = this.fit;
      if (renderObject._fit !== t1) {
        renderObject._fit = t1;
        renderObject.markNeedsLayout$0();
      }
      if (renderObject._overflow !== C.Overflow_1) {
        renderObject._overflow = C.Overflow_1;
        renderObject.markNeedsPaint$0();
      }
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("alignment", this.alignment, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.AlignmentGeometry);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, _null, _null, C.DiagnosticLevel_3, "textDirection", true, true, C.DiagnosticsTreeStyle_5, [P.TextDirection]));
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, this.fit, C.C__NoDefaultValue, C.DiagnosticLevel_3, "fit", true, true, C.DiagnosticsTreeStyle_5, [K.StackFit]));
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, C.Overflow_1, C.C__NoDefaultValue, C.DiagnosticLevel_3, "overflow", true, true, C.DiagnosticsTreeStyle_5, [K.Overflow]));
    }
  };
  T.Positioned.prototype = {
    applyParentData$1: function(renderObject) {
      var parentData, t1, needsLayout, targetParent, _this = this;
      H.assertHelper(renderObject.parentData instanceof K.StackParentData);
      parentData = H.interceptedTypeCheck(renderObject.parentData, "$isStackParentData");
      t1 = _this.left;
      if (parentData.left != t1) {
        parentData.left = t1;
        needsLayout = true;
      } else
        needsLayout = false;
      t1 = _this.top;
      if (parentData.top != t1) {
        parentData.top = t1;
        needsLayout = true;
      }
      t1 = _this.right;
      if (parentData.right != t1) {
        parentData.right = t1;
        needsLayout = true;
      }
      t1 = _this.bottom;
      if (parentData.bottom != t1) {
        parentData.bottom = t1;
        needsLayout = true;
      }
      t1 = _this.width;
      if (parentData.width != t1) {
        parentData.width = t1;
        needsLayout = true;
      }
      parentData.height;
      if (needsLayout) {
        targetParent = renderObject._node$_parent;
        if (targetParent instanceof K.RenderObject)
          targetParent.markNeedsLayout$0();
      }
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      t1 = Y.DoubleProperty$("left", _this.left, _null, _null, C.DiagnosticLevel_3, true, _null, _null);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("top", _this.top, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("right", _this.right, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("bottom", _this.bottom, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("width", _this.width, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("height", _this.height, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
    },
    $asParentDataWidget: function() {
      return [T.Stack];
    }
  };
  T.PositionedDirectional.prototype = {
    build$1: function(context) {
      var left, _this = this, _null = null,
        textDirection = T.Directionality_of(context),
        right = _this.start;
      H.assertHelper(textDirection != null);
      switch (textDirection) {
        case C.TextDirection_0:
          left = _null;
          break;
        case C.TextDirection_1:
          left = right;
          right = _null;
          break;
        default:
          right = _null;
          left = right;
      }
      return T.Positioned$(_this.bottom, _this.child, _null, _null, left, right, _this.top, _this.width);
    }
  };
  T.Flex.prototype = {
    get$_needTextDirection: function() {
      switch (this.direction) {
        case C.Axis_0:
          return true;
        case C.Axis_1:
          var t1 = this.crossAxisAlignment;
          return t1 === C.CrossAxisAlignment_0 || t1 === C.CrossAxisAlignment_1;
      }
      return;
    },
    getEffectiveTextDirection$1: function(context) {
      var t1 = H.boolConversionCheck(this.get$_needTextDirection()) ? T.Directionality_of(context) : null;
      return t1;
    },
    createRenderObject$1: function(context) {
      var _this = this, _null = null,
        t1 = new F.RenderFlex(_this.direction, _this.mainAxisAlignment, _this.mainAxisSize, _this.crossAxisAlignment, _this.getEffectiveTextDirection$1(context), _this.verticalDirection, _this.textBaseline, P.List_List$filled(4, U.TextPainter$(_null, _null, _null, _null, _null, C.TextAlign_4, C.TextDirection_1, 1), U.TextPainter), true, 0, _null, _null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.addAll$1(0, _null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      var t1, _this = this;
      H.interceptedTypeCheck(renderObject, "$isRenderFlex");
      t1 = _this.direction;
      if (renderObject._flex$_direction !== t1) {
        renderObject._flex$_direction = t1;
        renderObject.markNeedsLayout$0();
      }
      t1 = _this.mainAxisAlignment;
      if (renderObject._mainAxisAlignment !== t1) {
        renderObject._mainAxisAlignment = t1;
        renderObject.markNeedsLayout$0();
      }
      t1 = _this.mainAxisSize;
      if (renderObject._mainAxisSize !== t1) {
        renderObject._mainAxisSize = t1;
        renderObject.markNeedsLayout$0();
      }
      t1 = _this.crossAxisAlignment;
      if (renderObject._crossAxisAlignment !== t1) {
        renderObject._crossAxisAlignment = t1;
        renderObject.markNeedsLayout$0();
      }
      t1 = _this.getEffectiveTextDirection$1(context);
      if (renderObject._flex$_textDirection != t1) {
        renderObject._flex$_textDirection = t1;
        renderObject.markNeedsLayout$0();
      }
      t1 = _this.verticalDirection;
      if (renderObject._verticalDirection !== t1) {
        renderObject._verticalDirection = t1;
        renderObject.markNeedsLayout$0();
      }
      H.assertHelper(renderObject._crossAxisAlignment !== C.CrossAxisAlignment_4 || false);
      renderObject._textBaseline;
    },
    debugFillProperties$1: function(properties) {
      var t1, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      t1 = properties.properties;
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.direction, C.C__NoDefaultValue, C.DiagnosticLevel_3, "direction", true, true, C.DiagnosticsTreeStyle_5, [G.Axis]));
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.mainAxisAlignment, C.C__NoDefaultValue, C.DiagnosticLevel_3, "mainAxisAlignment", true, true, C.DiagnosticsTreeStyle_5, [F.MainAxisAlignment]));
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.mainAxisSize, C.MainAxisSize_1, C.DiagnosticLevel_3, "mainAxisSize", true, true, C.DiagnosticsTreeStyle_5, [F.MainAxisSize]));
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.crossAxisAlignment, C.C__NoDefaultValue, C.DiagnosticLevel_3, "crossAxisAlignment", true, true, C.DiagnosticsTreeStyle_5, [F.CrossAxisAlignment]));
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.textDirection, _null, C.DiagnosticLevel_3, "textDirection", true, true, C.DiagnosticsTreeStyle_5, [P.TextDirection]));
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.verticalDirection, C.VerticalDirection_1, C.DiagnosticLevel_3, "verticalDirection", true, true, C.DiagnosticsTreeStyle_5, [G.VerticalDirection]));
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.textBaseline, _null, C.DiagnosticLevel_3, "textBaseline", true, true, C.DiagnosticsTreeStyle_5, [P.TextBaseline]));
    }
  };
  T.Column.prototype = {};
  T.RichText.prototype = {
    createRenderObject$1: function(context) {
      var t3, t4, t5, t6, _this = this,
        t1 = _this.textDirection,
        t2 = t1 == null;
      if (t2)
        E.debugCheckHasDirectionality(context);
      if (t2)
        t1 = T.Directionality_of(context);
      t2 = _this.overflow;
      t3 = L.Localizations_localeOf(context, true);
      t4 = H.setRuntimeTypeInfo([], [P.int]);
      t5 = H.setRuntimeTypeInfo([], [S.GestureRecognizer]);
      t6 = t2 === C.TextOverflow_2 ? "\u2026" : null;
      t5 = new Q.RenderParagraph(U.TextPainter$(t6, t3, _this.maxLines, _this.strutStyle, _this.text, _this.textAlign, t1, _this.textScaleFactor), _this.softWrap, t2, t4, t5);
      t5.get$isRepaintBoundary();
      t5.get$alwaysNeedsCompositing();
      t5._needsCompositing = false;
      return t5;
    },
    updateRenderObject$2: function(context, renderObject) {
      var t1, t2, _this = this;
      H.interceptedTypeCheck(renderObject, "$isRenderParagraph");
      t1 = _this.textDirection;
      t2 = t1 == null;
      if (t2)
        E.debugCheckHasDirectionality(context);
      renderObject.set$text(_this.text);
      renderObject.set$textAlign(_this.textAlign);
      renderObject.set$textDirection(t2 ? T.Directionality_of(context) : t1);
      renderObject.set$softWrap(_this.softWrap);
      renderObject.set$overflow(_this.overflow);
      renderObject.set$textScaleFactor(_this.textScaleFactor);
      renderObject.set$maxLines(_this.maxLines);
      renderObject.set$strutStyle(_this.strutStyle);
      t1 = L.Localizations_localeOf(context, true);
      renderObject.set$locale(t1);
    },
    debugFillProperties$1: function(properties) {
      var t1, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      t1 = properties.properties;
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.textAlign, C.TextAlign_4, C.DiagnosticLevel_3, "textAlign", true, true, C.DiagnosticsTreeStyle_5, [P.TextAlign]));
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.textDirection, _null, C.DiagnosticLevel_3, "textDirection", true, true, C.DiagnosticsTreeStyle_5, [P.TextDirection]));
      C.JSArray_methods.add$1(t1, Y.FlagProperty$("softWrap", _null, "no wrapping except at line break characters", "wrapping at box width", C.DiagnosticLevel_3, true, _this.softWrap));
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.overflow, C.TextOverflow_0, C.DiagnosticLevel_3, "overflow", true, true, C.DiagnosticsTreeStyle_5, [Q.TextOverflow]));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("textScaleFactor", _this.textScaleFactor, 1, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t1, Y.IntProperty$("maxLines", _this.maxLines, C.C__NoDefaultValue, "unlimited", C.DiagnosticLevel_3, _null));
      C.JSArray_methods.add$1(t1, Y.StringProperty$("text", _this.text.toPlainText$0(), C.C__NoDefaultValue, true, true));
    }
  };
  T.DefaultAssetBundle.prototype = {};
  T.Listener.prototype = {
    createRenderObject$1: function(context) {
      var _this = this, _null = null,
        t1 = new E.RenderPointerListener(_this.onPointerDown, _null, _null, _null, _null, _this.onPointerUp, _this.onPointerCancel, _null, _this.behavior, _null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(_null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      var _this = this;
      H.interceptedTypeCheck(renderObject, "$isRenderPointerListener");
      renderObject.set$onPointerDown(_this.onPointerDown);
      renderObject.set$onPointerMove(null);
      renderObject.set$onPointerUp(_this.onPointerUp);
      renderObject.set$onPointerCancel(_this.onPointerCancel);
      renderObject.set$onPointerSignal(null);
      renderObject.behavior = _this.behavior;
    },
    debugFillProperties$1: function(properties) {
      var t1, listeners, t2, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      t1 = P.String;
      listeners = H.setRuntimeTypeInfo([], [t1]);
      C.JSArray_methods.add$1(listeners, "down");
      if (_this.onPointerUp != null)
        C.JSArray_methods.add$1(listeners, "up");
      if (_this.onPointerCancel != null)
        C.JSArray_methods.add$1(listeners, "cancel");
      t1 = Y.IterableProperty$("listeners", listeners, C.C__NoDefaultValue, "<none>", C.DiagnosticLevel_3, C.DiagnosticsTreeStyle_5, t1);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, _this.behavior, C.C__NoDefaultValue, C.DiagnosticLevel_3, "behavior", true, true, C.DiagnosticsTreeStyle_5, [E.HitTestBehavior]));
    }
  };
  T.RepaintBoundary.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new E.RenderRepaintBoundary(null);
      t1.get$isRepaintBoundary();
      t1._needsCompositing = true;
      t1.set$child(null);
      return t1;
    }
  };
  T.IgnorePointer.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new E.RenderIgnorePointer(this.ignoring, this.ignoringSemantics, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderIgnorePointer");
      renderObject.set$ignoring(this.ignoring);
      renderObject.set$ignoringSemantics(this.ignoringSemantics);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = P.bool;
      t2 = Y.DiagnosticsProperty$("ignoring", this.ignoring, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t2);
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("ignoringSemantics", this.ignoringSemantics, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
    }
  };
  T.AbsorbPointer.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new E.RenderAbsorbPointer(false, null, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderAbsorbPointer");
      renderObject.set$absorbing(false);
      renderObject.set$ignoringSemantics(null);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = P.bool;
      t2 = Y.DiagnosticsProperty$("absorbing", false, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1);
      t3 = properties.properties;
      C.JSArray_methods.add$1(t3, t2);
      C.JSArray_methods.add$1(t3, Y.DiagnosticsProperty$("ignoringSemantics", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
    }
  };
  T.Semantics.prototype = {
    createRenderObject$1: function(context) {
      var _this = this, _null = null,
        t1 = _this.properties;
      t1 = new E.RenderSemanticsAnnotations(_this.container, _this.explicitChildNodes, false, t1.checked, t1.enabled, t1.selected, t1.button, t1.header, t1.textField, t1.focused, t1.inMutuallyExclusiveGroup, t1.obscured, t1.scopesRoute, t1.namesRoute, t1.hidden, t1.image, t1.liveRegion, t1.toggled, t1.label, t1.value, t1.increasedValue, t1.decreasedValue, t1.hint, t1.hintOverrides, _this._getTextDirection$1(context), t1.sortKey, t1.onTap, t1.onDismiss, t1.onLongPress, t1.onScrollLeft, t1.onScrollRight, t1.onScrollUp, t1.onScrollDown, t1.onIncrease, t1.onDecrease, t1.onCopy, t1.onCut, t1.onPaste, t1.onMoveCursorForwardByCharacter, t1.onMoveCursorBackwardByCharacter, _null, _null, t1.onSetSelection, t1.onDidGainAccessibilityFocus, t1.onDidLoseAccessibilityFocus, t1.customSemanticsActions, _null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(_null);
      return t1;
    },
    _getTextDirection$1: function(context) {
      var containsText,
        t1 = this.properties,
        t2 = t1.textDirection;
      if (t2 != null)
        return t2;
      if (t1.label == null)
        containsText = false;
      else
        containsText = true;
      if (!containsText)
        return;
      return T.Directionality_of(context);
    },
    updateRenderObject$2: function(context, renderObject) {
      var t1, t2, _this = this;
      H.interceptedTypeCheck(renderObject, "$isRenderSemanticsAnnotations");
      renderObject.set$container(_this.container);
      renderObject.set$explicitChildNodes(_this.explicitChildNodes);
      renderObject.set$excludeSemantics(false);
      t1 = _this.properties;
      renderObject.set$scopesRoute(t1.scopesRoute);
      renderObject.set$enabled(t1.enabled);
      renderObject.set$checked(t1.checked);
      renderObject.set$toggled(t1.toggled);
      renderObject.set$selected(t1.selected);
      renderObject.set$button(t1.button);
      renderObject.set$header(t1.header);
      renderObject.set$textField(t1.textField);
      renderObject.set$focused(t1.focused);
      renderObject.set$inMutuallyExclusiveGroup(t1.inMutuallyExclusiveGroup);
      renderObject.set$obscured(t1.obscured);
      renderObject.set$hidden(t1.hidden);
      renderObject.set$image(t1.image);
      renderObject.set$liveRegion(t1.liveRegion);
      renderObject.set$label(t1.label);
      renderObject.set$value(t1.value);
      renderObject.set$increasedValue(t1.increasedValue);
      renderObject.set$decreasedValue(t1.decreasedValue);
      renderObject.set$hint(t1.hint);
      renderObject.set$hintOverrides(t1.hintOverrides);
      renderObject.set$namesRoute(t1.namesRoute);
      renderObject.set$textDirection(_this._getTextDirection$1(context));
      renderObject.set$sortKey(t1.sortKey);
      renderObject.set$onTap(t1.onTap);
      renderObject.set$onLongPress(t1.onLongPress);
      renderObject.set$onScrollLeft(t1.onScrollLeft);
      renderObject.set$onScrollRight(t1.onScrollRight);
      renderObject.set$onScrollUp(t1.onScrollUp);
      renderObject.set$onScrollDown(t1.onScrollDown);
      renderObject.set$onIncrease(t1.onIncrease);
      renderObject.set$onDismiss(t1.onDismiss);
      renderObject.set$onDecrease(t1.onDecrease);
      renderObject.set$onCopy(t1.onCopy);
      renderObject.set$onCut(t1.onCut);
      renderObject.set$onPaste(t1.onPaste);
      t2 = t1.onMoveCursorForwardByCharacter;
      renderObject.set$onMoveCursorForwardByCharacter(t2);
      renderObject.set$onMoveCursorBackwardByCharacter(t2);
      renderObject.set$onMoveCursorForwardByWord(null);
      renderObject.set$onMoveCursorBackwardByWord(null);
      renderObject.set$onSetSelection(t1.onSetSelection);
      renderObject.set$onDidGainAccessibilityFocus(t1.onDidGainAccessibilityFocus);
      renderObject.set$onDidLoseAccessibilityFocus(t1.onDidLoseAccessibilityFocus);
      renderObject.set$customSemanticsActions(t1.customSemanticsActions);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("container", this.container, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.bool);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      t1 = this.properties;
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("properties", t1, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, A.SemanticsProperties));
      t1.debugFillProperties$1(properties);
    }
  };
  T.MergeSemantics.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new E.RenderMergeSemantics(null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    }
  };
  T.BlockSemantics.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new E.RenderBlockSemantics(true, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderBlockSemantics").set$blocking(true);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("blocking", true, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.bool);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  T.ExcludeSemantics.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new E.RenderExcludeSemantics(this.excluding, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderExcludeSemantics").set$excluding(this.excluding);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("excluding", this.excluding, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.bool);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  T.KeyedSubtree.prototype = {
    build$1: function(context) {
      return this.child;
    }
  };
  T.Builder.prototype = {
    build$1: function(context) {
      return this.builder.call$1(context);
    }
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1.registerBoolServiceExtension$3$getter$name$setter(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure(), "debugPaint", new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure0(t1));
      t1.registerBoolServiceExtension$3$getter$name$setter(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure1(), "debugPaintBaselinesEnabled", new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure2(t1));
      t1.registerBoolServiceExtension$3$getter$name$setter(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure3(), "repaintRainbow", new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure4(t1));
      t1.registerBoolServiceExtension$3$getter$name$setter(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure5(), "debugCheckElevationsEnabled", new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure6(t1));
      t1.registerSignalServiceExtension$2$callback$name(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure7(), "debugDumpLayerTree");
      return true;
    },
    $signature: 0
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $.debugPaintSizeEnabled;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 4
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure0.prototype = {
    call$1: function(value) {
      var t1;
      if ($.debugPaintSizeEnabled === value) {
        t1 = new P._Future($.Zone__current, [-1]);
        t1._asyncComplete$1(null);
        return t1;
      }
      $.debugPaintSizeEnabled = value;
      return this.$this._forceRepaint$0();
    },
    $signature: 7
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure1.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $.debugPaintBaselinesEnabled;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 4
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure2.prototype = {
    call$1: function(value) {
      var t1;
      if ($.debugPaintBaselinesEnabled === value) {
        t1 = new P._Future($.Zone__current, [-1]);
        t1._asyncComplete$1(null);
        return t1;
      }
      $.debugPaintBaselinesEnabled = value;
      return this.$this._forceRepaint$0();
    },
    $signature: 7
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure3.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $.debugRepaintRainbowEnabled;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 4
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure4.prototype = {
    call$1: function(value) {
      var t1,
        repaint = $.debugRepaintRainbowEnabled && !value;
      $.debugRepaintRainbowEnabled = value;
      if (repaint)
        return this.$this._forceRepaint$0();
      t1 = new P._Future($.Zone__current, [-1]);
      t1._asyncComplete$1(null);
      return t1;
    },
    $signature: 7
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure5.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $.debugCheckElevationsEnabled;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 4
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure6.prototype = {
    call$1: function(value) {
      var t1;
      if ($.debugCheckElevationsEnabled === value) {
        t1 = new P._Future($.Zone__current, [-1]);
        t1._asyncComplete$1(null);
        return t1;
      }
      $.debugCheckElevationsEnabled = value;
      return this.$this._forceRepaint$0();
    },
    $signature: 7
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure7.prototype = {
    call$0: function() {
      var _null = null,
        t1 = $.RendererBinding__instance;
      t1 = t1 == null ? _null : t1.RendererBinding__pipelineOwner._rootNode;
      t1 = t1 == null ? _null : t1.get$debugLayer();
      t1 = t1 == null ? _null : t1.toDiagnosticsNode$0().toStringDeep$3$minLevel$prefixLineOne$prefixOtherLines(C.DiagnosticLevel_2, "", _null);
      D.print__debugPrintThrottled$closure().call$1(t1 == null ? "Layer tree unavailable." : t1);
      return D.debugPrintDone();
    },
    $signature: 6
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure0.prototype = {
    call$0: function() {
      var t1 = $.RendererBinding__instance;
      t1 = t1 == null ? null : t1.RendererBinding__pipelineOwner._rootNode;
      t1 = t1 == null ? null : t1.toStringDeep$0();
      D.print__debugPrintThrottled$closure().call$1(t1 == null ? "Render tree unavailable." : t1);
      return D.debugPrintDone();
    },
    $signature: 6
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure1.prototype = {
    call$0: function() {
      N.debugDumpSemanticsTree(C.DebugSemanticsDumpOrder_1);
      return D.debugPrintDone();
    },
    $signature: 6
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure2.prototype = {
    call$0: function() {
      N.debugDumpSemanticsTree(C.DebugSemanticsDumpOrder_0);
      return D.debugPrintDone();
    },
    $signature: 6
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.double),
        $async$returnValue;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $._timeDilation;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 122
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure0.prototype = {
    call$1: function(value) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null);
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              N.timeDilation(value);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 123
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_initServiceExtensions_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1.registerStringServiceExtension$3$getter$name$setter(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_initServiceExtensions__closure(), "evict", new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_initServiceExtensions__closure0(t1));
      return true;
    },
    $signature: 0
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_initServiceExtensions__closure.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = "";
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 124
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_initServiceExtensions__closure0.prototype = {
    call$1: function(value) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t1.super$ServicesBinding$evict(value);
              t1 = t1.PaintingBinding__imageCache;
              t1._image_cache$_cache.clear$0(0);
              t1._pendingImages.clear$0(0);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 125
  };
  N.WidgetsBindingObserver.prototype = {
    didPopRoute$0: function() {
      var t1 = new P._Future($.Zone__current, [P.bool]);
      t1._asyncComplete$1(false);
      return t1;
    },
    didPushRoute$1: function(route) {
      var t1 = new P._Future($.Zone__current, [P.bool]);
      t1._asyncComplete$1(false);
      return t1;
    },
    didChangeTextScaleFactor$0: function() {
    },
    didChangePlatformBrightness$0: function() {
    },
    didChangeLocales$1: function(locale) {
    },
    didChangeAppLifecycleState$1: function(state) {
    },
    didHaveMemoryPressure$0: function() {
    },
    didChangeAccessibilityFeatures$0: function() {
    }
  };
  N.WidgetsBinding.prototype = {
    _forceRebuild$0: function() {
      var t1 = this.WidgetsBinding__renderViewElement;
      if (t1 != null) {
        this.WidgetsBinding__buildOwner.reassemble$1(t1);
        return this.get$endOfFrame();
      }
      t1 = new P._Future($.Zone__current, [-1]);
      t1._asyncComplete$1(null);
      return t1;
    },
    handleLocaleChanged$0: function() {
      $.$get$window().toString;
      this.dispatchLocalesChanged$1(null);
    },
    dispatchLocalesChanged$1: function(locales) {
      var t1, t2, _i;
      for (t1 = this.WidgetsBinding__observers, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        t1[_i].didChangeLocales$1(locales);
    },
    handlePopRoute$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, t1, t2, _i, $async$temp1;
      var $async$handlePopRoute$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = P.List_List$from($async$self.WidgetsBinding__observers, true, N.WidgetsBindingObserver), t2 = t1.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t1.length)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$temp1 = H;
              $async$goto = 6;
              return P._asyncAwait(t1[_i].didPopRoute$0(), $async$handlePopRoute$0);
            case 6:
              // returning from await.
              if ($async$temp1.boolConversionCheck($async$result)) {
                // goto return
                $async$goto = 1;
                break;
              }
            case 4:
              // for update
              t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              M.SystemNavigator_pop();
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$handlePopRoute$0, $async$completer);
    },
    handlePushRoute$1: function(route) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, t1, t2, _i, $async$temp1;
      var $async$handlePushRoute$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = P.List_List$from($async$self.WidgetsBinding__observers, true, N.WidgetsBindingObserver), t2 = t1.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t1.length)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$temp1 = H;
              $async$goto = 6;
              return P._asyncAwait(t1[_i].didPushRoute$1(route), $async$handlePushRoute$1);
            case 6:
              // returning from await.
              if ($async$temp1.boolConversionCheck($async$result)) {
                // goto return
                $async$goto = 1;
                break;
              }
            case 4:
              // for update
              t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$handlePushRoute$1, $async$completer);
    },
    _handleNavigationInvocation$1: function(methodCall) {
      var t1;
      switch (methodCall.method) {
        case "popRoute":
          return this.handlePopRoute$0();
        case "pushRoute":
          return this.handlePushRoute$1(H.stringTypeCheck(methodCall.$arguments));
      }
      t1 = new P._Future($.Zone__current, [null]);
      t1._asyncComplete$1(null);
      return t1;
    },
    handleMemoryPressure$0: function() {
      var t1, t2, _i;
      for (t1 = this.WidgetsBinding__observers, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        t1[_i].didHaveMemoryPressure$0();
    },
    _handleSystemMessage$1: function(systemMessage) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this;
      var $async$_handleSystemMessage$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              switch (H.stringTypeCheck(H.assertSubtype(systemMessage, "$isMap", [P.String, null], "$asMap").$index(0, "type"))) {
                case "memoryPressure":
                  $async$self.handleMemoryPressure$0();
                  break;
              }
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_handleSystemMessage$1, $async$completer);
    },
    deferFirstFrameReport$0: function() {
      H.assertHelper(this.WidgetsBinding__deferFirstFrameReportCount >= 0);
      ++this.WidgetsBinding__deferFirstFrameReportCount;
    },
    allowFirstFrameReport$0: function() {
      H.assertHelper(this.WidgetsBinding__deferFirstFrameReportCount >= 1);
      --this.WidgetsBinding__deferFirstFrameReportCount;
    },
    _handleBuildScheduled$0: function() {
      H.assertHelper(new N.WidgetsBinding__handleBuildScheduled_closure(this).call$0());
      this.ensureVisualUpdate$0();
    }
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure.prototype = {
    call$0: function() {
      N.debugDumpApp();
      return D.debugPrintDone();
    },
    $signature: 6
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure0.prototype = {
    call$0: function() {
      var t1 = $.WidgetsApp_showPerformanceOverlayOverride,
        t2 = new P._Future($.Zone__current, [P.bool]);
      t2._asyncComplete$1(t1);
      return t2;
    },
    $signature: 4
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure1.prototype = {
    call$1: function(value) {
      var t1;
      if ($.WidgetsApp_showPerformanceOverlayOverride === value) {
        t1 = new P._Future($.Zone__current, [-1]);
        t1._asyncComplete$1(null);
        return t1;
      }
      $.WidgetsApp_showPerformanceOverlayOverride = value;
      return this.$this._forceRebuild$0();
    },
    $signature: 7
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure2.prototype = {
    call$1: function(_) {
      var t1 = P.String;
      return this.$call$body$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure(H.assertSubtype(_, "$isMap", [t1, t1], "$asMap"));
    },
    $call$body$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String,,]),
        $async$returnValue, $async$self = this;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = P.LinkedHashMap_LinkedHashMap$_literal(["enabled", $async$self.$this.WidgetsBinding__needToReportFirstFrame ? "false" : "true"], P.String, null);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 8
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure3.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $.debugProfileBuildsEnabled;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 4
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure4.prototype = {
    call$1: function(value) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null);
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($.debugProfileBuildsEnabled !== value)
                $.debugProfileBuildsEnabled = value;
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 36
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure5.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1.registerBoolServiceExtension$3$getter$name$setter(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure(), "debugAllowBanner", new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure0(t1));
      t1.registerBoolServiceExtension$3$getter$name$setter(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure1(), "debugWidgetInspector", new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure2(t1));
      $.$get$WidgetInspectorService__instance().initServiceExtensions$1(t1.get$registerServiceExtension());
      return true;
    },
    $signature: 0
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure.prototype = {
    call$0: function() {
      var t1 = $.WidgetsApp_debugAllowBannerOverride,
        t2 = new P._Future($.Zone__current, [P.bool]);
      t2._asyncComplete$1(t1);
      return t2;
    },
    $signature: 4
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure0.prototype = {
    call$1: function(value) {
      var t1;
      if ($.WidgetsApp_debugAllowBannerOverride === value) {
        t1 = new P._Future($.Zone__current, [-1]);
        t1._asyncComplete$1(null);
        return t1;
      }
      $.WidgetsApp_debugAllowBannerOverride = value;
      return this.$this._forceRebuild$0();
    },
    $signature: 7
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure1.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $.WidgetsApp_debugShowWidgetInspectorOverride;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 4
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure2.prototype = {
    call$1: function(value) {
      var t1;
      if ($.WidgetsApp_debugShowWidgetInspectorOverride === value) {
        t1 = new P._Future($.Zone__current, [-1]);
        t1._asyncComplete$1(null);
        return t1;
      }
      $.WidgetsApp_debugShowWidgetInspectorOverride = value;
      return this.$this._forceRebuild$0();
    },
    $signature: 7
  };
  N.WidgetsBinding__handleBuildScheduled_closure.prototype = {
    call$0: function() {
      if (this.$this.WidgetsBinding_debugBuildingDirtyElements)
        throw H.wrapException(U.FlutterError$("Build scheduled during frame.\nWhile the widget tree was being built, laid out, and painted, a new frame was scheduled to rebuild the widget tree. This might be because setState() was called from a layout or paint callback. If a change is needed to the widget tree, it should be applied as the tree is being built. Scheduling a change for the subsequent frame instead results in an interface that lags behind by one frame. If this was done to make your build dependent on a size measured at layout time, consider using a LayoutBuilder, CustomSingleChildLayout, or CustomMultiChildLayout. If, on the other hand, the one frame delay is the desired effect, for example because this is an animation, consider scheduling the frame in a post-frame callback using SchedulerBinding.addPostFrameCallback or using an AnimationController to trigger the animation."));
      return true;
    },
    $signature: 0
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_drawFrame_closure.prototype = {
    call$0: function() {
      return this.$this.WidgetsBinding_debugBuildingDirtyElements = true;
    },
    $signature: 0
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_drawFrame_closure0.prototype = {
    call$0: function() {
      this.$this.WidgetsBinding_debugBuildingDirtyElements = false;
      return true;
    },
    $signature: 0
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_performReassemble_closure.prototype = {
    call$0: function() {
      var t1 = $.$get$WidgetInspectorService__instance();
      t1.WidgetInspectorService__rebuildStats.resetCounts$0();
      t1.WidgetInspectorService__repaintStats.resetCounts$0();
      return true;
    },
    $signature: 0
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_performReassemble_closure0.prototype = {
    call$1: function(value) {
      this.$this.allowFirstFrameReport$0();
    },
    $signature: 129
  };
  N.debugDumpApp_closure.prototype = {
    call$0: function() {
      this._box_0.mode = "CHECKED MODE";
      return true;
    },
    $signature: 0
  };
  N.RenderObjectToWidgetAdapter.prototype = {
    createElement$0: function() {
      var t1 = ($.Element__nextHashCode + 1) % 16777215;
      $.Element__nextHashCode = t1;
      return new N.RenderObjectToWidgetElement(t1, this, C._ElementLifecycle_0, this.$ti);
    },
    createRenderObject$1: function(context) {
      return this.container;
    },
    updateRenderObject$2: function(context, renderObject) {
    },
    attachToRenderTree$2: function(owner, element) {
      var t1 = {};
      t1.element = element;
      H.assertSubtype(element, "$isRenderObjectToWidgetElement", this.$ti, "$asRenderObjectToWidgetElement");
      if (element == null) {
        owner.lockState$1(new N.RenderObjectToWidgetAdapter_attachToRenderTree_closure(t1, this, owner));
        owner.buildScope$2(t1.element, new N.RenderObjectToWidgetAdapter_attachToRenderTree_closure0(t1));
      } else {
        element._newWidget = this;
        element.markNeedsBuild$0();
      }
      return t1.element;
    },
    toStringShort$0: function() {
      return this.debugShortDescription;
    }
  };
  N.RenderObjectToWidgetAdapter_attachToRenderTree_closure.prototype = {
    call$0: function() {
      var t3,
        t1 = this.$this,
        t2 = ($.Element__nextHashCode + 1) % 16777215;
      $.Element__nextHashCode = t2;
      t3 = this._box_0;
      t3.element = new N.RenderObjectToWidgetElement(t2, t1, C._ElementLifecycle_0, [H.getTypeArgumentByIndex(t1, 0)]);
      t3.element._owner = this.owner;
    },
    $signature: 2
  };
  N.RenderObjectToWidgetAdapter_attachToRenderTree_closure0.prototype = {
    call$0: function() {
      this._box_0.element.mount$2(null, null);
    },
    $signature: 2
  };
  N.RenderObjectToWidgetElement.prototype = {
    get$widget: function() {
      return H.assertSubtype(N.RenderObjectElement.prototype.get$widget.call(this), "$isRenderObjectToWidgetAdapter", this.$ti, "$asRenderObjectToWidgetAdapter");
    },
    visitChildren$1: function(visitor) {
      var t1;
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [N.Element]});
      t1 = this._child;
      if (t1 != null)
        visitor.call$1(t1);
    },
    forgetChild$1: function(child) {
      H.assertHelper(child.$eq(0, this._child));
      this._child = null;
    },
    mount$2: function($parent, newSlot) {
      H.assertHelper($parent == null);
      this.super$RootRenderObjectElement$mount($parent, newSlot);
      this._rebuild$0();
    },
    update$1: function(newWidget) {
      var _this = this,
        t1 = _this.$ti;
      H.assertSubtype(newWidget, "$isRenderObjectToWidgetAdapter", t1, "$asRenderObjectToWidgetAdapter");
      _this.super$RenderObjectElement$update(newWidget);
      H.assertHelper(H.assertSubtype(N.RenderObjectElement.prototype.get$widget.call(_this), "$isRenderObjectToWidgetAdapter", t1, "$asRenderObjectToWidgetAdapter") === newWidget);
      _this._rebuild$0();
    },
    performRebuild$0: function() {
      var _this = this,
        t1 = _this._newWidget;
      if (t1 != null) {
        _this._newWidget = null;
        _this.update$1(H.assertSubtype(t1, "$isRenderObjectToWidgetAdapter", _this.$ti, "$asRenderObjectToWidgetAdapter"));
      }
      _this.super$RenderObjectElement$performRebuild();
      H.assertHelper(_this._newWidget == null);
    },
    _rebuild$0: function() {
      var exception, stack, details, error, t1, exception0, error0, _this = this;
      try {
        t1 = _this.updateChild$3(_this._child, H.assertSubtype(N.RenderObjectElement.prototype.get$widget.call(_this), "$isRenderObjectToWidgetAdapter", _this.$ti, "$asRenderObjectToWidgetAdapter").child, C.C_Object);
        _this._child = t1;
        H.assertHelper(t1 != null);
      } catch (exception0) {
        exception = H.unwrapException(exception0);
        stack = H.getTraceFromException(exception0);
        details = U.FlutterErrorDetails$("attaching to the render tree", exception, null, "widgets library", false, stack);
        U.FlutterError_reportError(details);
        error0 = $.$get$ErrorWidget_builder().call$1(details);
        error = error0;
        _this._child = _this.updateChild$3(null, error, C.C_Object);
      }
    },
    get$renderObject: function() {
      return H.assertSubtype(N.RenderObjectElement.prototype.get$renderObject.call(this), "$isRenderObjectWithChildMixin", this.$ti, "$asRenderObjectWithChildMixin");
    },
    insertChildRenderObject$2: function(child, slot) {
      var t1, _this = this;
      H.assertHelper(J.$eq$(slot, C.C_Object));
      t1 = _this.$ti;
      H.assertSubtype(N.RenderObjectElement.prototype.get$renderObject.call(_this), "$isRenderObjectWithChildMixin", t1, "$asRenderObjectWithChildMixin").debugValidateChild$1(child);
      H.assertSubtype(N.RenderObjectElement.prototype.get$renderObject.call(_this), "$isRenderObjectWithChildMixin", t1, "$asRenderObjectWithChildMixin").set$child(H.assertSubtypeOfRuntimeType(child, H.getTypeArgumentByIndex(_this, 0)));
    },
    moveChildRenderObject$2: function(child, slot) {
      H.assertHelper(false);
    },
    removeChildRenderObject$1: function(child) {
      var t1 = this.$ti;
      H.assertHelper(H.assertSubtype(N.RenderObjectElement.prototype.get$renderObject.call(this), "$isRenderObjectWithChildMixin", t1, "$asRenderObjectWithChildMixin").RenderObjectWithChildMixin__child == child);
      H.assertSubtype(N.RenderObjectElement.prototype.get$renderObject.call(this), "$isRenderObjectWithChildMixin", t1, "$asRenderObjectWithChildMixin").set$child(null);
    }
  };
  N.WidgetsFlutterBinding.prototype = {$isHitTestTarget: 1};
  N._WidgetsFlutterBinding_BindingBase_GestureBinding.prototype = {
    initInstances$0: function() {
      this.super$BindingBase$initInstances();
      $.GestureBinding__instance = this;
      var t1 = $.$get$window();
      t1.toString;
      t1.set$_onPointerDataPacket(H.functionTypeCheck(this.get$_handlePointerDataPacket(), {func: 1, ret: -1, args: [P.PointerDataPacket]}));
    },
    unlocked$0: function() {
      this.super$BindingBase$unlocked();
      this._flushPointerEventQueue$0();
    }
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding.prototype = {
    initInstances$0: function() {
      this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding$initInstances();
      var t1 = $.$get$window();
      t1.toString;
      t1.set$_onPlatformMessage(H.functionTypeCheck(B.platform_messages_BinaryMessages_handlePlatformMessage$closure(), {func: 1, ret: -1, args: [P.String, P.ByteData, {func: 1, ret: -1, args: [P.ByteData]}]}));
      t1 = $.LicenseRegistry__collectors;
      if (t1 == null)
        t1 = $.LicenseRegistry__collectors = H.setRuntimeTypeInfo([], [{func: 1, ret: [P.Stream, F.LicenseEntry]}]);
      C.JSArray_methods.add$1(t1, this.get$_addLicenses());
    },
    initServiceExtensions$0: function() {
      this.super$BindingBase$initServiceExtensions();
      H.assertHelper(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_initServiceExtensions_closure(this).call$0());
    }
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding.prototype = {
    initInstances$0: function() {
      var t1, _this = this;
      _this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding$initInstances();
      $.SchedulerBinding__instance = _this;
      t1 = $.$get$window();
      t1.toString;
      t1.set$_onBeginFrame(H.functionTypeCheck(_this.get$_handleBeginFrame(), {func: 1, ret: -1, args: [P.Duration]}));
      t1.set$_onDrawFrame(H.functionTypeCheck(_this.get$_handleDrawFrame(), {func: 1, ret: -1}));
      C.BasicMessageChannel_No7.setMessageHandler$1(_this.get$_handleLifecycleMessage());
      if (_this.SchedulerBinding__lifecycleState == null && N.SchedulerBinding__parseAppLifecycleMessage(null) != null)
        _this._handleLifecycleMessage$1(null);
    },
    initServiceExtensions$0: function() {
      this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding$initServiceExtensions();
      this.registerNumericServiceExtension$3$getter$name$setter(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure(), "timeDilation", new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure0());
    },
    set$_transientCallbacks: function(_transientCallbacks) {
      this.SchedulerBinding__transientCallbacks = H.assertSubtype(_transientCallbacks, "$isMap", [P.int, N._FrameCallbackEntry], "$asMap");
    },
    set$_nextFrameCompleter: function(_nextFrameCompleter) {
      this.SchedulerBinding__nextFrameCompleter = H.assertSubtype(_nextFrameCompleter, "$isCompleter", [-1], "$asCompleter");
    }
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding.prototype = {
    initInstances$0: function() {
      this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding$initInstances();
      var t1 = P.Object;
      this.PaintingBinding__imageCache = new E.ImageCache(P.LinkedHashMap_LinkedHashMap$_empty(t1, E._PendingImage), P.LinkedHashMap_LinkedHashMap$_empty(t1, E._CachedImage));
      C.C_DefaultShaderWarmUp.execute$0();
    }
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding.prototype = {
    initInstances$0: function() {
      this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding$initInstances();
      $.SemanticsBinding__instance = this;
      $.$get$window().toString;
      this.SemanticsBinding__accessibilityFeatures = null;
    }
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding.prototype = {
    initInstances$0: function() {
      var t1, t2, _this = this;
      _this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding$initInstances();
      $.RendererBinding__instance = _this;
      t1 = K.RenderObject;
      t2 = [t1];
      _this.RendererBinding__pipelineOwner = new K.PipelineOwner(_this.get$ensureVisualUpdate(), _this.get$_handleSemanticsOwnerCreated(), _this.get$_handleSemanticsOwnerDisposed(), H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2), P.LinkedHashSet_LinkedHashSet$_empty(t1));
      t1 = $.$get$window();
      t1.toString;
      t2 = {func: 1, ret: -1};
      t1.set$_onMetricsChanged(H.functionTypeCheck(_this.get$handleMetricsChanged(), t2));
      t1.set$_onTextScaleFactorChanged(H.functionTypeCheck(_this.get$handleTextScaleFactorChanged(), t2));
      t1.set$_onPlatformBrightnessChanged(H.functionTypeCheck(_this.get$handlePlatformBrightnessChanged(), t2));
      t1.set$_onSemanticsEnabledChanged(H.functionTypeCheck(_this.get$_handleSemanticsEnabledChanged(), t2));
      t1.set$_onSemanticsAction(H.functionTypeCheck(_this.get$_handleSemanticsAction(), {func: 1, ret: -1, args: [P.int, P.SemanticsAction, P.ByteData]}));
      H.assertHelper(_this.RendererBinding__pipelineOwner._rootNode == null);
      t1 = new A.RenderView(C.Size_0_0, _this.createViewConfiguration$0(), t1, null);
      t1.get$isRepaintBoundary();
      t1._needsCompositing = true;
      t1.set$child(null);
      _this.RendererBinding__pipelineOwner.set$rootNode(t1);
      t1 = _this.RendererBinding__pipelineOwner._rootNode;
      H.assertHelper(H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner") != null);
      H.assertHelper(t1._rootTransform == null);
      t1.scheduleInitialLayout$0();
      t2 = t1._updateMatricesAndCreateNewRootLayer$0();
      H.assertHelper(t2._node$_owner != null);
      H.assertHelper(t1._node$_owner != null);
      H.assertHelper(!(t1._node$_parent instanceof K.RenderObject));
      H.assertHelper(!H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner")._debugDoingPaint);
      t1.get$isRepaintBoundary();
      H.assertHelper(t1._layer == null);
      t1._layer = t2;
      H.assertHelper(t1._needsPaint);
      C.JSArray_methods.add$1(H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner")._nodesNeedingPaint, t1);
      H.assertHelper(t1._rootTransform != null);
      H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(t1), "$isPipelineOwner").onNeedVisualUpdate.call$0();
      _this.setSemanticsEnabled$1(false);
      H.assertHelper(_this.RendererBinding__pipelineOwner._rootNode != null);
      C.JSArray_methods.add$1(_this.SchedulerBinding__persistentCallbacks, H.functionTypeCheck(_this.get$_handlePersistentFrameCallback(), {func: 1, ret: -1, args: [P.Duration]}));
      _this.RendererBinding__mouseTracker = _this._createMouseTracker$0();
    },
    initServiceExtensions$0: function() {
      var _this = this;
      _this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding$initServiceExtensions();
      H.assertHelper(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure(_this).call$0());
      _this.registerSignalServiceExtension$2$callback$name(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure0(), "debugDumpRenderTree");
      _this.registerSignalServiceExtension$2$callback$name(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure1(), "debugDumpSemanticsTreeInTraversalOrder");
      _this.registerSignalServiceExtension$2$callback$name(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure2(), "debugDumpSemanticsTreeInInverseHitTestOrder");
    },
    performReassemble$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$next = [], $async$self = this;
      var $async$performReassemble$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait($async$self.super$BindingBase$performReassemble(), $async$performReassemble$0);
            case 2:
              // returning from await.
              P.Timeline_startSync("Dirty Render Tree", C.Map_9aZ6I, null);
              try {
                $async$self.RendererBinding__pipelineOwner._rootNode.reassemble$0();
              } finally {
                P.Timeline_finishSync();
              }
              $async$self.scheduleWarmUpFrame$0();
              $async$goto = 3;
              return P._asyncAwait($async$self.get$endOfFrame(), $async$performReassemble$0);
            case 3:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$performReassemble$0, $async$completer);
    }
  };
  N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding.prototype = {
    initServiceExtensions$0: function() {
      var _this = this;
      _this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding$initServiceExtensions();
      _this.registerSignalServiceExtension$2$callback$name(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure(), "debugDumpApp");
      _this.registerBoolServiceExtension$3$getter$name$setter(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure0(), "showPerformanceOverlay", new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure1(_this));
      _this.registerServiceExtension$2$callback$name(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure2(_this), "didSendFirstFrameEvent");
      _this.registerBoolServiceExtension$3$getter$name$setter(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure3(), "profileWidgetBuilds", new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure4());
      H.assertHelper(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure5(_this).call$0());
    },
    handleMetricsChanged$0: function() {
      var t1, t2, _i;
      this.super$RendererBinding$handleMetricsChanged();
      for (t1 = this.WidgetsBinding__observers, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        t1[_i].didChangeMetrics$0();
    },
    handleTextScaleFactorChanged$0: function() {
      var t1, t2, _i;
      this.super$RendererBinding$handleTextScaleFactorChanged();
      for (t1 = this.WidgetsBinding__observers, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        t1[_i].didChangeTextScaleFactor$0();
    },
    handlePlatformBrightnessChanged$0: function() {
      var t1, t2, _i;
      this.super$RendererBinding$handlePlatformBrightnessChanged();
      for (t1 = this.WidgetsBinding__observers, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        t1[_i].didChangePlatformBrightness$0();
    },
    handleAccessibilityFeaturesChanged$0: function() {
      var t1, t2, _i;
      this.super$SemanticsBinding$handleAccessibilityFeaturesChanged();
      for (t1 = this.WidgetsBinding__observers, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        t1[_i].didChangeAccessibilityFeatures$0();
    },
    handleAppLifecycleStateChanged$1: function(state) {
      var t1, t2, _i;
      this.super$SchedulerBinding$handleAppLifecycleStateChanged(state);
      for (t1 = this.WidgetsBinding__observers, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        t1[_i].didChangeAppLifecycleState$1(state);
    },
    drawFrame$0: function() {
      var t1, _this = this;
      H.assertHelper(!_this.WidgetsBinding_debugBuildingDirtyElements);
      H.assertHelper(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_drawFrame_closure(_this).call$0());
      try {
        t1 = _this.WidgetsBinding__renderViewElement;
        if (t1 != null)
          _this.WidgetsBinding__buildOwner.buildScope$1(t1);
        _this.super$RendererBinding$drawFrame();
        _this.WidgetsBinding__buildOwner.finalizeTree$0();
      } finally {
        H.assertHelper(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_drawFrame_closure0(_this).call$0());
      }
      if (_this.WidgetsBinding__needToReportFirstFrame && _this.WidgetsBinding__deferFirstFrameReportCount === 0) {
        P.Timeline_instantSync("Widgets completed first useful frame");
        P.postEvent("Flutter.FirstFrame", P.LinkedHashMap_LinkedHashMap$_empty(P.String, null));
        _this.WidgetsBinding__needToReportFirstFrame = false;
      }
    },
    performReassemble$0: function() {
      var t1, _this = this;
      H.assertHelper(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_performReassemble_closure().call$0());
      _this.deferFirstFrameReport$0();
      t1 = _this.WidgetsBinding__renderViewElement;
      if (t1 != null)
        _this.WidgetsBinding__buildOwner.reassemble$1(t1);
      return _this.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding$performReassemble().then$1$1(new N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_performReassemble_closure0(_this), -1);
    }
  };
  M.DecoratedBox.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new E.RenderDecoratedBox(this.decoration, this.position, U.createLocalImageConfiguration(context), null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderDecoratedBox");
      renderObject.set$decoration(this.decoration);
      renderObject.set$configuration(U.createLocalImageConfiguration(context));
      renderObject.set$position(this.position);
    },
    debugFillProperties$1: function(properties) {
      var label, t1, t2, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      switch (_this.position) {
        case C.DecorationPosition_0:
          label = "bg";
          break;
        case C.DecorationPosition_1:
          label = "fg";
          break;
        default:
          label = _null;
      }
      t1 = properties.properties;
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.position, C.C__NoDefaultValue, C.DiagnosticLevel_0, "position", true, true, C.DiagnosticsTreeStyle_5, [E.DecorationPosition]));
      t2 = _this.decoration;
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$(label, t2, C.C__NoDefaultValue, _null, _null, "no decoration", C.DiagnosticLevel_3, false, t2 != null, true, C.DiagnosticsTreeStyle_5, _null, Z.Decoration));
    }
  };
  M.Container.prototype = {
    get$_paddingIncludingDecoration: function() {
      var decorationPadding,
        t1 = this.decoration;
      if (t1 == null || t1.get$padding() == null)
        return this.padding;
      decorationPadding = t1.get$padding();
      t1 = this.padding;
      if (t1 == null)
        return decorationPadding;
      return t1.add$1(0, decorationPadding);
    },
    build$1: function(context) {
      var t1, t2, t3, effectivePadding, _this = this, _null = null,
        current = _this.child;
      if (current == null) {
        t1 = _this.constraints;
        if (t1 != null) {
          t2 = t1.minWidth;
          t3 = t1.maxWidth;
          if (typeof t2 !== "number")
            return t2.$ge();
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (t2 >= t3) {
            t2 = t1.minHeight;
            t1 = t1.maxHeight;
            if (typeof t2 !== "number")
              return t2.$ge();
            if (typeof t1 !== "number")
              return H.iae(t1);
            t1 = t2 >= t1;
          } else
            t1 = false;
          t1 = !t1;
        } else
          t1 = true;
      } else
        t1 = false;
      if (t1)
        current = new T.LimitedBox(0, 0, T.ConstrainedBox$(_null, C.BoxConstraints_ALM), _null);
      t1 = _this.alignment;
      if (t1 != null)
        current = T.Align$(t1, current, _null, _null, _null);
      effectivePadding = _this.get$_paddingIncludingDecoration();
      if (effectivePadding != null)
        current = T.Padding$(current, effectivePadding);
      t1 = _this.decoration;
      if (t1 != null)
        current = M.DecoratedBox$(current, t1, C.DecorationPosition_0);
      t1 = _this.constraints;
      if (t1 != null)
        current = T.ConstrainedBox$(current, t1);
      return current;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("alignment", _this.alignment, _null, _null, _null, _null, C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_5, _null, K.AlignmentGeometry);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      t1 = V.EdgeInsetsGeometry;
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("padding", _this.padding, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      t3 = Z.Decoration;
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("bg", _this.decoration, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("fg", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("constraints", _this.constraints, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, S.BoxConstraints));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("margin", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t1));
      C.JSArray_methods.add$1(t2, new Y.ObjectFlagProperty("has transform", _null, _null, _null, _null, false, _null, C.C__NoDefaultValue, C.DiagnosticLevel_3, "transform", true, false, C.DiagnosticsTreeStyle_5, [E.Matrix4]));
    }
  };
  E.debugCheckHasMediaQuery_closure.prototype = {
    call$0: function() {
      var t1 = this.context;
      if (!t1.get$widget().$isMediaQuery && t1.ancestorWidgetOfExactType$1(C.Type_MediaQuery_nDB) == null)
        throw H.wrapException(U.FlutterError$("No MediaQuery widget found.\n" + H.getRuntimeType(t1.get$widget()).toString$0(0) + " widgets require a MediaQuery widget ancestor.\nThe specific widget that could not find a MediaQuery ancestor was:\n  " + t1.get$widget().toString$0(0) + "\nThe ownership chain for the affected widget is:\n  " + t1.debugGetCreatorChain$1(10) + "\nTypically, the MediaQuery widget is introduced by the MaterialApp or WidgetsApp widget at the top of your application widget tree."));
      return true;
    },
    $signature: 0
  };
  E.debugCheckHasDirectionality_closure.prototype = {
    call$0: function() {
      var t1 = this.context;
      if (!t1.get$widget().$isDirectionality && t1.ancestorWidgetOfExactType$1(C.Type_Directionality_8Om) == null)
        throw H.wrapException(U.FlutterError$("No Directionality widget found.\n" + H.getRuntimeType(t1.get$widget()).toString$0(0) + " widgets require a Directionality widget ancestor.\nThe specific widget that could not find a Directionality ancestor was:\n  " + t1.get$widget().toString$0(0) + "\nThe ownership chain for the affected widget is:\n  " + t1.debugGetCreatorChain$1(10) + '\nTypically, the Directionality widget is introduced by the MaterialApp or WidgetsApp widget at the top of your application widget tree. It determines the ambient reading direction and is used, for example, to determine how to lay out text, how to interpret "start" and "end" values, and to resolve EdgeInsetsDirectional, AlignmentDirectional, and other *Directional objects.'));
      return true;
    },
    $signature: 0
  };
  E.debugWidgetBuilderValue_closure.prototype = {
    call$0: function() {
      var t2,
        t1 = this.built;
      if (t1 == null)
        throw H.wrapException(U.FlutterError$("A build function returned null.\nThe offending widget is: " + this.widget.toString$0(0) + '\nBuild functions must never return null. To return an empty space that causes the building widget to fill available room, return "new Container()". To return an empty space that takes as little room as possible, return "new Container(width: 0.0, height: 0.0)".'));
      t2 = this.widget;
      if (t2 === t1)
        throw H.wrapException(U.FlutterError$("A build function returned context.widget.\nThe offending widget is: " + t2.toString$0(0) + '\nBuild functions must never return their BuildContext parameter\'s widget or a child that contains "context.widget". Doing so introduces a loop in the widget tree that can cause the app to crash.'));
      return true;
    },
    $signature: 0
  };
  O.FocusAttachment.prototype = {
    detach$0: function() {
      var t1 = this._node,
        t2 = t1._attachment;
      if (t2 === this) {
        t2 = t1._parent;
        if (t2 != null)
          t2._removeChild$1(t1);
        t1 = t1._attachment = null;
      } else
        t1 = t2;
      H.assertHelper(t1 !== this);
    },
    reparent$0: function() {
      var t2, marker, t3, $parent,
        t1 = this._node;
      if (t1._attachment === this) {
        H.assertHelper(t1._context != null);
        t2 = t1._context;
        H.assertHelper(t2 != null);
        marker = H.interceptedTypeCheck(t2.inheritFromWidgetOfExactType$1(C.Type__FocusMarker_fgL), "$is_FocusMarker");
        t3 = marker == null ? null : marker.notifier;
        $parent = t3 == null ? t2._owner.focusManager.rootScope : t3;
        $parent._reparent$1(t1);
      }
    }
  };
  O.FocusNode.prototype = {
    set$debugLabel: function(value) {
      H.assertHelper(new O.FocusNode_debugLabel_closure(this, value).call$0());
    },
    get$descendants: function() {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var $async$goto = 0, $async$handler = 1, $async$currentError, t1, t2, _i, child;
        return function $async$get$descendants($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self._children, t2 = t1.length, _i = 0;
              case 2:
                // for condition
                if (!(_i < t1.length)) {
                  // goto after for
                  $async$goto = 4;
                  break;
                }
                child = t1[_i];
                $async$goto = 5;
                return P._IterationMarker_yieldStar(child.get$descendants());
              case 5:
                // after yield
                $async$goto = 6;
                return child;
              case 6:
                // after yield
              case 3:
                // for update
                t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i;
                // goto for condition
                $async$goto = 2;
                break;
              case 4:
                // after for
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, O.FocusNode);
    },
    get$ancestors: function() {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var $async$goto = 0, $async$handler = 1, $async$currentError, $parent;
        return function $async$get$ancestors($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $parent = $async$self._parent;
              case 2:
                // for condition
                if (!($parent != null)) {
                  // goto after for
                  $async$goto = 3;
                  break;
                }
                $async$goto = 4;
                return $parent;
              case 4:
                // after yield
                $parent = $parent._parent;
                // goto for condition
                $async$goto = 2;
                break;
              case 3:
                // after for
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, O.FocusNode);
    },
    get$hasFocus: function() {
      var _this = this,
        t1 = _this._manager;
      if ((t1 == null ? null : t1._currentFocus) == null)
        return false;
      if (_this.get$hasPrimaryFocus())
        return true;
      return _this._manager._currentFocus.get$ancestors().contains$1(0, _this);
    },
    get$hasPrimaryFocus: function() {
      var t1 = this._manager;
      return (t1 == null ? null : t1._currentFocus) === this;
    },
    get$nearestScope: function() {
      return this.get$enclosingScope();
    },
    get$enclosingScope: function() {
      return H.interceptedTypeCheck(this.get$ancestors().firstWhere$2$orElse(0, new O.FocusNode_enclosingScope_closure(), new O.FocusNode_enclosingScope_closure0()), "$isFocusScopeNode");
    },
    unfocus$0: function() {
      var t1, _this = this,
        scope = _this.get$enclosingScope();
      if (scope == null)
        return;
      C.JSArray_methods.remove$1(scope._focusedChildren, _this);
      t1 = _this._manager;
      if (t1 != null)
        t1._willUnfocusNode$1(_this);
    },
    _markAsDirty$1$newFocus: function(newFocus) {
      var _this = this,
        t1 = _this._manager;
      if (t1 != null) {
        t1._dirtyNodes.add$1(0, _this);
        _this._manager._markNeedsUpdate$1$newFocus(newFocus);
      } else {
        t1 = newFocus == null;
        if (!t1)
          newFocus._setAsFocusedChild$0();
        if (!t1)
          newFocus._notify$0();
        if (newFocus !== _this)
          _this._notify$0();
      }
    },
    _markAsDirty$0: function() {
      return this._markAsDirty$1$newFocus(null);
    },
    _removeChild$1: function(node) {
      var _this = this,
        t1 = _this._children;
      if (H.assertTest(C.JSArray_methods.contains$1(t1, node)))
        H.assertThrow("Tried to remove a node that wasn't a child.");
      H.assertHelper(node._parent === _this);
      H.assertHelper(node._manager == _this._manager);
      node.unfocus$0();
      node._parent = null;
      C.JSArray_methods.remove$1(t1, node);
      t1 = _this._manager;
      H.assertHelper(t1 == null || !t1.rootScope.get$descendants().contains$1(0, node));
    },
    _updateManager$1: function(manager) {
      var t1;
      this._manager = manager;
      for (t1 = this.get$descendants(), t1 = new P._SyncStarIterator(t1._outerHelper(), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        t1.get$current()._manager = manager;
    },
    _reparent$1: function(child) {
      var t1, oldPrimaryFocus, t2, oldFocusPath, newFocusPath, _this = this, _null = null;
      if (H.assertTest(child !== _this))
        H.assertThrow("Tried to make a child into a parent of itself.");
      if (child._parent === _this) {
        if (H.assertTest(C.JSArray_methods.contains$1(_this._children, child)))
          H.assertThrow("Found a node that says it's a child, but doesn't appear in the child list.");
        return;
      }
      t1 = _this._manager;
      if (H.assertTest(t1 == null || child !== t1.rootScope))
        H.assertThrow("Reparenting the root node isn't allowed.");
      if (H.assertTest(!_this.get$ancestors().contains$1(0, child)))
        H.assertThrow("The supplied child is already an ancestor of this node. Loops are not allowed.");
      if (child._manager != null) {
        oldPrimaryFocus = child.get$hasFocus() ? child._manager._currentFocus : _null;
        if (H.assertTest(oldPrimaryFocus == null || oldPrimaryFocus === child || oldPrimaryFocus.get$ancestors().contains$1(0, child)))
          H.assertThrow("child has focus, but primary focus isn't a descendant of it.");
      } else
        oldPrimaryFocus = _null;
      t1 = oldPrimaryFocus == null;
      t2 = t1 ? _null : oldPrimaryFocus.get$ancestors();
      oldFocusPath = t2 == null ? _null : P.LinkedHashSet_LinkedHashSet$from(t2, H.getRuntimeTypeArgument(t2, "Iterable", 0));
      if (oldFocusPath == null)
        oldFocusPath = P.LinkedHashSet_LinkedHashSet$_empty(O.FocusNode);
      t2 = child._parent;
      if (t2 != null)
        t2._removeChild$1(child);
      C.JSArray_methods.add$1(_this._children, child);
      child._parent = _this;
      child._updateManager$1(_this._manager);
      if (!t1) {
        t1 = _this._manager;
        t1 = t1 == null ? _null : t1._currentFocus;
        t1 = t1 == null ? _null : t1.get$ancestors();
        newFocusPath = t1 == null ? _null : P.LinkedHashSet_LinkedHashSet$from(t1, H.getRuntimeTypeArgument(t1, "Iterable", 0));
        for (t1 = oldFocusPath.difference$1(newFocusPath == null ? P.LinkedHashSet_LinkedHashSet$_empty(O.FocusNode) : newFocusPath), t1 = t1.get$iterator(t1); t1.moveNext$0();)
          t1.get$current()._markAsDirty$0();
        oldPrimaryFocus.requestFocus$0();
      }
    },
    attach$2$onKey: function(context, onKey) {
      var _this = this;
      _this._context = context;
      _this.set$_onKey(onKey);
      return _this._attachment = new O.FocusAttachment(_this);
    },
    attach$1: function(context) {
      return this.attach$2$onKey(context, null);
    },
    dispose$0: function() {
      var _this = this,
        t1 = _this._manager;
      if (t1 != null) {
        t1._willUnfocusNode$1(_this);
        t1._dirtyNodes.remove$1(0, _this);
      }
      t1 = _this._attachment;
      if (t1 != null)
        t1.detach$0();
      _this.super$ChangeNotifier$dispose();
    },
    _notify$0: function() {
      var _this = this;
      if (_this._parent == null)
        return;
      if (_this.get$hasPrimaryFocus())
        _this._setAsFocusedChild$0();
      _this.notifyListeners$0();
    },
    requestFocus$0: function() {
      this._doRequestFocus$1$isFromPolicy(false);
    },
    _doRequestFocus$1$isFromPolicy: function(isFromPolicy) {
      var _this = this;
      _this._setAsFocusedChild$0();
      if (_this.get$hasPrimaryFocus())
        return;
      _this._markAsDirty$1$newFocus(_this);
    },
    _setAsFocusedChild$0: function() {
      var t1, t2, scopeFocus, ancestor, t3;
      for (t1 = this.get$ancestors(), t1 = t1.get$iterator(t1), t2 = new H.WhereTypeIterator(t1, [O.FocusScopeNode]), scopeFocus = this; t2.moveNext$0(); scopeFocus = ancestor) {
        ancestor = H.interceptedTypeCheck(t1.get$current(), "$isFocusScopeNode");
        if (H.assertTest(scopeFocus != ancestor))
          H.assertThrow("Somehow made a loop by setting focusedChild to its scope.");
        t3 = ancestor._focusedChildren;
        C.JSArray_methods.remove$1(t3, scopeFocus);
        C.JSArray_methods.add$1(t3, scopeFocus);
      }
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$DiagnosticableTreeMixin$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("context", _this._context, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, N.BuildContext);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.FlagProperty$("hasFocus", false, _null, "FOCUSED", C.DiagnosticLevel_3, false, _this.get$hasFocus()));
      C.JSArray_methods.add$1(t2, Y.StringProperty$("debugLabel", _this._debugLabel, _null, true, true));
    },
    debugDescribeChildren$0: function() {
      var t2, t3, t4, t1 = {};
      t1.count = 1;
      t2 = this._children;
      t3 = Y.DiagnosticsNode;
      t4 = H.getTypeArgumentByIndex(t2, 0);
      return new H.MappedListIterable(t2, H.functionTypeCheck(new O.FocusNode_debugDescribeChildren_closure(t1), {func: 1, ret: t3, args: [t4]}), [t4, t3]).toList$0(0);
    },
    set$_onKey: function(_onKey) {
      this._onKey = H.functionTypeCheck(_onKey, {func: 1, ret: P.bool, args: [O.FocusNode, B.RawKeyEvent]});
    },
    $isListenable: 1,
    $isDiagnosticable: 1,
    $isDiagnosticableTree: 1
  };
  O.FocusNode_debugLabel_closure.prototype = {
    call$0: function() {
      this.$this._debugLabel = this.value;
      return true;
    },
    $signature: 0
  };
  O.FocusNode_enclosingScope_closure.prototype = {
    call$1: function(node) {
      return H.interceptedTypeCheck(node, "$isFocusNode") instanceof O.FocusScopeNode;
    },
    $signature: 130
  };
  O.FocusNode_enclosingScope_closure0.prototype = {
    call$0: function() {
      return;
    },
    $signature: 2
  };
  O.FocusNode_debugDescribeChildren_closure.prototype = {
    call$1: function(child) {
      var t1;
      H.interceptedTypeCheck(child, "$isFocusNode");
      t1 = "Child " + this._box_0.count++;
      child.toString;
      return new Y._DiagnosticableTreeNode(child, t1, true, true, null);
    },
    $signature: 131
  };
  O.FocusScopeNode.prototype = {
    get$nearestScope: function() {
      return this;
    },
    get$focusedChild: function() {
      var t1 = this._focusedChildren;
      if (H.assertTest(t1.length === 0 || C.JSArray_methods.get$last(t1).get$enclosingScope() === this))
        H.assertThrow("Focused child does not have the same idea of its enclosing scope as the scope does.");
      return t1.length !== 0 ? C.JSArray_methods.get$last(t1) : null;
    },
    setFirstFocus$1: function(scope) {
      var descendantFocus, t1;
      if (scope._parent == null)
        this._reparent$1(scope);
      if (H.assertTest(scope.get$ancestors().contains$1(0, this)))
        H.assertThrow(C.Type_FocusScopeNode_cwF.toString$0(0) + " " + scope.toString$0(0) + " must be a child of " + this.toString$0(0) + " to set it as first focus.");
      descendantFocus = scope.get$focusedChild();
      while (true) {
        if (!(descendantFocus instanceof O.FocusScopeNode && true))
          break;
        t1 = descendantFocus._focusedChildren;
        if (H.assertTest(t1.length === 0 || C.JSArray_methods.get$last(t1).get$enclosingScope() == descendantFocus))
          H.assertThrow("Focused child does not have the same idea of its enclosing scope as the scope does.");
        descendantFocus = t1.length !== 0 ? C.JSArray_methods.get$last(t1) : null;
      }
      if (descendantFocus != null)
        descendantFocus._doRequestFocus$1$isFromPolicy(false);
      else
        scope._doRequestFocus$1$isFromPolicy(false);
    },
    _doRequestFocus$1$isFromPolicy: function(isFromPolicy) {
      var t1, t2,
        _s83_ = "Focused child does not have the same idea of its enclosing scope as the scope does.",
        primaryFocus = this.get$focusedChild();
      if (primaryFocus == null)
        primaryFocus = this;
      while (true) {
        t1 = primaryFocus instanceof O.FocusScopeNode;
        if (t1) {
          t2 = primaryFocus._focusedChildren;
          if (H.assertTest(t2.length === 0 || C.JSArray_methods.get$last(t2).get$enclosingScope() === primaryFocus))
            H.assertThrow(_s83_);
          t2 = (t2.length !== 0 ? C.JSArray_methods.get$last(t2) : null) != null;
        } else
          t2 = false;
        if (!t2)
          break;
        t1 = primaryFocus._focusedChildren;
        if (H.assertTest(t1.length === 0 || C.JSArray_methods.get$last(t1).get$enclosingScope() == primaryFocus))
          H.assertThrow(_s83_);
        primaryFocus = t1.length !== 0 ? C.JSArray_methods.get$last(t1) : null;
      }
      if (t1)
        this._markAsDirty$1$newFocus(primaryFocus);
      else
        primaryFocus.requestFocus$0();
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$FocusNode$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("focusedChild", this.get$focusedChild(), _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, O.FocusNode);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  O.FocusManager.prototype = {
    _handleRawKeyEvent$1: function($event) {
      var t1;
      H.interceptedTypeCheck($event, "$isRawKeyEvent");
      t1 = this._currentFocus;
      if (t1 == null)
        return;
      for (t1 = new O.FocusManager__handleRawKeyEvent_allNodes().call$1(t1), t1 = new P._SyncStarIterator(t1._outerHelper(), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        t1.get$current()._onKey;
    },
    _willUnfocusNode$1: function(node) {
      var _this = this;
      if (_this._currentFocus === node) {
        _this._currentFocus = null;
        _this._dirtyNodes.add$1(0, node);
        _this._markNeedsUpdate$0();
      }
      if (_this._nextFocus === node) {
        _this._nextFocus = null;
        _this._dirtyNodes.add$1(0, node);
        _this._markNeedsUpdate$0();
      }
    },
    _markNeedsUpdate$1$newFocus: function(newFocus) {
      var _this = this;
      _this._nextFocus = newFocus == null ? _this._nextFocus : newFocus;
      if (_this._haveScheduledUpdate)
        return;
      _this._haveScheduledUpdate = true;
      P.scheduleMicrotask(_this.get$_applyFocusChange());
    },
    _markNeedsUpdate$0: function() {
      return this._markNeedsUpdate$1$newFocus(null);
    },
    _applyFocusChange$0: function() {
      var previousFocus, t1, t2, previousPath, nextPath, _this = this;
      _this._haveScheduledUpdate = false;
      previousFocus = _this._currentFocus;
      t1 = previousFocus == null;
      if (t1 && _this._nextFocus == null)
        _this._nextFocus = _this.rootScope;
      t2 = _this._nextFocus;
      if (t2 != null && t2 !== previousFocus) {
        _this._currentFocus = t2;
        t2 = t1 ? null : previousFocus.get$ancestors();
        previousPath = t2 == null ? null : P.LinkedHashSet_LinkedHashSet$from(t2, H.getRuntimeTypeArgument(t2, "Iterable", 0));
        if (previousPath == null)
          previousPath = P.LinkedHashSet_LinkedHashSet$_empty(O.FocusNode);
        t2 = _this._nextFocus.get$ancestors();
        nextPath = P.LinkedHashSet_LinkedHashSet$from(t2, H.getTypeArgumentByIndex(t2, 0));
        t2 = _this._dirtyNodes;
        t2.addAll$1(0, nextPath.difference$1(previousPath));
        t2.addAll$1(0, previousPath.difference$1(nextPath));
        _this._nextFocus = null;
      }
      if (previousFocus != _this._currentFocus) {
        if (!t1)
          _this._dirtyNodes.add$1(0, previousFocus);
        t1 = _this._currentFocus;
        if (t1 != null)
          _this._dirtyNodes.add$1(0, t1);
      }
      for (t1 = _this._dirtyNodes, t2 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0)); t2.moveNext$0();)
        t2._collection$_current._notify$0();
      t1.clear$0(0);
    },
    debugDescribeChildren$0: function() {
      return H.setRuntimeTypeInfo([new Y._DiagnosticableTreeNode(this.rootScope, "rootScope", true, true, null)], [Y.DiagnosticsNode]);
    },
    debugFillProperties$1: function(properties) {
      var _null = null,
        t1 = Y.FlagProperty$("haveScheduledUpdate", _null, _null, "UPDATE SCHEDULED", C.DiagnosticLevel_3, false, this._haveScheduledUpdate),
        t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("currentFocus", this._currentFocus, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, O.FocusNode));
    },
    $isDiagnosticable: 1,
    $isDiagnosticableTree: 1
  };
  O.FocusManager__handleRawKeyEvent_allNodes.prototype = {
    call$1: function($async$node) {
      return P._makeSyncStarIterable(function() {
        var node = $async$node;
        var $async$goto = 0, $async$handler = 1, $async$currentError, t1;
        return function $async$call$1($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return node;
              case 2:
                // after yield
                t1 = node.get$ancestors(), t1 = new P._SyncStarIterator(t1._outerHelper(), [H.getTypeArgumentByIndex(t1, 0)]);
              case 3:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 4;
                  break;
                }
                $async$goto = 5;
                return t1.get$current();
              case 5:
                // after yield
                // goto for condition
                $async$goto = 3;
                break;
              case 4:
                // after for
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, O.FocusNode);
    },
    $signature: 133
  };
  O._FocusManager_Object_DiagnosticableTreeMixin.prototype = {};
  O._FocusNode_Object_DiagnosticableTreeMixin.prototype = {};
  O._FocusNode_Object_DiagnosticableTreeMixin_ChangeNotifier.prototype = {
    set$_change_notifier$_listeners: function(_listeners) {
      this.ChangeNotifier__listeners = H.assertSubtype(_listeners, "$isObserverList", [{func: 1, ret: -1}], "$asObserverList");
    }
  };
  L.Focus.prototype = {
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      t1 = Y.StringProperty$("debugLabel", _this.debugLabel, _null, true, true);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.FlagProperty$("autofocus", false, _null, "AUTOFOCUS", C.DiagnosticLevel_3, false, _this.autofocus));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("node", _this.focusNode, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, O.FocusScopeNode));
    },
    createState$0: function() {
      return new L._FocusState(C._StateLifecycle_0);
    },
    get$child: function() {
      return this.child;
    }
  };
  L._FocusState.prototype = {
    get$node: function() {
      var t1 = this._widget.focusNode;
      return t1;
    },
    initState$0: function() {
      this.super$State$initState();
      this._initNode$0();
    },
    _initNode$0: function() {
      var t1, t2, _this = this;
      _this._widget.focusNode;
      _this._focusAttachment = _this.get$node().attach$2$onKey(_this._element, _this._widget.onKey);
      _this._hasFocus = _this.get$node().get$hasFocus();
      t1 = _this.get$node();
      t1.toString;
      t2 = H.functionTypeCheck(_this.get$_handleFocusChanged(), {func: 1, ret: -1});
      t1._debugAssertNotDisposed$0();
      t1 = t1.ChangeNotifier__listeners;
      t1.toString;
      H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(t1, 0));
      t1._isDirty = true;
      C.JSArray_methods.add$1(t1._list, t2);
    },
    dispose$0: function() {
      var t2, _this = this,
        t1 = _this.get$node();
      t1.toString;
      t2 = H.functionTypeCheck(_this.get$_handleFocusChanged(), {func: 1, ret: -1});
      t1._debugAssertNotDisposed$0();
      t1 = t1.ChangeNotifier__listeners;
      t1.toString;
      H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(t1, 0));
      t1._isDirty = true;
      C.JSArray_methods.remove$1(t1._list, t2);
      _this._focusAttachment.detach$0();
      t2 = _this._internalNode;
      if (t2 != null)
        t2.dispose$0();
      _this.super$State$dispose();
    },
    didChangeDependencies$0: function() {
      var t1, t2, _this = this;
      _this.super$State$didChangeDependencies();
      t1 = _this._focusAttachment;
      if (t1 != null)
        t1.reparent$0();
      if (!_this._didAutofocus && _this._widget.autofocus) {
        t1 = L.FocusScope_of(_this._element);
        t2 = _this.get$node();
        if (t1.get$focusedChild() == null) {
          if (t2._parent == null)
            t1._reparent$1(t2);
          if (H.assertTest(t2.get$ancestors().contains$1(0, t1)))
            H.assertThrow("Autofocus was requested for a node that is not a descendant of the scope from which it was requested.");
          t2._doRequestFocus$1$isFromPolicy(false);
        }
        _this._didAutofocus = true;
      }
    },
    deactivate$0: function() {
      this.super$State$deactivate();
      this._didAutofocus = false;
    },
    didUpdateWidget$1: function(oldWidget) {
      var t1, t2, _this = this;
      H.interceptedTypeCheck(oldWidget, "$isFocus");
      _this.super$State$didUpdateWidget(oldWidget);
      oldWidget.debugLabel;
      t1 = _this._widget;
      t1.debugLabel;
      t2 = oldWidget.focusNode;
      if (t2 === t1.focusNode) {
        oldWidget.onKey;
        t1.onKey;
        t1 = true;
      } else
        t1 = false;
      if (!t1)
        t1 = false;
      else
        t1 = true;
      if (t1)
        return;
      _this._focusAttachment.detach$0();
      _this._widget.focusNode;
      t1 = H.functionTypeCheck(_this.get$_handleFocusChanged(), {func: 1, ret: -1});
      t2._debugAssertNotDisposed$0();
      t2 = t2.ChangeNotifier__listeners;
      t2.toString;
      H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(t2, 0));
      t2._isDirty = true;
      C.JSArray_methods.remove$1(t2._list, t1);
      t2 = _this._widget.focusNode;
      t2._debugAssertNotDisposed$0();
      t2 = t2.ChangeNotifier__listeners;
      t2.toString;
      H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(t2, 0));
      t2._isDirty = true;
      C.JSArray_methods.add$1(t2._list, t1);
      t1 = _this._widget;
      _this._focusAttachment = t1.focusNode.attach$2$onKey(_this._element, t1.onKey);
      _this._hasFocus = _this.get$node().get$hasFocus();
    },
    _handleFocusChanged$0: function() {
      var _this = this;
      if (_this._hasFocus !== _this.get$node().get$hasFocus()) {
        _this.setState$1(new L._FocusState__handleFocusChanged_closure(_this));
        _this._widget.onFocusChange;
      }
    },
    build$1: function(context) {
      var t1;
      this._focusAttachment.reparent$0();
      t1 = this.get$node();
      return L._FocusMarker$(this._widget.child, t1);
    },
    $asState: function() {
      return [L.Focus];
    }
  };
  L._FocusState__handleFocusChanged_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._hasFocus = t1.get$node().get$hasFocus();
    },
    $signature: 2
  };
  L.FocusScope.prototype = {
    createState$0: function() {
      return new L._FocusScopeState(C._StateLifecycle_0);
    }
  };
  L._FocusScopeState.prototype = {
    build$1: function(context) {
      var t1, _null = null;
      this._focusAttachment.reparent$0();
      t1 = this.get$node();
      return T.Semantics$(_null, L._FocusMarker$(this._widget.child, t1), false, _null, true, _null, _null, _null, _null, _null, _null);
    }
  };
  L._FocusMarker.prototype = {
    $asInheritedNotifier: function() {
      return [O.FocusNode];
    }
  };
  N.UniqueKey.prototype = {
    toString$0: function(_) {
      return "[#" + Y.shortHash(this) + "]";
    }
  };
  N.GlobalKey.prototype = {
    _register$1: function(element) {
      H.assertHelper(new N.GlobalKey__register_closure(this, element).call$0());
      $.GlobalKey__registry.$indexSet(0, this, element);
    },
    _unregister$1: function(element) {
      H.assertHelper(new N.GlobalKey__unregister_closure(this, element).call$0());
      if (J.$eq$($.GlobalKey__registry.$index(0, this), element))
        $.GlobalKey__registry.remove$1(0, this);
    },
    _debugReserveFor$1: function($parent) {
      H.assertHelper(new N.GlobalKey__debugReserveFor_closure(this, $parent).call$0());
    },
    get$currentState: function() {
      var state,
        element = $.GlobalKey__registry.$index(0, this);
      if (element instanceof N.StatefulElement) {
        state = element._framework$_state;
        if (H.checkSubtypeOfRuntimeType(state, H.getTypeArgumentByIndex(this, 0)))
          return state;
      }
      return;
    }
  };
  N.GlobalKey__register_closure.prototype = {
    call$0: function() {
      var t2,
        t1 = this.$this;
      if ($.GlobalKey__registry.containsKey$1(t1)) {
        t2 = this.element;
        t2.get$widget();
        $.GlobalKey__registry.$index(0, t1).get$widget();
        H.assertHelper(!new H.TypeImpl(H.getRti(t2.get$widget())).$eq(0, new H.TypeImpl(H.getRti($.GlobalKey__registry.$index(0, t1).get$widget()))));
        $.$get$GlobalKey__debugIllFatedElements().add$1(0, $.GlobalKey__registry.$index(0, t1));
      }
      return true;
    },
    $signature: 0
  };
  N.GlobalKey__unregister_closure.prototype = {
    call$0: function() {
      var t2,
        t1 = this.$this;
      if ($.GlobalKey__registry.containsKey$1(t1) && !J.$eq$($.GlobalKey__registry.$index(0, t1), this.element)) {
        t2 = this.element;
        t2.get$widget();
        $.GlobalKey__registry.$index(0, t1).get$widget();
        H.assertHelper(!new H.TypeImpl(H.getRti(t2.get$widget())).$eq(0, new H.TypeImpl(H.getRti($.GlobalKey__registry.$index(0, t1).get$widget()))));
      }
      return true;
    },
    $signature: 0
  };
  N.GlobalKey__debugReserveFor_closure.prototype = {
    call$0: function() {
      var older, newer, _this = this,
        _s50_ = "Multiple widgets used the same GlobalKey.\nThe key ",
        _s78_ = "\nA GlobalKey can only be specified on one widget at a time in the widget tree.",
        t1 = _this.$this;
      if ($.GlobalKey__debugReservations.containsKey$1(t1) && !J.$eq$($.GlobalKey__debugReservations.$index(0, t1), _this.parent)) {
        older = J.toString$0$($.GlobalKey__debugReservations.$index(0, t1));
        newer = _this.parent.toString$0(0);
        if (older !== newer)
          throw H.wrapException(U.FlutterError$(_s50_ + t1.toString$0(0) + " was used by multiple widgets. The parents of those widgets were:\n- " + older + "\n- " + newer + _s78_));
        throw H.wrapException(U.FlutterError$(_s50_ + t1.toString$0(0) + " was used by multiple widgets. The parents of those widgets were different widgets that both had the following description:\n  " + newer + _s78_));
      }
      $.GlobalKey__debugReservations.$indexSet(0, t1, _this.parent);
      return true;
    },
    $signature: 0
  };
  N.GlobalKey__debugVerifyIllFatedPopulation_closure.prototype = {
    call$0: function() {
      var t1, t2, t3, t4, duplicates, t5, key, elements, buffer;
      for (t1 = $.$get$GlobalKey__debugIllFatedElements(), t1 = new P._HashSetIterator(t1, t1._computeElements$0(), [H.getTypeArgumentByIndex(t1, 0)]), t2 = [[N.State, N.StatefulWidget]], t3 = [N.GlobalKey, [N.State, N.StatefulWidget]], t4 = [P.Set, N.Element], duplicates = null; t1.moveNext$0();) {
        t5 = t1._collection$_current;
        if (t5._debugLifecycleState !== C._ElementLifecycle_3) {
          H.assertHelper(t5 != null);
          t5.get$widget();
          H.assertHelper(t5.get$widget().key != null);
          key = H.assertSubtype(t5.get$widget().key, "$isGlobalKey", t2, "$asGlobalKey");
          H.assertHelper($.GlobalKey__registry.containsKey$1(key));
          if (duplicates == null)
            duplicates = P.LinkedHashMap_LinkedHashMap$_empty(t3, t4);
          elements = duplicates.putIfAbsent$2(key, new N.GlobalKey__debugVerifyIllFatedPopulation__closure());
          elements.add$1(0, t5);
          elements.add$1(0, $.GlobalKey__registry.$index(0, key));
        }
      }
      $.$get$GlobalKey__debugIllFatedElements().clear$0(0);
      $.GlobalKey__debugReservations.clear$0(0);
      if (duplicates != null) {
        buffer = new P.StringBuffer("");
        buffer._contents = "Multiple widgets used the same GlobalKey.\n\n";
        for (t1 = duplicates.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
          t2 = t1.get$current();
          elements = duplicates.$index(0, t2);
          buffer._contents += "The key " + H.S(t2) + " was used by " + elements.get$length(elements) + " widgets:\n";
          for (t2 = elements.get$iterator(elements); t2.moveNext$0();)
            buffer._contents += "- " + H.S(t2.get$current()) + "\n";
        }
        buffer._contents += "A GlobalKey can only be specified on one widget at a time in the widget tree.";
        throw H.wrapException(U.FlutterError$(buffer.toString$0(0)));
      }
      return true;
    },
    $signature: 0
  };
  N.GlobalKey__debugVerifyIllFatedPopulation__closure.prototype = {
    call$0: function() {
      return P.HashSet_HashSet(N.Element);
    },
    $signature: 134
  };
  N.LabeledGlobalKey.prototype = {
    toString$0: function(_) {
      var _this = this,
        t1 = _this._framework$_debugLabel,
        label = t1 != null ? " " + t1 : "";
      if (new H.TypeImpl(H.getRti(_this)).$eq(0, C.Type_LabeledGlobalKey_6TW))
        return "[GlobalKey#" + Y.shortHash(_this) + label + "]";
      return "[" + (_this.get$runtimeType(_this).toString$0(0) + "#" + Y.shortHash(_this)) + label + "]";
    }
  };
  N.GlobalObjectKey.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(this))))
        return false;
      return this.value == H.assertSubtype(other, "$isGlobalObjectKey", this.$ti, "$asGlobalObjectKey").value;
    },
    get$hashCode: function(_) {
      return H.objectHashCode(this.value);
    },
    toString$0: function(_) {
      var selfType = new H.TypeImpl(H.getRti(this)).get$_typeName(),
        t1 = this.value;
      return "[" + (C.JSString_methods.endsWith$1(selfType, "<State<StatefulWidget>>") ? C.JSString_methods.substring$2(selfType, 0, selfType.length - 23) : selfType) + " " + (J.get$runtimeType$(t1).toString$0(0) + "#" + Y.shortHash(t1)) + "]";
    }
  };
  N.TypeMatcher.prototype = {};
  N.Widget.prototype = {
    toStringShort$0: function() {
      var t1 = this.key;
      return t1 == null ? new H.TypeImpl(H.getRti(this)).toString$0(0) : new H.TypeImpl(H.getRti(this)).toString$0(0) + "-" + t1.toString$0(0);
    },
    debugFillProperties$1: function(properties) {
      this.super$Diagnosticable$debugFillProperties(properties);
      properties.defaultDiagnosticsTreeStyle = C.DiagnosticsTreeStyle_2;
    }
  };
  N.StatelessWidget.prototype = {
    createElement$0: function() {
      var t1 = ($.Element__nextHashCode + 1) % 16777215;
      $.Element__nextHashCode = t1;
      return new N.StatelessElement(t1, this, C._ElementLifecycle_0);
    }
  };
  N.StatefulWidget.prototype = {
    createElement$0: function() {
      return N.StatefulElement$(this);
    }
  };
  N._StateLifecycle.prototype = {
    toString$0: function(_) {
      return this._framework$_name;
    }
  };
  N.State.prototype = {
    get$widget: function() {
      return this._widget;
    },
    initState$0: function() {
      H.assertHelper(this._debugLifecycleState === C._StateLifecycle_0);
    },
    didUpdateWidget$1: function(oldWidget) {
      H.assertSubtypeOfRuntimeType(oldWidget, H.getRuntimeTypeArgument(this, "State", 0));
    },
    setState$1: function(fn) {
      H.functionTypeCheck(fn, {func: 1, ret: -1});
      H.assertHelper(new N.State_setState_closure(this).call$0());
      H.assertHelper(new N.State_setState_closure0(this, fn.call$0()).call$0());
      this._element.markNeedsBuild$0();
    },
    deactivate$0: function() {
    },
    dispose$0: function() {
      H.assertHelper(this._debugLifecycleState === C._StateLifecycle_2);
      H.assertHelper(new N.State_dispose_closure(this).call$0());
    },
    didChangeDependencies$0: function() {
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this;
      _this.super$Diagnosticable$debugFillProperties(properties);
      H.assertHelper(new N.State_debugFillProperties_closure(_this, properties).call$0());
      t1 = Y.ObjectFlagProperty$("_widget", _this._widget, "no widget", H.getRuntimeTypeArgument(_this, "State", 0));
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.ObjectFlagProperty$("_element", _this._element, "not mounted", N.StatefulElement));
    },
    set$_widget: function(_widget) {
      this._widget = H.assertSubtypeOfRuntimeType(_widget, H.getRuntimeTypeArgument(this, "State", 0));
    }
  };
  N.State_setState_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._debugLifecycleState;
      if (t2 === C._StateLifecycle_3)
        throw H.wrapException(U.FlutterError$("setState() called after dispose(): " + t1.toString$0(0) + '\nThis error happens if you call setState() on a State object for a widget that no longer appears in the widget tree (e.g., whose parent widget no longer includes the widget in its build). This error can occur when code calls setState() from a timer or an animation callback. The preferred solution is to cancel the timer or stop listening to the animation in the dispose() callback. Another solution is to check the "mounted" property of this object before calling setState() to ensure the object is still in the tree.\nThis error might indicate a memory leak if setState() is being called because another object is retaining a reference to this State object after it has been removed from the tree. To avoid memory leaks, consider breaking the reference to this object during dispose().'));
      if (t2 === C._StateLifecycle_0 && t1._element == null)
        throw H.wrapException(U.FlutterError$("setState() called in constructor: " + t1.toString$0(0) + "\nThis happens when you call setState() on a State object for a widget that hasn't been inserted into the widget tree yet. It is not necessary to call setState() in the constructor, since the state is already assumed to be dirty when it is initially created."));
      return true;
    },
    $signature: 0
  };
  N.State_setState_closure0.prototype = {
    call$0: function() {
      if (!!J.getInterceptor$(this.result).$isFuture)
        throw H.wrapException(U.FlutterError$("setState() callback argument returned a Future.\nThe setState() method on " + this.$this.toString$0(0) + ' was called with a closure or method that returned a Future. Maybe it is marked as "async".\nInstead of performing asynchronous work inside a call to setState(), first execute the work (without updating the widget state), and then synchronously update the state inside a call to setState().'));
      return true;
    },
    $signature: 0
  };
  N.State_dispose_closure.prototype = {
    call$0: function() {
      this.$this._debugLifecycleState = C._StateLifecycle_3;
      return true;
    },
    $signature: 0
  };
  N.State_debugFillProperties_closure.prototype = {
    call$0: function() {
      var _null = null,
        t1 = this.$this._debugLifecycleState;
      C.JSArray_methods.add$1(this.properties.properties, new Y.EnumProperty(_null, _null, _null, _null, false, t1, C._StateLifecycle_2, C.DiagnosticLevel_3, "lifecycle state", true, true, C.DiagnosticsTreeStyle_5, [N._StateLifecycle]));
      return true;
    },
    $signature: 0
  };
  N.ProxyWidget.prototype = {};
  N.ParentDataWidget.prototype = {
    createElement$0: function() {
      var t1 = ($.Element__nextHashCode + 1) % 16777215;
      $.Element__nextHashCode = t1;
      return new N.ParentDataElement(t1, this, C._ElementLifecycle_0, [H.getRuntimeTypeArgument(this, "ParentDataWidget", 0)]);
    },
    debugDescribeInvalidAncestorChain$4$badAncestors$description$foundValidAncestor$ownershipChain: function(badAncestors, description, foundValidAncestor, ownershipChain) {
      var t1, result, t2, _i, ancestor, _this = this;
      H.assertSubtype(badAncestors, "$isIterable", [N.Widget], "$asIterable");
      t1 = H.getRuntimeTypeArgument(_this, "ParentDataWidget", 0);
      H.assertHelper(!new H.TypeImpl(t1).$eq(0, C.Type_dynamic_0Rz));
      H.assertHelper(!new H.TypeImpl(t1).$eq(0, C.Type_RenderObjectWidget_gmA));
      if (!foundValidAncestor)
        result = new H.TypeImpl(H.getRti(_this)).toString$0(0) + " widgets must be placed inside " + new H.TypeImpl(t1).toString$0(0) + " widgets.\n" + description + " has no " + new H.TypeImpl(t1).toString$0(0) + " ancestor at all.\n";
      else {
        H.assertHelper(badAncestors.length !== 0);
        result = new H.TypeImpl(H.getRti(_this)).toString$0(0) + " widgets must be placed directly inside " + new H.TypeImpl(t1).toString$0(0) + " widgets.\n" + description + " has a " + new H.TypeImpl(t1).toString$0(0) + " ancestor, but there are other widgets between them:\n";
        for (t2 = badAncestors.length, _i = 0; _i < badAncestors.length; badAncestors.length === t2 || (0, H.throwConcurrentModificationError)(badAncestors), ++_i) {
          ancestor = badAncestors[_i];
          result = ancestor.get$runtimeType(ancestor).$eq(0, new H.TypeImpl(H.getRti(_this))) ? result + ("- " + ancestor.toString$0(0) + " (this is a different " + new H.TypeImpl(H.getRti(_this)).toString$0(0) + " than the one with the problem)\n") : result + ("- " + ancestor.toString$0(0) + "\n");
        }
        result += "These widgets cannot come between a " + new H.TypeImpl(H.getRti(_this)).toString$0(0) + " and its " + new H.TypeImpl(t1).toString$0(0) + ".\n";
      }
      return result + ("The ownership chain for the parent of the offending " + new H.TypeImpl(H.getRti(_this)).toString$0(0) + " was:\n  " + ownershipChain);
    }
  };
  N.InheritedWidget.prototype = {
    createElement$0: function() {
      var t1 = P.HashMap_HashMap(N.Element, P.Object),
        t2 = ($.Element__nextHashCode + 1) % 16777215;
      $.Element__nextHashCode = t2;
      return new N.InheritedElement(t1, t2, this, C._ElementLifecycle_0);
    }
  };
  N.RenderObjectWidget.prototype = {
    updateRenderObject$2: function(context, renderObject) {
    },
    didUnmountRenderObject$1: function(renderObject) {
    }
  };
  N.LeafRenderObjectWidget.prototype = {
    createElement$0: function() {
      var t1 = ($.Element__nextHashCode + 1) % 16777215;
      $.Element__nextHashCode = t1;
      return new N.LeafRenderObjectElement(t1, this, C._ElementLifecycle_0);
    }
  };
  N.SingleChildRenderObjectWidget.prototype = {
    createElement$0: function() {
      var t1 = ($.Element__nextHashCode + 1) % 16777215;
      $.Element__nextHashCode = t1;
      return new N.SingleChildRenderObjectElement(t1, this, C._ElementLifecycle_0);
    }
  };
  N.MultiChildRenderObjectWidget.prototype = {
    createElement$0: function() {
      var t1 = P.HashSet_HashSet(N.Element),
        t2 = ($.Element__nextHashCode + 1) % 16777215;
      $.Element__nextHashCode = t2;
      return new N.MultiChildRenderObjectElement(t1, t2, this, C._ElementLifecycle_0);
    }
  };
  N._ElementLifecycle.prototype = {
    toString$0: function(_) {
      return this._framework$_name;
    }
  };
  N._InactiveElements.prototype = {
    _unmount$1: function(element) {
      H.interceptedTypeCheck(element, "$isElement");
      H.assertHelper(element._debugLifecycleState === C._ElementLifecycle_2);
      H.assertHelper(new N._InactiveElements__unmount_closure(element).call$0());
      element.visitChildren$1(new N._InactiveElements__unmount_closure0(this, element));
      element.unmount$0();
      H.assertHelper(element._debugLifecycleState === C._ElementLifecycle_3);
    },
    _unmountAll$0: function() {
      var elements, t1, elements0, t2, _this = this;
      _this._locked = true;
      t1 = _this._elements;
      elements0 = t1.toList$0(0);
      C.JSArray_methods.sort$1(elements0, N.framework_Element__sort$closure());
      elements = elements0;
      t1.clear$0(0);
      try {
        t2 = elements;
        new H.ReversedListIterable(t2, [H.getTypeArgumentByIndex(t2, 0)]).forEach$1(0, _this.get$_unmount());
      } finally {
        H.assertHelper(t1._collection$_length === 0);
        _this._locked = false;
      }
    },
    _deactivateRecursively$1: function(element) {
      H.assertHelper(element._debugLifecycleState === C._ElementLifecycle_1);
      element.deactivate$0();
      H.assertHelper(element._debugLifecycleState === C._ElementLifecycle_2);
      element.visitChildren$1(this.get$_deactivateRecursively());
      H.assertHelper(new N._InactiveElements__deactivateRecursively_closure(element).call$0());
    },
    remove$1: function(_, element) {
      var t1;
      H.assertHelper(!this._locked);
      t1 = this._elements;
      H.assertHelper(t1.contains$1(0, element));
      H.assertHelper(element._framework$_parent == null);
      t1.remove$1(0, element);
      H.assertHelper(!element._active);
    }
  };
  N._InactiveElements__unmount_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  N._InactiveElements__unmount_closure0.prototype = {
    call$1: function(child) {
      H.assertHelper(J.$eq$(child._framework$_parent, this.element));
      this.$this._unmount$1(child);
    },
    $signature: 15
  };
  N._InactiveElements__deactivateRecursively_closure.prototype = {
    call$0: function() {
      this.element.debugDeactivated$0();
      return true;
    },
    $signature: 0
  };
  N.BuildContext.prototype = {};
  N.BuildOwner.prototype = {
    scheduleBuildFor$1: function(element) {
      var _this = this;
      H.assertHelper(element._owner === _this);
      H.assertHelper(new N.BuildOwner_scheduleBuildFor_closure(_this, element).call$0());
      if (element._inDirtyList) {
        H.assertHelper(new N.BuildOwner_scheduleBuildFor_closure0(_this).call$0());
        _this._dirtyElementsNeedsResorting = true;
        return;
      }
      if (!_this._scheduledFlushDirtyElements && _this.onBuildScheduled != null) {
        _this._scheduledFlushDirtyElements = true;
        _this.onBuildScheduled.call$0();
      }
      C.JSArray_methods.add$1(_this._dirtyElements, element);
      element._inDirtyList = true;
      H.assertHelper(new N.BuildOwner_scheduleBuildFor_closure1(_this).call$0());
    },
    lockState$1: function(callback) {
      var _this = this;
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      H.assertHelper(callback != null);
      H.assertHelper(_this._debugStateLockLevel >= 0);
      H.assertHelper(new N.BuildOwner_lockState_closure(_this).call$0());
      try {
        callback.call$0();
      } finally {
        H.assertHelper(new N.BuildOwner_lockState_closure0(_this).call$0());
      }
      H.assertHelper(_this._debugStateLockLevel >= 0);
    },
    buildScope$2: function(context, callback) {
      var e, stack, element, t1, t2, t3, t4, exception, t5, t6, _i, _this = this, _box_0 = {};
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      if (callback == null && _this._dirtyElements.length === 0)
        return;
      H.assertHelper(context != null);
      H.assertHelper(_this._debugStateLockLevel >= 0);
      H.assertHelper(!_this._debugBuilding);
      H.assertHelper(new N.BuildOwner_buildScope_closure(_this, context).call$0());
      P.Timeline_startSync("Build", C.Map_9aZ6I, null);
      try {
        _this._scheduledFlushDirtyElements = true;
        if (callback != null) {
          H.assertHelper(_this._debugStateLockLevel > 0);
          _box_0.debugPreviousBuildTarget = null;
          H.assertHelper(new N.BuildOwner_buildScope_closure0(_box_0, _this, context).call$0());
          _this._dirtyElementsNeedsResorting = false;
          try {
            callback.call$0();
          } finally {
            H.assertHelper(new N.BuildOwner_buildScope_closure1(_box_0, _this, context).call$0());
          }
        }
        t1 = _this._dirtyElements;
        C.JSArray_methods.sort$1(t1, N.framework_Element__sort$closure());
        _this._dirtyElementsNeedsResorting = false;
        _box_0.dirtyCount = t1.length;
        _box_0.index = 0;
        for (t2 = H.getTypeArgumentByIndex(t1, 0), t3 = {func: 1, ret: P.int, args: [t2, t2]}, t4 = 0; t4 < _box_0.dirtyCount;) {
          if (t4 < 0 || t4 >= t1.length)
            return H.ioore(t1, t4);
          H.assertHelper(t1[t4]._inDirtyList);
          t4 = _box_0.index;
          if (t4 < 0 || t4 >= t1.length)
            return H.ioore(t1, t4);
          t4 = t1[t4];
          H.assertHelper(!t4._active || t4._debugIsInScope$1(context));
          try {
            t4 = _box_0.index;
            if (t4 < 0 || t4 >= t1.length)
              return H.ioore(t1, t4);
            t1[t4].rebuild$0();
          } catch (exception) {
            e = H.unwrapException(exception);
            stack = H.getTraceFromException(exception);
            U.assertions_FlutterError_dumpErrorToConsole$closure().call$1(new U.FlutterErrorDetails(e, stack, "widgets library", "while rebuilding dirty elements", new N.BuildOwner_buildScope_closure2(_box_0, _this), false));
          }
          t4 = ++_box_0.index;
          t5 = _box_0.dirtyCount;
          t6 = t1.length;
          if (t5 < t6 || H.boolConversionCheck(_this._dirtyElementsNeedsResorting)) {
            H.functionTypeCheck(N.framework_Element__sort$closure(), t3);
            t4 = t6 - 1;
            if (t4 - 0 <= 32)
              H.Sort__insertionSort(t1, 0, t4, N.framework_Element__sort$closure(), t2);
            else
              H.Sort__dualPivotQuicksort(t1, 0, t4, N.framework_Element__sort$closure(), t2);
            t4 = _this._dirtyElementsNeedsResorting = false;
            _box_0.dirtyCount = t1.length;
            while (true) {
              t5 = _box_0.index;
              if (t5 > 0) {
                t6 = t5 - 1;
                if (t6 >= t1.length)
                  return H.ioore(t1, t6);
                t6 = t1[t6]._dirty;
              } else
                t6 = t4;
              if (!t6)
                break;
              _box_0.index = t5 - 1;
            }
            t4 = t5;
          }
        }
        H.assertHelper(new N.BuildOwner_buildScope_closure3(_this).call$0());
      } finally {
        for (t1 = _this._dirtyElements, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          element = t1[_i];
          H.assertHelper(element._inDirtyList);
          element._inDirtyList = false;
        }
        C.JSArray_methods.set$length(t1, 0);
        _this._scheduledFlushDirtyElements = false;
        _this._dirtyElementsNeedsResorting = null;
        P.Timeline_finishSync();
        H.assertHelper(_this._debugBuilding);
        H.assertHelper(new N.BuildOwner_buildScope_closure4(_this).call$0());
      }
      H.assertHelper(_this._debugStateLockLevel >= 0);
    },
    buildScope$1: function(context) {
      return this.buildScope$2(context, null);
    },
    _debugTrackElementThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans$2: function(node, key) {
      H.assertSubtype(key, "$isGlobalKey", [[N.State, N.StatefulWidget]], "$asGlobalKey");
      if (this._debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans == null)
        this.set$_debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans(P.HashMap_HashMap(N.Element, [P.Set, [N.GlobalKey, [N.State, N.StatefulWidget]]]));
      this._debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans.putIfAbsent$2(node, new N.BuildOwner__debugTrackElementThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans_closure()).add$1(0, key);
    },
    _debugElementWasRebuilt$1: function(node) {
      var t1 = this._debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans;
      if (t1 != null)
        t1.remove$1(0, node);
    },
    finalizeTree$0: function() {
      var e, stack, exception;
      P.Timeline_startSync("Finalize tree", C.Map_9aZ6I, null);
      try {
        this.lockState$1(new N.BuildOwner_finalizeTree_closure(this));
        H.assertHelper(new N.BuildOwner_finalizeTree_closure0(this).call$0());
      } catch (exception) {
        e = H.unwrapException(exception);
        stack = H.getTraceFromException(exception);
        N._debugReportException("while finalizing the widget tree", e, stack, null);
      } finally {
        P.Timeline_finishSync();
      }
    },
    reassemble$1: function(root) {
      P.Timeline_startSync("Dirty Element Tree", null, null);
      try {
        H.assertHelper(root._framework$_parent == null);
        H.assertHelper(root._owner === this);
        root.reassemble$0();
      } finally {
        P.Timeline_finishSync();
      }
    },
    set$onBuildScheduled: function(onBuildScheduled) {
      this.onBuildScheduled = H.functionTypeCheck(onBuildScheduled, {func: 1, ret: -1});
    },
    set$_debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans: function(_debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans) {
      this._debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans = H.assertSubtype(_debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans, "$isMap", [N.Element, [P.Set, [N.GlobalKey, [N.State, N.StatefulWidget]]]], "$asMap");
    }
  };
  N.BuildOwner_scheduleBuildFor_closure.prototype = {
    call$0: function() {
      var t1 = this.element;
      if (!t1._dirty)
        throw H.wrapException(U.FlutterError$("scheduleBuildFor() called for a widget that is not marked as dirty.\nThe method was called for the following element:\n  " + t1.toString$0(0) + "\nThis element is not current marked as dirty. Make sure to set the dirty flag before calling scheduleBuildFor().\nIf you did not attempt to call scheduleBuildFor() yourself, then this probably indicates a bug in the widgets framework. Please report it: https://github.com/flutter/flutter/issues/new?template=BUG.md"));
      return true;
    },
    $signature: 0
  };
  N.BuildOwner_scheduleBuildFor_closure0.prototype = {
    call$0: function() {
      if (this.$this._dirtyElementsNeedsResorting == null)
        throw H.wrapException(U.FlutterError$("BuildOwner.scheduleBuildFor() called inappropriately.\nThe BuildOwner.scheduleBuildFor() method should only be called while the buildScope() method is actively rebuilding the widget tree."));
      return true;
    },
    $signature: 0
  };
  N.BuildOwner_scheduleBuildFor_closure1.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  N.BuildOwner_lockState_closure.prototype = {
    call$0: function() {
      ++this.$this._debugStateLockLevel;
      return true;
    },
    $signature: 0
  };
  N.BuildOwner_lockState_closure0.prototype = {
    call$0: function() {
      --this.$this._debugStateLockLevel;
      return true;
    },
    $signature: 0
  };
  N.BuildOwner_buildScope_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      ++t1._debugStateLockLevel;
      return t1._debugBuilding = true;
    },
    $signature: 0
  };
  N.BuildOwner_buildScope_closure0.prototype = {
    call$0: function() {
      var t2,
        t1 = this.context;
      t1._debugSetAllowIgnoredCallsToMarkNeedsBuild$1(true);
      t2 = this.$this;
      this._box_0.debugPreviousBuildTarget = t2._debugCurrentBuildTarget;
      t2._debugCurrentBuildTarget = t1;
      return true;
    },
    $signature: 0
  };
  N.BuildOwner_buildScope_closure1.prototype = {
    call$0: function() {
      var t2,
        t1 = this.context;
      t1._debugSetAllowIgnoredCallsToMarkNeedsBuild$1(false);
      t2 = this.$this;
      H.assertHelper(J.$eq$(t2._debugCurrentBuildTarget, t1));
      t2._debugCurrentBuildTarget = this._box_0.debugPreviousBuildTarget;
      t2._debugElementWasRebuilt$1(t1);
      return true;
    },
    $signature: 0
  };
  N.BuildOwner_buildScope_closure2.prototype = {
    call$1: function(information) {
      var t2,
        t1 = this._box_0;
      information._contents += "The element being rebuilt at the time was index " + t1.index + " of " + t1.dirtyCount + ":\n";
      t2 = this.$this._dirtyElements;
      t1 = t1.index;
      if (t1 < 0 || t1 >= t2.length)
        return H.ioore(t2, t1);
      information._contents += "  " + t2[t1].toString$0(0);
    },
    $signature: 3
  };
  N.BuildOwner_buildScope_closure3.prototype = {
    call$0: function() {
      var t1 = this.$this._dirtyElements;
      if (C.JSArray_methods.any$1(t1, new N.BuildOwner_buildScope__closure()))
        throw H.wrapException(U.FlutterError$("buildScope missed some dirty elements.\nThis probably indicates that the dirty list should have been resorted but was not.\nThe list of dirty elements at the end of the buildScope call was:\n  " + H.S(t1)));
      return true;
    },
    $signature: 0
  };
  N.BuildOwner_buildScope__closure.prototype = {
    call$1: function(element) {
      H.interceptedTypeCheck(element, "$isElement");
      return element._active && element._dirty;
    },
    $signature: 22
  };
  N.BuildOwner_buildScope_closure4.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._debugBuilding = false;
      --t1._debugStateLockLevel;
      return true;
    },
    $signature: 0
  };
  N.BuildOwner__debugTrackElementThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans_closure.prototype = {
    call$0: function() {
      return P.HashSet_HashSet([N.GlobalKey, [N.State, N.StatefulWidget]]);
    },
    $signature: 137
  };
  N.BuildOwner_finalizeTree_closure.prototype = {
    call$0: function() {
      this.$this._inactiveElements._unmountAll$0();
    },
    $signature: 2
  };
  N.BuildOwner_finalizeTree_closure0.prototype = {
    call$0: function() {
      var keys, element, keyStringCount, key, keyLabels, elements, elementStringCount, element0, elementLabels, the, s, were, their, respective, those, s2, those2, they, think, are, t1, t2, t3, t4, t5, t6, t7,
        _s16_ = " previous parent";
      try {
        N.GlobalKey__debugVerifyIllFatedPopulation();
        t1 = this.$this;
        t2 = t1._debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans;
        if (t2 != null && t2._collection$_length !== 0) {
          keys = P.HashSet_HashSet([N.GlobalKey, [N.State, N.StatefulWidget]]);
          for (t2 = t1._debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans, t2.toString, t2 = new P._HashMapKeyIterable(t2, [H.getTypeArgumentByIndex(t2, 0)]), t2 = t2.get$iterator(t2); t2.moveNext$0();) {
            element = t2._collection$_current;
            if (element._debugLifecycleState !== C._ElementLifecycle_3)
              J.addAll$1$ax(keys, t1._debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans.$index(0, element));
          }
          if (keys._collection$_length !== 0) {
            t2 = P.String;
            t3 = P.int;
            keyStringCount = P.HashMap_HashMap(t2, t3);
            for (t4 = keys, t5 = H.getTypeArgumentByIndex(t4, 0), t6 = H.functionTypeCheck(new N.BuildOwner_finalizeTree__closure(), {func: 1, ret: t2, args: [t5]}), t5 = new H.MappedIterator(J.get$iterator$ax(t4), t6, [t5, t2]); t5.moveNext$0();) {
              key = t5._current;
              if (keyStringCount.containsKey$1(key)) {
                t4 = keyStringCount;
                t6 = key;
                t7 = J.getInterceptor$asx(t4);
                t7.$indexSet(t4, t6, J.$add$ansx(t7.$index(t4, t6), 1));
              } else
                J.$indexSet$ax(keyStringCount, key, 1);
            }
            t4 = [t2];
            keyLabels = H.setRuntimeTypeInfo([], t4);
            J.forEach$1$ax(keyStringCount, new N.BuildOwner_finalizeTree__closure0(keyLabels));
            t1 = t1._debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans;
            t1.toString;
            elements = new P._HashMapKeyIterable(t1, [H.getTypeArgumentByIndex(t1, 0)]);
            elementStringCount = P.HashMap_HashMap(t2, t3);
            for (t1 = elements, t3 = H.getRuntimeTypeArgumentIntercepted(J.getInterceptor$(t1), t1, "Iterable", 0), t2 = H.MappedIterable_MappedIterable(t1, H.functionTypeCheck(new N.BuildOwner_finalizeTree__closure1(), {func: 1, ret: t2, args: [t3]}), t3, t2), t2 = new H.MappedIterator(J.get$iterator$ax(t2._iterable), t2._f, [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]); t2.moveNext$0();) {
              element0 = t2._current;
              if (elementStringCount.containsKey$1(element0)) {
                t1 = elementStringCount;
                t3 = element0;
                t5 = J.getInterceptor$asx(t1);
                t5.$indexSet(t1, t3, J.$add$ansx(t5.$index(t1, t3), 1));
              } else
                J.$indexSet$ax(elementStringCount, element0, 1);
            }
            elementLabels = H.setRuntimeTypeInfo([], t4);
            J.forEach$1$ax(elementStringCount, new N.BuildOwner_finalizeTree__closure2(elementLabels));
            H.assertHelper(J.get$length$asx(keyLabels) !== 0);
            the = keys._collection$_length === 1 ? " the" : "";
            s = keys._collection$_length === 1 ? "" : "s";
            were = keys._collection$_length === 1 ? "was" : "were";
            their = keys._collection$_length === 1 ? "its" : "their";
            respective = J.get$length$asx(elementLabels) === 1 ? "" : " respective";
            those = keys._collection$_length === 1 ? "that" : "those";
            s2 = J.get$length$asx(elementLabels) === 1 ? "" : "s";
            those2 = J.get$length$asx(elementLabels) === 1 ? "that" : "those";
            they = J.get$length$asx(elementLabels) === 1 ? "it" : "they";
            think = J.get$length$asx(elementLabels) === 1 ? "thinks" : "think";
            are = J.get$length$asx(elementLabels) === 1 ? "is" : "are";
            t1 = U.FlutterError$("Duplicate GlobalKey" + H.S(s) + " detected in widget tree.\nThe following GlobalKey" + H.S(s) + " " + H.S(were) + " specified multiple times in the widget tree. This will lead to parts of the widget tree being truncated unexpectedly, because the second time a key is seen, the previous instance is moved to the new location. The key" + H.S(s) + " " + H.S(were) + ":\n- " + J.join$1$ax(keyLabels, "\n  ") + "\nThis was determined by noticing that after" + H.S(the) + " widget" + H.S(s) + " with the above global key" + H.S(s) + " " + H.S(were) + " moved out of " + H.S(their) + H.S(respective) + _s16_ + H.S(s2) + ", " + H.S(those2) + _s16_ + H.S(s2) + " never updated during this frame, meaning that " + H.S(they) + " either did not update at all or updated before the widget" + H.S(s) + " " + H.S(were) + " moved, in either case implying that " + H.S(they) + " still " + H.S(think) + " that " + H.S(they) + " should have a child with " + H.S(those) + " global key" + H.S(s) + ".\nThe specific parent" + H.S(s2) + " that did not update after having one or more children forcibly removed due to GlobalKey reparenting " + H.S(are) + ":\n- " + J.join$1$ax(elementLabels, "\n  ") + "\nA GlobalKey can only be specified on one widget at a time in the widget tree.");
            throw H.wrapException(t1);
          }
        }
      } finally {
        t1 = this.$this._debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans;
        if (t1 != null)
          if (t1._collection$_length > 0) {
            t1._collection$_strings = t1._collection$_nums = t1._collection$_rest = t1._collection$_keys = null;
            t1._collection$_length = 0;
          }
      }
      return true;
    },
    $signature: 0
  };
  N.BuildOwner_finalizeTree__closure.prototype = {
    call$1: function(key) {
      H.assertSubtype(key, "$isGlobalKey", [[N.State, N.StatefulWidget]], "$asGlobalKey");
      return J.toString$0$(key);
    },
    $signature: 138
  };
  N.BuildOwner_finalizeTree__closure0.prototype = {
    call$2: function(key, count) {
      var t1;
      H.stringTypeCheck(key);
      H.intTypeCheck(count);
      t1 = this.keyLabels;
      if (J.$eq$(count, 1))
        C.JSArray_methods.add$1(t1, key);
      else
        C.JSArray_methods.add$1(t1, H.S(key) + " (" + H.S(count) + " different affected keys had this toString representation)");
    },
    $signature: 51
  };
  N.BuildOwner_finalizeTree__closure1.prototype = {
    call$1: function(element) {
      H.interceptedTypeCheck(element, "$isElement");
      return J.toString$0$(element);
    },
    $signature: 140
  };
  N.BuildOwner_finalizeTree__closure2.prototype = {
    call$2: function(element, count) {
      var t1;
      H.stringTypeCheck(element);
      H.intTypeCheck(count);
      t1 = this.elementLabels;
      if (J.$eq$(count, 1))
        C.JSArray_methods.add$1(t1, element);
      else
        C.JSArray_methods.add$1(t1, H.S(element) + " (" + H.S(count) + " different affected elements had this toString representation)");
    },
    $signature: 51
  };
  N.Element.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      return this === other;
    },
    get$hashCode: function(_) {
      return this._cachedHash;
    },
    get$widget: function() {
      return this._widget;
    },
    reassemble$0: function() {
      this.markNeedsBuild$0();
      this.visitChildren$1(new N.Element_reassemble_closure());
    },
    _debugIsInScope$1: function(target) {
      var t1, current;
      for (t1 = J.getInterceptor$(target), current = this; current != null;) {
        if (t1.$eq(target, current))
          return true;
        current = current._framework$_parent;
      }
      return false;
    },
    get$renderObject: function() {
      var t1 = {};
      t1.result = null;
      new N.Element_renderObject_visit(t1).call$1(this);
      return t1.result;
    },
    visitChildren$1: function(visitor) {
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [N.Element]});
    },
    visitChildElements$1: function(visitor) {
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [N.Element]});
      H.assertHelper(new N.Element_visitChildElements_closure(this).call$0());
      this.visitChildren$1(visitor);
    },
    updateChild$3: function(child, newWidget, newSlot) {
      var _this = this;
      H.assertHelper(new N.Element_updateChild_closure(_this, newWidget).call$0());
      if (newWidget == null) {
        if (child != null)
          _this.deactivateChild$1(child);
        return;
      }
      if (child != null) {
        if (child.get$widget() === newWidget) {
          if (!J.$eq$(child._slot, newSlot))
            _this.updateSlotForChild$2(child, newSlot);
          return child;
        }
        if (N.Widget_canUpdate(child.get$widget(), newWidget)) {
          if (!J.$eq$(child._slot, newSlot))
            _this.updateSlotForChild$2(child, newSlot);
          child.update$1(newWidget);
          H.assertHelper(child.get$widget() === newWidget);
          H.assertHelper(new N.Element_updateChild_closure0(child).call$0());
          return child;
        }
        _this.deactivateChild$1(child);
        H.assertHelper(child._framework$_parent == null);
      }
      return _this.inflateWidget$2(newWidget, newSlot);
    },
    mount$2: function($parent, newSlot) {
      var t1, t2, _this = this;
      H.assertHelper(_this._debugLifecycleState === C._ElementLifecycle_0);
      _this.get$widget();
      H.assertHelper(_this._framework$_parent == null);
      t1 = $parent != null;
      H.assertHelper(!t1 || $parent._debugLifecycleState === C._ElementLifecycle_1);
      H.assertHelper(_this._slot == null);
      H.assertHelper(_this._depth == null);
      H.assertHelper(!_this._active);
      _this._framework$_parent = $parent;
      _this._slot = newSlot;
      if (t1) {
        t2 = $parent._depth;
        if (typeof t2 !== "number")
          return t2.$add();
        ++t2;
      } else
        t2 = 1;
      _this._depth = t2;
      _this._active = true;
      if (t1)
        _this._owner = $parent._owner;
      if (!!J.getInterceptor$(_this.get$widget().key).$isGlobalKey)
        H.assertSubtype(_this.get$widget().key, "$isGlobalKey", [[N.State, N.StatefulWidget]], "$asGlobalKey")._register$1(_this);
      _this._updateInheritance$0();
      H.assertHelper(new N.Element_mount_closure(_this).call$0());
    },
    update$1: function(newWidget) {
      var t1, _this = this;
      if (_this._debugLifecycleState === C._ElementLifecycle_1) {
        _this.get$widget();
        t1 = newWidget != null && newWidget !== _this.get$widget() && _this._depth != null && _this._active && N.Widget_canUpdate(_this.get$widget(), newWidget);
      } else
        t1 = false;
      H.assertHelper(t1);
      _this._widget = newWidget;
    },
    updateSlotForChild$2: function(child, newSlot) {
      H.assertHelper(this._debugLifecycleState === C._ElementLifecycle_1);
      H.assertHelper(J.$eq$(child._framework$_parent, this));
      new N.Element_updateSlotForChild_visit(newSlot).call$1(child);
    },
    _updateSlot$1: function(newSlot) {
      var _this = this;
      H.assertHelper(_this._debugLifecycleState === C._ElementLifecycle_1);
      _this.get$widget();
      H.assertHelper(_this._framework$_parent != null);
      H.assertHelper(_this._framework$_parent._debugLifecycleState === C._ElementLifecycle_1);
      H.assertHelper(_this._depth != null);
      _this._slot = newSlot;
    },
    _updateDepth$1: function(parentDepth) {
      var expectedDepth, t1;
      if (typeof parentDepth !== "number")
        return parentDepth.$add();
      expectedDepth = parentDepth + 1;
      t1 = this._depth;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (t1 < expectedDepth) {
        this._depth = expectedDepth;
        this.visitChildren$1(new N.Element__updateDepth_closure(expectedDepth));
      }
    },
    detachRenderObject$0: function() {
      this.visitChildren$1(new N.Element_detachRenderObject_closure());
      this._slot = null;
    },
    attachRenderObject$1: function(newSlot) {
      H.assertHelper(this._slot == null);
      this.visitChildren$1(new N.Element_attachRenderObject_closure(newSlot));
      this._slot = newSlot;
    },
    _retakeInactiveElement$2: function(key, newWidget) {
      var element, $parent, t1;
      H.assertSubtype(key, "$isGlobalKey", [[N.State, N.StatefulWidget]], "$asGlobalKey");
      element = $.GlobalKey__registry.$index(0, key);
      if (element == null)
        return;
      if (!N.Widget_canUpdate(element.get$widget(), newWidget))
        return;
      H.assertHelper(new N.Element__retakeInactiveElement_closure(this, element).call$0());
      $parent = element._framework$_parent;
      if ($parent != null) {
        H.assertHelper(new N.Element__retakeInactiveElement_closure0(this, $parent, key, element).call$0());
        $parent.forgetChild$1(element);
        $parent.deactivateChild$1(element);
      }
      H.assertHelper(element._framework$_parent == null);
      t1 = this._owner._inactiveElements;
      H.assertHelper(!t1._locked);
      t1 = t1._elements;
      H.assertHelper(t1.contains$1(0, element));
      H.assertHelper(element._framework$_parent == null);
      t1.remove$1(0, element);
      H.assertHelper(!element._active);
      return element;
    },
    inflateWidget$2: function(newWidget, newSlot) {
      var key, newChild, updatedChild, _this = this;
      H.assertHelper(newWidget != null);
      key = newWidget.key;
      if (!!J.getInterceptor$(key).$isGlobalKey) {
        newChild = _this._retakeInactiveElement$2(key, newWidget);
        if (newChild != null) {
          H.assertHelper(newChild._framework$_parent == null);
          H.assertHelper(new N.Element_inflateWidget_closure(_this, newChild).call$0());
          newChild._activateWithParent$2(_this, newSlot);
          updatedChild = _this.updateChild$3(newChild, newWidget, newSlot);
          H.assertHelper(newChild.$eq(0, updatedChild));
          return updatedChild;
        }
      }
      newChild = newWidget.createElement$0();
      H.assertHelper(new N.Element_inflateWidget_closure0(_this, newChild).call$0());
      newChild.mount$2(_this, newSlot);
      H.assertHelper(newChild._debugLifecycleState === C._ElementLifecycle_1);
      return newChild;
    },
    _debugCheckForCycles$1: function(newChild) {
      H.assertHelper(newChild._framework$_parent == null);
      H.assertHelper(new N.Element__debugCheckForCycles_closure(this, newChild).call$0());
    },
    deactivateChild$1: function(child) {
      var t1, t2;
      H.assertHelper(child != null);
      H.assertHelper(J.$eq$(child._framework$_parent, this));
      child._framework$_parent = null;
      child.detachRenderObject$0();
      t1 = this._owner._inactiveElements;
      H.assertHelper(!t1._locked);
      t2 = t1._elements;
      H.assertHelper(!t2.contains$1(0, child));
      H.assertHelper(child._framework$_parent == null);
      if (child._active)
        t1._deactivateRecursively$1(child);
      t2.add$1(0, child);
      H.assertHelper(new N.Element_deactivateChild_closure(this, child).call$0());
    },
    _activateWithParent$2: function($parent, newSlot) {
      var _this = this;
      H.assertHelper(_this._debugLifecycleState === C._ElementLifecycle_2);
      _this._framework$_parent = $parent;
      H.assertHelper(new N.Element__activateWithParent_closure(_this).call$0());
      _this._updateDepth$1(_this._framework$_parent._depth);
      N.Element__activateRecursively(_this);
      _this.attachRenderObject$1(newSlot);
      H.assertHelper(_this._debugLifecycleState === C._ElementLifecycle_1);
    },
    activate$0: function() {
      var t1, t2, hadDependencies, _this = this;
      H.assertHelper(_this._debugLifecycleState === C._ElementLifecycle_2);
      _this.get$widget();
      H.assertHelper(_this._owner != null);
      H.assertHelper(_this._depth != null);
      H.assertHelper(!_this._active);
      t1 = _this._dependencies;
      t2 = t1 == null;
      hadDependencies = !t2 && t1._collection$_length !== 0 || _this._hadUnsatisfiedDependencies;
      _this._active = true;
      if (!t2)
        t1.clear$0(0);
      _this._hadUnsatisfiedDependencies = false;
      _this._updateInheritance$0();
      H.assertHelper(new N.Element_activate_closure(_this).call$0());
      if (_this._dirty)
        _this._owner.scheduleBuildFor$1(_this);
      if (hadDependencies)
        _this.didChangeDependencies$0();
    },
    deactivate$0: function() {
      var t1, _this = this;
      H.assertHelper(_this._debugLifecycleState === C._ElementLifecycle_1);
      _this.get$widget();
      H.assertHelper(_this._depth != null);
      H.assertHelper(_this._active);
      t1 = _this._dependencies;
      if (t1 != null && t1._collection$_length !== 0)
        for (t1 = new P._HashSetIterator(t1, t1._computeElements$0(), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
          t1._collection$_current._dependents.remove$1(0, _this);
      _this.set$_inheritedWidgets(null);
      _this._active = false;
      H.assertHelper(new N.Element_deactivate_closure(_this).call$0());
    },
    debugDeactivated$0: function() {
      H.assertHelper(this._debugLifecycleState === C._ElementLifecycle_2);
    },
    unmount$0: function() {
      var _this = this;
      H.assertHelper(_this._debugLifecycleState === C._ElementLifecycle_2);
      _this.get$widget();
      H.assertHelper(_this._depth != null);
      H.assertHelper(!_this._active);
      if (!!J.getInterceptor$(_this.get$widget().key).$isGlobalKey)
        H.assertSubtype(_this.get$widget().key, "$isGlobalKey", [[N.State, N.StatefulWidget]], "$asGlobalKey")._unregister$1(_this);
      H.assertHelper(new N.Element_unmount_closure(_this).call$0());
    },
    get$size: function() {
      H.assertHelper(new N.Element_size_closure(this).call$0());
      var renderObject = this.get$renderObject();
      H.assertHelper(new N.Element_size_closure0(this, renderObject).call$0());
      if (renderObject instanceof S.RenderBox)
        return renderObject.get$size();
      return;
    },
    _debugCheckStateIsActiveForAncestorLookup$0: function() {
      H.assertHelper(new N.Element__debugCheckStateIsActiveForAncestorLookup_closure(this).call$0());
      return true;
    },
    inheritFromElement$2$aspect: function(ancestor, aspect) {
      var _this = this;
      if (_this._dependencies == null)
        _this.set$_dependencies(P.HashSet_HashSet(N.InheritedElement));
      _this._dependencies.add$1(0, ancestor);
      ancestor._dependents.$indexSet(0, _this, null);
      return ancestor.get$widget();
    },
    inheritFromWidgetOfExactType$1: function(targetType) {
      var t1, ancestor, _this = this;
      _this._debugCheckStateIsActiveForAncestorLookup$0();
      t1 = _this._inheritedWidgets;
      ancestor = t1 == null ? null : t1.$index(0, targetType);
      if (ancestor != null)
        return _this.inheritFromElement$2$aspect(ancestor, null);
      _this._hadUnsatisfiedDependencies = true;
      return;
    },
    _updateInheritance$0: function() {
      H.assertHelper(this._active);
      var t1 = this._framework$_parent;
      this.set$_inheritedWidgets(t1 == null ? null : t1._inheritedWidgets);
    },
    ancestorWidgetOfExactType$1: function(targetType) {
      var ancestor, t1;
      this._debugCheckStateIsActiveForAncestorLookup$0();
      ancestor = this._framework$_parent;
      while (true) {
        t1 = ancestor == null;
        if (!(!t1 && !new H.TypeImpl(H.getRti(ancestor.get$widget())).$eq(0, targetType)))
          break;
        ancestor = ancestor._framework$_parent;
      }
      return t1 ? null : ancestor.get$widget();
    },
    ancestorStateOfType$1: function(matcher) {
      var ancestor, t1, t2, t3;
      this._debugCheckStateIsActiveForAncestorLookup$0();
      ancestor = this._framework$_parent;
      for (t1 = H.getTypeArgumentByIndex(matcher, 0); t2 = ancestor == null, !t2;) {
        if (!!ancestor.$isStatefulElement) {
          t3 = ancestor._framework$_state;
          t3 = H.checkSubtypeOfRuntimeType(t3, t1);
        } else
          t3 = false;
        if (t3)
          break;
        ancestor = ancestor._framework$_parent;
      }
      H.interceptedTypeCheck(ancestor, "$isStatefulElement");
      return t2 ? null : ancestor._framework$_state;
    },
    ancestorRenderObjectOfType$1: function(matcher) {
      var ancestor, t1, t2, t3;
      this._debugCheckStateIsActiveForAncestorLookup$0();
      ancestor = this._framework$_parent;
      for (t1 = H.getTypeArgumentByIndex(matcher, 0); t2 = ancestor == null, !t2;) {
        if (!!ancestor.$isRenderObjectElement) {
          t3 = ancestor.get$renderObject();
          t3 = H.checkSubtypeOfRuntimeType(t3, t1);
        } else
          t3 = false;
        if (t3)
          break;
        ancestor = ancestor._framework$_parent;
      }
      H.interceptedTypeCheck(ancestor, "$isRenderObjectElement");
      return t2 ? null : ancestor.get$renderObject();
    },
    visitAncestorElements$1: function(visitor) {
      var ancestor;
      H.functionTypeCheck(visitor, {func: 1, ret: P.bool, args: [N.Element]});
      this._debugCheckStateIsActiveForAncestorLookup$0();
      ancestor = this._framework$_parent;
      while (true) {
        if (!(ancestor != null && H.boolConversionCheck(visitor.call$1(ancestor))))
          break;
        ancestor = ancestor._framework$_parent;
      }
    },
    didChangeDependencies$0: function() {
      H.assertHelper(this._active);
      this._debugCheckOwnerBuildTargetExists$1("didChangeDependencies");
      this.markNeedsBuild$0();
    },
    _debugCheckOwnerBuildTargetExists$1: function(methodName) {
      H.assertHelper(new N.Element__debugCheckOwnerBuildTargetExists_closure(this, methodName).call$0());
      return true;
    },
    debugGetCreatorChain$1: function(limit) {
      var t1,
        chain = H.setRuntimeTypeInfo([], [P.String]),
        node = this;
      while (true) {
        if (!(chain.length < limit && node != null))
          break;
        node.get$widget();
        t1 = node.get$widget().toStringShort$0();
        C.JSArray_methods.add$1(chain, t1);
        node = node._framework$_parent;
      }
      if (node != null)
        C.JSArray_methods.add$1(chain, "\u22ef");
      return C.JSArray_methods.join$1(chain, " \u2190 ");
    },
    debugGetDiagnosticChain$0: function() {
      var chain = H.setRuntimeTypeInfo([this], [N.Element]),
        node = this._framework$_parent;
      for (; node != null;) {
        C.JSArray_methods.add$1(chain, node);
        node = node._framework$_parent;
      }
      return chain;
    },
    toStringShort$0: function() {
      this.get$widget();
      var t1 = this.get$widget().toStringShort$0();
      return t1;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, t4, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      properties.defaultDiagnosticsTreeStyle = C.DiagnosticsTreeStyle_2;
      t1 = Y.ObjectFlagProperty$("depth", _this._depth, "no depth", P.int);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.ObjectFlagProperty$("widget", _this.get$widget(), "no widget", N.Widget));
      _this.get$widget();
      t1 = _this.get$widget();
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("key", t1.key, _null, _null, _null, _null, C.DiagnosticLevel_0, false, false, true, C.DiagnosticsTreeStyle_5, _null, D.Key));
      _this.get$widget().debugFillProperties$1(properties);
      C.JSArray_methods.add$1(t2, Y.FlagProperty$("dirty", _null, _null, "dirty", C.DiagnosticLevel_3, false, _this._dirty));
      t1 = _this._dependencies;
      if (t1 != null && t1._collection$_length !== 0) {
        t3 = Y.DiagnosticsNode;
        t1.toString;
        t4 = H.getTypeArgumentByIndex(t1, 0);
        C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("dependencies", P.List_List$from(new H.EfficientLengthMappedIterable(t1, H.functionTypeCheck(new N.Element_debugFillProperties_closure(), {func: 1, ret: t3, args: [t4]}), [t4, t3]), true, t3), C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, [P.List, Y.DiagnosticsNode]));
      }
    },
    debugDescribeChildren$0: function() {
      var children = H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]);
      this.visitChildren$1(new N.Element_debugDescribeChildren_closure(children));
      return children;
    },
    _debugSetAllowIgnoredCallsToMarkNeedsBuild$1: function(value) {
      H.assertHelper(this._debugAllowIgnoredCallsToMarkNeedsBuild === !value);
      this._debugAllowIgnoredCallsToMarkNeedsBuild = value;
      return true;
    },
    markNeedsBuild$0: function() {
      var _this = this;
      H.assertHelper(_this._debugLifecycleState !== C._ElementLifecycle_3);
      if (!_this._active)
        return;
      H.assertHelper(_this._owner != null);
      H.assertHelper(_this._debugLifecycleState === C._ElementLifecycle_1);
      H.assertHelper(new N.Element_markNeedsBuild_closure(_this).call$0());
      if (_this._dirty)
        return;
      _this._dirty = true;
      _this._owner.scheduleBuildFor$1(_this);
    },
    rebuild$0: function() {
      var _this = this, t1 = {};
      H.assertHelper(_this._debugLifecycleState !== C._ElementLifecycle_0);
      if (!_this._active || !_this._dirty)
        return;
      H.assertHelper(new N.Element_rebuild_closure(_this).call$0());
      H.assertHelper(_this._debugLifecycleState === C._ElementLifecycle_1);
      H.assertHelper(_this._owner._debugStateLockLevel > 0);
      t1.debugPreviousBuildTarget = null;
      H.assertHelper(new N.Element_rebuild_closure0(t1, _this).call$0());
      _this.performRebuild$0();
      H.assertHelper(new N.Element_rebuild_closure1(t1, _this).call$0());
      H.assertHelper(!_this._dirty);
    },
    set$_inheritedWidgets: function(_inheritedWidgets) {
      this._inheritedWidgets = H.assertSubtype(_inheritedWidgets, "$isMap", [P.Type, N.InheritedElement], "$asMap");
    },
    set$_dependencies: function(_dependencies) {
      this._dependencies = H.assertSubtype(_dependencies, "$isSet", [N.InheritedElement], "$asSet");
    },
    $isBuildContext: 1
  };
  N.Element_reassemble_closure.prototype = {
    call$1: function(child) {
      child.reassemble$0();
    },
    $signature: 15
  };
  N.Element_renderObject_visit.prototype = {
    call$1: function(element) {
      var t1 = this._box_0;
      H.assertHelper(t1.result == null);
      if (element instanceof N.RenderObjectElement)
        t1.result = element.get$renderObject();
      else
        element.visitChildren$1(this);
    },
    $signature: 9
  };
  N.Element_visitChildElements_closure.prototype = {
    call$0: function() {
      var t1 = this.$this._owner;
      if (t1 == null || t1._debugStateLockLevel <= 0)
        return true;
      throw H.wrapException(U.FlutterError$("visitChildElements() called during build.\nThe BuildContext.visitChildElements() method can't be called during build because the child list is still being updated at that point, so the children might not be constructed yet, or might be old children that are going to be replaced."));
    },
    $signature: 0
  };
  N.Element_updateChild_closure.prototype = {
    call$0: function() {
      var t1 = this.newWidget;
      if (t1 != null && !!J.getInterceptor$(t1.key).$isGlobalKey)
        H.assertSubtype(t1.key, "$isGlobalKey", [[N.State, N.StatefulWidget]], "$asGlobalKey")._debugReserveFor$1(this.$this);
      return true;
    },
    $signature: 0
  };
  N.Element_updateChild_closure0.prototype = {
    call$0: function() {
      var t1 = this.child;
      t1._owner._debugElementWasRebuilt$1(t1);
      return true;
    },
    $signature: 0
  };
  N.Element_mount_closure.prototype = {
    call$0: function() {
      this.$this._debugLifecycleState = C._ElementLifecycle_1;
      return true;
    },
    $signature: 0
  };
  N.Element_updateSlotForChild_visit.prototype = {
    call$1: function(element) {
      element._updateSlot$1(this.newSlot);
      if (!element.$isRenderObjectElement)
        element.visitChildren$1(this);
    },
    $signature: 9
  };
  N.Element__updateDepth_closure.prototype = {
    call$1: function(child) {
      child._updateDepth$1(this.expectedDepth);
    },
    $signature: 15
  };
  N.Element_detachRenderObject_closure.prototype = {
    call$1: function(child) {
      child.detachRenderObject$0();
    },
    $signature: 15
  };
  N.Element_attachRenderObject_closure.prototype = {
    call$1: function(child) {
      child.attachRenderObject$1(this.newSlot);
    },
    $signature: 15
  };
  N.Element__retakeInactiveElement_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  N.Element__retakeInactiveElement_closure0.prototype = {
    call$0: function() {
      var _this = this,
        t1 = _this.parent,
        t2 = _this.$this;
      if (t1 === t2)
        throw H.wrapException(U.FlutterError$("A GlobalKey was used multiple times inside one widget's child list.\nThe offending GlobalKey was: " + _this.key.toString$0(0) + "\nThe parent of the widgets with that key was:\n  " + t1.toString$0(0) + "\nThe first child to get instantiated with that key became:\n  " + _this.element.toString$0(0) + "\nThe second child that was to be instantiated with that key was:\n  " + t2.get$widget().toString$0(0) + "\nA GlobalKey can only be specified on one widget at a time in the widget tree."));
      t1._owner._debugTrackElementThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans$2(t1, _this.key);
      return true;
    },
    $signature: 0
  };
  N.Element_inflateWidget_closure.prototype = {
    call$0: function() {
      this.$this._debugCheckForCycles$1(this.newChild);
      return true;
    },
    $signature: 0
  };
  N.Element_inflateWidget_closure0.prototype = {
    call$0: function() {
      this.$this._debugCheckForCycles$1(this.newChild);
      return true;
    },
    $signature: 0
  };
  N.Element__debugCheckForCycles_closure.prototype = {
    call$0: function() {
      var node0,
        node = this.$this;
      for (; node0 = node._framework$_parent, node0 != null; node = node0)
        ;
      H.assertHelper(!node.$eq(0, this.newChild));
      return true;
    },
    $signature: 0
  };
  N.Element_deactivateChild_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  N.Element__activateWithParent_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  N.Element_activate_closure.prototype = {
    call$0: function() {
      this.$this._debugLifecycleState = C._ElementLifecycle_1;
      return true;
    },
    $signature: 0
  };
  N.Element_deactivate_closure.prototype = {
    call$0: function() {
      this.$this._debugLifecycleState = C._ElementLifecycle_2;
      return true;
    },
    $signature: 0
  };
  N.Element_unmount_closure.prototype = {
    call$0: function() {
      this.$this._debugLifecycleState = C._ElementLifecycle_3;
      return true;
    },
    $signature: 0
  };
  N.Element_size_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._debugLifecycleState;
      if (t2 !== C._ElementLifecycle_1)
        throw H.wrapException(U.FlutterError$("Cannot get size of inactive element.\nIn order for an element to have a valid size, the element must be active, which means it is part of the tree. Instead, this element is in the " + t2.toString$0(0) + " state.\nThe size getter was called for the following element:\n  " + t1.toString$0(0) + "\n"));
      if (t1._owner._debugBuilding)
        throw H.wrapException(U.FlutterError$("Cannot get size during build.\nThe size of this render object has not yet been determined because the framework is still in the process of building widgets, which means the render tree for this frame has not yet been determined. The size getter should only be called from paint callbacks or interaction event handlers (e.g. gesture callbacks).\n\nIf you need some sizing information during build to decide which widgets to build, consider using a LayoutBuilder widget, which can tell you the layout constraints at a given location in the tree. See <https://docs.flutter.io/flutter/widgets/LayoutBuilder-class.html> for more details.\n\nThe size getter was called for the following element:\n  " + t1.toString$0(0) + "\n"));
      return true;
    },
    $signature: 0
  };
  N.Element_size_closure0.prototype = {
    call$0: function() {
      var _this = this,
        _s65_ = "\nThe render object from which the size was to be obtained was:\n  ",
        t1 = _this.renderObject;
      if (t1 == null)
        throw H.wrapException(U.FlutterError$("Cannot get size without a render object.\nIn order for an element to have a valid size, the element must have an associated render object. This element does not have an associated render object, which typically means that the size getter was called too early in the pipeline (e.g., during the build phase) before the framework has created the render tree.\nThe size getter was called for the following element:\n  " + _this.$this.toString$0(0) + "\n"));
      if (!t1.$isRenderBox)
        throw H.wrapException(U.FlutterError$("Cannot get size from a render object that is not a RenderBox.\nInstead of being a subtype of RenderBox, the render object associated with this element is a " + H.getRuntimeType(t1).toString$0(0) + ". If this type of render object does have a size, consider calling findRenderObject and extracting its size manually.\nThe size getter was called for the following element:\n  " + _this.$this.toString$0(0) + "\nThe associated render object was:\n  " + t1.toStringShallow$1$joiner("\n  ")));
      if (t1._size == null)
        throw H.wrapException(U.FlutterError$("Cannot get size from a render object that has not been through layout.\nThe size of this render object has not yet been determined because this render object has not yet been through layout, which typically means that the size getter was called too early in the pipeline (e.g., during the build phase) before the framework has determined the size and position of the render objects during layout.\nThe size getter was called for the following element:\n  " + _this.$this.toString$0(0) + _s65_ + t1.toStringShallow$1$joiner("\n  ")));
      if (H.boolConversionCheck(t1.get$debugNeedsLayout()))
        throw H.wrapException(U.FlutterError$("Cannot get size from a render object that has been marked dirty for layout.\nThe size of this render object is ambiguous because this render object has been modified since it was last laid out, which typically means that the size getter was called too early in the pipeline (e.g., during the build phase) before the framework has determined the size and position of the render objects during layout.\nThe size getter was called for the following element:\n  " + _this.$this.toString$0(0) + _s65_ + t1.toStringShallow$1$joiner("\n  ") + "\nConsider using debugPrintMarkNeedsLayoutStacks to determine why the render object in question is dirty, if you did not expect this."));
      return true;
    },
    $signature: 0
  };
  N.Element__debugCheckStateIsActiveForAncestorLookup_closure.prototype = {
    call$0: function() {
      if (this.$this._debugLifecycleState !== C._ElementLifecycle_1)
        throw H.wrapException(U.FlutterError$("Looking up a deactivated widget's ancestor is unsafe.\nAt this point the state of the widget's element tree is no longer stable. To safely refer to a widget's ancestor in its dispose() method, save a reference to the ancestor by calling inheritFromWidgetOfExactType() in the widget's didChangeDependencies() method.\n"));
      return true;
    },
    $signature: 0
  };
  N.Element__debugCheckOwnerBuildTargetExists_closure.prototype = {
    call$0: function() {
      var t2,
        t1 = this.$this;
      if (t1._owner._debugCurrentBuildTarget == null) {
        t2 = this.methodName;
        throw H.wrapException(U.FlutterError$(t2 + " for " + H.getRuntimeType(t1.get$widget()).toString$0(0) + " was called at an inappropriate time.\nIt may only be called while the widgets are being built. A possible cause of this error is when " + t2 + " is called during one of:\n * network I/O event\n * file I/O event\n * timer\n * microtask (caused by Future.then, async/await, scheduleMicrotask)"));
      }
      return true;
    },
    $signature: 0
  };
  N.Element_debugFillProperties_closure.prototype = {
    call$1: function(element) {
      return new Y._DiagnosticableTreeNode(H.interceptedTypeCheck(element, "$isInheritedElement").get$widget(), null, true, true, C.DiagnosticsTreeStyle_0);
    },
    $signature: 141
  };
  N.Element_debugDescribeChildren_closure.prototype = {
    call$1: function(child) {
      var t1 = this.children;
      if (child != null)
        C.JSArray_methods.add$1(t1, new Y._DiagnosticableTreeNode(child, null, true, true, null));
      else
        C.JSArray_methods.add$1(t1, Y.DiagnosticsNode_DiagnosticsNode$message("<null child>", C.DiagnosticsTreeStyle_5));
    },
    $signature: 15
  };
  N.Element_markNeedsBuild_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._owner;
      if (t2._debugBuilding) {
        H.assertHelper(t2._debugCurrentBuildTarget != null);
        H.assertHelper(t1._owner._debugStateLockLevel > 0);
        if (t1._debugIsInScope$1(t1._owner._debugCurrentBuildTarget))
          return true;
        if (!t1._debugAllowIgnoredCallsToMarkNeedsBuild) {
          t2 = "setState() or markNeedsBuild() called during build.\nThis " + H.getRuntimeType(t1.get$widget()).toString$0(0) + " widget cannot be marked as needing to build because the framework is already in the process of building widgets. A widget can be marked as needing to be built during the build phase only if one of its ancestors is currently building. This exception is allowed because the framework builds parent widgets before children, which means a dirty descendant will always be built. Otherwise, the framework might not visit this widget during this build phase.\nThe widget on which setState() or markNeedsBuild() was called was:\n  " + t1.toString$0(0) + "\n";
          t1 = t1._owner._debugCurrentBuildTarget;
          throw H.wrapException(U.FlutterError$(t2 + (t1 == null ? "" : "The widget which was currently being built when the offending call was made was:\n  " + t1.toString$0(0))));
        }
        H.assertHelper(t1._dirty);
      } else if (t2._debugStateLockLevel > 0) {
        H.assertHelper(!t1._debugAllowIgnoredCallsToMarkNeedsBuild);
        throw H.wrapException(U.FlutterError$("setState() or markNeedsBuild() called when widget tree was locked.\nThis " + H.getRuntimeType(t1.get$widget()).toString$0(0) + " widget cannot be marked as needing to build because the framework is locked.\nThe widget on which setState() or markNeedsBuild() was called was:\n  " + t1.toString$0(0) + "\n"));
      }
      return true;
    },
    $signature: 0
  };
  N.Element_rebuild_closure.prototype = {
    call$0: function() {
      var t2,
        t1 = $.debugOnRebuildDirtyWidget;
      if (t1 != null) {
        t2 = this.$this;
        t1.call$2(t2, t2._debugBuiltOnce);
      }
      return true;
    },
    $signature: 0
  };
  N.Element_rebuild_closure0.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._owner;
      this._box_0.debugPreviousBuildTarget = t2._debugCurrentBuildTarget;
      t2._debugCurrentBuildTarget = t1;
      return true;
    },
    $signature: 0
  };
  N.Element_rebuild_closure1.prototype = {
    call$0: function() {
      var t1 = this.$this;
      H.assertHelper(J.$eq$(t1._owner._debugCurrentBuildTarget, t1));
      t1._owner._debugCurrentBuildTarget = this._box_0.debugPreviousBuildTarget;
      return true;
    },
    $signature: 0
  };
  N.ErrorWidget.prototype = {
    createRenderObject$1: function(context) {
      return V.RenderErrorBox$(this.message);
    },
    debugFillProperties$1: function(properties) {
      var t1;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.StringProperty$("message", this.message, C.C__NoDefaultValue, false, true);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  N.ErrorWidget_closure.prototype = {
    call$1: function(details) {
      return new N.ErrorWidget(N.ErrorWidget__stringify(details.exception), new N.UniqueKey());
    },
    $signature: 142
  };
  N.ComponentElement.prototype = {
    mount$2: function($parent, newSlot) {
      var _this = this;
      _this.super$Element$mount($parent, newSlot);
      H.assertHelper(_this._framework$_child == null);
      H.assertHelper(_this._active);
      _this._firstBuild$0();
      H.assertHelper(_this._framework$_child != null);
    },
    _firstBuild$0: function() {
      this.rebuild$0();
    },
    performRebuild$0: function() {
      var built, e, stack, e0, stack0, exception, built0, _this = this, _null = null,
        t1 = $.debugProfileBuildsEnabled;
      if (t1)
        P.Timeline_startSync(new H.TypeImpl(H.getRti(_this.get$widget())).toString$0(0), C.Map_9aZ6I, _null);
      _this._debugSetAllowIgnoredCallsToMarkNeedsBuild$1(true);
      built = null;
      try {
        built = _this.build$0();
        E.debugWidgetBuilderValue(_this.get$widget(), built);
      } catch (exception) {
        e = H.unwrapException(exception);
        stack = H.getTraceFromException(exception);
        built0 = $.$get$ErrorWidget_builder().call$1(N._debugReportException("building " + _this.toString$0(0), e, stack, _null));
        built = built0;
      } finally {
        _this._dirty = false;
        _this._debugSetAllowIgnoredCallsToMarkNeedsBuild$1(false);
      }
      try {
        t1 = _this.updateChild$3(_this._framework$_child, built, _this._slot);
        _this._framework$_child = t1;
        H.assertHelper(t1 != null);
      } catch (exception) {
        e0 = H.unwrapException(exception);
        stack0 = H.getTraceFromException(exception);
        built0 = $.$get$ErrorWidget_builder().call$1(N._debugReportException("building " + _this.toString$0(0), e0, stack0, _null));
        built = built0;
        _this._framework$_child = _this.updateChild$3(_null, built, _this._slot);
      }
      t1 = $.debugProfileBuildsEnabled;
      if (t1)
        P.Timeline_finishSync();
    },
    visitChildren$1: function(visitor) {
      var t1;
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [N.Element]});
      t1 = this._framework$_child;
      if (t1 != null)
        visitor.call$1(t1);
    },
    forgetChild$1: function(child) {
      H.assertHelper(child.$eq(0, this._framework$_child));
      this._framework$_child = null;
    }
  };
  N.StatelessElement.prototype = {
    get$widget: function() {
      return H.interceptedTypeCheck(N.Element.prototype.get$widget.call(this), "$isStatelessWidget");
    },
    build$0: function() {
      return H.interceptedTypeCheck(N.Element.prototype.get$widget.call(this), "$isStatelessWidget").build$1(this);
    },
    update$1: function(newWidget) {
      var _this = this;
      H.interceptedTypeCheck(newWidget, "$isStatelessWidget");
      _this.super$Element$update(newWidget);
      H.assertHelper(H.interceptedTypeCheck(N.Element.prototype.get$widget.call(_this), "$isStatelessWidget") === newWidget);
      _this._dirty = true;
      _this.rebuild$0();
    }
  };
  N.StatefulElement.prototype = {
    StatefulElement$1: function(widget) {
      var t1, _this = this;
      H.assertHelper(new N.StatefulElement_closure(_this, widget).call$0());
      H.assertHelper(_this._framework$_state._element == null);
      t1 = _this._framework$_state;
      t1._element = _this;
      H.assertHelper(t1._widget == null);
      _this._framework$_state.set$_widget(widget);
      H.assertHelper(_this._framework$_state._debugLifecycleState === C._StateLifecycle_0);
    },
    build$0: function() {
      return this._framework$_state.build$1(this);
    },
    reassemble$0: function() {
      this._framework$_state.toString;
      this.super$Element$reassemble();
    },
    _firstBuild$0: function() {
      var debugCheckForReturnedFuture, _this = this;
      H.assertHelper(_this._framework$_state._debugLifecycleState === C._StateLifecycle_0);
      try {
        _this._debugSetAllowIgnoredCallsToMarkNeedsBuild$1(true);
        debugCheckForReturnedFuture = _this._framework$_state.initState$0();
        H.assertHelper(new N.StatefulElement__firstBuild_closure(_this, debugCheckForReturnedFuture).call$0());
      } finally {
        _this._debugSetAllowIgnoredCallsToMarkNeedsBuild$1(false);
      }
      H.assertHelper(new N.StatefulElement__firstBuild_closure0(_this).call$0());
      _this._framework$_state.didChangeDependencies$0();
      H.assertHelper(new N.StatefulElement__firstBuild_closure1(_this).call$0());
      _this.super$ComponentElement$_firstBuild();
    },
    update$1: function(newWidget) {
      var oldWidget, debugCheckForReturnedFuture, t1, _this = this;
      H.interceptedTypeCheck(newWidget, "$isStatefulWidget");
      _this.super$Element$update(newWidget);
      H.assertHelper(_this._widget === newWidget);
      t1 = _this._framework$_state;
      oldWidget = t1._widget;
      _this._dirty = true;
      t1.set$_widget(H.interceptedTypeCheck(_this._widget, "$isStatefulWidget"));
      try {
        _this._debugSetAllowIgnoredCallsToMarkNeedsBuild$1(true);
        debugCheckForReturnedFuture = _this._framework$_state.didUpdateWidget$1(oldWidget);
        H.assertHelper(new N.StatefulElement_update_closure(_this, debugCheckForReturnedFuture).call$0());
      } finally {
        _this._debugSetAllowIgnoredCallsToMarkNeedsBuild$1(false);
      }
      _this.rebuild$0();
    },
    activate$0: function() {
      this.super$Element$activate();
      H.assertHelper(this._active);
      this.markNeedsBuild$0();
    },
    deactivate$0: function() {
      this._framework$_state.deactivate$0();
      this.super$Element$deactivate();
    },
    unmount$0: function() {
      var _this = this;
      _this.super$Element$unmount();
      _this._framework$_state.dispose$0();
      H.assertHelper(new N.StatefulElement_unmount_closure(_this).call$0());
      _this._framework$_state._element = null;
      _this.set$_framework$_state(null);
    },
    inheritFromElement$2$aspect: function(ancestor, aspect) {
      H.assertHelper(new N.StatefulElement_inheritFromElement_closure(this, ancestor).call$0());
      return this.super$Element$inheritFromElement(ancestor, aspect);
    },
    didChangeDependencies$0: function() {
      this.super$Element$didChangeDependencies();
      this._framework$_state.didChangeDependencies$0();
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Element$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("state", this._framework$_state, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, [N.State, N.StatefulWidget]);
      C.JSArray_methods.add$1(properties.properties, t1);
    },
    set$_framework$_state: function(_state) {
      this._framework$_state = H.assertSubtype(_state, "$isState", [N.StatefulWidget], "$asState");
    }
  };
  N.StatefulElement_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._framework$_state,
        t3 = this.widget;
      t2.toString;
      if (!H.checkSubtypeOfRuntimeType(t3, H.getRuntimeTypeArgument(t2, "State", 0)))
        throw H.wrapException(U.FlutterError$("StatefulWidget.createState must return a subtype of State<" + H.getRuntimeType(t3).toString$0(0) + ">\nThe createState function for " + H.getRuntimeType(t3).toString$0(0) + " returned a state of type " + J.get$runtimeType$(t1._framework$_state).toString$0(0) + ", which is not a subtype of State<" + H.getRuntimeType(t3).toString$0(0) + ">, violating the contract for createState."));
      return true;
    },
    $signature: 0
  };
  N.StatefulElement__firstBuild_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  N.StatefulElement__firstBuild_closure0.prototype = {
    call$0: function() {
      this.$this._framework$_state._debugLifecycleState = C._StateLifecycle_1;
      return true;
    },
    $signature: 0
  };
  N.StatefulElement__firstBuild_closure1.prototype = {
    call$0: function() {
      this.$this._framework$_state._debugLifecycleState = C._StateLifecycle_2;
      return true;
    },
    $signature: 0
  };
  N.StatefulElement_update_closure.prototype = {
    call$0: function() {
      return true;
    },
    $signature: 0
  };
  N.StatefulElement_unmount_closure.prototype = {
    call$0: function() {
      var t1 = this.$this._framework$_state;
      if (t1._debugLifecycleState === C._StateLifecycle_3)
        return true;
      throw H.wrapException(U.FlutterError$(J.get$runtimeType$(t1).toString$0(0) + ".dispose failed to call super.dispose.\ndispose() implementations must always call their superclass dispose() method, to ensure that all the resources used by the widget are fully released."));
    },
    $signature: 0
  };
  N.StatefulElement_inheritFromElement_closure.prototype = {
    call$0: function() {
      var _s29_ = "inheritFromWidgetOfExactType(",
        targetType = new H.TypeImpl(H.getRti(this.ancestor.get$widget())),
        t1 = this.$this,
        t2 = t1._framework$_state._debugLifecycleState;
      if (t2 === C._StateLifecycle_0)
        throw H.wrapException(U.FlutterError$(_s29_ + targetType.toString$0(0) + ") or inheritFromElement() was called before " + J.get$runtimeType$(t1._framework$_state).toString$0(0) + ".initState() completed.\nWhen an inherited widget changes, for example if the value of Theme.of() changes, its dependent widgets are rebuilt. If the dependent widget's reference to the inherited widget is in a constructor or an initState() method, then the rebuilt dependent widget will not reflect the changes in the inherited widget.\nTypically references to inherited widgets should occur in widget build() methods. Alternatively, initialization based on inherited widgets can be placed in the didChangeDependencies method, which is called after initState and whenever the dependencies change thereafter."));
      if (t2 === C._StateLifecycle_3)
        throw H.wrapException(U.FlutterError$(_s29_ + targetType.toString$0(0) + ") or inheritFromElement() was called after dispose(): " + t1.toString$0(0) + '\nThis error happens if you call inheritFromWidgetOfExactType() on the BuildContext for a widget that no longer appears in the widget tree (e.g., whose parent widget no longer includes the widget in its build). This error can occur when code calls inheritFromWidgetOfExactType() from a timer or an animation callback. The preferred solution is to cancel the timer or stop listening to the animation in the dispose() callback. Another solution is to check the "mounted" property of this object before calling inheritFromWidgetOfExactType() to ensure the object is still in the tree.\nThis error might indicate a memory leak if inheritFromWidgetOfExactType() is being called because another object is retaining a reference to this State object after it has been removed from the tree. To avoid memory leaks, consider breaking the reference to this object during dispose().'));
      return true;
    },
    $signature: 0
  };
  N.ProxyElement.prototype = {
    get$widget: function() {
      return H.interceptedTypeCheck(N.Element.prototype.get$widget.call(this), "$isProxyWidget");
    },
    build$0: function() {
      return this.get$widget().child;
    },
    update$1: function(newWidget) {
      var oldWidget, _this = this;
      H.interceptedTypeCheck(newWidget, "$isProxyWidget");
      oldWidget = _this.get$widget();
      _this.get$widget();
      H.assertHelper(_this.get$widget() !== newWidget);
      _this.super$Element$update(newWidget);
      H.assertHelper(_this.get$widget() === newWidget);
      _this.updated$1(oldWidget);
      _this._dirty = true;
      _this.rebuild$0();
    },
    updated$1: function(oldWidget) {
      this.notifyClients$1(oldWidget);
    }
  };
  N.ParentDataElement.prototype = {
    get$widget: function() {
      return H.assertSubtype(N.ProxyElement.prototype.get$widget.call(this), "$isParentDataWidget", this.$ti, "$asParentDataWidget");
    },
    mount$2: function($parent, newSlot) {
      H.assertHelper(new N.ParentDataElement_mount_closure(this, $parent).call$0());
      this.super$ComponentElement$mount($parent, newSlot);
    },
    _applyParentData$1: function(widget) {
      this.visitChildren$1(new N.ParentDataElement__applyParentData_applyParentDataToChild(H.assertSubtype(widget, "$isParentDataWidget", this.$ti, "$asParentDataWidget")));
    },
    notifyClients$1: function(oldWidget) {
      var t1 = this.$ti;
      H.assertSubtype(oldWidget, "$isParentDataWidget", t1, "$asParentDataWidget");
      this._applyParentData$1(H.assertSubtype(N.ProxyElement.prototype.get$widget.call(this), "$isParentDataWidget", t1, "$asParentDataWidget"));
    }
  };
  N.ParentDataElement_mount_closure.prototype = {
    call$0: function() {
      var t1, t2, ancestor0, t3, t4, t5,
        badAncestors = H.setRuntimeTypeInfo([], [N.Widget]),
        ancestor = this.parent;
      for (t1 = this.$this, t2 = [H.getTypeArgumentByIndex(t1, 0)], ancestor0 = ancestor; t3 = ancestor0 != null, t3;) {
        if (!!ancestor0.$isParentDataElement)
          C.JSArray_methods.add$1(badAncestors, H.assertSubtype(N.ProxyElement.prototype.get$widget.call(ancestor0), "$isParentDataWidget", [H.getTypeArgumentByIndex(ancestor0, 0)], "$asParentDataWidget"));
        else if (!!ancestor0.$isRenderObjectElement) {
          t4 = H.assertSubtype(N.ProxyElement.prototype.get$widget.call(t1), "$isParentDataWidget", t2, "$asParentDataWidget");
          t5 = ancestor0.get$widget();
          t4 = H.getRuntimeTypeArgument(t4, "ParentDataWidget", 0);
          H.assertHelper(!new H.TypeImpl(t4).$eq(0, C.Type_dynamic_0Rz));
          H.assertHelper(!new H.TypeImpl(t4).$eq(0, C.Type_RenderObjectWidget_gmA));
          if (H.checkSubtypeOfRuntimeType(t5, t4))
            break;
          C.JSArray_methods.add$1(badAncestors, ancestor0.get$widget());
        }
        ancestor0 = ancestor0._framework$_parent;
      }
      if (t3 && badAncestors.length === 0)
        return true;
      throw H.wrapException(U.FlutterError$("Incorrect use of ParentDataWidget.\n" + t1.get$widget().debugDescribeInvalidAncestorChain$4$badAncestors$description$foundValidAncestor$ownershipChain(badAncestors, t1.toString$0(0), t3, ancestor.debugGetCreatorChain$1(10))));
    },
    $signature: 0
  };
  N.ParentDataElement__applyParentData_applyParentDataToChild.prototype = {
    call$1: function(child) {
      var t1 = J.getInterceptor$(child);
      if (!!t1.$isRenderObjectElement)
        H.assertSubtype(this.widget, "$isParentDataWidget", [N.RenderObjectWidget], "$asParentDataWidget").applyParentData$1(child.get$renderObject());
      else {
        H.assertHelper(!t1.$isParentDataElement);
        child.visitChildren$1(this);
      }
    },
    $signature: 9
  };
  N.InheritedElement.prototype = {
    get$widget: function() {
      return H.interceptedTypeCheck(N.ProxyElement.prototype.get$widget.call(this), "$isInheritedWidget");
    },
    _updateInheritance$0: function() {
      var t1, incomingWidgets, t2, _this = this;
      H.assertHelper(_this._active);
      t1 = _this._framework$_parent;
      incomingWidgets = t1 == null ? null : t1._inheritedWidgets;
      t1 = P.Type;
      t2 = N.InheritedElement;
      if (incomingWidgets != null)
        _this.set$_inheritedWidgets(P.HashMap_HashMap$from(incomingWidgets, t1, t2));
      else
        _this.set$_inheritedWidgets(P.HashMap_HashMap(t1, t2));
      _this._inheritedWidgets.$indexSet(0, new H.TypeImpl(H.getRti(_this.get$widget())), _this);
    },
    debugDeactivated$0: function() {
      H.assertHelper(new N.InheritedElement_debugDeactivated_closure(this).call$0());
      this.super$Element$debugDeactivated();
    },
    updated$1: function(oldWidget) {
      H.interceptedTypeCheck(oldWidget, "$isInheritedWidget");
      if (this.get$widget().updateShouldNotify$1(oldWidget))
        this.super$ProxyElement$updated(oldWidget);
    },
    notifyClients$1: function(oldWidget) {
      var t1, t2, _this = this;
      H.interceptedTypeCheck(oldWidget, "$isInheritedWidget");
      _this._debugCheckOwnerBuildTargetExists$1("notifyClients");
      for (t1 = _this._dependents, t1 = new P._HashMapKeyIterable(t1, [H.getTypeArgumentByIndex(t1, 0)]), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        t2 = t1._collection$_current;
        H.assertHelper(new N.InheritedElement_notifyClients_closure(_this, t2).call$0());
        H.assertHelper(t2._dependencies.contains$1(0, _this));
        t2.didChangeDependencies$0();
      }
    }
  };
  N.InheritedElement_debugDeactivated_closure.prototype = {
    call$0: function() {
      H.assertHelper(this.$this._dependents._collection$_length === 0);
      return true;
    },
    $signature: 0
  };
  N.InheritedElement_notifyClients_closure.prototype = {
    call$0: function() {
      var t2,
        ancestor = this.dependent._framework$_parent,
        t1 = this.$this;
      while (true) {
        t2 = J.getInterceptor$(ancestor);
        if (!(!t2.$eq(ancestor, t1) && ancestor != null))
          break;
        ancestor = ancestor._framework$_parent;
      }
      return t2.$eq(ancestor, t1);
    },
    $signature: 0
  };
  N.RenderObjectElement.prototype = {
    get$widget: function() {
      return H.interceptedTypeCheck(N.Element.prototype.get$widget.call(this), "$isRenderObjectWidget");
    },
    get$renderObject: function() {
      return this._renderObject;
    },
    _findAncestorRenderObjectElement$0: function() {
      var ancestor = this._framework$_parent;
      while (true) {
        if (!(ancestor != null && !ancestor.$isRenderObjectElement))
          break;
        ancestor = ancestor._framework$_parent;
      }
      return H.interceptedTypeCheck(ancestor, "$isRenderObjectElement");
    },
    _findAncestorParentDataElement$0: function() {
      var ancestor = this._framework$_parent;
      while (true) {
        if (!(ancestor != null && !ancestor.$isRenderObjectElement))
          break;
        if (!!J.getInterceptor$(ancestor).$isParentDataElement)
          return ancestor;
        ancestor = ancestor._framework$_parent;
      }
      return;
    },
    mount$2: function($parent, newSlot) {
      var _this = this;
      _this.super$Element$mount($parent, newSlot);
      _this._renderObject = _this.get$widget().createRenderObject$1(_this);
      H.assertHelper(new N.RenderObjectElement_mount_closure(_this).call$0());
      H.assertHelper(J.$eq$(_this._slot, newSlot));
      _this.attachRenderObject$1(newSlot);
      _this._dirty = false;
    },
    update$1: function(newWidget) {
      var _this = this;
      H.interceptedTypeCheck(newWidget, "$isRenderObjectWidget");
      _this.super$Element$update(newWidget);
      H.assertHelper(_this.get$widget() === newWidget);
      H.assertHelper(new N.RenderObjectElement_update_closure(_this).call$0());
      _this.get$widget().updateRenderObject$2(_this, _this.get$renderObject());
      _this._dirty = false;
    },
    _debugUpdateRenderObjectOwner$0: function() {
      H.assertHelper(new N.RenderObjectElement__debugUpdateRenderObjectOwner_closure(this).call$0());
    },
    performRebuild$0: function() {
      var _this = this;
      _this.get$widget().updateRenderObject$2(_this, _this.get$renderObject());
      _this._dirty = false;
    },
    updateChildren$3$forgottenChildren: function(oldChildren, newWidgets, forgottenChildren) {
      var replaceWithNullIfForgotten, t2, newChildrenBottom, t3, oldChildrenBottom, newChildren, previousChild, newChildrenTop, oldChildrenTop, oldChild, newWidget, newChild, oldChildrenBottom0, haveOldChildren, oldKeyedChildren, key, _this = this, _null = null,
        t1 = N.Element;
      H.assertSubtype(oldChildren, "$isList", [t1], "$asList");
      H.assertSubtype(newWidgets, "$isList", [N.Widget], "$asList");
      H.assertSubtype(forgottenChildren, "$isSet", [t1], "$asSet");
      H.assertHelper(oldChildren != null);
      H.assertHelper(newWidgets != null);
      replaceWithNullIfForgotten = new N.RenderObjectElement_updateChildren_replaceWithNullIfForgotten(forgottenChildren);
      t2 = newWidgets.length;
      newChildrenBottom = t2 - 1;
      t3 = oldChildren.length;
      oldChildrenBottom = t3 - 1;
      if (t3 === t2)
        newChildren = oldChildren;
      else {
        t2 = new Array(t2);
        t2.fixed$length = Array;
        newChildren = H.setRuntimeTypeInfo(t2, [t1]);
      }
      previousChild = _null;
      newChildrenTop = 0;
      oldChildrenTop = 0;
      while (true) {
        if (!(oldChildrenTop <= oldChildrenBottom && newChildrenTop <= newChildrenBottom))
          break;
        if (oldChildrenTop >= t3)
          return H.ioore(oldChildren, oldChildrenTop);
        oldChild = replaceWithNullIfForgotten.call$1(oldChildren[oldChildrenTop]);
        if (newChildrenTop >= newWidgets.length)
          return H.ioore(newWidgets, newChildrenTop);
        newWidget = newWidgets[newChildrenTop];
        t2 = oldChild != null;
        H.assertHelper(!t2 || oldChild._debugLifecycleState === C._ElementLifecycle_1);
        if (t2) {
          t2 = oldChild.get$widget();
          t2 = !(new H.TypeImpl(H.getRti(t2)).$eq(0, J.get$runtimeType$(newWidget)) && J.$eq$(t2.key, newWidget.key));
        } else
          t2 = true;
        if (t2)
          break;
        newChild = _this.updateChild$3(oldChild, newWidget, previousChild);
        H.assertHelper(newChild._debugLifecycleState === C._ElementLifecycle_1);
        C.JSArray_methods.$indexSet(newChildren, newChildrenTop, newChild);
        ++newChildrenTop;
        ++oldChildrenTop;
        previousChild = newChild;
      }
      oldChildrenBottom0 = oldChildrenBottom;
      while (true) {
        haveOldChildren = oldChildrenTop <= oldChildrenBottom0;
        if (!(haveOldChildren && newChildrenTop <= newChildrenBottom))
          break;
        if (oldChildrenBottom0 < 0)
          return H.ioore(oldChildren, oldChildrenBottom0);
        oldChild = replaceWithNullIfForgotten.call$1(oldChildren[oldChildrenBottom0]);
        if (newChildrenBottom < 0 || newChildrenBottom >= newWidgets.length)
          return H.ioore(newWidgets, newChildrenBottom);
        newWidget = newWidgets[newChildrenBottom];
        t2 = oldChild != null;
        H.assertHelper(!t2 || oldChild._debugLifecycleState === C._ElementLifecycle_1);
        if (t2) {
          t2 = oldChild.get$widget();
          t2 = !(new H.TypeImpl(H.getRti(t2)).$eq(0, J.get$runtimeType$(newWidget)) && J.$eq$(t2.key, newWidget.key));
        } else
          t2 = true;
        if (t2)
          break;
        --oldChildrenBottom0;
        --newChildrenBottom;
      }
      if (haveOldChildren) {
        oldKeyedChildren = P.LinkedHashMap_LinkedHashMap$_empty(D.Key, t1);
        for (; oldChildrenTop <= oldChildrenBottom0;) {
          oldChild = replaceWithNullIfForgotten.call$1(oldChildren[oldChildrenTop]);
          t1 = oldChild != null;
          H.assertHelper(!t1 || oldChild._debugLifecycleState === C._ElementLifecycle_1);
          if (t1)
            if (oldChild.get$widget().key != null)
              oldKeyedChildren.$indexSet(0, oldChild.get$widget().key, oldChild);
            else
              _this.deactivateChild$1(oldChild);
          ++oldChildrenTop;
        }
        haveOldChildren = true;
      } else
        oldKeyedChildren = _null;
      for (; newChildrenTop <= newChildrenBottom; previousChild = newChild) {
        if (newChildrenTop >= newWidgets.length)
          return H.ioore(newWidgets, newChildrenTop);
        newWidget = newWidgets[newChildrenTop];
        if (haveOldChildren) {
          key = newWidget.key;
          if (key != null) {
            oldChild = oldKeyedChildren.$index(0, key);
            if (oldChild != null) {
              t1 = oldChild.get$widget();
              if (new H.TypeImpl(H.getRti(t1)).$eq(0, J.get$runtimeType$(newWidget)) && J.$eq$(t1.key, key))
                oldKeyedChildren.remove$1(0, key);
              else
                oldChild = _null;
            }
          } else
            oldChild = _null;
        } else
          oldChild = _null;
        t1 = oldChild != null;
        if (t1) {
          t2 = oldChild.get$widget();
          t2 = new H.TypeImpl(H.getRti(t2)).$eq(0, J.get$runtimeType$(newWidget)) && J.$eq$(t2.key, newWidget.key);
        } else
          t2 = true;
        H.assertHelper(t2);
        newChild = _this.updateChild$3(oldChild, newWidget, previousChild);
        H.assertHelper(newChild._debugLifecycleState === C._ElementLifecycle_1);
        H.assertHelper(J.$eq$(oldChild, newChild) || !t1 || oldChild._debugLifecycleState !== C._ElementLifecycle_1);
        C.JSArray_methods.$indexSet(newChildren, newChildrenTop, newChild);
        ++newChildrenTop;
      }
      H.assertHelper(oldChildrenTop === oldChildrenBottom0 + 1);
      H.assertHelper(newChildrenTop === newChildrenBottom + 1);
      H.assertHelper(newWidgets.length - newChildrenTop === t3 - oldChildrenTop);
      newChildrenBottom = newWidgets.length - 1;
      while (true) {
        if (!(oldChildrenTop <= oldChildrenBottom && newChildrenTop <= newChildrenBottom))
          break;
        if (oldChildrenTop >= t3)
          return H.ioore(oldChildren, oldChildrenTop);
        oldChild = oldChildren[oldChildrenTop];
        H.assertHelper(replaceWithNullIfForgotten.call$1(oldChild) != null);
        H.assertHelper(oldChild._debugLifecycleState === C._ElementLifecycle_1);
        if (newChildrenTop >= newWidgets.length)
          return H.ioore(newWidgets, newChildrenTop);
        newWidget = newWidgets[newChildrenTop];
        t1 = oldChild.get$widget();
        H.assertHelper(new H.TypeImpl(H.getRti(t1)).$eq(0, J.get$runtimeType$(newWidget)) && J.$eq$(t1.key, newWidget.key));
        newChild = _this.updateChild$3(oldChild, newWidget, previousChild);
        H.assertHelper(newChild._debugLifecycleState === C._ElementLifecycle_1);
        if (!oldChild.$eq(0, newChild))
          t1 = oldChild._debugLifecycleState !== C._ElementLifecycle_1;
        else
          t1 = true;
        H.assertHelper(t1);
        C.JSArray_methods.$indexSet(newChildren, newChildrenTop, newChild);
        ++newChildrenTop;
        ++oldChildrenTop;
        previousChild = newChild;
      }
      if (haveOldChildren && oldKeyedChildren.get$isNotEmpty(oldKeyedChildren))
        for (t1 = oldKeyedChildren.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
          t2 = t1.get$current();
          if (!forgottenChildren.contains$1(0, t2))
            _this.deactivateChild$1(t2);
        }
      return newChildren;
    },
    deactivate$0: function() {
      this.super$Element$deactivate();
      if (H.assertTest(this.get$renderObject()._node$_owner == null))
        H.assertThrow("A RenderObject was still attached when attempting to deactivate its RenderObjectElement: " + H.S(this.get$renderObject()));
    },
    unmount$0: function() {
      var _this = this;
      _this.super$Element$unmount();
      if (H.assertTest(_this.get$renderObject()._node$_owner == null))
        H.assertThrow("A RenderObject was still attached when attempting to unmount its RenderObjectElement: " + H.S(_this.get$renderObject()));
      _this.get$widget().didUnmountRenderObject$1(_this.get$renderObject());
    },
    _updateSlot$1: function(newSlot) {
      var _this = this;
      H.assertHelper(!J.$eq$(_this._slot, newSlot));
      _this.super$Element$_updateSlot(newSlot);
      H.assertHelper(J.$eq$(_this._slot, newSlot));
      _this._ancestorRenderObjectElement.moveChildRenderObject$2(_this.get$renderObject(), _this._slot);
    },
    attachRenderObject$1: function(newSlot) {
      var t1, parentDataElement, _this = this;
      H.assertHelper(_this._ancestorRenderObjectElement == null);
      _this._slot = newSlot;
      t1 = _this._ancestorRenderObjectElement = _this._findAncestorRenderObjectElement$0();
      if (t1 != null)
        t1.insertChildRenderObject$2(_this.get$renderObject(), newSlot);
      parentDataElement = _this._findAncestorParentDataElement$0();
      if (parentDataElement != null)
        H.assertSubtype(H.assertSubtype(N.ProxyElement.prototype.get$widget.call(parentDataElement), "$isParentDataWidget", [H.getTypeArgumentByIndex(parentDataElement, 0)], "$asParentDataWidget"), "$isParentDataWidget", [N.RenderObjectWidget], "$asParentDataWidget").applyParentData$1(_this.get$renderObject());
    },
    detachRenderObject$0: function() {
      var _this = this,
        t1 = _this._ancestorRenderObjectElement;
      if (t1 != null) {
        t1.removeChildRenderObject$1(_this.get$renderObject());
        _this._ancestorRenderObjectElement = null;
      }
      _this._slot = null;
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Element$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("renderObject", this.get$renderObject(), _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.RenderObject);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  N.RenderObjectElement_mount_closure.prototype = {
    call$0: function() {
      this.$this._debugUpdateRenderObjectOwner$0();
      return true;
    },
    $signature: 0
  };
  N.RenderObjectElement_update_closure.prototype = {
    call$0: function() {
      this.$this._debugUpdateRenderObjectOwner$0();
      return true;
    },
    $signature: 0
  };
  N.RenderObjectElement__debugUpdateRenderObjectOwner_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._renderObject.debugCreator = new N._DebugCreator(t1);
      return true;
    },
    $signature: 0
  };
  N.RenderObjectElement_updateChildren_replaceWithNullIfForgotten.prototype = {
    call$1: function(child) {
      var t1 = this.forgottenChildren.contains$1(0, child);
      return t1 ? null : child;
    },
    $signature: 203
  };
  N.RootRenderObjectElement.prototype = {
    mount$2: function($parent, newSlot) {
      H.assertHelper($parent == null);
      H.assertHelper(newSlot == null);
      this.super$RenderObjectElement$mount($parent, newSlot);
    }
  };
  N.LeafRenderObjectElement.prototype = {
    forgetChild$1: function(child) {
      H.assertHelper(false);
    },
    insertChildRenderObject$2: function(child, slot) {
      H.assertHelper(false);
    },
    moveChildRenderObject$2: function(child, slot) {
      H.assertHelper(false);
    },
    removeChildRenderObject$1: function(child) {
      H.assertHelper(false);
    },
    debugDescribeChildren$0: function() {
      H.interceptedTypeCheck(N.Element.prototype.get$widget.call(this), "$isRenderObjectWidget");
      return C.List_empty;
    }
  };
  N.SingleChildRenderObjectElement.prototype = {
    get$widget: function() {
      return H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$widget.call(this), "$isSingleChildRenderObjectWidget");
    },
    visitChildren$1: function(visitor) {
      var t1;
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [N.Element]});
      t1 = this._framework$_child;
      if (t1 != null)
        visitor.call$1(t1);
    },
    forgetChild$1: function(child) {
      H.assertHelper(child.$eq(0, this._framework$_child));
      this._framework$_child = null;
    },
    mount$2: function($parent, newSlot) {
      var _this = this;
      _this.super$RenderObjectElement$mount($parent, newSlot);
      _this._framework$_child = _this.updateChild$3(_this._framework$_child, _this.get$widget().child, null);
    },
    update$1: function(newWidget) {
      var _this = this;
      H.interceptedTypeCheck(newWidget, "$isSingleChildRenderObjectWidget");
      _this.super$RenderObjectElement$update(newWidget);
      H.assertHelper(_this.get$widget() === newWidget);
      _this._framework$_child = _this.updateChild$3(_this._framework$_child, _this.get$widget().child, null);
    },
    insertChildRenderObject$2: function(child, slot) {
      var renderObject = H.assertSubtype(this._renderObject, "$isRenderObjectWithChildMixin", [K.RenderObject], "$asRenderObjectWithChildMixin");
      H.assertHelper(slot == null);
      renderObject.debugValidateChild$1(child);
      renderObject.set$child(child);
      H.assertHelper(renderObject === this._renderObject);
    },
    moveChildRenderObject$2: function(child, slot) {
      H.assertHelper(false);
    },
    removeChildRenderObject$1: function(child) {
      var renderObject = H.assertSubtype(this._renderObject, "$isRenderObjectWithChildMixin", [K.RenderObject], "$asRenderObjectWithChildMixin");
      H.assertHelper(renderObject.RenderObjectWithChildMixin__child == child);
      renderObject.set$child(null);
      H.assertHelper(renderObject === this._renderObject);
    }
  };
  N.MultiChildRenderObjectElement.prototype = {
    get$widget: function() {
      return H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$widget.call(this), "$isMultiChildRenderObjectWidget");
    },
    insertChildRenderObject$2: function(child, slot) {
      var renderObject;
      H.interceptedTypeCheck(slot, "$isElement");
      renderObject = H.assertSubtype(this._renderObject, "$isContainerRenderObjectMixin", [K.RenderObject, [K.ContainerParentDataMixin, K.RenderObject]], "$asContainerRenderObjectMixin");
      renderObject.debugValidateChild$1(child);
      renderObject.insert$2$after(0, child, slot == null ? null : slot.get$renderObject());
      H.assertHelper(renderObject === this._renderObject);
    },
    moveChildRenderObject$2: function(child, slot) {
      var renderObject = H.assertSubtype(this._renderObject, "$isContainerRenderObjectMixin", [K.RenderObject, [K.ContainerParentDataMixin, K.RenderObject]], "$asContainerRenderObjectMixin");
      H.assertHelper(child._node$_parent == renderObject);
      renderObject.move$2$after(child, slot == null ? null : slot.get$renderObject());
      H.assertHelper(renderObject === this._renderObject);
    },
    removeChildRenderObject$1: function(child) {
      var renderObject = H.assertSubtype(this._renderObject, "$isContainerRenderObjectMixin", [K.RenderObject, [K.ContainerParentDataMixin, K.RenderObject]], "$asContainerRenderObjectMixin");
      H.assertHelper(child._node$_parent == renderObject);
      renderObject.toString;
      H.assertSubtypeOfRuntimeType(child, H.getRuntimeTypeArgument(renderObject, "ContainerRenderObjectMixin", 0));
      renderObject._removeFromChildList$1(child);
      renderObject.dropChild$1(child);
      H.assertHelper(renderObject === this._renderObject);
    },
    visitChildren$1: function(visitor) {
      var t1, t2, t3, _i, child;
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [N.Element]});
      for (t1 = this._framework$_children, t2 = t1.length, t3 = this._forgottenChildren, _i = 0; _i < t2; ++_i) {
        child = t1[_i];
        if (!t3.contains$1(0, child))
          visitor.call$1(child);
      }
    },
    forgetChild$1: function(child) {
      var t1 = this._framework$_children;
      H.assertHelper((t1 && C.JSArray_methods).contains$1(t1, child));
      t1 = this._forgottenChildren;
      H.assertHelper(!t1.contains$1(0, child));
      t1.add$1(0, child);
    },
    mount$2: function($parent, newSlot) {
      var t1, previousChild, i, newChild, _this = this;
      _this.super$RenderObjectElement$mount($parent, newSlot);
      t1 = new Array(H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$widget.call(_this), "$isMultiChildRenderObjectWidget").children.length);
      t1.fixed$length = Array;
      _this.set$_framework$_children(H.setRuntimeTypeInfo(t1, [N.Element]));
      for (previousChild = null, i = 0; i < _this._framework$_children.length; ++i, previousChild = newChild) {
        t1 = H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$widget.call(_this), "$isMultiChildRenderObjectWidget").children;
        if (i >= t1.length)
          return H.ioore(t1, i);
        newChild = _this.inflateWidget$2(t1[i], previousChild);
        t1 = _this._framework$_children;
        (t1 && C.JSArray_methods).$indexSet(t1, i, newChild);
      }
    },
    update$1: function(newWidget) {
      var t1, _this = this;
      H.interceptedTypeCheck(newWidget, "$isMultiChildRenderObjectWidget");
      _this.super$RenderObjectElement$update(newWidget);
      H.assertHelper(H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$widget.call(_this), "$isMultiChildRenderObjectWidget") === newWidget);
      t1 = _this._forgottenChildren;
      _this.set$_framework$_children(_this.updateChildren$3$forgottenChildren(_this._framework$_children, H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$widget.call(_this), "$isMultiChildRenderObjectWidget").children, t1));
      t1.clear$0(0);
    },
    set$_framework$_children: function(_children) {
      this._framework$_children = H.assertSubtype(_children, "$isList", [N.Element], "$asList");
    }
  };
  N._DebugCreator.prototype = {
    toString$0: function(_) {
      return this.element.debugGetCreatorChain$1(12);
    }
  };
  D.GestureRecognizerFactory.prototype = {};
  D.GestureRecognizerFactoryWithHandlers.prototype = {};
  D.GestureDetector.prototype = {
    build$1: function(context) {
      var t1, _this = this,
        gestures = P.LinkedHashMap_LinkedHashMap$_empty(P.Type, [D.GestureRecognizerFactory, S.GestureRecognizer]);
      if (_this.onTapDown == null)
        t1 = _this.onTap != null || _this.onTapCancel != null;
      else
        t1 = true;
      if (t1)
        gestures.$indexSet(0, C.Type_TapGestureRecognizer_62h, D.GestureRecognizerFactoryWithHandlers$(new D.GestureDetector_build_closure(_this), new D.GestureDetector_build_closure0(_this), N.TapGestureRecognizer));
      if (_this.onDoubleTap != null)
        gestures.$indexSet(0, C.Type_DoubleTapGestureRecognizer_oyU, D.GestureRecognizerFactoryWithHandlers$(new D.GestureDetector_build_closure1(_this), new D.GestureDetector_build_closure2(_this), F.DoubleTapGestureRecognizer));
      if (_this.onLongPress == null)
        t1 = false;
      else
        t1 = true;
      if (t1)
        gestures.$indexSet(0, C.Type_LongPressGestureRecognizer_46y, D.GestureRecognizerFactoryWithHandlers$(new D.GestureDetector_build_closure3(_this), new D.GestureDetector_build_closure4(_this), T.LongPressGestureRecognizer));
      t1 = _this.onVerticalDragUpdate != null || _this.onVerticalDragEnd != null || false;
      if (t1)
        gestures.$indexSet(0, C.Type_mLh, D.GestureRecognizerFactoryWithHandlers$(new D.GestureDetector_build_closure5(_this), new D.GestureDetector_build_closure6(_this), O.VerticalDragGestureRecognizer));
      if (_this.onHorizontalDragDown == null)
        t1 = _this.onHorizontalDragUpdate != null || _this.onHorizontalDragEnd != null || _this.onHorizontalDragCancel != null;
      else
        t1 = true;
      if (t1)
        gestures.$indexSet(0, C.Type_Vq1, D.GestureRecognizerFactoryWithHandlers$(new D.GestureDetector_build_closure7(_this), new D.GestureDetector_build_closure8(_this), O.HorizontalDragGestureRecognizer));
      if (_this.onPanDown == null)
        t1 = _this.onPanUpdate != null || _this.onPanEnd != null || false;
      else
        t1 = true;
      if (t1)
        gestures.$indexSet(0, C.Type_PanGestureRecognizer_bbH, D.GestureRecognizerFactoryWithHandlers$(new D.GestureDetector_build_closure9(_this), new D.GestureDetector_build_closure10(_this), O.PanGestureRecognizer));
      return new D.RawGestureDetector(_this.child, gestures, _this.behavior, _this.excludeFromSemantics, null);
    },
    debugFillProperties$1: function(properties) {
      var _null = null;
      this.super$Widget$debugFillProperties(properties);
      C.JSArray_methods.add$1(properties.properties, new Y.EnumProperty(_null, _null, _null, _null, false, this.dragStartBehavior, C.C__NoDefaultValue, C.DiagnosticLevel_3, "startBehavior", true, true, C.DiagnosticsTreeStyle_5, [S.DragStartBehavior]));
    }
  };
  D.GestureDetector_build_closure.prototype = {
    call$0: function() {
      var t1 = P.int;
      return new N.TapGestureRecognizer(C.Duration_100000, 18, C.GestureRecognizerState_0, P.LinkedHashMap_LinkedHashMap$_empty(t1, D.GestureArenaEntry), P.HashSet_HashSet(t1), this.$this, null);
    },
    $signature: 144
  };
  D.GestureDetector_build_closure0.prototype = {
    call$1: function(instance) {
      var t1;
      H.interceptedTypeCheck(instance, "$isTapGestureRecognizer");
      t1 = this.$this;
      instance.set$onTapDown(t1.onTapDown);
      instance.set$onTapUp(null);
      instance.set$onTap(t1.onTap);
      instance.set$onTapCancel(t1.onTapCancel);
    },
    $signature: 145
  };
  D.GestureDetector_build_closure1.prototype = {
    call$0: function() {
      return new F.DoubleTapGestureRecognizer(P.LinkedHashMap_LinkedHashMap$_empty(P.int, F._TapTracker), this.$this, null);
    },
    $signature: 146
  };
  D.GestureDetector_build_closure2.prototype = {
    call$1: function(instance) {
      H.interceptedTypeCheck(instance, "$isDoubleTapGestureRecognizer").set$onDoubleTap(this.$this.onDoubleTap);
    },
    $signature: 147
  };
  D.GestureDetector_build_closure3.prototype = {
    call$0: function() {
      var t1 = P.int;
      return new T.LongPressGestureRecognizer(C.Duration_500000, null, C.GestureRecognizerState_0, P.LinkedHashMap_LinkedHashMap$_empty(t1, D.GestureArenaEntry), P.HashSet_HashSet(t1), this.$this, null);
    },
    $signature: 148
  };
  D.GestureDetector_build_closure4.prototype = {
    call$1: function(instance) {
      var _null = null;
      H.interceptedTypeCheck(instance, "$isLongPressGestureRecognizer");
      instance.set$onLongPress(this.$this.onLongPress);
      instance.set$onLongPressStart(_null);
      instance.set$onLongPressMoveUpdate(_null);
      instance.set$onLongPressEnd(_null);
      instance.set$onLongPressUp(_null);
    },
    $signature: 149
  };
  D.GestureDetector_build_closure5.prototype = {
    call$0: function() {
      var t1 = P.int;
      return new O.VerticalDragGestureRecognizer(C.DragStartBehavior_1, C._DragState_0, P.LinkedHashMap_LinkedHashMap$_empty(t1, R.VelocityTracker), P.LinkedHashMap_LinkedHashMap$_empty(t1, D.GestureArenaEntry), P.HashSet_HashSet(t1), this.$this, null);
    },
    $signature: 150
  };
  D.GestureDetector_build_closure6.prototype = {
    call$1: function(instance) {
      var t1;
      H.interceptedTypeCheck(instance, "$isVerticalDragGestureRecognizer");
      instance.set$onDown(null);
      instance.set$onStart(null);
      t1 = this.$this;
      instance.set$onUpdate(t1.onVerticalDragUpdate);
      instance.set$onEnd(t1.onVerticalDragEnd);
      instance.set$onCancel(null);
      instance.dragStartBehavior = t1.dragStartBehavior;
    },
    $signature: 151
  };
  D.GestureDetector_build_closure7.prototype = {
    call$0: function() {
      var t1 = P.int;
      return new O.HorizontalDragGestureRecognizer(C.DragStartBehavior_1, C._DragState_0, P.LinkedHashMap_LinkedHashMap$_empty(t1, R.VelocityTracker), P.LinkedHashMap_LinkedHashMap$_empty(t1, D.GestureArenaEntry), P.HashSet_HashSet(t1), this.$this, null);
    },
    $signature: 152
  };
  D.GestureDetector_build_closure8.prototype = {
    call$1: function(instance) {
      var t1;
      H.interceptedTypeCheck(instance, "$isHorizontalDragGestureRecognizer");
      t1 = this.$this;
      instance.set$onDown(t1.onHorizontalDragDown);
      instance.set$onStart(null);
      instance.set$onUpdate(t1.onHorizontalDragUpdate);
      instance.set$onEnd(t1.onHorizontalDragEnd);
      instance.set$onCancel(t1.onHorizontalDragCancel);
      instance.dragStartBehavior = t1.dragStartBehavior;
    },
    $signature: 153
  };
  D.GestureDetector_build_closure9.prototype = {
    call$0: function() {
      var t1 = P.int;
      return new O.PanGestureRecognizer(C.DragStartBehavior_1, C._DragState_0, P.LinkedHashMap_LinkedHashMap$_empty(t1, R.VelocityTracker), P.LinkedHashMap_LinkedHashMap$_empty(t1, D.GestureArenaEntry), P.HashSet_HashSet(t1), this.$this, null);
    },
    $signature: 154
  };
  D.GestureDetector_build_closure10.prototype = {
    call$1: function(instance) {
      var t1;
      H.interceptedTypeCheck(instance, "$isPanGestureRecognizer");
      t1 = this.$this;
      instance.set$onDown(t1.onPanDown);
      instance.set$onStart(null);
      instance.set$onUpdate(t1.onPanUpdate);
      instance.set$onEnd(t1.onPanEnd);
      instance.set$onCancel(null);
      instance.dragStartBehavior = t1.dragStartBehavior;
    },
    $signature: 155
  };
  D.RawGestureDetector.prototype = {
    createState$0: function() {
      return new D.RawGestureDetectorState(C.Map_empty0, C._StateLifecycle_0);
    },
    get$child: function() {
      return this.child;
    },
    get$excludeFromSemantics: function() {
      return this.excludeFromSemantics;
    }
  };
  D.RawGestureDetectorState.prototype = {
    initState$0: function() {
      this.super$State$initState();
      this._syncAll$1(this._widget.gestures);
    },
    didUpdateWidget$1: function(oldWidget) {
      this.super$State$didUpdateWidget(H.interceptedTypeCheck(oldWidget, "$isRawGestureDetector"));
      this._syncAll$1(this._widget.gestures);
    },
    dispose$0: function() {
      for (var t1 = this._recognizers.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
        t1.get$current().dispose$0();
      this.set$_recognizers(null);
      this.super$State$dispose();
    },
    _syncAll$1: function(gestures) {
      var oldRecognizers, t2, t3, t4, _this = this,
        _s33_ = "GestureRecognizerFactory of type ",
        t1 = P.Type;
      H.assertSubtype(gestures, "$isMap", [t1, [D.GestureRecognizerFactory, S.GestureRecognizer]], "$asMap");
      H.assertHelper(_this._recognizers != null);
      oldRecognizers = _this._recognizers;
      _this.set$_recognizers(P.LinkedHashMap_LinkedHashMap$_empty(t1, S.GestureRecognizer));
      for (t1 = gestures.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        t2 = t1.get$current();
        H.assertHelper(gestures.$index(0, t2) != null);
        t3 = gestures.$index(0, t2);
        t3.toString;
        t3 = H.getTypeArgumentByIndex(t3, 0);
        if (H.assertTest(J.$eq$(t2, new H.TypeImpl(t3))))
          H.assertThrow(_s33_ + new H.TypeImpl(t3).toString$0(0) + " was used where type " + H.S(t2) + " was specified.");
        H.assertHelper(!_this._recognizers.containsKey$1(t2));
        t3 = _this._recognizers;
        t4 = oldRecognizers.$index(0, t2);
        t3.$indexSet(0, t2, t4 == null ? gestures.$index(0, t2)._constructor.call$0() : t4);
        if (H.assertTest(J.get$runtimeType$(_this._recognizers.$index(0, t2)).$eq(0, t2)))
          H.assertThrow(_s33_ + H.S(t2) + " created a GestureRecognizer of type " + J.get$runtimeType$(_this._recognizers.$index(0, t2)).toString$0(0) + ". The GestureRecognizerFactory must be specialized with the type of the class that it returns from its constructor method.");
        t3 = gestures.$index(0, t2);
        t2 = _this._recognizers.$index(0, t2);
        t3.toString;
        H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(t3, 0));
        t3._initializer.call$1(t2);
      }
      for (t1 = oldRecognizers.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        t2 = t1.get$current();
        if (!_this._recognizers.containsKey$1(t2))
          oldRecognizers.$index(0, t2).dispose$0();
      }
    },
    _gesture_detector$_handlePointerDown$1: function($event) {
      var t1, t2;
      H.assertHelper(this._recognizers != null);
      for (t1 = this._recognizers.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        t2 = t1.get$current();
        t2.addAllowedPointer$1($event);
      }
    },
    _handleSemanticsTap$0: function() {
      var t1,
        recognizer = H.interceptedTypeCheck(this._recognizers.$index(0, C.Type_TapGestureRecognizer_62h), "$isTapGestureRecognizer");
      H.assertHelper(recognizer != null);
      t1 = recognizer.onTapDown;
      if (t1 != null)
        t1.call$1(new N.TapDownDetails(C.Offset_0_0));
      t1 = recognizer.onTap;
      if (t1 != null)
        t1.call$0();
    },
    _handleSemanticsLongPress$0: function() {
      var t1,
        recognizer = H.interceptedTypeCheck(this._recognizers.$index(0, C.Type_LongPressGestureRecognizer_46y), "$isLongPressGestureRecognizer");
      H.assertHelper(recognizer != null);
      t1 = recognizer.onLongPress;
      if (t1 != null)
        t1.call$0();
    },
    _handleSemanticsHorizontalDragUpdate$1: function(updateDetails) {
      var recognizer, t1;
      H.interceptedTypeCheck(updateDetails, "$isDragUpdateDetails");
      recognizer = H.interceptedTypeCheck(this._recognizers.$index(0, C.Type_Vq1), "$isHorizontalDragGestureRecognizer");
      if (recognizer != null) {
        t1 = recognizer.onDown;
        if (t1 != null)
          t1.call$1(new O.DragDownDetails(C.Offset_0_0));
        t1 = recognizer.onStart;
        if (t1 != null)
          t1.call$1(new O.DragStartDetails(C.Offset_0_0));
        t1 = recognizer.onUpdate;
        if (t1 != null)
          t1.call$1(updateDetails);
        t1 = recognizer.onEnd;
        if (t1 != null)
          t1.call$1(O.DragEndDetails$(0, C.Velocity_Offset_0_0));
        return;
      }
      recognizer = H.interceptedTypeCheck(this._recognizers.$index(0, C.Type_PanGestureRecognizer_bbH), "$isPanGestureRecognizer");
      if (recognizer != null) {
        t1 = recognizer.onDown;
        if (t1 != null)
          t1.call$1(new O.DragDownDetails(C.Offset_0_0));
        t1 = recognizer.onStart;
        if (t1 != null)
          t1.call$1(new O.DragStartDetails(C.Offset_0_0));
        t1 = recognizer.onUpdate;
        if (t1 != null)
          t1.call$1(updateDetails);
        t1 = recognizer.onEnd;
        if (t1 != null)
          t1.call$1(O.DragEndDetails$(null, C.Velocity_Offset_0_0));
        return;
      }
    },
    _handleSemanticsVerticalDragUpdate$1: function(updateDetails) {
      var recognizer, t1;
      H.interceptedTypeCheck(updateDetails, "$isDragUpdateDetails");
      recognizer = H.interceptedTypeCheck(this._recognizers.$index(0, C.Type_mLh), "$isVerticalDragGestureRecognizer");
      if (recognizer != null) {
        t1 = recognizer.onDown;
        if (t1 != null)
          t1.call$1(new O.DragDownDetails(C.Offset_0_0));
        t1 = recognizer.onStart;
        if (t1 != null)
          t1.call$1(new O.DragStartDetails(C.Offset_0_0));
        t1 = recognizer.onUpdate;
        if (t1 != null)
          t1.call$1(updateDetails);
        t1 = recognizer.onEnd;
        if (t1 != null)
          t1.call$1(O.DragEndDetails$(0, C.Velocity_Offset_0_0));
        return;
      }
      recognizer = H.interceptedTypeCheck(this._recognizers.$index(0, C.Type_PanGestureRecognizer_bbH), "$isPanGestureRecognizer");
      if (recognizer != null) {
        t1 = recognizer.onDown;
        if (t1 != null)
          t1.call$1(new O.DragDownDetails(C.Offset_0_0));
        t1 = recognizer.onStart;
        if (t1 != null)
          t1.call$1(new O.DragStartDetails(C.Offset_0_0));
        t1 = recognizer.onUpdate;
        if (t1 != null)
          t1.call$1(updateDetails);
        t1 = recognizer.onEnd;
        if (t1 != null)
          t1.call$1(O.DragEndDetails$(null, C.Velocity_Offset_0_0));
        return;
      }
    },
    build$1: function(context) {
      var result,
        t1 = this._widget,
        t2 = t1.behavior;
      if (t2 == null)
        t2 = t1.child == null ? C.HitTestBehavior_2 : C.HitTestBehavior_0;
      result = T.Listener$(t2, t1.child, null, this.get$_gesture_detector$_handlePointerDown(), null);
      return !t1.excludeFromSemantics ? new D._GestureSemantics(this, result, null) : result;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _this = this, _null = null;
      _this.super$State$debugFillProperties(properties);
      t1 = _this._recognizers;
      if (t1 == null) {
        t1 = Y.DiagnosticsNode_DiagnosticsNode$message("DISPOSED", C.DiagnosticsTreeStyle_5);
        t2 = properties.properties;
        C.JSArray_methods.add$1(t2, t1);
        t1 = t2;
      } else {
        t1 = t1.get$values();
        t2 = P.String;
        t3 = H.getRuntimeTypeArgument(t1, "Iterable", 0);
        t3 = H.MappedIterable_MappedIterable(t1, H.functionTypeCheck(new D.RawGestureDetectorState_debugFillProperties_closure(), {func: 1, ret: t2, args: [t3]}), t3, t2);
        t2 = Y.IterableProperty$("gestures", P.List_List$from(t3, true, H.getRuntimeTypeArgument(t3, "Iterable", 0)), C.C__NoDefaultValue, "<none>", C.DiagnosticLevel_3, C.DiagnosticsTreeStyle_5, t2);
        t3 = properties.properties;
        C.JSArray_methods.add$1(t3, t2);
        C.JSArray_methods.add$1(t3, Y.IterableProperty$("recognizers", _this._recognizers.get$values(), C.C__NoDefaultValue, "[]", C.DiagnosticLevel_1, C.DiagnosticsTreeStyle_5, S.GestureRecognizer));
        t1 = t3;
      }
      t2 = _this._widget.behavior;
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, t2, _null, C.DiagnosticLevel_3, "behavior", true, true, C.DiagnosticsTreeStyle_5, [E.HitTestBehavior]));
    },
    set$_recognizers: function(_recognizers) {
      this._recognizers = H.assertSubtype(_recognizers, "$isMap", [P.Type, S.GestureRecognizer], "$asMap");
    },
    $asState: function() {
      return [D.RawGestureDetector];
    }
  };
  D.RawGestureDetectorState_debugFillProperties_closure.prototype = {
    call$1: function(recognizer) {
      return H.interceptedTypeCheck(recognizer, "$isGestureRecognizer").get$debugDescription();
    },
    $signature: 156
  };
  D._GestureSemantics.prototype = {
    createRenderObject$1: function(context) {
      var _this = this,
        t1 = new E.RenderSemanticsGestureHandler(_this.get$_onTapHandler(), _this.get$_onLongPressHandler(), _this.get$_onHorizontalDragUpdateHandler(), _this.get$_onVerticalDragUpdateHandler(), null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      var _this = this;
      H.interceptedTypeCheck(renderObject, "$isRenderSemanticsGestureHandler");
      renderObject.set$onTap(_this.get$_onTapHandler());
      renderObject.set$onLongPress(_this.get$_onLongPressHandler());
      renderObject.set$onHorizontalDragUpdate(_this.get$_onHorizontalDragUpdateHandler());
      renderObject.set$onVerticalDragUpdate(_this.get$_onVerticalDragUpdateHandler());
    },
    get$_onTapHandler: function() {
      var t1 = this.owner;
      return t1._recognizers.containsKey$1(C.Type_TapGestureRecognizer_62h) ? t1.get$_handleSemanticsTap() : null;
    },
    get$_onLongPressHandler: function() {
      var t1 = this.owner;
      return t1._recognizers.containsKey$1(C.Type_LongPressGestureRecognizer_46y) ? t1.get$_handleSemanticsLongPress() : null;
    },
    get$_onHorizontalDragUpdateHandler: function() {
      var t1 = this.owner;
      return t1._recognizers.containsKey$1(C.Type_Vq1) || t1._recognizers.containsKey$1(C.Type_PanGestureRecognizer_bbH) ? t1.get$_handleSemanticsHorizontalDragUpdate() : null;
    },
    get$_onVerticalDragUpdateHandler: function() {
      var t1 = this.owner;
      return t1._recognizers.containsKey$1(C.Type_mLh) || t1._recognizers.containsKey$1(C.Type_PanGestureRecognizer_bbH) ? t1.get$_handleSemanticsVerticalDragUpdate() : null;
    }
  };
  T.HeroFlightDirection.prototype = {
    toString$0: function(_) {
      return this._heroes$_name;
    }
  };
  T.Hero.prototype = {
    createState$0: function() {
      return new T._HeroState(new N.LabeledGlobalKey(null, [[N.State, N.StatefulWidget]]), C._StateLifecycle_0);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("tag", this.tag, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Object);
      C.JSArray_methods.add$1(properties.properties, t1);
    },
    get$child: function() {
      return this.child;
    }
  };
  T.Hero__allHeroesFor_addHero.prototype = {
    call$2: function(hero, tag) {
      var t1 = this.result;
      H.assertHelper(new T.Hero__allHeroesFor_addHero_closure(t1, tag, hero).call$0());
      t1.$indexSet(0, tag, H.interceptedTypeCheck(hero._framework$_state, "$is_HeroState"));
    },
    $signature: 157
  };
  T.Hero__allHeroesFor_addHero_closure.prototype = {
    call$0: function() {
      var t1 = this.tag;
      if (this.result.containsKey$1(t1))
        throw H.wrapException(U.FlutterError$("There are multiple heroes that share the same tag within a subtree.\nWithin each subtree for which heroes are to be animated (i.e. a PageRoute subtree), each Hero must have a unique non-null tag.\nIn this case, multiple heroes had the following tag: " + t1.toString$0(0) + "\nHere is the subtree for one of the offending heroes:\n" + this.hero.toStringDeep$1$prefixLineOne("# ")));
      return true;
    },
    $signature: 0
  };
  T.Hero__allHeroesFor_visitor.prototype = {
    call$1: function(element) {
      var heroWidget, tag, heroRoute, t1, _this = this;
      if (!!element.get$widget().$isHero) {
        H.interceptedTypeCheck(element, "$isStatefulElement");
        heroWidget = H.interceptedTypeCheck(element.get$widget(), "$isHero");
        if (!_this.isUserGestureTransition || false) {
          tag = heroWidget.tag;
          if (K.Navigator_of(element) === _this.navigator)
            _this.addHero.call$2(element, tag);
          else {
            heroRoute = T.ModalRoute_of(element, P.Object);
            if (heroRoute != null)
              t1 = heroRoute.get$isCurrent();
            else
              t1 = false;
            if (t1)
              _this.addHero.call$2(element, tag);
          }
        }
      }
      element.visitChildren$1(_this);
    },
    $signature: 9
  };
  T._HeroState.prototype = {
    startFlight$0: function() {
      var box, _this = this;
      H.assertHelper(_this._element != null);
      box = H.interceptedTypeCheck(_this._element.get$renderObject(), "$isRenderBox");
      H.assertHelper(box != null && box._size != null);
      _this.setState$1(new T._HeroState_startFlight_closure(_this, box));
    },
    endFlight$0: function() {
      if (this._element != null)
        this.setState$1(new T._HeroState_endFlight_closure(this));
    },
    build$1: function(context) {
      var t1, t2, _this = this;
      if (H.assertTest(context.ancestorWidgetOfExactType$1(C.Type_Hero_qBr) == null))
        H.assertThrow("A Hero widget cannot be the descendant of another Hero widget.");
      t1 = _this._placeholderSize;
      if (t1 != null) {
        _this._widget.toString;
        t2 = t1._dx;
        t1 = t1._dy;
        return new T.SizedBox(t2, t1, null, null);
      }
      return new T.KeyedSubtree(_this._widget.child, _this._heroes$_key);
    },
    $asState: function() {
      return [T.Hero];
    }
  };
  T._HeroState_startFlight_closure.prototype = {
    call$0: function() {
      this.$this._placeholderSize = this.box.get$size();
    },
    $signature: 2
  };
  T._HeroState_endFlight_closure.prototype = {
    call$0: function() {
      this.$this._placeholderSize = null;
    },
    $signature: 2
  };
  T._HeroFlightManifest.prototype = {
    get$animation: function() {
      return S.CurvedAnimation$(C.Cubic_ifx, this.type === C.HeroFlightDirection_0 ? this.toRoute._animationProxy : this.fromRoute._animationProxy, null);
    },
    toString$0: function(_) {
      var _this = this,
        t1 = _this.fromHero;
      return "_HeroFlightManifest(" + _this.type.toString$0(0) + " tag: " + t1._widget.tag.toString$0(0) + " from route: " + _this.fromRoute.settings.toString$0(0) + " to route: " + _this.toRoute.settings.toString$0(0) + " with hero: " + H.S(t1) + " to " + H.S(_this.toHero) + ")";
    }
  };
  T._HeroFlight.prototype = {
    _doCreateRectTween$2: function(begin, end) {
      var createRectTween,
        t1 = this.manifest;
      t1.toHero._widget.toString;
      createRectTween = t1.createRectTween;
      return createRectTween.call$2(begin, end);
    },
    _buildOverlay$1: function(context) {
      var t1, t2, t3, t4, t5, _this = this;
      H.interceptedTypeCheck(context, "$isBuildContext");
      H.assertHelper(_this.manifest != null);
      t1 = _this.shuttle;
      if (t1 == null) {
        t1 = _this.manifest;
        t2 = t1.get$animation();
        t3 = _this.manifest;
        t4 = t3.type;
        t5 = t3.fromHero._element;
        t3 = t3.toHero._element;
        t3 = _this.shuttle = H.interceptedTypeCheck(t1.shuttleBuilder.call$5(context, t2, t4, t5, t3), "$isWidget");
        t1 = t3;
      }
      H.assertHelper(t1 != null);
      return K.AnimatedBuilder$(_this._proxyAnimation, new T._HeroFlight__buildOverlay_closure(_this), _this.shuttle);
    },
    _handleAnimationUpdate$1: function($status) {
      var _this = this;
      H.interceptedTypeCheck($status, "$isAnimationStatus");
      if ($status === C.AnimationStatus_3 || $status === C.AnimationStatus_0) {
        _this._proxyAnimation.set$parent(null);
        H.assertHelper(_this.overlayEntry != null);
        _this.overlayEntry.remove$0(0);
        _this.overlayEntry = null;
        _this.manifest.fromHero.endFlight$0();
        _this.manifest.toHero.endFlight$0();
        _this.onFlightEnded.call$1(_this);
      }
    },
    start$1: function(initialManifest) {
      var t1, t2, _this = this;
      H.assertHelper(!_this._aborted);
      H.assertHelper(new T._HeroFlight_start_closure(initialManifest).call$0());
      _this.manifest = initialManifest;
      t1 = _this._proxyAnimation;
      if (initialManifest.type === C.HeroFlightDirection_1) {
        t2 = {func: 1, ret: -1, args: [X.AnimationStatus]};
        t1.set$parent(new S.ReverseAnimation(initialManifest.get$animation(), new R.ObserverList(H.setRuntimeTypeInfo([], [t2]), [t2]), 0));
      } else
        t1.set$parent(initialManifest.get$animation());
      _this.manifest.fromHero.startFlight$0();
      _this.manifest.toHero.startFlight$0();
      _this.set$heroRectTween(_this._doCreateRectTween$2(T._globalBoundingBoxFor(_this.manifest.fromHero._element), T._globalBoundingBoxFor(_this.manifest.toHero._element)));
      t1 = X.OverlayEntry$(_this.get$_buildOverlay(), false);
      _this.overlayEntry = t1;
      _this.manifest.overlay.insert$1(0, t1);
    },
    toString$0: function(_) {
      var t1 = this.manifest,
        t2 = t1.fromRoute,
        t3 = t1.toRoute;
      return "HeroFlight(for: " + t1.fromHero._widget.tag.toString$0(0) + ", from: " + t2.settings.toString$0(0) + ", to: " + t3.settings.toString$0(0) + " " + H.S(this._proxyAnimation._animations$_parent) + ")";
    },
    set$heroRectTween: function(heroRectTween) {
      this.heroRectTween = H.assertSubtype(heroRectTween, "$isTween", [P.Rect], "$asTween");
    },
    set$_heroOpacity: function(_heroOpacity) {
      this._heroOpacity = H.assertSubtype(_heroOpacity, "$isAnimation", [P.double], "$asAnimation");
    }
  };
  T._HeroFlight__buildOverlay_closure.prototype = {
    call$2: function(context, child) {
      var t1, t2, toHeroBox, t3, t4, t5, toHeroOrigin, t6, t7, t8, rect, t9, offsets, _null = null;
      H.interceptedTypeCheck(context, "$isBuildContext");
      H.interceptedTypeCheck(child, "$isWidget");
      t1 = this.$this;
      t2 = t1.manifest.toHero._element;
      toHeroBox = H.interceptedTypeCheck(t2 == null ? _null : t2.get$renderObject(), "$isRenderBox");
      if (t1._aborted || toHeroBox == null || toHeroBox._node$_owner == null) {
        t2 = t1._heroOpacity;
        if (t2.get$status(t2) === C.AnimationStatus_3) {
          t2 = t1._proxyAnimation;
          t3 = $.$get$_HeroFlight__reverseTween();
          t4 = Z.Interval$(t2.get$value(), 1, C.C__Linear);
          t3.toString;
          t5 = P.double;
          t1.set$_heroOpacity(t2.drive$1$1(new R._ChainedEvaluation(H.assertSubtype(new R.CurveTween(t4), "$isAnimatable", [t5], "$asAnimatable"), t3, [H.getRuntimeTypeArgument(t3, "Animatable", 0)]), t5));
        }
      } else if (toHeroBox._size != null) {
        t2 = $.GlobalKey__registry.$index(0, t1.manifest.toRoute._subtreeKey);
        toHeroOrigin = T.MatrixUtils_transformPoint(toHeroBox.getTransformTo$1(H.interceptedTypeCheck(t2 == null ? _null : t2.get$renderObject(), "$isRenderBox")), C.Offset_0_0);
        t2 = t1.heroRectTween.end;
        if (!toHeroOrigin.$eq(0, new P.Offset(t2.left, t2.top))) {
          t2 = t1.heroRectTween;
          t3 = t2.end;
          t4 = t3.right;
          t5 = t3.left;
          if (typeof t4 !== "number")
            return t4.$sub();
          if (typeof t5 !== "number")
            return H.iae(t5);
          t6 = t3.bottom;
          t3 = t3.top;
          if (typeof t6 !== "number")
            return t6.$sub();
          if (typeof t3 !== "number")
            return H.iae(t3);
          t7 = toHeroOrigin._dx;
          t8 = toHeroOrigin._dy;
          if (typeof t7 !== "number")
            return t7.$add();
          if (typeof t8 !== "number")
            return t8.$add();
          t1.set$heroRectTween(t1._doCreateRectTween$2(t2.begin, new P.Rect(t7, t8, t7 + (t4 - t5), t8 + (t6 - t3))));
        }
      }
      t2 = t1.heroRectTween;
      t3 = t1._proxyAnimation;
      t2.toString;
      rect = t2.transform$1(H.assertSubtype(t3, "$isAnimation", [P.double], "$asAnimation").get$value());
      t3 = t1.manifest.navigatorRect;
      t2 = t3.right;
      t4 = t3.left;
      if (typeof t2 !== "number")
        return t2.$sub();
      if (typeof t4 !== "number")
        return H.iae(t4);
      t5 = t3.bottom;
      t3 = t3.top;
      if (typeof t5 !== "number")
        return t5.$sub();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t6 = rect.left;
      t7 = rect.top;
      t8 = rect.right;
      if (typeof t8 !== "number")
        return H.iae(t8);
      t9 = rect.bottom;
      if (typeof t9 !== "number")
        return H.iae(t9);
      offsets = K.RelativeRect$fromLTRB(t6, t7, t2 - t4 - t8, t5 - t3 - t9);
      return T.Positioned$(offsets.bottom, T.IgnorePointer$(new T.RepaintBoundary(T.Opacity$(child, t1._heroOpacity.get$value()), _null), true, _null, _null), _null, _null, offsets.left, offsets.right, offsets.top, _null);
    },
    $signature: 158
  };
  T._HeroFlight_start_closure.prototype = {
    call$0: function() {
      var t2,
        t1 = this.initialManifest,
        initial = t1.get$animation();
      switch (t1.type) {
        case C.HeroFlightDirection_1:
          t1 = initial.get$value() === 1 && t1.isUserGestureTransition;
          t2 = initial.parent;
          return t1 ? t2.get$status(t2) === C.AnimationStatus_3 : t2.get$status(t2) === C.AnimationStatus_2;
        case C.HeroFlightDirection_0:
          if (initial.get$value() === 0) {
            t1 = initial.parent;
            t1 = t1.get$status(t1) === C.AnimationStatus_1;
          } else
            t1 = false;
          return t1;
      }
      return;
    },
    $signature: 0
  };
  T.HeroController.prototype = {
    _maybeStartHeroTransition$4: function(fromRoute, toRoute, flightType, isUserGestureTransition) {
      var animation, t1, t2;
      if (toRoute != fromRoute && toRoute instanceof V.PageRoute && fromRoute instanceof V.PageRoute) {
        animation = flightType === C.HeroFlightDirection_0 ? toRoute._animationProxy : fromRoute._animationProxy;
        switch (flightType) {
          case C.HeroFlightDirection_1:
            if (animation.get$value() === 0)
              return;
            break;
          case C.HeroFlightDirection_0:
            if (animation.get$value() === 1)
              return;
            break;
        }
        if (isUserGestureTransition)
          if (flightType === C.HeroFlightDirection_1) {
            toRoute.toString;
            t1 = true;
          } else
            t1 = false;
        else
          t1 = false;
        if (t1)
          this._startHeroTransition$5(fromRoute, toRoute, animation, flightType, isUserGestureTransition);
        else {
          toRoute.set$offstage(toRoute._animationProxy.get$value() === 0);
          t1 = $.WidgetsBinding__instance;
          t1.toString;
          t2 = H.functionTypeCheck(new T.HeroController__maybeStartHeroTransition_closure(this, fromRoute, toRoute, animation, flightType, isUserGestureTransition), {func: 1, ret: -1, args: [P.Duration]});
          C.JSArray_methods.add$1(t1.SchedulerBinding__postFrameCallbacks, t2);
        }
      }
    },
    _startHeroTransition$5: function(from, to, animation, flightType, isUserGestureTransition) {
      var navigatorRect, fromHeroes, toHeroes, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, tag, t16, t17, t18, t19, manifest, t20, box, t21, t22, _this = this, _null = null,
        t1 = P.double,
        t2 = [t1];
      H.assertSubtype(animation, "$isAnimation", t2, "$asAnimation");
      if (_this._navigator$_navigator == null || $.GlobalKey__registry.$index(0, from._subtreeKey) == null || $.GlobalKey__registry.$index(0, to._subtreeKey) == null) {
        to.set$offstage(false);
        return;
      }
      navigatorRect = T._globalBoundingBoxFor(_this._navigator$_navigator._element);
      fromHeroes = T.Hero__allHeroesFor($.GlobalKey__registry.$index(0, from._subtreeKey), isUserGestureTransition, _this._navigator$_navigator);
      toHeroes = T.Hero__allHeroesFor($.GlobalKey__registry.$index(0, to._subtreeKey), isUserGestureTransition, _this._navigator$_navigator);
      to.set$offstage(false);
      for (t3 = fromHeroes.get$keys(), t3 = t3.get$iterator(t3), t4 = _this._flights, t5 = {func: 1, ret: -1, args: [X.AnimationStatus]}, t6 = _this.get$_handleFlightEnded(), t7 = [t5], t8 = [t5], t9 = {func: 1, ret: -1}, t10 = [t9], t9 = [t9], t11 = _this.createRectTween, t12 = [t1], t1 = [t1], t13 = [P.Rect], t14 = flightType === C.HeroFlightDirection_0, t15 = flightType === C.HeroFlightDirection_1; t3.moveNext$0();) {
        tag = t3.get$current();
        if (toHeroes.$index(0, tag) != null) {
          fromHeroes.$index(0, tag)._widget.toString;
          toHeroes.$index(0, tag)._widget.toString;
          t16 = _this._navigator$_navigator._overlayKey.get$currentState();
          t17 = fromHeroes.$index(0, tag);
          t18 = toHeroes.$index(0, tag);
          t19 = $.$get$HeroController__defaultHeroFlightShuttleBuilder();
          manifest = new T._HeroFlightManifest(flightType, t16, navigatorRect, from, to, t17, t18, t11, t19, isUserGestureTransition);
          if (t4.$index(0, tag) != null) {
            t16 = t4.$index(0, tag);
            H.assertHelper(t16.manifest.fromHero._widget.tag === t17._widget.tag);
            t19 = t16.manifest;
            t20 = t19.type;
            if (t20 === C.HeroFlightDirection_0 && t15) {
              t19 = S.CurvedAnimation$(C.Cubic_ifx, t14 ? to._animationProxy : from._animationProxy, _null).parent;
              H.assertHelper(t19.get$status(t19) === C.AnimationStatus_2);
              H.assertHelper(t16.manifest.fromHero == t18);
              H.assertHelper(t16.manifest.toHero == t17);
              H.assertHelper(t16.manifest.fromRoute === to);
              H.assertHelper(t16.manifest.toRoute === from);
              t17 = t16._proxyAnimation;
              t17.set$parent(new S.ReverseAnimation(S.CurvedAnimation$(C.Cubic_ifx, t14 ? to._animationProxy : from._animationProxy, _null), new R.ObserverList(H.setRuntimeTypeInfo([], t7), t8), 0));
              t17 = t16.heroRectTween;
              t16.set$heroRectTween(new R.ReverseTween(t17, t17.end, t17.begin, t13));
            } else if (t20 === C.HeroFlightDirection_1 && t14) {
              t19 = S.CurvedAnimation$(C.Cubic_ifx, t14 ? to._animationProxy : from._animationProxy, _null).parent;
              H.assertHelper(t19.get$status(t19) === C.AnimationStatus_1);
              H.assertHelper(t16.manifest.toHero == t17);
              H.assertHelper(t16.manifest.toRoute === from);
              t17 = t16._proxyAnimation;
              t19 = S.CurvedAnimation$(C.Cubic_ifx, t14 ? to._animationProxy : from._animationProxy, _null);
              t20 = t16.manifest;
              t20 = H.assertSubtype(new R.Tween(S.CurvedAnimation$(C.Cubic_ifx, t20.type === C.HeroFlightDirection_0 ? t20.toRoute._animationProxy : t20.fromRoute._animationProxy, _null).get$value(), 1, t12), "$isAnimatable", t1, "$asAnimatable");
              H.assertHelper(H.checkSubtype(t19, "$isAnimation", t2, "$asAnimation"));
              t17.set$parent(new R._AnimatedEvaluation(H.assertSubtype(t19, "$isAnimation", t2, "$asAnimation"), t20, [H.getTypeArgumentByIndex(t20, 0)]));
              t17 = t16.manifest.fromHero;
              if (t17 != t18) {
                t17.endFlight$0();
                t18.startFlight$0();
                t17 = t16.heroRectTween.end;
                box = H.interceptedTypeCheck(t18._element.get$renderObject(), "$isRenderBox");
                H.assertHelper(box != null && box._size != null);
                t18 = box.getTransformTo$1(_null);
                t19 = box.get$size();
                t20 = t19._dx;
                t19 = t19._dy;
                if (typeof t20 !== "number")
                  return H.iae(t20);
                if (typeof t19 !== "number")
                  return H.iae(t19);
                t16.set$heroRectTween(t16._doCreateRectTween$2(t17, T.MatrixUtils_transformRect(t18, new P.Rect(0, 0, 0 + t20, 0 + t19))));
              } else {
                t17 = t16.heroRectTween;
                t16.set$heroRectTween(t16._doCreateRectTween$2(t17.end, t17.begin));
              }
            } else {
              H.assertHelper(t19.fromHero != t17);
              H.assertHelper(t16.manifest.toHero != t18);
              t19 = t16.heroRectTween;
              t20 = t16._proxyAnimation;
              t19.toString;
              t20 = t19.transform$1(H.assertSubtype(t20, "$isAnimation", t2, "$asAnimation").get$value());
              box = H.interceptedTypeCheck(t18._element.get$renderObject(), "$isRenderBox");
              H.assertHelper(box != null && box._size != null);
              t19 = box.getTransformTo$1(_null);
              t21 = box.get$size();
              t22 = t21._dx;
              t21 = t21._dy;
              if (typeof t22 !== "number")
                return H.iae(t22);
              if (typeof t21 !== "number")
                return H.iae(t21);
              t16.set$heroRectTween(t16._doCreateRectTween$2(t20, T.MatrixUtils_transformRect(t19, new P.Rect(0, 0, 0 + t22, 0 + t21))));
              t16.shuttle = null;
              t19 = t16._proxyAnimation;
              if (t15)
                t19.set$parent(new S.ReverseAnimation(S.CurvedAnimation$(C.Cubic_ifx, t14 ? to._animationProxy : from._animationProxy, _null), new R.ObserverList(H.setRuntimeTypeInfo([], t7), t8), 0));
              else
                t19.set$parent(S.CurvedAnimation$(C.Cubic_ifx, t14 ? to._animationProxy : from._animationProxy, _null));
              t16.manifest.fromHero.endFlight$0();
              t16.manifest.toHero.endFlight$0();
              t17.startFlight$0();
              t18.startFlight$0();
              t17 = t16.overlayEntry._key.get$currentState();
              if (t17 != null)
                t17._markNeedsBuild$0();
            }
            t16._aborted = false;
            t16.manifest = manifest;
          } else {
            t16 = new T._HeroFlight(t6, C.C__AlwaysCompleteAnimation);
            t17 = H.setRuntimeTypeInfo([], t7);
            t18 = new R.ObserverList(t17, t8);
            t19 = new S.ProxyAnimation(t18, new R.ObserverList(H.setRuntimeTypeInfo([], t10), t9), 0);
            t19.set$_animations$_parent(_null);
            if (t19._animations$_parent == null) {
              t19._animations$_status = C.AnimationStatus_0;
              t19._animations$_value = 0;
            }
            t20 = H.functionTypeCheck(t16.get$_handleAnimationUpdate(), t5);
            t19.didRegisterListener$0();
            H.assertSubtypeOfRuntimeType(t20, t5);
            t18._isDirty = true;
            C.JSArray_methods.add$1(t17, t20);
            t16._proxyAnimation = t19;
            t16.start$1(manifest);
            t4.$indexSet(0, tag, t16);
          }
        } else if (t4.$index(0, tag) != null)
          t4.$index(0, tag)._aborted = true;
      }
    },
    _handleFlightEnded$1: function(flight) {
      this._flights.remove$1(0, flight.manifest.fromHero._widget.tag);
    }
  };
  T.HeroController__maybeStartHeroTransition_closure.prototype = {
    call$1: function(value) {
      var _this = this;
      H.interceptedTypeCheck(value, "$isDuration");
      _this.$this._startHeroTransition$5(_this.from, _this.to, _this.animation, _this.flightType, _this.isUserGestureTransition);
    },
    $signature: 34
  };
  T.HeroController_closure.prototype = {
    call$5: function(flightContext, animation, flightDirection, fromHeroContext, toHeroContext) {
      H.interceptedTypeCheck(flightContext, "$isBuildContext");
      H.assertSubtype(animation, "$isAnimation", [P.double], "$asAnimation");
      H.interceptedTypeCheck(flightDirection, "$isHeroFlightDirection");
      H.interceptedTypeCheck(fromHeroContext, "$isBuildContext");
      return H.interceptedTypeCheck(H.interceptedTypeCheck(toHeroContext, "$isBuildContext").get$widget(), "$isHero").child;
    },
    $signature: 160
  };
  L.Icon.prototype = {
    build$1: function(context) {
      var textDirection, iconThemeData, iconTheme, iconSize, t1, iconOpacity, iconColor, t2, iconWidget, _null = null;
      E.debugCheckHasDirectionality(context);
      textDirection = T.Directionality_of(context);
      iconThemeData = Y.IconTheme__getInheritedIconThemeData(context);
      iconTheme = iconThemeData.color != null && iconThemeData.get$opacity() != null && iconThemeData.size != null ? iconThemeData : C.IconThemeData_Color_4278190080_1_24.merge$1(iconThemeData);
      iconSize = iconTheme.size;
      t1 = this.icon;
      if (t1 == null)
        return T.Semantics$(_null, new T.SizedBox(iconSize, iconSize, _null, _null), false, _null, false, _null, _null, _null, _null, _null, _null);
      iconOpacity = iconTheme.get$opacity();
      iconColor = iconTheme.color;
      if (iconOpacity !== 1) {
        t2 = iconColor.value;
        if (typeof iconOpacity !== "number")
          return H.iae(iconOpacity);
        iconColor = iconColor.withOpacity$1(((4278190080 & t2) >>> 24) / 255 * iconOpacity);
      }
      t2 = H.Primitives_stringFromCharCode(t1.codePoint);
      iconWidget = T.RichText$(_null, _null, C.TextOverflow_3, true, _null, Q.TextSpan$(_null, A.TextStyle$0(_null, _null, iconColor, _null, _null, _null, _null, _null, t1.fontFamily, _null, iconSize, _null, _null, _null, _null, false, _null, _null, _null, _null, _null, _null), t2), C.TextAlign_4, textDirection, 1);
      if (t1.matchTextDirection)
        switch (textDirection) {
          case C.TextDirection_0:
            t1 = new E.Matrix4(new Float64Array(16));
            t1.setIdentity$0();
            t1.scale$3(-1, 1, 1);
            iconWidget = T.Transform$(C.Alignment_0_0, iconWidget, t1, false);
            break;
          case C.TextDirection_1:
            break;
        }
      return T.Semantics$(_null, T.ExcludeSemantics$(new T.SizedBox(iconSize, iconSize, new T.Center(C.Alignment_0_0, _null, _null, iconWidget, _null), _null), true), false, _null, false, _null, _null, _null, _null, _null, _null);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("icon", this.icon, C.C__NoDefaultValue, _null, _null, "<empty>", C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_5, _null, X.IconData);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("size", _null, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("color", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Color));
    }
  };
  X.IconData.prototype = {
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (!new H.TypeImpl(H.getRti(_this)).$eq(0, J.get$runtimeType$(other)))
        return false;
      H.interceptedTypeCheck(other, "$isIconData");
      if (_this.codePoint === other.codePoint)
        if (_this.fontFamily === other.fontFamily)
          t1 = _this.matchTextDirection === other.matchTextDirection;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return P.hashValues(this.codePoint, this.fontFamily, null, this.matchTextDirection, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      return "IconData(U+" + C.JSString_methods.padLeft$2(C.JSInt_methods.toRadixString$1(this.codePoint, 16).toUpperCase(), 5, "0") + ")";
    }
  };
  Y.IconTheme.prototype = {
    updateShouldNotify$1: function(oldWidget) {
      return !this.data.$eq(0, H.interceptedTypeCheck(oldWidget, "$isIconTheme").data);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("data", this.data, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_5, _null, T.IconThemeData);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  Y.IconTheme_merge_closure.prototype = {
    call$1: function(context) {
      return Y.IconTheme$(this.child, Y.IconTheme__getInheritedIconThemeData(H.interceptedTypeCheck(context, "$isBuildContext")).merge$1(this.data), this.key);
    },
    $signature: 161
  };
  T.IconThemeData.prototype = {
    copyWith$3$color$opacity$size: function(color, opacity, size) {
      var t1 = color == null ? this.color : color,
        t2 = opacity == null ? this.get$opacity() : opacity;
      return new T.IconThemeData(t1, t2, size == null ? this.size : size);
    },
    merge$1: function(other) {
      return this.copyWith$3$color$opacity$size(other.color, other.get$opacity(), other.size);
    },
    get$opacity: function() {
      var t1 = this._opacity;
      return t1 == null ? null : C.JSNumber_methods.clamp$2(t1, 0, 1);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isIconThemeData");
      return J.$eq$(_this.color, other.color) && _this.get$opacity() == other.get$opacity() && _this.size == other.size;
    },
    get$hashCode: function(_) {
      return P.hashValues(this.color, this.get$opacity(), this.size, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _this = this, _null = null;
      _this.super$Diagnosticable$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("color", _this.color, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Color);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("opacity", _this.get$opacity(), _null, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("size", _this.size, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
    }
  };
  G.DecorationTween.prototype = {
    lerp$1: function(t) {
      return Z.Decoration_lerp(this.begin, this.end, t);
    },
    $asAnimatable: function() {
      return [Z.Decoration];
    },
    $asTween: function() {
      return [Z.Decoration];
    }
  };
  G.BorderRadiusTween.prototype = {
    lerp$1: function(t) {
      return K.BorderRadius_lerp(this.begin, this.end, t);
    },
    $asAnimatable: function() {
      return [K.BorderRadius];
    },
    $asTween: function() {
      return [K.BorderRadius];
    }
  };
  G.TextStyleTween.prototype = {
    lerp$1: function(t) {
      return A.TextStyle_lerp(this.begin, this.end, t);
    },
    $asAnimatable: function() {
      return [A.TextStyle0];
    },
    $asTween: function() {
      return [A.TextStyle0];
    }
  };
  G.ImplicitlyAnimatedWidget.prototype = {
    debugFillProperties$1: function(properties) {
      var t1;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.IntProperty$("duration", C.JSInt_methods._tdivFast$1(this.duration._duration, 1000), C.C__NoDefaultValue, null, C.DiagnosticLevel_3, "ms");
      C.JSArray_methods.add$1(properties.properties, t1);
    },
    get$curve: function() {
      return this.curve;
    },
    get$duration: function() {
      return this.duration;
    }
  };
  G.ImplicitlyAnimatedWidgetState.prototype = {
    initState$0: function() {
      var t1, _this = this;
      _this.super$State$initState();
      t1 = _this._widget.get$duration();
      _this._implicit_animations$_controller = G.AnimationController$(_this._widget.toStringShort$0(), t1, 0, 1, null, _this);
      _this._updateCurve$0();
      _this._constructTweens$0();
    },
    didUpdateWidget$1: function(oldWidget) {
      var t1, _this = this;
      H.assertSubtypeOfRuntimeType(oldWidget, H.getRuntimeTypeArgument(_this, "ImplicitlyAnimatedWidgetState", 0));
      _this.super$State$didUpdateWidget(oldWidget);
      if (_this._widget.get$curve() !== oldWidget.get$curve())
        _this._updateCurve$0();
      _this._implicit_animations$_controller.duration = _this._widget.get$duration();
      if (_this._constructTweens$0()) {
        _this.forEachTween$1(new G.ImplicitlyAnimatedWidgetState_didUpdateWidget_closure(_this));
        t1 = _this._implicit_animations$_controller;
        t1.set$value(0);
        t1.forward$0();
      }
    },
    _updateCurve$0: function() {
      var t1, _this = this;
      _this._widget.get$curve();
      t1 = _this._implicit_animations$_controller;
      _this.set$_animation(S.CurvedAnimation$(_this._widget.get$curve(), t1, null));
    },
    dispose$0: function() {
      this._implicit_animations$_controller.dispose$0();
      this.super$_ImplicitlyAnimatedWidgetState_State_SingleTickerProviderStateMixin$dispose();
    },
    _updateTween$2: function(tween, targetValue) {
      if (tween == null)
        return;
      tween.set$begin(tween.transform$1(H.assertSubtype(this._animation, "$isAnimation", [P.double], "$asAnimation").get$value()));
      tween.set$end(targetValue);
    },
    _constructTweens$0: function() {
      var t1 = {};
      t1.shouldStartAnimation = false;
      this.forEachTween$1(new G.ImplicitlyAnimatedWidgetState__constructTweens_closure(t1, this));
      return t1.shouldStartAnimation;
    },
    set$_animation: function(_animation) {
      this._animation = H.assertSubtype(_animation, "$isAnimation", [P.double], "$asAnimation");
    },
    $isTickerProvider: 1
  };
  G.ImplicitlyAnimatedWidgetState_didUpdateWidget_closure.prototype = {
    call$3: function(tween, targetValue, $constructor) {
      H.functionTypeCheck($constructor, {func: 1, ret: [R.Tween,,], args: [,]});
      this.$this._updateTween$2(tween, targetValue);
      return tween;
    },
    $signature: 52
  };
  G.ImplicitlyAnimatedWidgetState__constructTweens_closure.prototype = {
    call$3: function(tween, targetValue, $constructor) {
      var t1;
      H.functionTypeCheck($constructor, {func: 1, ret: [R.Tween,,], args: [,]});
      if (targetValue != null) {
        if (tween == null)
          tween = $constructor.call$1(targetValue);
        t1 = tween.end;
        if (!J.$eq$(targetValue, t1 == null ? tween.begin : t1))
          this._box_0.shouldStartAnimation = true;
      } else
        tween = null;
      return tween;
    },
    $signature: 52
  };
  G.AnimatedWidgetBaseState.prototype = {
    initState$0: function() {
      var t1, t2;
      this.super$ImplicitlyAnimatedWidgetState$initState();
      t1 = this._implicit_animations$_controller;
      t1.toString;
      t2 = H.functionTypeCheck(this.get$_handleAnimationChanged(), {func: 1, ret: -1});
      t1.didRegisterListener$0();
      t1 = t1.AnimationLocalListenersMixin__listeners;
      H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(t1, 0));
      t1._isDirty = true;
      C.JSArray_methods.add$1(t1._list, t2);
    },
    _handleAnimationChanged$0: function() {
      this.setState$1(new G.AnimatedWidgetBaseState__handleAnimationChanged_closure());
    }
  };
  G.AnimatedWidgetBaseState__handleAnimationChanged_closure.prototype = {
    call$0: function() {
    },
    $signature: 2
  };
  G.AnimatedDefaultTextStyle.prototype = {
    createState$0: function() {
      return new G._AnimatedDefaultTextStyleState(null, C._StateLifecycle_0);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$ImplicitlyAnimatedWidget$debugFillProperties(properties);
      t1 = this.style;
      if (t1 != null)
        t1.debugFillProperties$1(properties);
      t1 = properties.properties;
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _null, _null, C.DiagnosticLevel_3, "textAlign", true, true, C.DiagnosticsTreeStyle_5, [P.TextAlign]));
      C.JSArray_methods.add$1(t1, Y.FlagProperty$("softWrap", _null, "no wrapping except at line break characters", "wrapping at box width", C.DiagnosticLevel_3, true, true));
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, C.TextOverflow_0, _null, C.DiagnosticLevel_3, "overflow", true, true, C.DiagnosticsTreeStyle_5, [Q.TextOverflow]));
      C.JSArray_methods.add$1(t1, Y.IntProperty$("maxLines", _null, _null, _null, C.DiagnosticLevel_3, _null));
    },
    get$child: function() {
      return this.child;
    }
  };
  G._AnimatedDefaultTextStyleState.prototype = {
    forEachTween$1: function(visitor) {
      this._implicit_animations$_style = H.interceptedTypeCheck(H.functionTypeCheck(visitor, {func: 1, ret: [R.Tween,,], args: [[R.Tween,,],, {func: 1, ret: [R.Tween,,], args: [,]}]}).call$3(this._implicit_animations$_style, this._widget.style, new G._AnimatedDefaultTextStyleState_forEachTween_closure()), "$isTextStyleTween");
    },
    build$1: function(context) {
      var t1 = this._implicit_animations$_style,
        t2 = this._animation;
      t1.toString;
      t2 = t1.transform$1(H.assertSubtype(t2, "$isAnimation", [P.double], "$asAnimation").get$value());
      return L.DefaultTextStyle$(this._widget.child, null, C.TextOverflow_0, true, t2, null);
    },
    $asState: function() {
      return [G.AnimatedDefaultTextStyle];
    },
    $asImplicitlyAnimatedWidgetState: function() {
      return [G.AnimatedDefaultTextStyle];
    }
  };
  G._AnimatedDefaultTextStyleState_forEachTween_closure.prototype = {
    call$1: function(value) {
      return new G.TextStyleTween(H.interceptedTypeCheck(value, "$isTextStyle0"), null);
    },
    $signature: 163
  };
  G.AnimatedPhysicalModel.prototype = {
    createState$0: function() {
      return new G._AnimatedPhysicalModelState(null, C._StateLifecycle_0);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _this = this, _null = null;
      _this.super$ImplicitlyAnimatedWidget$debugFillProperties(properties);
      t1 = properties.properties;
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.shape, C.C__NoDefaultValue, C.DiagnosticLevel_3, "shape", true, true, C.DiagnosticsTreeStyle_5, [F.BoxShape]));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("borderRadius", _this.borderRadius, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.BorderRadius));
      C.JSArray_methods.add$1(t1, Y.DoubleProperty$("elevation", _this.elevation, C.C__NoDefaultValue, _null, C.DiagnosticLevel_3, true, _null, _null));
      t2 = P.Color;
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("color", _this.color, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t2));
      t3 = P.bool;
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("animateColor", false, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("shadowColor", _this.shadowColor, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t2));
      C.JSArray_methods.add$1(t1, Y.DiagnosticsProperty$("animateShadowColor", true, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, t3));
    },
    get$child: function() {
      return this.child;
    },
    get$borderRadius: function() {
      return this.borderRadius;
    }
  };
  G._AnimatedPhysicalModelState.prototype = {
    forEachTween$1: function(visitor) {
      var _this = this;
      H.functionTypeCheck(visitor, {func: 1, ret: [R.Tween,,], args: [[R.Tween,,],, {func: 1, ret: [R.Tween,,], args: [,]}]});
      _this._implicit_animations$_borderRadius = H.interceptedTypeCheck(visitor.call$3(_this._implicit_animations$_borderRadius, _this._widget.borderRadius, new G._AnimatedPhysicalModelState_forEachTween_closure()), "$isBorderRadiusTween");
      _this.set$_implicit_animations$_elevation(H.assertSubtype(visitor.call$3(_this._implicit_animations$_elevation, _this._widget.elevation, new G._AnimatedPhysicalModelState_forEachTween_closure0()), "$isTween", [P.double], "$asTween"));
      _this._implicit_animations$_color = H.interceptedTypeCheck(visitor.call$3(_this._implicit_animations$_color, _this._widget.color, new G._AnimatedPhysicalModelState_forEachTween_closure1()), "$isColorTween");
      _this._implicit_animations$_shadowColor = H.interceptedTypeCheck(visitor.call$3(_this._implicit_animations$_shadowColor, _this._widget.shadowColor, new G._AnimatedPhysicalModelState_forEachTween_closure2()), "$isColorTween");
    },
    build$1: function(context) {
      var t4, t5, t6, t7, t8, t9, _this = this,
        t1 = _this._widget,
        t2 = t1.child,
        t3 = t1.shape;
      t1 = t1.clipBehavior;
      t4 = _this._implicit_animations$_borderRadius;
      t5 = _this._animation;
      t4.toString;
      t6 = [P.double];
      t5 = t4.transform$1(H.assertSubtype(t5, "$isAnimation", t6, "$asAnimation").get$value());
      t4 = _this._implicit_animations$_elevation;
      t7 = _this._animation;
      t4.toString;
      t7 = t4.transform$1(H.assertSubtype(t7, "$isAnimation", t6, "$asAnimation").get$value());
      t4 = _this._widget;
      t8 = t4.color;
      t4.toString;
      t4 = _this._implicit_animations$_shadowColor;
      t9 = _this._animation;
      t4.toString;
      t6 = t4.transform$1(H.assertSubtype(t9, "$isAnimation", t6, "$asAnimation").get$value());
      return new T.PhysicalModel(t3, t1, t5, t7, t8, t6, t2, null);
    },
    set$_implicit_animations$_elevation: function(_elevation) {
      this._implicit_animations$_elevation = H.assertSubtype(_elevation, "$isTween", [P.double], "$asTween");
    },
    $asState: function() {
      return [G.AnimatedPhysicalModel];
    },
    $asImplicitlyAnimatedWidgetState: function() {
      return [G.AnimatedPhysicalModel];
    }
  };
  G._AnimatedPhysicalModelState_forEachTween_closure.prototype = {
    call$1: function(value) {
      return new G.BorderRadiusTween(H.interceptedTypeCheck(value, "$isBorderRadius"), null);
    },
    $signature: 164
  };
  G._AnimatedPhysicalModelState_forEachTween_closure0.prototype = {
    call$1: function(value) {
      return new R.Tween(H.doubleTypeCheck(value), null, [P.double]);
    },
    $signature: 55
  };
  G._AnimatedPhysicalModelState_forEachTween_closure1.prototype = {
    call$1: function(value) {
      return new R.ColorTween(H.interceptedTypeCheck(value, "$isColor"), null);
    },
    $signature: 31
  };
  G._AnimatedPhysicalModelState_forEachTween_closure2.prototype = {
    call$1: function(value) {
      return new R.ColorTween(H.interceptedTypeCheck(value, "$isColor"), null);
    },
    $signature: 31
  };
  G._ImplicitlyAnimatedWidgetState_State_SingleTickerProviderStateMixin_dispose_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1.SingleTickerProviderStateMixin__ticker;
      if (t2 == null || t2._future == null)
        return true;
      throw H.wrapException(U.FlutterError$(t1.toString$0(0) + " was disposed with an active Ticker.\n" + H.getRuntimeType(t1).toString$0(0) + " created a Ticker via its SingleTickerProviderStateMixin, but at the time dispose() was called on the mixin, that Ticker was still active. The Ticker must be disposed before calling super.dispose(). Tickers used by AnimationControllers should be disposed by calling dispose() on the AnimationController itself. Otherwise, the ticker will leak.\nThe offending ticker was: " + J.toString$1$debugIncludeStack$(t1.SingleTickerProviderStateMixin__ticker, true)));
    },
    $signature: 0
  };
  G._ImplicitlyAnimatedWidgetState_State_SingleTickerProviderStateMixin.prototype = {
    dispose$0: function() {
      H.assertHelper(new G._ImplicitlyAnimatedWidgetState_State_SingleTickerProviderStateMixin_dispose_closure(this).call$0());
      this.super$State$dispose();
    },
    didChangeDependencies$0: function() {
      var t1 = this.SingleTickerProviderStateMixin__ticker;
      if (t1 != null)
        t1.set$muted(!U.TickerMode_of(this._element));
      this.super$State$didChangeDependencies();
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, tickerDescription, _null = null;
      this.super$State$debugFillProperties(properties);
      t1 = this.SingleTickerProviderStateMixin__ticker;
      if (t1 != null) {
        t2 = t1._future != null;
        if (t2 && t1._muted)
          tickerDescription = "active but muted";
        else if (t2)
          tickerDescription = "active";
        else
          tickerDescription = t1._muted ? "inactive and muted" : "inactive";
      } else
        tickerDescription = _null;
      t1 = Y.DiagnosticsProperty$("ticker", t1, _null, tickerDescription, _null, _null, C.DiagnosticLevel_3, false, true, false, C.DiagnosticsTreeStyle_5, _null, M.Ticker);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  S.InheritedNotifier.prototype = {
    updateShouldNotify$1: function(oldWidget) {
      return H.assertSubtype(oldWidget, "$isInheritedNotifier", [H.getRuntimeTypeArgument(this, "InheritedNotifier", 0)], "$asInheritedNotifier").notifier != this.notifier;
    },
    createElement$0: function() {
      var t3,
        t1 = P.HashMap_HashMap(N.Element, P.Object),
        t2 = ($.Element__nextHashCode + 1) % 16777215;
      $.Element__nextHashCode = t2;
      t2 = new S._InheritedNotifierElement(t1, t2, this, C._ElementLifecycle_0, [H.getRuntimeTypeArgument(this, "InheritedNotifier", 0)]);
      t1 = this.notifier;
      if (t1 != null) {
        t3 = H.functionTypeCheck(t2.get$_handleUpdate(), {func: 1, ret: -1});
        t1._debugAssertNotDisposed$0();
        t1 = t1.ChangeNotifier__listeners;
        t1.toString;
        H.assertSubtypeOfRuntimeType(t3, H.getTypeArgumentByIndex(t1, 0));
        t1._isDirty = true;
        C.JSArray_methods.add$1(t1._list, t3);
      }
      return t2;
    }
  };
  S._InheritedNotifierElement.prototype = {
    get$widget: function() {
      return H.assertSubtype(N.InheritedElement.prototype.get$widget.call(this), "$isInheritedNotifier", this.$ti, "$asInheritedNotifier");
    },
    update$1: function(newWidget) {
      var oldNotifier, newNotifier, t2, _this = this,
        t1 = _this.$ti;
      H.assertSubtype(newWidget, "$isInheritedNotifier", t1, "$asInheritedNotifier");
      oldNotifier = H.assertSubtype(N.InheritedElement.prototype.get$widget.call(_this), "$isInheritedNotifier", t1, "$asInheritedNotifier").notifier;
      newNotifier = newWidget.notifier;
      if (oldNotifier != newNotifier) {
        if (oldNotifier != null) {
          t1 = H.functionTypeCheck(_this.get$_handleUpdate(), {func: 1, ret: -1});
          oldNotifier._debugAssertNotDisposed$0();
          t2 = oldNotifier.ChangeNotifier__listeners;
          t2.toString;
          H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(t2, 0));
          t2._isDirty = true;
          C.JSArray_methods.remove$1(t2._list, t1);
        }
        if (newNotifier != null) {
          t1 = H.functionTypeCheck(_this.get$_handleUpdate(), {func: 1, ret: -1});
          newNotifier._debugAssertNotDisposed$0();
          t2 = newNotifier.ChangeNotifier__listeners;
          t2.toString;
          H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(t2, 0));
          t2._isDirty = true;
          C.JSArray_methods.add$1(t2._list, t1);
        }
      }
      _this.super$ProxyElement$update(newWidget);
    },
    build$0: function() {
      var _this = this;
      if (_this._inherited_notifier$_dirty) {
        _this.super$InheritedElement$notifyClients(H.assertSubtype(N.InheritedElement.prototype.get$widget.call(_this), "$isInheritedNotifier", _this.$ti, "$asInheritedNotifier"));
        _this._inherited_notifier$_dirty = false;
      }
      return _this.super$ProxyElement$build();
    },
    _handleUpdate$0: function() {
      this._inherited_notifier$_dirty = true;
      this.markNeedsBuild$0();
    },
    notifyClients$1: function(oldWidget) {
      this.super$InheritedElement$notifyClients(H.assertSubtype(oldWidget, "$isInheritedNotifier", this.$ti, "$asInheritedNotifier"));
      this._inherited_notifier$_dirty = false;
    },
    unmount$0: function() {
      var t2, _this = this,
        t1 = H.assertSubtype(N.InheritedElement.prototype.get$widget.call(_this), "$isInheritedNotifier", _this.$ti, "$asInheritedNotifier").notifier;
      if (t1 != null) {
        t2 = H.functionTypeCheck(_this.get$_handleUpdate(), {func: 1, ret: -1});
        t1._debugAssertNotDisposed$0();
        t1 = t1.ChangeNotifier__listeners;
        t1.toString;
        H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(t1, 0));
        t1._isDirty = true;
        C.JSArray_methods.remove$1(t1._list, t2);
      }
      _this.super$Element$unmount();
    }
  };
  L._Pending.prototype = {};
  L._loadAll_closure.prototype = {
    call$1: function(value) {
      return this._box_0.completedValue = value;
    },
    $signature: 23
  };
  L._loadAll_closure0.prototype = {
    call$1: function(p) {
      return H.interceptedTypeCheck(p, "$is_Pending").futureValue;
    },
    $signature: 165
  };
  L._loadAll_closure1.prototype = {
    call$1: function(values) {
      var t1, t2, t3, i, t4, type;
      H.listTypeCheck(values);
      t1 = J.getInterceptor$asx(values);
      t2 = this._box_1;
      H.assertHelper(t1.get$length(values) === t2.pendingList.length);
      for (t3 = this.output, i = 0; i < t1.get$length(values); ++i) {
        t4 = t2.pendingList;
        if (i >= t4.length)
          return H.ioore(t4, i);
        type = new H.TypeImpl(H.getRuntimeTypeArgument(t4[i].delegate, "LocalizationsDelegate", 0));
        H.assertHelper(!t3.containsKey$1(type));
        t3.$indexSet(0, type, t1.$index(values, i));
      }
      return t3;
    },
    $signature: 166
  };
  L.LocalizationsDelegate.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "[" + new H.TypeImpl(H.getRuntimeTypeArgument(this, "LocalizationsDelegate", 0)).toString$0(0) + "]";
    }
  };
  L.WidgetsLocalizations.prototype = {};
  L._WidgetsLocalizationsDelegate.prototype = {
    isSupported$1: function(locale) {
      return true;
    },
    load$1: function(locale) {
      return new O.SynchronousFuture(C.C_DefaultWidgetsLocalizations, [L.WidgetsLocalizations]);
    },
    shouldReload$1: function(old) {
      H.interceptedTypeCheck(old, "$is_WidgetsLocalizationsDelegate");
      return false;
    },
    toString$0: function(_) {
      return "DefaultWidgetsLocalizations.delegate(en_US)";
    },
    $asLocalizationsDelegate: function() {
      return [L.WidgetsLocalizations];
    }
  };
  L.DefaultWidgetsLocalizations.prototype = {$isWidgetsLocalizations: 1};
  L._LocalizationsScope.prototype = {
    updateShouldNotify$1: function(old) {
      return this.typeToResources != H.interceptedTypeCheck(old, "$is_LocalizationsScope").typeToResources;
    }
  };
  L.Localizations.prototype = {
    createState$0: function() {
      return new L._LocalizationsState(new N.LabeledGlobalKey(null, [[N.State, N.StatefulWidget]]), P.LinkedHashMap_LinkedHashMap$_empty(P.Type, null), C._StateLifecycle_0);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("locale", this.locale, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Locale);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.IterableProperty$("delegates", this.delegates, C.C__NoDefaultValue, "[]", C.DiagnosticLevel_3, C.DiagnosticsTreeStyle_5, [L.LocalizationsDelegate,,]));
    },
    get$child: function() {
      return this.child;
    }
  };
  L._LocalizationsState.prototype = {
    initState$0: function() {
      this.super$State$initState();
      this.load$1(this._widget.locale);
    },
    _anyDelegatesShouldReload$1: function(old) {
      var delegates, oldDelegates, i, delegate, oldDelegate,
        t1 = this._widget.delegates,
        t2 = old.delegates;
      if (t1.length !== t2.length)
        return true;
      delegates = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
      oldDelegates = H.setRuntimeTypeInfo(t2.slice(0), [H.getTypeArgumentByIndex(t2, 0)]);
      for (i = 0; i < delegates.length; ++i) {
        delegate = delegates[i];
        if (i >= oldDelegates.length)
          return H.ioore(oldDelegates, i);
        oldDelegate = oldDelegates[i];
        if (J.get$runtimeType$(delegate).$eq(0, J.get$runtimeType$(oldDelegate))) {
          delegate.shouldReload$1(oldDelegate);
          t1 = false;
        } else
          t1 = true;
        if (t1)
          return true;
      }
      return false;
    },
    didUpdateWidget$1: function(old) {
      var t1, _this = this;
      H.interceptedTypeCheck(old, "$isLocalizations");
      _this.super$State$didUpdateWidget(old);
      if (J.$eq$(_this._widget.locale, old.locale)) {
        _this._widget.delegates;
        old.delegates;
        t1 = _this._anyDelegatesShouldReload$1(old);
      } else
        t1 = true;
      if (t1)
        _this.load$1(_this._widget.locale);
    },
    load$1: function(locale) {
      var typeToResourcesFuture, _this = this, t1 = {},
        delegates = _this._widget.delegates,
        t2 = delegates.length;
      if (t2 === 0) {
        _this._localizations$_locale = locale;
        return;
      }
      t1.typeToResources = null;
      typeToResourcesFuture = L._loadAll(locale, delegates).then$1$1(new L._LocalizationsState_load_closure(t1), [P.Map, P.Type,,]);
      t1 = t1.typeToResources;
      if (t1 != null) {
        _this.set$_typeToResources(t1);
        _this._localizations$_locale = locale;
      } else {
        $.WidgetsBinding__instance.deferFirstFrameReport$0();
        typeToResourcesFuture.then$1$1(new L._LocalizationsState_load_closure0(_this, locale), -1);
      }
    },
    get$_localizations$_textDirection: function() {
      H.assertHelper(H.interceptedTypeCheck(this._typeToResources.$index(0, C.Type_WidgetsLocalizations_43h), "$isWidgetsLocalizations") != null);
      return C.TextDirection_1;
    },
    build$1: function(context) {
      var t1, _this = this, _null = null;
      if (_this._localizations$_locale == null)
        return M.Container$(_null, _null, _null, _null, _null, _null, _null);
      t1 = _this.get$_localizations$_textDirection();
      return T.Semantics$(_null, new L._LocalizationsScope(_this, _this._typeToResources, new T.Directionality(_this.get$_localizations$_textDirection(), _this._widget.child, _null), _this._localizedResourcesScopeKey), false, _null, false, _null, _null, _null, _null, _null, t1);
    },
    set$_typeToResources: function(_typeToResources) {
      this._typeToResources = H.assertSubtype(_typeToResources, "$isMap", [P.Type, null], "$asMap");
    },
    $asState: function() {
      return [L.Localizations];
    }
  };
  L._LocalizationsState_load_closure.prototype = {
    call$1: function(value) {
      return this._box_0.typeToResources = H.assertSubtype(value, "$isMap", [P.Type, null], "$asMap");
    },
    $signature: 167
  };
  L._LocalizationsState_load_closure0.prototype = {
    call$1: function(value) {
      var t1;
      H.assertSubtype(value, "$isMap", [P.Type, null], "$asMap");
      $.WidgetsBinding__instance.allowFirstFrameReport$0();
      t1 = this.$this;
      if (t1._element == null)
        return;
      t1.setState$1(new L._LocalizationsState_load__closure(t1, value, this.locale));
    },
    $signature: 168
  };
  L._LocalizationsState_load__closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1.set$_typeToResources(this.value);
      t1._localizations$_locale = this.locale;
    },
    $signature: 2
  };
  F.MediaQueryData.prototype = {
    removePadding$4$removeBottom$removeLeft$removeRight$removeTop: function(removeBottom, removeLeft, removeRight, removeTop) {
      var t1, t2, t3, t4, _this = this, _null = null;
      if (!(removeLeft || removeTop || removeRight || removeBottom))
        return _this;
      t1 = removeLeft ? 0 : _null;
      t2 = removeTop ? 0 : _null;
      t3 = removeRight ? 0 : _null;
      t4 = removeBottom ? 0 : _null;
      return F.MediaQueryData$(_this.accessibleNavigation, false, _this.boldText, _this.devicePixelRatio, _this.disableAnimations, _this.invertColors, _this.padding.copyWith$4$bottom$left$right$top(t4, t1, t3, t2), _this.platformBrightness, _this.size, _this.textScaleFactor, _this.viewInsets);
    },
    removeViewInsets$1$removeBottom: function(removeBottom) {
      var _this = this;
      return F.MediaQueryData$(_this.accessibleNavigation, false, _this.boldText, _this.devicePixelRatio, _this.disableAnimations, _this.invertColors, _this.padding, _this.platformBrightness, _this.size, _this.textScaleFactor, _this.viewInsets.copyWith$4$bottom$left$right$top(0, null, null, null));
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$isMediaQueryData");
      if (other.size.$eq(0, _this.size))
        if (other.devicePixelRatio === _this.devicePixelRatio)
          if (other.textScaleFactor === _this.textScaleFactor)
            if (other.platformBrightness === _this.platformBrightness)
              if (other.padding.$eq(0, _this.padding))
                other.viewInsets.$eq(0, _this.viewInsets);
      return false;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.size, _this.devicePixelRatio, _this.textScaleFactor, _this.platformBrightness, _this.padding, _this.viewInsets, false, _this.disableAnimations, _this.invertColors, _this.accessibleNavigation, _this.boldText, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var _this = this;
      return new H.TypeImpl(H.getRti(_this)).toString$0(0) + "(size: " + _this.size.toString$0(0) + ", devicePixelRatio: " + C.JSInt_methods.toStringAsFixed$1(_this.devicePixelRatio, 1) + ", textScaleFactor: " + C.JSInt_methods.toStringAsFixed$1(_this.textScaleFactor, 1) + ", platformBrightness: " + _this.platformBrightness.toString$0(0) + ", padding: " + _this.padding.toString$0(0) + ", viewInsets: " + _this.viewInsets.toString$0(0) + ", alwaysUse24HourFormat: false, accessibleNavigation: " + H.S(_this.accessibleNavigation) + "disableAnimations: " + H.S(_this.disableAnimations) + "invertColors: " + H.S(_this.invertColors) + "boldText: " + H.S(_this.boldText) + ")";
    }
  };
  F.MediaQuery.prototype = {
    updateShouldNotify$1: function(oldWidget) {
      return !this.data.$eq(0, H.interceptedTypeCheck(oldWidget, "$isMediaQuery").data);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("data", this.data, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_5, _null, F.MediaQueryData);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  X.ModalBarrier.prototype = {
    build$1: function(context) {
      var _null = null,
        t1 = this.color;
      return new T.BlockSemantics(T.ExcludeSemantics$(D.GestureDetector$(C.HitTestBehavior_1, T.Semantics$(_null, T.ConstrainedBox$(t1 == null ? _null : M.DecoratedBox$(_null, S.BoxDecoration$(_null, _null, _null, t1, _null, _null, C.BoxShape_0), C.DecorationPosition_0), C.BoxConstraints_ALM), false, _null, false, _null, _null, _null, _null, _null, _null), C.DragStartBehavior_1, false, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, new X.ModalBarrier_build_closure(this, context), _null, _null), true), _null);
    }
  };
  X.ModalBarrier_build_closure.prototype = {
    call$1: function(details) {
    },
    $signature: 169
  };
  E.NavigationToolbar.prototype = {
    build$1: function(context) {
      var children, t1, _this = this;
      E.debugCheckHasDirectionality(context);
      children = H.setRuntimeTypeInfo([], [N.Widget]);
      t1 = _this.leading;
      if (t1 != null)
        C.JSArray_methods.add$1(children, T.LayoutId$(t1, C._ToolbarSlot_0));
      t1 = _this.middle;
      if (t1 != null)
        C.JSArray_methods.add$1(children, T.LayoutId$(t1, C._ToolbarSlot_1));
      t1 = _this.trailing;
      if (t1 != null)
        C.JSArray_methods.add$1(children, T.LayoutId$(t1, C._ToolbarSlot_2));
      return T.CustomMultiChildLayout$(children, new E._ToolbarLayout(_this.centerMiddle, _this.middleSpacing, T.Directionality_of(context)));
    }
  };
  E._ToolbarSlot.prototype = {
    toString$0: function(_) {
      return this._navigation_toolbar$_name;
    }
  };
  E._ToolbarLayout.prototype = {
    performLayout$1: function(size) {
      var t1, t2, leadingWidth, leadingX, trailingSize, trailingX, t3, trailingWidth, maxWidth, middleSize, middleStartMargin, t4, middleStart, t5, middleX, _this = this;
      if (_this._idToChild.$index(0, C._ToolbarSlot_0) != null) {
        t1 = size._dx;
        if (typeof t1 !== "number")
          return t1.$div();
        t2 = size._dy;
        leadingWidth = _this.layoutChild$2(C._ToolbarSlot_0, new S.BoxConstraints(0, t1 / 3, t2, t2))._dx;
        switch (_this.textDirection) {
          case C.TextDirection_0:
            if (typeof leadingWidth !== "number")
              return H.iae(leadingWidth);
            leadingX = t1 - leadingWidth;
            break;
          case C.TextDirection_1:
            leadingX = 0;
            break;
          default:
            leadingX = null;
        }
        _this.positionChild$2(C._ToolbarSlot_0, new P.Offset(leadingX, 0));
      } else
        leadingWidth = 0;
      if (_this._idToChild.$index(0, C._ToolbarSlot_2) != null) {
        t1 = size._dx;
        t2 = size._dy;
        trailingSize = _this.layoutChild$2(C._ToolbarSlot_2, new S.BoxConstraints(0, t1, 0, t2));
        switch (_this.textDirection) {
          case C.TextDirection_0:
            trailingX = 0;
            break;
          case C.TextDirection_1:
            t3 = trailingSize._dx;
            if (typeof t1 !== "number")
              return t1.$sub();
            if (typeof t3 !== "number")
              return H.iae(t3);
            trailingX = t1 - t3;
            break;
          default:
            trailingX = null;
        }
        t1 = trailingSize._dy;
        if (typeof t2 !== "number")
          return t2.$sub();
        if (typeof t1 !== "number")
          return H.iae(t1);
        trailingWidth = trailingSize._dx;
        _this.positionChild$2(C._ToolbarSlot_2, new P.Offset(trailingX, (t2 - t1) / 2));
      } else
        trailingWidth = 0;
      if (_this._idToChild.$index(0, C._ToolbarSlot_1) != null) {
        t1 = size._dx;
        if (typeof t1 !== "number")
          return t1.$sub();
        if (typeof leadingWidth !== "number")
          return H.iae(leadingWidth);
        if (typeof trailingWidth !== "number")
          return H.iae(trailingWidth);
        t2 = _this.middleSpacing;
        maxWidth = Math.max(t1 - leadingWidth - trailingWidth - t2 * 2, 0);
        t3 = size._dy;
        middleSize = _this.layoutChild$2(C._ToolbarSlot_1, new S.BoxConstraints(0, maxWidth, 0, t3));
        middleStartMargin = leadingWidth + t2;
        t2 = middleSize._dy;
        if (typeof t3 !== "number")
          return t3.$sub();
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (H.boolConversionCheck(_this.centerMiddle)) {
          t4 = middleSize._dx;
          if (typeof t4 !== "number")
            return H.iae(t4);
          middleStart = (t1 - t4) / 2;
          t5 = t1 - trailingWidth;
          if (middleStart + t4 > t5)
            middleStart = t5 - t4;
          else if (middleStart < middleStartMargin)
            middleStart = middleStartMargin;
        } else
          middleStart = middleStartMargin;
        switch (_this.textDirection) {
          case C.TextDirection_0:
            t4 = middleSize._dx;
            if (typeof t4 !== "number")
              return H.iae(t4);
            middleX = t1 - t4 - middleStart;
            break;
          case C.TextDirection_1:
            middleX = middleStart;
            break;
          default:
            middleX = null;
        }
        _this.positionChild$2(C._ToolbarSlot_1, new P.Offset(middleX, (t3 - t2) / 2));
      }
    },
    shouldRelayout$1: function(oldDelegate) {
      H.interceptedTypeCheck(oldDelegate, "$is_ToolbarLayout");
      return oldDelegate.centerMiddle != this.centerMiddle || oldDelegate.middleSpacing !== this.middleSpacing || oldDelegate.textDirection != this.textDirection;
    }
  };
  K.RoutePopDisposition.prototype = {
    toString$0: function(_) {
      return this._navigator$_name;
    }
  };
  K.Route.prototype = {
    install$1: function(insertionPoint) {
    },
    willPop$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(K.RoutePopDisposition),
        $async$returnValue, $async$self = this;
      var $async$willPop$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $async$self.get$isFirst() ? C.RoutePopDisposition_2 : C.RoutePopDisposition_0;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$willPop$0, $async$completer);
    },
    didPop$1: function(result) {
      this._popCompleter.complete$1(H.assertSubtypeOfRuntimeType(result, H.getTypeArgumentByIndex(this, 0)));
      return true;
    },
    didPopNext$1: function(nextRoute) {
    },
    didChangeNext$1: function(nextRoute) {
    },
    didChangePrevious$1: function(previousRoute) {
    },
    changedInternalState$0: function() {
    },
    changedExternalState$0: function() {
    },
    dispose$0: function() {
      this._navigator$_navigator = null;
    },
    get$isCurrent: function() {
      var t1 = this._navigator$_navigator;
      return t1 != null && C.JSArray_methods.get$last(t1._history) === this;
    },
    get$isFirst: function() {
      var t1 = this._navigator$_navigator;
      return t1 != null && C.JSArray_methods.get$first(t1._history) === this;
    }
  };
  K.RouteSettings.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + '("' + H.S(this.name) + '", ' + H.S(this.$arguments) + ")";
    }
  };
  K.NavigatorObserver.prototype = {};
  K.Navigator.prototype = {
    createState$0: function() {
      var t1 = [K.Route,,],
        t2 = H.setRuntimeTypeInfo([], [t1]),
        t3 = [O.FocusNode],
        t4 = {func: 1, ret: -1};
      t4 = new O.FocusScopeNode(H.setRuntimeTypeInfo([], t3), null, H.setRuntimeTypeInfo([], t3), new R.ObserverList(H.setRuntimeTypeInfo([], [t4]), [t4]));
      t4.set$debugLabel("Navigator Scope");
      return new K.NavigatorState(new N.LabeledGlobalKey(null, [X.OverlayState]), t2, P.LinkedHashSet_LinkedHashSet$_empty(t1), t4, H.setRuntimeTypeInfo([], [X.OverlayEntry]), P.LinkedHashSet_LinkedHashSet$_empty(P.int), null, C._StateLifecycle_0);
    },
    onGenerateRoute$1: function(arg0) {
      return this.onGenerateRoute.call$1(arg0);
    },
    onUnknownRoute$1: function(arg0) {
      return this.onUnknownRoute.call$1(arg0);
    }
  };
  K.Navigator_of_closure.prototype = {
    call$0: function() {
      if (this.navigator == null && !this.nullOk)
        throw H.wrapException(U.FlutterError$("Navigator operation requested with a context that does not include a Navigator.\nThe context used to push or pop routes from the Navigator must be that of a widget that is a descendant of a Navigator widget."));
      return true;
    },
    $signature: 0
  };
  K.NavigatorState.prototype = {
    initState$0: function() {
      var t1, t2, _i, observer, initialRouteName, plannedInitialRouteNames, plannedInitialRoutes, routeParts, routeName, route, t3, _this = this, _null = null, _box_0 = {};
      _this.super$State$initState();
      for (t1 = _this._widget.observers, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        observer = t1[_i];
        H.assertHelper(observer._navigator$_navigator == null);
        observer._navigator$_navigator = _this;
      }
      initialRouteName = _this._widget.initialRoute;
      _box_0.initialRouteName = initialRouteName;
      if (initialRouteName.startsWith$1(0, "/") && initialRouteName.length > 1) {
        _box_0.initialRouteName = initialRouteName.substring$1(0, 1);
        plannedInitialRouteNames = H.setRuntimeTypeInfo(["/"], [P.String]);
        plannedInitialRoutes = H.setRuntimeTypeInfo([_this._routeNamed$1$3$allowNull$arguments("/", true, _null, _null)], [[K.Route,,]]);
        routeParts = _box_0.initialRouteName.split("/");
        if (_box_0.initialRouteName.length !== 0)
          for (t1 = routeParts.length, routeName = "", _i = 0; _i < t1; ++_i) {
            routeName += "/" + H.S(routeParts[_i]);
            C.JSArray_methods.add$1(plannedInitialRouteNames, routeName);
            C.JSArray_methods.add$1(plannedInitialRoutes, _this._routeNamed$1$3$allowNull$arguments(routeName, true, _null, _null));
          }
        if (C.JSArray_methods.contains$1(plannedInitialRoutes, _null)) {
          H.assertHelper(new K.NavigatorState_initState_closure(_box_0, plannedInitialRouteNames, plannedInitialRoutes).call$0());
          t1 = P.Object;
          _this.push$1$1(_this._routeNamed$1$2$arguments("/", _null, t1), t1);
        } else
          C.JSArray_methods.forEach$1(plannedInitialRoutes, H.instantiate1(_this.get$push(), _null));
      } else {
        t1 = P.Object;
        route = _this._routeNamed$1$3$allowNull$arguments(initialRouteName, true, _null, t1);
        _this.push$1$1(route == null ? _this._routeNamed$1$2$arguments("/", _null, t1) : route, t1);
      }
      for (t1 = _this._history, t2 = t1.length, t3 = _this._initialOverlayEntries, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        C.JSArray_methods.addAll$1(t3, t1[_i]._overlayEntries);
    },
    didUpdateWidget$1: function(oldWidget) {
      var t1, t2, _i, observer, route, t3, _this = this;
      H.interceptedTypeCheck(oldWidget, "$isNavigator");
      _this.super$State$didUpdateWidget(oldWidget);
      t1 = oldWidget.observers;
      t2 = _this._widget.observers;
      if (t1 == null ? t2 != null : t1 !== t2) {
        for (t2 = t1.length, _i = 0; _i < t2; ++_i)
          t1[_i]._navigator$_navigator = null;
        for (t1 = _this._widget.observers, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          observer = t1[_i];
          H.assertHelper(observer._navigator$_navigator == null);
          observer._navigator$_navigator = _this;
        }
      }
      for (t1 = _this._history, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        route = t1[_i];
        route.super$Route$changedExternalState();
        t3 = route._scopeKey;
        if (t3.get$currentState() != null)
          t3.get$currentState()._forceRebuildPage$0();
      }
    },
    dispose$0: function() {
      var t1, t2, _i, doomed, t3, _this = this;
      H.assertHelper(!_this._debugLocked);
      H.assertHelper(new K.NavigatorState_dispose_closure(_this).call$0());
      for (t1 = _this._widget.observers, t2 = t1.length, _i = 0; _i < t2; ++_i)
        t1[_i]._navigator$_navigator = null;
      t1 = _this._poppedRoutes;
      doomed = t1.toList$0(0);
      t2 = _this._history;
      C.JSArray_methods.addAll$1(doomed, t2);
      for (t3 = doomed.length, _i = 0; _i < doomed.length; doomed.length === t3 || (0, H.throwConcurrentModificationError)(doomed), ++_i)
        doomed[_i].dispose$0();
      t1.clear$0(0);
      C.JSArray_methods.set$length(t2, 0);
      _this.focusScopeNode.dispose$0();
      _this.super$_NavigatorState_State_TickerProviderStateMixin$dispose();
      H.assertHelper(new K.NavigatorState_dispose_closure0(_this).call$0());
    },
    get$_currentOverlayEntry: function() {
      var t1, t2;
      for (t1 = this._history, t2 = H.getTypeArgumentByIndex(t1, 0), t1 = new H.ReversedListIterable(t1, [t2]), t2 = new H.ListIterator(t1, t1.get$length(t1), [t2]); t2.moveNext$0();) {
        t1 = t2._current._overlayEntries;
        if (t1.length !== 0)
          return C.JSArray_methods.get$last(t1);
      }
      return;
    },
    _routeNamed$1$3$allowNull$arguments: function($name, allowNull, $arguments, $T) {
      var settings, t2, route, _this = this, t1 = {};
      H.assertHelper(!_this._debugLocked);
      H.assertHelper($name != null);
      settings = new K.RouteSettings($name, _this._history.length === 0, $arguments);
      t2 = [$T];
      route = H.assertSubtype(_this._widget.onGenerateRoute$1(settings), "$isRoute", t2, "$asRoute");
      t1.route = route;
      if (route == null && !allowNull) {
        H.assertHelper(new K.NavigatorState__routeNamed_closure(_this, $name).call$0());
        t1.route = H.assertSubtype(_this._widget.onUnknownRoute$1(settings), "$isRoute", t2, "$asRoute");
        H.assertHelper(new K.NavigatorState__routeNamed_closure0(t1, _this, $name).call$0());
      }
      return t1.route;
    },
    _routeNamed$1$2$arguments: function($name, $arguments, $T) {
      return this._routeNamed$1$3$allowNull$arguments($name, false, $arguments, $T);
    },
    push$1$1: function(route, $T) {
      var t1, oldRoute, t2, _i, observer, _this = this;
      H.assertSubtype(route, "$isRoute", [$T], "$asRoute");
      H.assertHelper(!_this._debugLocked);
      H.assertHelper(new K.NavigatorState_push_closure(_this).call$0());
      H.assertHelper(route != null);
      H.assertHelper(route._navigator$_navigator == null);
      t1 = _this._history;
      oldRoute = t1.length !== 0 ? C.JSArray_methods.get$last(t1) : null;
      route._navigator$_navigator = _this;
      route.super$TransitionRoute$install(_this.get$_currentOverlayEntry());
      route._animationProxy = S.ProxyAnimation$(T.TransitionRoute.prototype.get$animation.call(route));
      route._secondaryAnimationProxy = S.ProxyAnimation$(T.TransitionRoute.prototype.get$secondaryAnimation.call(route));
      C.JSArray_methods.add$1(t1, route);
      t1 = route._scopeKey;
      if (t1.get$currentState() != null)
        route._navigator$_navigator.focusScopeNode.setFirstFocus$1(t1.get$currentState().focusScopeNode);
      route.super$TransitionRoute$didPush();
      route.didChangeNext$1(null);
      if (oldRoute != null) {
        oldRoute.didChangeNext$1(route);
        route.super$Route$didChangePrevious(oldRoute);
        route.changedInternalState$0();
      }
      for (t1 = _this._widget.observers, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        observer = t1[_i];
        H.assertHelper(observer._navigator$_navigator != null);
        observer._maybeStartHeroTransition$4(oldRoute, route, C.HeroFlightDirection_0, false);
      }
      H.assertHelper(new K.NavigatorState_push_closure0(_this).call$0());
      _this._afterNavigation$0();
      return route._popCompleter.future;
    },
    push$1: function(route) {
      return this.push$1$1(route, P.Object);
    },
    _afterNavigation$0: function() {
      P.postEvent("Flutter.Navigation", P.LinkedHashMap_LinkedHashMap$_empty(P.String, null));
      this._cancelActivePointers$0();
    },
    maybePop$1$1: function(result, $T) {
      return this.maybePop$body$NavigatorState(H.assertSubtypeOfRuntimeType(result, $T), $T);
    },
    maybePop$1$0: function($T) {
      return this.maybePop$1$1(null, $T);
    },
    maybePop$body$NavigatorState: function(result, $T) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this, disposition, route;
      var $async$maybePop$1$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              route = H.assertSubtype(C.JSArray_methods.get$last($async$self._history), "$isRoute", [$T], "$asRoute");
              H.assertHelper(route._navigator$_navigator === $async$self);
              $async$goto = 3;
              return P._asyncAwait(route.willPop$0(), $async$maybePop$1$1);
            case 3:
              // returning from await.
              disposition = $async$result;
              if (disposition !== C.RoutePopDisposition_2 && $async$self._element != null) {
                if (disposition === C.RoutePopDisposition_0)
                  $async$self.pop$1$1(result, $T);
                $async$returnValue = true;
                // goto return
                $async$goto = 1;
                break;
              }
              $async$returnValue = false;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$maybePop$1$1, $async$completer);
    },
    pop$1$1: function(result, $T) {
      var t1, route, t2, t3, _i, observer, t4, _this = this, _box_0 = {};
      H.assertSubtypeOfRuntimeType(result, $T);
      H.assertHelper(!_this._debugLocked);
      H.assertHelper(new K.NavigatorState_pop_closure(_this).call$0());
      t1 = _this._history;
      route = C.JSArray_methods.get$last(t1);
      H.assertHelper(route._navigator$_navigator === _this);
      _box_0.debugPredictedWouldPop = null;
      H.assertHelper(new K.NavigatorState_pop_closure0(_box_0, route).call$0());
      t2 = route.didPop$1(null);
      t3 = _box_0.debugPredictedWouldPop;
      if (t2) {
        H.assertHelper(t3);
        if (t1.length > 1) {
          t1.pop();
          if (route._navigator$_navigator != null)
            _this._poppedRoutes.add$1(0, route);
          t2 = C.JSArray_methods.get$last(t1);
          if (H.assertTest(t2._routes$_controller != null))
            H.assertThrow(new H.TypeImpl(H.getRti(t2)).toString$0(0) + ".didPopNext called before calling install() or after calling dispose().");
          if (H.assertTest(t2._transitionCompleter.future._state === 0))
            H.assertThrow("Cannot reuse a " + new H.TypeImpl(H.getRti(t2)).toString$0(0) + " after disposing it.");
          t2._updateSecondaryAnimation$1(route);
          t2.super$Route$didPopNext(route);
          for (t2 = _this._widget.observers, t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
            observer = t2[_i];
            t4 = C.JSArray_methods.get$last(t1);
            H.assertHelper(observer._navigator$_navigator != null);
            if (observer._navigator$_navigator._userGesturesInProgress <= 0)
              observer._maybeStartHeroTransition$4(route, t4, C.HeroFlightDirection_1, false);
          }
        } else {
          H.assertHelper(new K.NavigatorState_pop_closure1(_this).call$0());
          return false;
        }
      } else
        H.assertHelper(!H.boolConversionCheck(t3));
      H.assertHelper(new K.NavigatorState_pop_closure2(_this).call$0());
      _this._afterNavigation$0();
      return true;
    },
    pop$1$0: function($T) {
      return this.pop$1$1(null, $T);
    },
    didStartUserGesture$0: function() {
      var t1, route, t2, t3, previousRoute, _i, observer;
      if (++this._userGesturesInProgress === 1) {
        t1 = this._history;
        route = C.JSArray_methods.get$last(t1);
        if (!route.get$willHandlePopInternally() && t1.length > 1) {
          t2 = t1.length;
          t3 = t2 - 2;
          if (t3 < 0)
            return H.ioore(t1, t3);
          previousRoute = t1[t3];
        } else
          previousRoute = null;
        for (t1 = this._widget.observers, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          observer = t1[_i];
          H.assertHelper(observer._navigator$_navigator != null);
          observer._maybeStartHeroTransition$4(route, previousRoute, C.HeroFlightDirection_1, true);
        }
      }
    },
    didStopUserGesture$0: function() {
      var t1, t2, _i;
      H.assertHelper(this._userGesturesInProgress > 0);
      if (--this._userGesturesInProgress === 0)
        for (t1 = this._widget.observers, t2 = t1.length, _i = 0; _i < t2; ++_i)
          t1[_i].toString;
    },
    _handlePointerDown$1: function($event) {
      this._activePointers.add$1(0, $event.pointer);
    },
    _handlePointerUpOrCancel$1: function($event) {
      this._activePointers.remove$1(0, $event.pointer);
    },
    _cancelActivePointers$0: function() {
      if ($.SchedulerBinding__instance.SchedulerBinding__schedulerPhase === C.SchedulerPhase_0) {
        var t1 = $.GlobalKey__registry.$index(0, this._overlayKey);
        this.setState$1(new K.NavigatorState__cancelActivePointers_closure(H.interceptedTypeCheck(t1 == null ? null : t1.ancestorRenderObjectOfType$1(C.C_TypeMatcher1), "$isRenderAbsorbPointer")));
      }
      C.JSArray_methods.forEach$1(this._activePointers.toList$0(0), $.WidgetsBinding__instance.get$cancelPointer());
    },
    build$1: function(context) {
      var t1, _this = this;
      H.assertHelper(!_this._debugLocked);
      H.assertHelper(_this._history.length !== 0);
      t1 = _this.get$_handlePointerUpOrCancel();
      return T.Listener$(C.HitTestBehavior_0, new T.AbsorbPointer(false, L.FocusScope$(true, new X.Overlay(_this._initialOverlayEntries, _this._overlayKey), null, _this.focusScopeNode), null), t1, _this.get$_handlePointerDown(), t1);
    },
    $isTickerProvider: 1,
    $asState: function() {
      return [K.Navigator];
    },
    $asTickerProviderStateMixin: function() {
      return [K.Navigator];
    }
  };
  K.NavigatorState_initState_closure.prototype = {
    call$0: function() {
      U.FlutterError_reportError(U.FlutterErrorDetails$(null, 'Could not navigate to initial route.\nThe requested route name was: "/' + this._box_0.initialRouteName + '"\nThe following routes were therefore attempted:\n * ' + C.JSArray_methods.join$1(this.plannedInitialRouteNames, "\n * ") + "\nThis resulted in the following objects:\n * " + C.JSArray_methods.join$1(this.plannedInitialRoutes, "\n * ") + '\nOne or more of those objects was null, and therefore the initial route specified will be ignored and "/" will be used instead.', null, "Flutter framework", false, null));
      return true;
    },
    $signature: 0
  };
  K.NavigatorState_dispose_closure.prototype = {
    call$0: function() {
      return this.$this._debugLocked = true;
    },
    $signature: 0
  };
  K.NavigatorState_dispose_closure0.prototype = {
    call$0: function() {
      this.$this._debugLocked = false;
      return true;
    },
    $signature: 0
  };
  K.NavigatorState__routeNamed_closure.prototype = {
    call$0: function() {
      this.$this._widget.onUnknownRoute;
      return true;
    },
    $signature: 0
  };
  K.NavigatorState__routeNamed_closure0.prototype = {
    call$0: function() {
      if (this._box_0.route == null)
        throw H.wrapException(U.FlutterError$("A Navigator's onUnknownRoute returned null.\nWhen trying to build the route \"" + this.name + '", both onGenerateRoute and onUnknownRoute returned null. The onUnknownRoute callback should never return null.\nThe Navigator was:\n  ' + this.$this.toString$0(0)));
      return true;
    },
    $signature: 0
  };
  K.NavigatorState_push_closure.prototype = {
    call$0: function() {
      return this.$this._debugLocked = true;
    },
    $signature: 0
  };
  K.NavigatorState_push_closure0.prototype = {
    call$0: function() {
      this.$this._debugLocked = false;
      return true;
    },
    $signature: 0
  };
  K.NavigatorState_pop_closure.prototype = {
    call$0: function() {
      return this.$this._debugLocked = true;
    },
    $signature: 0
  };
  K.NavigatorState_pop_closure0.prototype = {
    call$0: function() {
      this._box_0.debugPredictedWouldPop = !this.route.get$willHandlePopInternally();
      return true;
    },
    $signature: 0
  };
  K.NavigatorState_pop_closure1.prototype = {
    call$0: function() {
      this.$this._debugLocked = false;
      return true;
    },
    $signature: 0
  };
  K.NavigatorState_pop_closure2.prototype = {
    call$0: function() {
      this.$this._debugLocked = false;
      return true;
    },
    $signature: 0
  };
  K.NavigatorState__cancelActivePointers_closure.prototype = {
    call$0: function() {
      var t1 = this.absorber;
      if (t1 != null)
        t1.set$absorbing(true);
    },
    $signature: 2
  };
  K._NavigatorState_State_TickerProviderStateMixin_dispose_closure.prototype = {
    call$0: function() {
      var t3,
        t1 = this.$this,
        t2 = t1.TickerProviderStateMixin__tickers;
      if (t2 != null)
        for (t2 = P._LinkedHashSetIterator$(t2, t2._collection$_modifications, H.getTypeArgumentByIndex(t2, 0)); t2.moveNext$0();) {
          t3 = t2._collection$_current;
          if (t3._future != null)
            throw H.wrapException(U.FlutterError$(t1.toString$0(0) + " was disposed with an active Ticker.\n" + H.getRuntimeType(t1).toString$0(0) + " created a Ticker via its TickerProviderStateMixin, but at the time dispose() was called on the mixin, that Ticker was still active. All Tickers must be disposed before calling super.dispose(). Tickers used by AnimationControllers should be disposed by calling dispose() on the AnimationController itself. Otherwise, the ticker will leak.\nThe offending ticker was: " + J.toString$1$debugIncludeStack$(t3, true)));
        }
      return true;
    },
    $signature: 0
  };
  K._NavigatorState_State_TickerProviderStateMixin.prototype = {
    dispose$0: function() {
      H.assertHelper(new K._NavigatorState_State_TickerProviderStateMixin_dispose_closure(this).call$0());
      this.super$State$dispose();
    },
    didChangeDependencies$0: function() {
      var muted = !U.TickerMode_of(this._element),
        t1 = this.TickerProviderStateMixin__tickers;
      if (t1 != null)
        for (t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0)); t1.moveNext$0();)
          t1._collection$_current.set$muted(muted);
      this.super$State$didChangeDependencies();
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$State$debugFillProperties(properties);
      t1 = this.TickerProviderStateMixin__tickers;
      if (t1 != null) {
        t2 = "tracking " + t1._collection$_length + " ticker";
        t2 += this.TickerProviderStateMixin__tickers._collection$_length === 1 ? "" : "s";
      } else
        t2 = _null;
      t2 = Y.DiagnosticsProperty$("tickers", t1, _null, t2, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, [P.Set, M.Ticker]);
      C.JSArray_methods.add$1(properties.properties, t2);
    },
    set$_tickers: function(_tickers) {
      this.TickerProviderStateMixin__tickers = H.assertSubtype(_tickers, "$isSet", [M.Ticker], "$asSet");
    }
  };
  U.Notification.prototype = {
    visitAncestor$1: function(element) {
      var widget;
      if (!!element.$isStatelessElement) {
        widget = H.interceptedTypeCheck(N.Element.prototype.get$widget.call(element), "$isStatelessWidget");
        if (!!widget.$isNotificationListener)
          if (widget._notification_listener$_dispatch$2(this, element))
            return false;
      }
      return true;
    },
    toString$0: function(_) {
      var t1 = [P.String],
        description = H.setRuntimeTypeInfo([], t1);
      H.assertSubtype(description, "$isList", t1, "$asList");
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(" + C.JSArray_methods.join$1(description, ", ") + ")";
    }
  };
  U.NotificationListener.prototype = {
    _notification_listener$_dispatch$2: function(notification, element) {
      var t1 = H.checkSubtypeOfRuntimeType(notification, H.getTypeArgumentByIndex(this, 0));
      if (t1)
        return this.onNotification.call$1(notification) === true;
      return false;
    },
    build$1: function(context) {
      return this.child;
    }
  };
  U.LayoutChangedNotification.prototype = {};
  X.OverlayEntry.prototype = {
    set$opaque: function(value) {
      var _this = this;
      if (_this._opaque === value)
        return;
      _this._opaque = value;
      H.assertHelper(_this._overlay != null);
      _this._overlay._didChangeEntryOpacity$0();
    },
    remove$0: function(_) {
      var overlay, t1, t2, _this = this;
      H.assertHelper(_this._overlay != null);
      overlay = _this._overlay;
      _this._overlay = null;
      t1 = $.SchedulerBinding__instance;
      if (t1.SchedulerBinding__schedulerPhase === C.SchedulerPhase_3) {
        t1.toString;
        t2 = H.functionTypeCheck(new X.OverlayEntry_remove_closure(_this, overlay), {func: 1, ret: -1, args: [P.Duration]});
        C.JSArray_methods.add$1(t1.SchedulerBinding__postFrameCallbacks, t2);
      } else
        overlay._overlay$_remove$1(_this);
    },
    markNeedsBuild$0: function() {
      var t1 = this._key.get$currentState();
      if (t1 != null)
        t1._markNeedsBuild$0();
    },
    toString$0: function(_) {
      var _this = this;
      return _this.get$runtimeType(_this).toString$0(0) + "#" + Y.shortHash(_this) + "(opaque: " + _this._opaque + "; maintainState: " + _this._maintainState + ")";
    }
  };
  X.OverlayEntry_remove_closure.prototype = {
    call$1: function(duration) {
      H.interceptedTypeCheck(duration, "$isDuration");
      this.overlay._overlay$_remove$1(this.$this);
    },
    $signature: 34
  };
  X._OverlayEntry.prototype = {
    createState$0: function() {
      return new X._OverlayEntryState(C._StateLifecycle_0);
    }
  };
  X._OverlayEntryState.prototype = {
    build$1: function(context) {
      return this._widget.entry.builder.call$1(context);
    },
    _markNeedsBuild$0: function() {
      this.setState$1(new X._OverlayEntryState__markNeedsBuild_closure());
    },
    $asState: function() {
      return [X._OverlayEntry];
    }
  };
  X._OverlayEntryState__markNeedsBuild_closure.prototype = {
    call$0: function() {
    },
    $signature: 2
  };
  X.Overlay.prototype = {
    createState$0: function() {
      return new X.OverlayState(H.setRuntimeTypeInfo([], [X.OverlayEntry]), null, C._StateLifecycle_0);
    }
  };
  X.Overlay_of_closure.prototype = {
    call$0: function() {
      var t2, additional,
        t1 = this.debugRequiredFor;
      if (t1 != null && this.result == null) {
        t2 = this.context;
        additional = t2._widget !== t1 ? "\nThe context from which that widget was searching for an overlay was:\n  " + t2.toString$0(0) : "";
        throw H.wrapException(U.FlutterError$("No Overlay widget found.\n" + H.getRuntimeType(t1).toString$0(0) + " widgets require an Overlay widget ancestor for correct operation.\nThe most common way to add an Overlay to an application is to include a MaterialApp or Navigator widget in the runApp() call.\nThe specific widget that failed to find an overlay was:\n  " + H.S(t1) + additional));
      }
      return true;
    },
    $signature: 0
  };
  X.OverlayState.prototype = {
    initState$0: function() {
      this.super$State$initState();
      this.insertAll$1(0, this._widget.initialEntries);
    },
    _insertionIndex$2: function(below, above) {
      if (above != null)
        return C.JSArray_methods.indexOf$1(this._entries, above) + 1;
      return this._entries.length;
    },
    insert$1: function(_, entry) {
      var _this = this;
      if (H.assertTest(!C.JSArray_methods.contains$1(_this._entries, entry)))
        H.assertThrow("The specified entry is already present in the Overlay.");
      if (H.assertTest(entry._overlay == null))
        H.assertThrow("The specified entry is already present in another Overlay.");
      entry._overlay = _this;
      _this.setState$1(new X.OverlayState_insert_closure(_this, null, null, entry));
    },
    insertAll$2$above: function(_, entries, above) {
      var t1, _i, entry, _this = this;
      H.assertSubtype(entries, "$isIterable", [X.OverlayEntry], "$asIterable");
      if (above != null)
        t1 = above._overlay === _this && C.JSArray_methods.contains$1(_this._entries, above);
      else
        t1 = true;
      if (H.assertTest(t1))
        H.assertThrow("The provided entry for `above` is not present in the Overlay.");
      if (H.assertTest(C.JSArray_methods.every$1(entries, new X.OverlayState_insertAll_closure(_this))))
        H.assertThrow("One or more of the specified entries are already present in the Overlay.");
      if (H.assertTest(C.JSArray_methods.every$1(entries, new X.OverlayState_insertAll_closure0())))
        H.assertThrow("One or more of the specified entries are already present in another Overlay.");
      t1 = entries.length;
      if (t1 === 0)
        return;
      for (_i = 0; _i < entries.length; entries.length === t1 || (0, H.throwConcurrentModificationError)(entries), ++_i) {
        entry = entries[_i];
        H.assertHelper(entry._overlay == null);
        entry._overlay = _this;
      }
      _this.setState$1(new X.OverlayState_insertAll_closure1(_this, null, above, entries));
    },
    insertAll$1: function($receiver, entries) {
      return this.insertAll$2$above($receiver, entries, null);
    },
    _overlay$_remove$1: function(entry) {
      if (this._element != null)
        this.setState$1(new X.OverlayState__remove_closure(this, entry));
    },
    _didChangeEntryOpacity$0: function() {
      this.setState$1(new X.OverlayState__didChangeEntryOpacity_closure());
    },
    build$1: function(context) {
      var i, onstage, entry,
        t1 = [N.Widget],
        onstageChildren = H.setRuntimeTypeInfo([], t1),
        offstageChildren = H.setRuntimeTypeInfo([], t1);
      for (t1 = this._entries, i = t1.length - 1, onstage = true; i >= 0; --i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        entry = t1[i];
        if (onstage) {
          C.JSArray_methods.add$1(onstageChildren, new X._OverlayEntry(entry, entry._key));
          onstage = !entry._opaque || false;
        } else if (entry._maintainState)
          C.JSArray_methods.add$1(offstageChildren, new U.TickerMode(false, new X._OverlayEntry(entry, entry._key), null));
      }
      return X._Theatre$(offstageChildren, T.Stack$(C.AlignmentDirectional_m1_m1, new H.ReversedListIterable(onstageChildren, [H.getTypeArgumentByIndex(onstageChildren, 0)]).toList$1$growable(0, false), C.StackFit_1));
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$_OverlayState_State_TickerProviderStateMixin$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("entries", this._entries, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, [P.List, X.OverlayEntry]);
      C.JSArray_methods.add$1(properties.properties, t1);
    },
    $isTickerProvider: 1,
    $asState: function() {
      return [X.Overlay];
    },
    $asTickerProviderStateMixin: function() {
      return [X.Overlay];
    }
  };
  X.OverlayState_insert_closure.prototype = {
    call$0: function() {
      var _this = this,
        t1 = _this.$this;
      C.JSArray_methods.insert$2(t1._entries, t1._insertionIndex$2(_this.below, _this.above), _this.entry);
    },
    $signature: 2
  };
  X.OverlayState_insertAll_closure.prototype = {
    call$1: function(entry) {
      return !C.JSArray_methods.contains$1(this.$this._entries, H.interceptedTypeCheck(entry, "$isOverlayEntry"));
    },
    $signature: 53
  };
  X.OverlayState_insertAll_closure0.prototype = {
    call$1: function(entry) {
      return H.interceptedTypeCheck(entry, "$isOverlayEntry")._overlay == null;
    },
    $signature: 53
  };
  X.OverlayState_insertAll_closure1.prototype = {
    call$0: function() {
      var iterable, t3, insertionLength, end, _this = this,
        t1 = _this.$this,
        t2 = t1._entries;
      t1 = t1._insertionIndex$2(_this.below, _this.above);
      iterable = H.assertSubtype(_this.entries, "$isIterable", [H.getTypeArgumentByIndex(t2, 0)], "$asIterable");
      t3 = t2.length;
      P.RangeError_checkValueInInterval(t1, 0, t3, "index");
      insertionLength = iterable.length;
      C.JSArray_methods.set$length(t2, t3 + insertionLength);
      end = t1 + insertionLength;
      C.JSArray_methods.setRange$4(t2, end, t2.length, t2, t1);
      C.JSArray_methods.setRange$3(t2, t1, end, iterable);
    },
    $signature: 2
  };
  X.OverlayState__remove_closure.prototype = {
    call$0: function() {
      C.JSArray_methods.remove$1(this.$this._entries, this.entry);
    },
    $signature: 2
  };
  X.OverlayState__didChangeEntryOpacity_closure.prototype = {
    call$0: function() {
    },
    $signature: 2
  };
  X._Theatre.prototype = {
    createElement$0: function() {
      var t1 = P.HashSet_HashSet(N.Element),
        t2 = ($.Element__nextHashCode + 1) % 16777215;
      $.Element__nextHashCode = t2;
      return new X._TheatreElement(t1, t2, this, C._ElementLifecycle_0);
    },
    createRenderObject$1: function(context) {
      var t1 = new X._RenderTheatre(0, null, null, null);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = false;
      return t1;
    }
  };
  X._TheatreElement.prototype = {
    get$widget: function() {
      return H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$widget.call(this), "$is_Theatre");
    },
    get$renderObject: function() {
      return H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$renderObject.call(this), "$is_RenderTheatre");
    },
    insertChildRenderObject$2: function(child, slot) {
      var t1, t2;
      H.interceptedTypeCheck(child, "$isRenderBox");
      H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$renderObject.call(this), "$is_RenderTheatre").debugValidateChild$1(child);
      t1 = J.getInterceptor$(slot);
      if (t1.$eq(slot, $.$get$_TheatreElement__onstageSlot())) {
        H.assertHelper(child instanceof K.RenderStack);
        H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$renderObject.call(this), "$is_RenderTheatre").set$child(child);
      } else {
        t2 = slot == null;
        H.assertHelper(t2 || !!t1.$isElement);
        t1 = H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$renderObject.call(this), "$is_RenderTheatre");
        t1.insert$2$after(0, child, H.interceptedTypeCheck(t2 ? null : slot.get$renderObject(), "$isRenderBox"));
      }
    },
    moveChildRenderObject$2: function(child, slot) {
      var t1, t2, _this = this;
      H.interceptedTypeCheck(child, "$isRenderBox");
      t1 = J.getInterceptor$(slot);
      if (t1.$eq(slot, $.$get$_TheatreElement__onstageSlot())) {
        t1 = H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$renderObject.call(_this), "$is_RenderTheatre");
        t1.toString;
        H.assertSubtypeOfRuntimeType(child, H.getRuntimeTypeArgument(t1, "ContainerRenderObjectMixin", 0));
        t1._removeFromChildList$1(child);
        t1.dropChild$1(child);
        H.assertHelper(child instanceof K.RenderStack);
        H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$renderObject.call(_this), "$is_RenderTheatre").set$child(child);
      } else {
        t2 = slot == null;
        H.assertHelper(t2 || !!t1.$isElement);
        if (H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$renderObject.call(_this), "$is_RenderTheatre").RenderObjectWithChildMixin__child == child) {
          H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$renderObject.call(_this), "$is_RenderTheatre").set$child(null);
          t1 = H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$renderObject.call(_this), "$is_RenderTheatre");
          t1.insert$2$after(0, child, H.interceptedTypeCheck(t2 ? null : slot.get$renderObject(), "$isRenderBox"));
        } else {
          t1 = H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$renderObject.call(_this), "$is_RenderTheatre");
          t1.move$2$after(child, H.interceptedTypeCheck(t2 ? null : slot.get$renderObject(), "$isRenderBox"));
        }
      }
    },
    removeChildRenderObject$1: function(child) {
      var t1;
      H.interceptedTypeCheck(child, "$isRenderBox");
      if (H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$renderObject.call(this), "$is_RenderTheatre").RenderObjectWithChildMixin__child == child)
        H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$renderObject.call(this), "$is_RenderTheatre").set$child(null);
      else {
        t1 = H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$renderObject.call(this), "$is_RenderTheatre");
        t1.toString;
        H.assertSubtypeOfRuntimeType(child, H.getRuntimeTypeArgument(t1, "ContainerRenderObjectMixin", 0));
        t1._removeFromChildList$1(child);
        t1.dropChild$1(child);
      }
    },
    visitChildren$1: function(visitor) {
      var t1, t2, t3, _i, child;
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [N.Element]});
      t1 = this._onstage;
      if (t1 != null)
        visitor.call$1(t1);
      for (t1 = this._offstage, t2 = t1.length, t3 = this._forgottenOffstageChildren, _i = 0; _i < t2; ++_i) {
        child = t1[_i];
        if (!t3.contains$1(0, child))
          visitor.call$1(child);
      }
    },
    forgetChild$1: function(child) {
      var t1, _this = this;
      if (child.$eq(0, _this._onstage))
        _this._onstage = null;
      else {
        t1 = _this._offstage;
        H.assertHelper((t1 && C.JSArray_methods).contains$1(t1, child));
        t1 = _this._forgottenOffstageChildren;
        H.assertHelper(!t1.contains$1(0, child));
        t1.add$1(0, child);
      }
      return true;
    },
    mount$2: function($parent, newSlot) {
      var t1, previousChild, i, newChild, _this = this;
      _this.super$RenderObjectElement$mount($parent, newSlot);
      _this._onstage = _this.updateChild$3(_this._onstage, H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$widget.call(_this), "$is_Theatre").onstage, $.$get$_TheatreElement__onstageSlot());
      t1 = new Array(H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$widget.call(_this), "$is_Theatre").offstage.length);
      t1.fixed$length = Array;
      _this.set$_offstage(H.setRuntimeTypeInfo(t1, [N.Element]));
      for (previousChild = null, i = 0; i < _this._offstage.length; ++i, previousChild = newChild) {
        t1 = H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$widget.call(_this), "$is_Theatre").offstage;
        if (i >= t1.length)
          return H.ioore(t1, i);
        newChild = _this.inflateWidget$2(t1[i], previousChild);
        t1 = _this._offstage;
        (t1 && C.JSArray_methods).$indexSet(t1, i, newChild);
      }
    },
    update$1: function(newWidget) {
      var t1, _this = this;
      H.interceptedTypeCheck(newWidget, "$is_Theatre");
      _this.super$RenderObjectElement$update(newWidget);
      H.assertHelper(H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$widget.call(_this), "$is_Theatre") === newWidget);
      _this._onstage = _this.updateChild$3(_this._onstage, H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$widget.call(_this), "$is_Theatre").onstage, $.$get$_TheatreElement__onstageSlot());
      t1 = _this._forgottenOffstageChildren;
      _this.set$_offstage(_this.updateChildren$3$forgottenChildren(_this._offstage, H.interceptedTypeCheck(N.RenderObjectElement.prototype.get$widget.call(_this), "$is_Theatre").offstage, t1));
      t1.clear$0(0);
    },
    set$_offstage: function(_offstage) {
      this._offstage = H.assertSubtype(_offstage, "$isList", [N.Element], "$asList");
    }
  };
  X._RenderTheatre.prototype = {
    setupParentData$1: function(child) {
      if (!(child.parentData instanceof K.StackParentData))
        child.parentData = new K.StackParentData(null, null, C.Offset_0_0);
    },
    redepthChildren$0: function() {
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        this.redepthChild$1(t1);
      this.super$ContainerRenderObjectMixin$redepthChildren();
    },
    visitChildren$1: function(visitor) {
      var t1;
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [K.RenderObject]});
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        visitor.call$1(t1);
      this.super$ContainerRenderObjectMixin$visitChildren(visitor);
    },
    debugDescribeChildren$0: function() {
      var child, count,
        children = H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]),
        t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        C.JSArray_methods.add$1(children, new Y._DiagnosticableTreeNode(t1, "onstage", true, true, null));
      child = this.ContainerRenderObjectMixin__firstChild;
      if (child != null)
        for (count = 1; true;) {
          t1 = "offstage " + count;
          child.toString;
          C.JSArray_methods.add$1(children, new Y._DiagnosticableTreeNode(child, t1, true, true, C.DiagnosticsTreeStyle_1));
          if (child == this.ContainerRenderObjectMixin__lastChild)
            break;
          child = H.interceptedTypeCheck(child.parentData, "$isStackParentData").ContainerParentDataMixin_nextSibling;
          ++count;
        }
      else
        C.JSArray_methods.add$1(children, Y.DiagnosticsNode_DiagnosticsNode$message("no offstage children", C.DiagnosticsTreeStyle_1));
      return children;
    },
    visitChildrenForSemantics$1: function(visitor) {
      var t1;
      H.functionTypeCheck(visitor, {func: 1, ret: -1, args: [K.RenderObject]});
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        visitor.call$1(t1);
    },
    $asRenderObjectWithChildMixin: function() {
      return [K.RenderStack];
    },
    $asContainerRenderObjectMixin: function() {
      return [S.RenderBox, K.StackParentData];
    }
  };
  X._OverlayState_State_TickerProviderStateMixin_dispose_closure.prototype = {
    call$0: function() {
      var t3,
        t1 = this.$this,
        t2 = t1.TickerProviderStateMixin__tickers;
      if (t2 != null)
        for (t2 = P._LinkedHashSetIterator$(t2, t2._collection$_modifications, H.getTypeArgumentByIndex(t2, 0)); t2.moveNext$0();) {
          t3 = t2._collection$_current;
          if (t3._future != null)
            throw H.wrapException(U.FlutterError$(t1.toString$0(0) + " was disposed with an active Ticker.\n" + H.getRuntimeType(t1).toString$0(0) + " created a Ticker via its TickerProviderStateMixin, but at the time dispose() was called on the mixin, that Ticker was still active. All Tickers must be disposed before calling super.dispose(). Tickers used by AnimationControllers should be disposed by calling dispose() on the AnimationController itself. Otherwise, the ticker will leak.\nThe offending ticker was: " + J.toString$1$debugIncludeStack$(t3, true)));
        }
      return true;
    },
    $signature: 0
  };
  X._OverlayState_State_TickerProviderStateMixin.prototype = {
    dispose$0: function() {
      H.assertHelper(new X._OverlayState_State_TickerProviderStateMixin_dispose_closure(this).call$0());
      this.super$State$dispose();
    },
    didChangeDependencies$0: function() {
      var muted = !U.TickerMode_of(this._element),
        t1 = this.TickerProviderStateMixin__tickers;
      if (t1 != null)
        for (t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0)); t1.moveNext$0();)
          t1._collection$_current.set$muted(muted);
      this.super$State$didChangeDependencies();
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$State$debugFillProperties(properties);
      t1 = this.TickerProviderStateMixin__tickers;
      if (t1 != null) {
        t2 = "tracking " + t1._collection$_length + " ticker";
        t2 += this.TickerProviderStateMixin__tickers._collection$_length === 1 ? "" : "s";
      } else
        t2 = _null;
      t2 = Y.DiagnosticsProperty$("tickers", t1, _null, t2, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, [P.Set, M.Ticker]);
      C.JSArray_methods.add$1(properties.properties, t2);
    },
    set$_tickers: function(_tickers) {
      this.TickerProviderStateMixin__tickers = H.assertSubtype(_tickers, "$isSet", [M.Ticker], "$asSet");
    }
  };
  X.__RenderTheatre_RenderBox_RenderObjectWithChildMixin.prototype = {
    attach$1: function(owner) {
      var t1;
      H.interceptedTypeCheck(owner, "$isPipelineOwner");
      this.super$RenderObject$attach(owner);
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.attach$1(owner);
    },
    detach$0: function() {
      this.super$AbstractNode$detach();
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.detach$0();
    },
    set$_object$_child: function(_child) {
      this.RenderObjectWithChildMixin__child = H.assertSubtypeOfRuntimeType(_child, H.getRuntimeTypeArgument(this, "RenderObjectWithChildMixin", 0));
    }
  };
  X.__RenderTheatre_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin.prototype = {
    computeDistanceToActualBaseline$1: function(baseline) {
      var t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        return t1.getDistanceToActualBaseline$1(baseline);
      return this.super$RenderBox$computeDistanceToActualBaseline(baseline);
    }
  };
  X.__RenderTheatre_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin_ContainerRenderObjectMixin.prototype = {
    attach$1: function(owner) {
      var child;
      H.interceptedTypeCheck(owner, "$isPipelineOwner");
      this.super$__RenderTheatre_RenderBox_RenderObjectWithChildMixin$attach(owner);
      child = this.ContainerRenderObjectMixin__firstChild;
      for (; child != null;) {
        child.attach$1(owner);
        child = H.interceptedTypeCheck(child.parentData, "$isStackParentData").ContainerParentDataMixin_nextSibling;
      }
    },
    detach$0: function() {
      this.super$__RenderTheatre_RenderBox_RenderObjectWithChildMixin$detach();
      var child = this.ContainerRenderObjectMixin__firstChild;
      for (; child != null;) {
        child.detach$0();
        child = H.interceptedTypeCheck(child.parentData, "$isStackParentData").ContainerParentDataMixin_nextSibling;
      }
    },
    set$_firstChild: function(_firstChild) {
      this.ContainerRenderObjectMixin__firstChild = H.assertSubtypeOfRuntimeType(_firstChild, H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 0));
    },
    set$_lastChild: function(_lastChild) {
      this.ContainerRenderObjectMixin__lastChild = H.assertSubtypeOfRuntimeType(_lastChild, H.getRuntimeTypeArgument(this, "ContainerRenderObjectMixin", 0));
    }
  };
  S.PageStorageBucket.prototype = {};
  S.PageStorage.prototype = {
    build$1: function(context) {
      return this.child;
    }
  };
  V.PageRoute.prototype = {};
  L.PerformanceOverlay.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new L.RenderPerformanceOverlay(this.optionsMask, 0, false, false);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = true;
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderPerformanceOverlay");
      renderObject.set$optionsMask(this.optionsMask);
      renderObject.set$rasterizerThreshold(0);
    }
  };
  E.PrimaryScrollController.prototype = {
    updateShouldNotify$1: function(oldWidget) {
      return this.controller !== H.interceptedTypeCheck(oldWidget, "$isPrimaryScrollController").controller;
    },
    debugFillProperties$1: function(properties) {
      var t1;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("controller", this.controller, C.C__NoDefaultValue, null, null, "no controller", C.DiagnosticLevel_3, false, false, true, C.DiagnosticsTreeStyle_5, null, F.ScrollController);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  T.OverlayRoute.prototype = {
    install$1: function(insertionPoint) {
      var t2, _this = this,
        t1 = _this._overlayEntries;
      H.assertHelper(t1.length === 0);
      C.JSArray_methods.addAll$1(t1, _this.createOverlayEntries$0());
      t2 = _this._navigator$_navigator._overlayKey.get$currentState();
      if (t2 != null)
        t2.insertAll$2$above(0, t1, insertionPoint);
      _this.super$Route$install(insertionPoint);
    },
    didPop$1: function(result) {
      var _this = this;
      _this.super$Route$didPop(H.assertSubtypeOfRuntimeType(result, H.getTypeArgumentByIndex(_this, 0)));
      if (_this._routes$_controller._status === C.AnimationStatus_0) {
        _this._navigator$_navigator._poppedRoutes.remove$1(0, _this);
        _this.dispose$0();
      }
      return true;
    },
    dispose$0: function() {
      var t1, t2, _i;
      for (t1 = this._overlayEntries, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        J.remove$0$ax(t1[_i]);
      C.JSArray_methods.set$length(t1, 0);
      this.super$Route$dispose();
    }
  };
  T.TransitionRoute.prototype = {
    get$animation: function() {
      return this._routes$_animation;
    },
    get$secondaryAnimation: function() {
      return this._secondaryAnimation;
    },
    createAnimationController$0: function() {
      var _this = this;
      if (H.assertTest(_this._transitionCompleter.future._state === 0))
        H.assertThrow("Cannot reuse a " + new H.TypeImpl(H.getRti(_this)).toString$0(0) + " after disposing it.");
      return G.AnimationController$(T.TransitionRoute.prototype.get$debugLabel.call(_this) + "(" + H.S(_this.settings.name) + ")", C.Duration_300000, 0, 1, null, _this._navigator$_navigator);
    },
    _routes$_handleStatusChanged$1: function($status) {
      var t1, _this = this;
      switch (H.interceptedTypeCheck($status, "$isAnimationStatus")) {
        case C.AnimationStatus_3:
          t1 = _this._overlayEntries;
          if (t1.length !== 0)
            C.JSArray_methods.get$first(t1).set$opaque(true);
          break;
        case C.AnimationStatus_1:
        case C.AnimationStatus_2:
          t1 = _this._overlayEntries;
          if (t1.length !== 0)
            C.JSArray_methods.get$first(t1).set$opaque(false);
          break;
        case C.AnimationStatus_0:
          t1 = _this._navigator$_navigator;
          if (!(t1 != null && C.JSArray_methods.contains$1(t1._history, _this))) {
            _this._navigator$_navigator._poppedRoutes.remove$1(0, _this);
            _this.dispose$0();
            H.assertHelper(_this._overlayEntries.length === 0);
          }
          break;
      }
      _this.changedInternalState$0();
    },
    install$1: function(insertionPoint) {
      var controller, _this = this,
        _s20_ = " after disposing it.",
        t1 = _this._transitionCompleter.future;
      if (H.assertTest(t1._state === 0))
        H.assertThrow("Cannot install a " + new H.TypeImpl(H.getRti(_this)).toString$0(0) + _s20_);
      controller = _this.super$TransitionRoute$createAnimationController();
      if (_this.settings.isInitialRoute)
        controller.set$value(1);
      _this._routes$_controller = controller;
      if (H.assertTest(t1._state === 0))
        H.assertThrow("Cannot reuse a " + new H.TypeImpl(H.getRti(_this)).toString$0(0) + _s20_);
      H.assertHelper(_this._routes$_controller != null);
      t1 = _this._routes$_controller;
      t1.toString;
      _this.set$_routes$_animation(t1);
      if (H.assertTest(_this._routes$_animation != null))
        H.assertThrow(new H.TypeImpl(H.getRti(_this)).toString$0(0) + ".createAnimation() returned null.");
      _this.super$OverlayRoute$install(insertionPoint);
    },
    didPush$0: function() {
      var _this = this;
      if (H.assertTest(_this._routes$_controller != null))
        H.assertThrow(new H.TypeImpl(H.getRti(_this)).toString$0(0) + ".didPush called before calling install() or after calling dispose().");
      if (H.assertTest(_this._transitionCompleter.future._state === 0))
        H.assertThrow("Cannot reuse a " + new H.TypeImpl(H.getRti(_this)).toString$0(0) + " after disposing it.");
      _this._routes$_animation.addStatusListener$1(_this.get$_routes$_handleStatusChanged());
      return _this._routes$_controller.forward$0();
    },
    didPop$1: function(result) {
      var _this = this;
      H.assertSubtypeOfRuntimeType(result, H.getTypeArgumentByIndex(_this, 0));
      if (H.assertTest(_this._routes$_controller != null))
        H.assertThrow(new H.TypeImpl(H.getRti(_this)).toString$0(0) + ".didPop called before calling install() or after calling dispose().");
      if (H.assertTest(_this._transitionCompleter.future._state === 0))
        H.assertThrow("Cannot reuse a " + new H.TypeImpl(H.getRti(_this)).toString$0(0) + " after disposing it.");
      _this.set$_result(result);
      _this._routes$_controller.reverse$0();
      _this.super$OverlayRoute$didPop(result);
      return true;
    },
    didChangeNext$1: function(nextRoute) {
      var _this = this;
      if (H.assertTest(_this._routes$_controller != null))
        H.assertThrow(new H.TypeImpl(H.getRti(_this)).toString$0(0) + ".didChangeNext called before calling install() or after calling dispose().");
      if (H.assertTest(_this._transitionCompleter.future._state === 0))
        H.assertThrow("Cannot reuse a " + new H.TypeImpl(H.getRti(_this)).toString$0(0) + " after disposing it.");
      _this._updateSecondaryAnimation$1(nextRoute);
      _this.super$Route$didChangeNext(nextRoute);
    },
    _updateSecondaryAnimation$1: function(nextRoute) {
      var t2, t3, current, newAnimation, t1 = {};
      if (nextRoute instanceof T.TransitionRoute)
        t2 = true;
      else
        t2 = false;
      t3 = this._secondaryAnimation;
      if (t2) {
        current = t3._animations$_parent;
        if (current != null)
          if (!!current.$isTrainHoppingAnimation) {
            t1.newAnimation = null;
            newAnimation = S.TrainHoppingAnimation$(current._currentTrain, nextRoute._routes$_animation, new T.TransitionRoute__updateSecondaryAnimation_closure(t1, this, nextRoute));
            t1.newAnimation = newAnimation;
            t3.set$parent(newAnimation);
            current.dispose$0();
          } else
            t3.set$parent(S.TrainHoppingAnimation$(current, nextRoute._routes$_animation, null));
        else
          t3.set$parent(nextRoute._routes$_animation);
      } else
        t3.set$parent(C.C__AlwaysDismissedAnimation);
    },
    dispose$0: function() {
      var t2, _this = this,
        t1 = _this._transitionCompleter;
      if (H.assertTest(t1.future._state === 0))
        H.assertThrow("Cannot dispose a " + new H.TypeImpl(H.getRti(_this)).toString$0(0) + " twice.");
      t2 = _this._routes$_controller;
      if (t2 != null)
        t2.dispose$0();
      t1.complete$1(_this._result);
      _this.super$OverlayRoute$dispose();
    },
    get$debugLabel: function() {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    },
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(animation: " + H.S(this._routes$_controller) + ")";
    },
    set$_routes$_animation: function(_animation) {
      this._routes$_animation = H.assertSubtype(_animation, "$isAnimation", [P.double], "$asAnimation");
    },
    set$_result: function(_result) {
      this._result = H.assertSubtypeOfRuntimeType(_result, H.getTypeArgumentByIndex(this, 0));
    }
  };
  T.TransitionRoute__updateSecondaryAnimation_closure.prototype = {
    call$0: function() {
      var t1 = this.$this._secondaryAnimation,
        t2 = this._box_0;
      H.assertHelper(t1._animations$_parent == t2.newAnimation);
      H.assertHelper(t2.newAnimation._currentTrain == this.nextRoute._routes$_animation);
      t1.set$parent(t2.newAnimation._currentTrain);
      t2.newAnimation.dispose$0();
    },
    $signature: 2
  };
  T.LocalHistoryEntry.prototype = {};
  T.LocalHistoryRoute.prototype = {
    get$willHandlePopInternally: function() {
      var t1 = this.LocalHistoryRoute__localHistory;
      return t1 != null && t1.length !== 0;
    }
  };
  T._ModalScopeStatus.prototype = {
    updateShouldNotify$1: function(old) {
      H.interceptedTypeCheck(old, "$is_ModalScopeStatus");
      return this.isCurrent !== old.isCurrent || this.canPop !== old.canPop || this.route !== old.route;
    },
    debugFillProperties$1: function(description) {
      var t1, t2;
      this.super$Widget$debugFillProperties(description);
      t1 = Y.FlagProperty$("isCurrent", null, "inactive", "active", C.DiagnosticLevel_3, false, this.isCurrent);
      t2 = description.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.FlagProperty$("canPop", null, null, "can pop", C.DiagnosticLevel_3, false, this.canPop));
    }
  };
  T._ModalScope.prototype = {
    createState$0: function() {
      var t1 = C.Type__ModalScopeState_Yap.toString$0(0) + " Focus Scope",
        t2 = [O.FocusNode],
        t3 = {func: 1, ret: -1};
      t3 = new O.FocusScopeNode(H.setRuntimeTypeInfo([], t2), null, H.setRuntimeTypeInfo([], t2), new R.ObserverList(H.setRuntimeTypeInfo([], [t3]), [t3]));
      t3.set$debugLabel(t1);
      return new T._ModalScopeState(t3, C._StateLifecycle_0, this.$ti);
    }
  };
  T._ModalScopeState.prototype = {
    initState$0: function() {
      var animations, t1, _this = this;
      _this.super$State$initState();
      animations = H.setRuntimeTypeInfo([], [B.Listenable]);
      t1 = _this._widget.route._animationProxy;
      if (t1 != null)
        C.JSArray_methods.add$1(animations, t1);
      t1 = _this._widget.route._secondaryAnimationProxy;
      if (t1 != null)
        C.JSArray_methods.add$1(animations, t1);
      _this._listenable = new B._MergingListenable(animations);
      if (_this._widget.route.get$isCurrent())
        _this._widget.route._navigator$_navigator.focusScopeNode.setFirstFocus$1(_this.focusScopeNode);
    },
    didUpdateWidget$1: function(oldWidget) {
      var _this = this;
      H.assertSubtype(oldWidget, "$is_ModalScope", _this.$ti, "$as_ModalScope");
      _this.super$State$didUpdateWidget(oldWidget);
      H.assertHelper(_this._widget.route === oldWidget.route);
      if (_this._widget.route.get$isCurrent())
        _this._widget.route._navigator$_navigator.focusScopeNode.setFirstFocus$1(_this.focusScopeNode);
    },
    didChangeDependencies$0: function() {
      this.super$State$didChangeDependencies();
      this._page = null;
    },
    _forceRebuildPage$0: function() {
      this.setState$1(new T._ModalScopeState__forceRebuildPage_closure(this));
    },
    dispose$0: function() {
      this.focusScopeNode.dispose$0();
      this.super$State$dispose();
    },
    build$1: function(context) {
      var t4, t5, t6, t7, _this = this, _null = null,
        t1 = _this._widget.route,
        t2 = t1.get$isCurrent(),
        t3 = _this._widget.route;
      t3 = !t3.get$isFirst() || t3.get$willHandlePopInternally();
      t4 = _this._widget.route;
      t5 = t4._routes$_offstage;
      t6 = _this._listenable;
      t7 = _this._page;
      t4 = t7 == null ? _this._page = new T.RepaintBoundary(T.Builder$(new T._ModalScopeState_build_closure(_this)), t4._subtreeKey) : t7;
      return new T._ModalScopeStatus(t2, t3, t1, new T.Offstage(t5, new S.PageStorage(L.FocusScope$(false, new T.RepaintBoundary(K.AnimatedBuilder$(t6, new T._ModalScopeState_build_closure0(_this), t4), _null), _null, _this.focusScopeNode), _null), _null), _null);
    },
    $asState: function($T) {
      return [[T._ModalScope, $T]];
    }
  };
  T._ModalScopeState__forceRebuildPage_closure.prototype = {
    call$0: function() {
      this.$this._page = null;
    },
    $signature: 2
  };
  T._ModalScopeState_build_closure0.prototype = {
    call$2: function(context, child) {
      var t1, t2, t3, t4, t5, theme, platform, matchingBuilder;
      H.interceptedTypeCheck(context, "$isBuildContext");
      H.interceptedTypeCheck(child, "$isWidget");
      t1 = this.$this._widget.route;
      t2 = t1._animationProxy;
      t3 = t1._secondaryAnimationProxy;
      t4 = T.IgnorePointer$(child, (t2 == null ? null : t2.get$status(t2)) === C.AnimationStatus_2, null, null);
      t5 = [P.double];
      H.assertSubtype(t2, "$isAnimation", t5, "$asAnimation");
      H.assertSubtype(t3, "$isAnimation", t5, "$asAnimation");
      theme = K.Theme_of(context).pageTransitionsTheme;
      t5 = H.getTypeArgumentByIndex(t1, 0);
      H.assertSubtype(t1, "$isPageRoute", [t5], "$asPageRoute");
      platform = K.Theme_of(context).platform;
      if (t1._navigator$_navigator._userGesturesInProgress > 0)
        platform = C.TargetPlatform_2;
      matchingBuilder = theme.get$builders().$index(0, platform);
      return (matchingBuilder == null ? C.C_FadeUpwardsPageTransitionsBuilder : matchingBuilder).buildTransitions$1$5(t1, context, t2, t3, t4, t5);
    },
    $signature: 172
  };
  T._ModalScopeState_build_closure.prototype = {
    call$1: function(context) {
      var t1;
      H.interceptedTypeCheck(context, "$isBuildContext");
      t1 = this.$this._widget.route;
      return t1.buildPage$3(context, t1._animationProxy, t1._secondaryAnimationProxy);
    },
    $signature: 11
  };
  T.ModalRoute.prototype = {
    setState$1: function(fn) {
      var t1;
      H.functionTypeCheck(fn, {func: 1, ret: -1});
      t1 = this._scopeKey;
      if (t1.get$currentState() != null)
        t1.get$currentState().setState$1(fn);
      else
        fn.call$0();
    },
    set$offstage: function(value) {
      var t1, _this = this;
      if (_this._routes$_offstage === value)
        return;
      _this.setState$1(new T.ModalRoute_offstage_closure(_this, value));
      t1 = _this._animationProxy;
      t1.set$parent(_this._routes$_offstage ? C.C__AlwaysCompleteAnimation : T.TransitionRoute.prototype.get$animation.call(_this));
      t1 = _this._secondaryAnimationProxy;
      t1.set$parent(_this._routes$_offstage ? C.C__AlwaysDismissedAnimation : T.TransitionRoute.prototype.get$secondaryAnimation.call(_this));
    },
    willPop$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(K.RoutePopDisposition),
        $async$returnValue, $async$self = this, t1, t2, _i, $async$temp1;
      var $async$willPop$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              H.assertHelper($async$self._scopeKey.get$currentState() != null);
              t1 = P.List_List$from($async$self._willPopCallbacks, true, {func: 1, ret: [P.Future, P.bool]}), t2 = t1.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t1.length)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$temp1 = H;
              $async$goto = 6;
              return P._asyncAwait(t1[_i].call$0(), $async$willPop$0);
            case 6:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result)) {
                $async$returnValue = C.RoutePopDisposition_1;
                // goto return
                $async$goto = 1;
                break;
              }
            case 4:
              // for update
              t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              $async$goto = 7;
              return P._asyncAwait($async$self.super$_ModalRoute_TransitionRoute_LocalHistoryRoute$willPop(), $async$willPop$0);
            case 7:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$willPop$0, $async$completer);
    },
    changedInternalState$0: function() {
      this.super$Route$changedInternalState();
      this.setState$1(new T.ModalRoute_changedInternalState_closure());
      this._modalBarrier.markNeedsBuild$0();
    },
    _buildModalBarrier$1: function(context) {
      var barrier, t1, _null = null;
      H.interceptedTypeCheck(context, "$isBuildContext");
      barrier = X.ModalBarrier$(true, _null, false, _null);
      t1 = this._animationProxy;
      if (t1.get$status(t1) !== C.AnimationStatus_2) {
        t1 = this._animationProxy;
        t1 = t1.get$status(t1) === C.AnimationStatus_0;
      } else
        t1 = true;
      return T.IgnorePointer$(barrier, t1, _null, _null);
    },
    _buildModalScope$1: function(context) {
      var t1, _this = this;
      H.interceptedTypeCheck(context, "$isBuildContext");
      t1 = _this._modalScopeCache;
      return t1 == null ? _this._modalScopeCache = new T._ModalScope(_this, _this._scopeKey, _this.$ti) : t1;
    },
    createOverlayEntries$0: function() {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var $async$goto = 0, $async$handler = 1, $async$currentError, t1;
        return function $async$createOverlayEntries$0($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = X.OverlayEntry$($async$self.get$_buildModalBarrier(), false);
                $async$self._modalBarrier = t1;
                $async$goto = 2;
                return t1;
              case 2:
                // after yield
                $async$goto = 3;
                return X.OverlayEntry$($async$self.get$_buildModalScope(), true);
              case 3:
                // after yield
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, X.OverlayEntry);
    },
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0) + "(" + this.settings.toString$0(0) + ", animation: " + H.S(this._routes$_animation) + ")";
    }
  };
  T.ModalRoute_offstage_closure.prototype = {
    call$0: function() {
      this.$this._routes$_offstage = this.value;
    },
    $signature: 2
  };
  T.ModalRoute_changedInternalState_closure.prototype = {
    call$0: function() {
    },
    $signature: 2
  };
  T._ModalRoute_TransitionRoute_LocalHistoryRoute.prototype = {
    willPop$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(K.RoutePopDisposition),
        $async$returnValue, $async$self = this;
      var $async$willPop$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self.get$willHandlePopInternally()) {
                $async$returnValue = C.RoutePopDisposition_0;
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return P._asyncAwait($async$self.super$Route$willPop(), $async$willPop$0);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$willPop$0, $async$completer);
    },
    didPop$1: function(result) {
      var t1, entry, _this = this;
      H.assertSubtypeOfRuntimeType(result, H.getTypeArgumentByIndex(_this, 0));
      t1 = _this.LocalHistoryRoute__localHistory;
      if (t1 != null && t1.length !== 0) {
        if (0 >= t1.length)
          return H.ioore(t1, -1);
        entry = t1.pop();
        H.assertHelper(entry._routes$_owner === _this);
        entry._routes$_owner = null;
        entry.onRemove.call$0();
        if (_this.LocalHistoryRoute__localHistory.length === 0)
          _this.changedInternalState$0();
        return false;
      }
      _this.super$TransitionRoute$didPop(result);
      return true;
    }
  };
  Q.SafeArea.prototype = {
    build$1: function(context) {
      var padding, t1, t2, t3, t4, t5;
      E.debugCheckHasMediaQuery(context);
      padding = F.MediaQuery_of(context, false).padding;
      t1 = Math.max(H.checkNum(padding.left), 0);
      t2 = this.top;
      t3 = Math.max(H.checkNum(t2 ? padding.top : 0), 0);
      t4 = Math.max(H.checkNum(padding.right), 0);
      t5 = Math.max(H.checkNum(padding.bottom), 0);
      return T.Padding$(F.MediaQuery$(this.child, F.MediaQuery_of(context, false).removePadding$4$removeBottom$removeLeft$removeRight$removeTop(true, true, true, t2), null), new V.EdgeInsets(t1, t3, t4, t5));
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.FlagProperty$("left", _null, _null, "avoid left padding", C.DiagnosticLevel_3, false, true);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.FlagProperty$("top", _null, _null, "avoid top padding", C.DiagnosticLevel_3, false, true));
      C.JSArray_methods.add$1(t2, Y.FlagProperty$("right", _null, _null, "avoid right padding", C.DiagnosticLevel_3, false, true));
      C.JSArray_methods.add$1(t2, Y.FlagProperty$("bottom", _null, _null, "avoid bottom padding", C.DiagnosticLevel_3, false, true));
    }
  };
  K.ScrollBehavior.prototype = {
    toString$0: function(_) {
      return new H.TypeImpl(H.getRti(this)).toString$0(0);
    }
  };
  K.ScrollConfiguration.prototype = {
    updateShouldNotify$1: function(oldWidget) {
      var t1;
      H.interceptedTypeCheck(oldWidget, "$isScrollConfiguration");
      if (new H.TypeImpl(H.getRti(this.behavior)).$eq(0, new H.TypeImpl(H.getRti(oldWidget.behavior))))
        t1 = false;
      else
        t1 = true;
      return t1;
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("behavior", this.behavior, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, K.ScrollBehavior);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  F.ScrollController.prototype = {
    toString$0: function(_) {
      var t1 = [P.String],
        description = H.setRuntimeTypeInfo([], t1);
      H.assertSubtype(description, "$isList", t1, "$asList");
      C.JSArray_methods.add$1(description, "no clients");
      return this.get$runtimeType(this).toString$0(0) + "#" + Y.shortHash(this) + "(" + C.JSArray_methods.join$1(description, ", ") + ")";
    }
  };
  A.ScrollPosition.prototype = {};
  A._ScrollPosition_ViewportOffset_ScrollMetrics.prototype = {};
  L.DefaultTextStyle.prototype = {
    updateShouldNotify$1: function(oldWidget) {
      var t1;
      H.interceptedTypeCheck(oldWidget, "$isDefaultTextStyle");
      if (J.$eq$(this.style, oldWidget.style))
        t1 = this.softWrap !== oldWidget.softWrap || this.overflow !== oldWidget.overflow || false;
      else
        t1 = true;
      return t1;
    },
    debugFillProperties$1: function(properties) {
      var t1, _this = this, _null = null;
      _this.super$Widget$debugFillProperties(properties);
      t1 = _this.style;
      if (t1 != null)
        t1.debugFillProperties$1(properties);
      t1 = properties.properties;
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.textAlign, _null, C.DiagnosticLevel_3, "textAlign", true, true, C.DiagnosticsTreeStyle_5, [P.TextAlign]));
      C.JSArray_methods.add$1(t1, Y.FlagProperty$("softWrap", _null, "no wrapping except at line break characters", "wrapping at box width", C.DiagnosticLevel_3, true, _this.softWrap));
      C.JSArray_methods.add$1(t1, new Y.EnumProperty(_null, _null, _null, _null, false, _this.overflow, _null, C.DiagnosticLevel_3, "overflow", true, true, C.DiagnosticsTreeStyle_5, [Q.TextOverflow]));
      C.JSArray_methods.add$1(t1, Y.IntProperty$("maxLines", _this.maxLines, _null, _null, C.DiagnosticLevel_3, _null));
    }
  };
  L.Text.prototype = {
    build$1: function(context) {
      var result, _null = null,
        t1 = context.inheritFromWidgetOfExactType$1(C.Type_DefaultTextStyle_ird),
        defaultTextStyle = H.interceptedTypeCheck(t1 == null ? C.DefaultTextStyle_mN7 : t1, "$isDefaultTextStyle"),
        effectiveTextStyle = this.style;
      if (effectiveTextStyle == null || effectiveTextStyle.inherit)
        effectiveTextStyle = defaultTextStyle.style.merge$1(effectiveTextStyle);
      F.MediaQuery_of(context, true);
      t1 = F.MediaQuery_of(context, true);
      t1 = t1 == null ? _null : t1.textScaleFactor;
      if (t1 == null)
        t1 = 1;
      result = T.RichText$(_null, defaultTextStyle.maxLines, defaultTextStyle.overflow, defaultTextStyle.softWrap, _null, Q.TextSpan$(_null, effectiveTextStyle, this.data), C.TextAlign_4, _null, t1);
      return result;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.StringProperty$("data", this.data, C.C__NoDefaultValue, true, false);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      t1 = this.style;
      if (t1 != null)
        t1.debugFillProperties$1(properties);
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, _null, _null, C.DiagnosticLevel_3, "textAlign", true, true, C.DiagnosticsTreeStyle_5, [P.TextAlign]));
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, _null, _null, C.DiagnosticLevel_3, "textDirection", true, true, C.DiagnosticsTreeStyle_5, [P.TextDirection]));
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("locale", _null, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Locale));
      C.JSArray_methods.add$1(t2, Y.FlagProperty$("softWrap", _null, "no wrapping except at line break characters", "wrapping at box width", C.DiagnosticLevel_3, true, _null));
      C.JSArray_methods.add$1(t2, new Y.EnumProperty(_null, _null, _null, _null, false, _null, _null, C.DiagnosticLevel_3, "overflow", true, true, C.DiagnosticsTreeStyle_5, [Q.TextOverflow]));
      C.JSArray_methods.add$1(t2, Y.DoubleProperty$("textScaleFactor", _null, _null, _null, C.DiagnosticLevel_3, true, _null, _null));
      C.JSArray_methods.add$1(t2, Y.IntProperty$("maxLines", _null, _null, _null, C.DiagnosticLevel_3, _null));
    }
  };
  U.TickerMode.prototype = {
    updateShouldNotify$1: function(oldWidget) {
      H.interceptedTypeCheck(oldWidget, "$isTickerMode");
      return false;
    },
    debugFillProperties$1: function(properties) {
      var t1;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.FlagProperty$("mode", null, "disabled", "enabled", C.DiagnosticLevel_3, true, false);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  U.SingleTickerProviderStateMixin.prototype = {
    createTicker$1: function(onTick) {
      H.functionTypeCheck(onTick, {func: 1, ret: -1, args: [P.Duration]});
      H.assertHelper(new U.SingleTickerProviderStateMixin_createTicker_closure(this).call$0());
      return this.SingleTickerProviderStateMixin__ticker = M.Ticker$(onTick, "created by " + this.toString$0(0));
    }
  };
  U.SingleTickerProviderStateMixin_createTicker_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      if (t1.SingleTickerProviderStateMixin__ticker == null)
        return true;
      throw H.wrapException(U.FlutterError$(H.getRuntimeType(t1).toString$0(0) + " is a SingleTickerProviderStateMixin but multiple tickers were created.\nA SingleTickerProviderStateMixin can only be used as a TickerProvider once. If a State is used for multiple AnimationController objects, or if it is passed to other objects and those objects might use it more than one time in total, then instead of mixing in a SingleTickerProviderStateMixin, use a regular TickerProviderStateMixin."));
    },
    $signature: 0
  };
  U.TickerProviderStateMixin.prototype = {
    createTicker$1: function(onTick) {
      var t1, result, _this = this;
      H.functionTypeCheck(onTick, {func: 1, ret: -1, args: [P.Duration]});
      if (_this.TickerProviderStateMixin__tickers == null)
        _this.set$_tickers(P.LinkedHashSet_LinkedHashSet$_empty(U._WidgetTicker));
      t1 = "created by " + _this.toString$0(0);
      result = new U._WidgetTicker(_this, onTick, t1);
      result.Ticker$2$debugLabel(onTick, t1);
      _this.TickerProviderStateMixin__tickers.add$1(0, result);
      return result;
    },
    set$_tickers: function(_tickers) {
      this.TickerProviderStateMixin__tickers = H.assertSubtype(_tickers, "$isSet", [M.Ticker], "$asSet");
    }
  };
  U._WidgetTicker.prototype = {
    dispose$0: function() {
      var _this = this,
        t1 = _this._creator;
      H.assertHelper(t1.TickerProviderStateMixin__tickers != null);
      H.assertHelper(t1.TickerProviderStateMixin__tickers.contains$1(0, _this));
      t1.TickerProviderStateMixin__tickers.remove$1(0, _this);
      _this.super$Ticker$dispose();
    }
  };
  U.Title.prototype = {
    build$1: function(context) {
      X.SystemChrome_setApplicationSwitcherDescription(new X.ApplicationSwitcherDescription(this.title, this.color.value));
      return this.child;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.StringProperty$("title", this.title, "", true, true);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.DiagnosticsProperty$("color", this.color, _null, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, P.Color));
    }
  };
  K.AnimatedWidget.prototype = {
    createState$0: function() {
      return new K._AnimatedState(C._StateLifecycle_0);
    },
    debugFillProperties$1: function(properties) {
      var t1, _null = null;
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("animation", this.listenable, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, B.Listenable);
      C.JSArray_methods.add$1(properties.properties, t1);
    }
  };
  K._AnimatedState.prototype = {
    initState$0: function() {
      this.super$State$initState();
      this._widget.listenable.addListener$1(this.get$_handleChange());
    },
    didUpdateWidget$1: function(oldWidget) {
      var t1, t2, _this = this;
      H.interceptedTypeCheck(oldWidget, "$isAnimatedWidget");
      _this.super$State$didUpdateWidget(oldWidget);
      t1 = _this._widget.listenable;
      t2 = oldWidget.listenable;
      if (t1 != t2) {
        t1 = _this.get$_handleChange();
        t2.removeListener$1(t1);
        _this._widget.listenable.addListener$1(t1);
      }
    },
    dispose$0: function() {
      this._widget.listenable.removeListener$1(this.get$_handleChange());
      this.super$State$dispose();
    },
    _handleChange$0: function() {
      this.setState$1(new K._AnimatedState__handleChange_closure());
    },
    build$1: function(context) {
      return this._widget.build$1(context);
    },
    $asState: function() {
      return [K.AnimatedWidget];
    }
  };
  K._AnimatedState__handleChange_closure.prototype = {
    call$0: function() {
    },
    $signature: 2
  };
  K.SlideTransition.prototype = {
    build$1: function(context) {
      var t1, _this = this,
        offset = H.assertSubtype(_this.listenable, "$isAnimation", [P.Offset], "$asAnimation").get$value();
      if (_this.textDirection === C.TextDirection_0) {
        t1 = offset._dx;
        if (typeof t1 !== "number")
          return t1.$negate();
        offset = new P.Offset(-t1, offset._dy);
      }
      return new T.FractionalTranslation(offset, _this.transformHitTests, _this.child, null);
    },
    get$child: function() {
      return this.child;
    }
  };
  K.ScaleTransition.prototype = {
    build$1: function(context) {
      var scaleValue = H.assertSubtype(this.listenable, "$isAnimation", [P.double], "$asAnimation").get$value(),
        transform = new E.Matrix4(new Float64Array(16));
      transform.setIdentity$0();
      transform.scale$3(scaleValue, scaleValue, 1);
      return T.Transform$(C.Alignment_0_0, this.child, transform, true);
    },
    get$child: function() {
      return this.child;
    }
  };
  K.RotationTransition.prototype = {
    build$1: function(context) {
      var t1, t2, c, s,
        turnsValue = H.assertSubtype(this.listenable, "$isAnimation", [P.double], "$asAnimation").get$value();
      if (typeof turnsValue !== "number")
        return turnsValue.$mul();
      t1 = turnsValue * 3.141592653589793 * 2;
      t2 = new Float64Array(16);
      t2[15] = 1;
      c = Math.cos(t1);
      s = Math.sin(t1);
      t2[0] = c;
      t2[1] = s;
      t2[2] = 0;
      t2[4] = -s;
      t2[5] = c;
      t2[6] = 0;
      t2[8] = 0;
      t2[9] = 0;
      t2[10] = 1;
      t2[3] = 0;
      t2[7] = 0;
      t2[11] = 0;
      return T.Transform$(C.Alignment_0_0, this.child, new E.Matrix4(t2), true);
    },
    get$child: function() {
      return this.child;
    }
  };
  K.FadeTransition.prototype = {
    createRenderObject$1: function(context) {
      var t2,
        t1 = new E.RenderAnimatedOpacity(false, null);
      t1.get$isRepaintBoundary();
      t2 = t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = t2;
      t1.set$child(null);
      t1.set$opacity(this.opacity);
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      H.interceptedTypeCheck(renderObject, "$isRenderAnimatedOpacity");
      renderObject.set$opacity(this.opacity);
      renderObject.set$alwaysIncludeSemantics(false);
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, _null = null,
        _s22_ = "alwaysIncludeSemantics";
      this.super$Widget$debugFillProperties(properties);
      t1 = Y.DiagnosticsProperty$("opacity", this.opacity, C.C__NoDefaultValue, _null, _null, _null, C.DiagnosticLevel_3, false, true, true, C.DiagnosticsTreeStyle_5, _null, [X.Animation, P.double]);
      t2 = properties.properties;
      C.JSArray_methods.add$1(t2, t1);
      C.JSArray_methods.add$1(t2, Y.FlagProperty$(_s22_, _null, _null, _s22_, C.DiagnosticLevel_3, false, false));
    }
  };
  K.DecoratedBoxTransition.prototype = {
    build$1: function(context) {
      var t1 = this.decoration;
      return M.DecoratedBox$(this.child, t1._evaluatable.transform$1(H.assertSubtype(t1.parent, "$isAnimation", [P.double], "$asAnimation").get$value()), C.DecorationPosition_0);
    },
    get$child: function() {
      return this.child;
    }
  };
  K.AnimatedBuilder.prototype = {
    build$1: function(context) {
      return this.builder.call$2(context, this.child);
    },
    builder$2: function(arg0, arg1) {
      return this.builder.call$2(arg0, arg1);
    },
    get$child: function() {
      return this.child;
    }
  };
  N._ProxyLayer.prototype = {
    addToScene$2: function(builder, layerOffset) {
      return this._widget_inspector$_layer.addToScene$2(builder, layerOffset);
    },
    addToScene$1: function(builder) {
      return this.addToScene$2(builder, C.Offset_0_0);
    },
    find$1$1: function(regionOffset, $S) {
      return this._widget_inspector$_layer.find$1$1(regionOffset, $S);
    }
  };
  N._MulticastCanvas.prototype = {
    clipPath$2$doAntiAlias: function(path, doAntiAlias) {
      this._main.clipPath$2$doAntiAlias(path, doAntiAlias);
    },
    clipPath$1: function(path) {
      return this.clipPath$2$doAntiAlias(path, true);
    },
    clipRRect$2$doAntiAlias: function(rrect, doAntiAlias) {
      this._main.clipRRect$2$doAntiAlias(rrect, true);
    },
    clipRRect$1: function(rrect) {
      return this.clipRRect$2$doAntiAlias(rrect, true);
    },
    clipRect$3$clipOp$doAntiAlias: function(rect, clipOp, doAntiAlias) {
      this._main.clipRect$3$clipOp$doAntiAlias(rect, clipOp, doAntiAlias);
    },
    clipRect$2$doAntiAlias: function(rect, doAntiAlias) {
      return this.clipRect$3$clipOp$doAntiAlias(rect, C.ClipOp_1, doAntiAlias);
    },
    clipRect$1: function(rect) {
      return this.clipRect$3$clipOp$doAntiAlias(rect, C.ClipOp_1, true);
    },
    drawCircle$3: function(c, radius, paint) {
      this._main.drawCircle$3(c, radius, paint);
    },
    drawDRRect$3: function(outer, inner, paint) {
      this._main.drawDRRect$3(outer, inner, paint);
    },
    drawParagraph$2: function(paragraph, offset) {
      this._main.drawParagraph$2(paragraph, offset);
    },
    drawPath$2: function(path, paint) {
      this._main.drawPath$2(path, paint);
    },
    drawRRect$2: function(rrect, paint) {
      this._main.drawRRect$2(rrect, paint);
    },
    drawRect$2: function(rect, paint) {
      this._main.drawRect$2(rect, paint);
    },
    getSaveCount$0: function() {
      return this._main.getSaveCount$0();
    },
    restore$0: function() {
      this._main.restore$0();
    },
    rotate$1: function(radians) {
      this._main.rotate$1(radians);
    },
    save$0: function() {
      this._main.save$0();
    },
    saveLayer$2: function(bounds, paint) {
      this._main.saveLayer$2(bounds, paint);
    },
    transform$1: function(matrix4) {
      this._main.transform$1(matrix4);
    },
    translate$2: function(dx, dy) {
      this._main.translate$2(dx, dy);
    },
    $isCanvas: 1
  };
  N._calculateSubtreeBoundsHelper_closure.prototype = {
    call$1: function(child) {
      var t2, childBounds, paintClip, t3, bounds,
        t1 = this.transform,
        childTransform = new E.Matrix4(new Float64Array(16));
      childTransform.setFrom$1(t1);
      t2 = this.object;
      t2.applyPaintTransform$2(child, childTransform);
      childBounds = N._calculateSubtreeBoundsHelper(child, childTransform);
      paintClip = t2.describeApproximatePaintClip$1(child);
      if (paintClip != null)
        childBounds = childBounds.intersect$1(T.MatrixUtils_transformRect(t1, paintClip));
      t1 = childBounds.left;
      t1.toString;
      if (isFinite(t1)) {
        t2 = childBounds.top;
        t2.toString;
        if (isFinite(t2)) {
          t2 = childBounds.right;
          t2.toString;
          if (isFinite(t2)) {
            t2 = childBounds.bottom;
            t2.toString;
            t2 = isFinite(t2);
          } else
            t2 = false;
        } else
          t2 = false;
      } else
        t2 = false;
      if (t2 && !childBounds.get$isEmpty(childBounds)) {
        t2 = this._box_0;
        t3 = t2.bounds;
        if (t3.get$isEmpty(t3))
          bounds = childBounds;
        else {
          t3 = t2.bounds;
          bounds = P.Rect$fromLTRB(Math.min(H.checkNum(t3.left), H.checkNum(t1)), Math.min(H.checkNum(t3.top), H.checkNum(childBounds.top)), Math.max(H.checkNum(t3.right), H.checkNum(childBounds.right)), Math.max(H.checkNum(t3.bottom), H.checkNum(childBounds.bottom)));
        }
        t2.bounds = bounds;
      }
    },
    $signature: 10
  };
  N._ScreenshotContainerLayer.prototype = {
    addToScene$2: function(builder, layerOffset) {
      this.addChildrenToScene$2(builder, layerOffset);
      return;
    },
    addToScene$1: function(builder) {
      return this.addToScene$2(builder, C.Offset_0_0);
    }
  };
  N._ScreenshotData.prototype = {
    get$target: function(receiver) {
      return this.target;
    }
  };
  N._ScreenshotPaintingContext.prototype = {
    get$canvas: function() {
      var t2, _this = this,
        t1 = _this._widget_inspector$_data;
      if (t1.includeInScreenshot) {
        if (_this._screenshotCanvas == null) {
          H.assertHelper(!_this.get$_isScreenshotRecording());
          t2 = new T.PictureLayer(_this.estimatedBounds);
          _this._screenshotCurrentLayer = t2;
          _this._screenshotRecorder = new P.PictureRecorder();
          _this._screenshotCanvas = new P.Canvas();
          t1.containerLayer.append$1(t2);
          if (t1.includeInRegularContext)
            _this._multicastCanvas = new N._MulticastCanvas(K.PaintingContext.prototype.get$canvas.call(_this), _this._screenshotCanvas);
          else
            _this._multicastCanvas = null;
        }
        H.assertHelper(_this._screenshotCanvas != null);
        return t1.includeInRegularContext ? _this._multicastCanvas : _this._screenshotCanvas;
      } else {
        H.assertHelper(t1.includeInRegularContext);
        return K.PaintingContext.prototype.get$canvas.call(_this);
      }
    },
    get$_isScreenshotRecording: function() {
      var hasScreenshotCanvas = this._screenshotCanvas != null;
      H.assertHelper(new N._ScreenshotPaintingContext__isScreenshotRecording_closure(this, hasScreenshotCanvas).call$0());
      return hasScreenshotCanvas;
    },
    stopRecordingIfNeeded$0: function() {
      this.super$PaintingContext$stopRecordingIfNeeded();
      this._stopRecordingScreenshotIfNeeded$0();
    },
    _stopRecordingScreenshotIfNeeded$0: function() {
      if (!this.get$_isScreenshotRecording())
        return;
      var t1 = this._screenshotCurrentLayer;
      this._screenshotRecorder.endRecording$0();
      t1.toString;
    },
    appendLayer$1: function(layer) {
      var _this = this,
        t1 = _this._widget_inspector$_data;
      if (t1.includeInRegularContext) {
        _this.super$PaintingContext$appendLayer(layer);
        if (t1.includeInScreenshot) {
          H.assertHelper(!_this.get$_isScreenshotRecording());
          t1.containerLayer.append$1(new N._ProxyLayer(layer));
        }
      } else {
        H.assertHelper(!_this.get$_isScreenshotRecording());
        H.assertHelper(t1.includeInScreenshot);
        layer.remove$0(0);
        t1.containerLayer.append$1(layer);
        return;
      }
    },
    createChildContext$2: function(childLayer, bounds) {
      var t1 = this._widget_inspector$_data;
      if (t1.foundTarget)
        return this.super$PaintingContext$createChildContext(childLayer, bounds);
      else
        return new N._ScreenshotPaintingContext(t1, childLayer, bounds);
    },
    paintChild$2: function(child, offset) {
      var t1 = this._widget_inspector$_data,
        isScreenshotTarget = child === t1.target;
      if (isScreenshotTarget) {
        H.assertHelper(!t1.includeInScreenshot);
        H.assertHelper(!t1.foundTarget);
        t1.foundTarget = true;
        t1.containerLayer.set$offset(offset);
        t1.includeInScreenshot = true;
      }
      this.super$PaintingContext$paintChild(child, offset);
      if (isScreenshotTarget) {
        this._stopRecordingScreenshotIfNeeded$0();
        t1.includeInScreenshot = false;
      }
    }
  };
  N._ScreenshotPaintingContext__isScreenshotRecording_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._screenshotCurrentLayer;
      if (this.hasScreenshotCanvas) {
        H.assertHelper(t2 != null);
        H.assertHelper(t1._screenshotRecorder != null);
        H.assertHelper(t1._screenshotCanvas != null);
      } else {
        H.assertHelper(t2 == null);
        H.assertHelper(t1._screenshotRecorder == null);
        H.assertHelper(t1._screenshotCanvas == null);
      }
      return true;
    },
    $signature: 0
  };
  N._DiagnosticsPathNode.prototype = {};
  N._InspectorReferenceData.prototype = {};
  N._SerializeConfig.prototype = {};
  N._WidgetInspectorService.prototype = {
    set$selectionChangedCallback: function(selectionChangedCallback) {
      this.WidgetInspectorService_selectionChangedCallback = H.functionTypeCheck(selectionChangedCallback, {func: 1, ret: -1});
    },
    set$_pubRootDirectories: function(_pubRootDirectories) {
      this.WidgetInspectorService__pubRootDirectories = H.assertSubtype(_pubRootDirectories, "$isList", [P.String], "$asList");
    },
    set$_registerServiceExtensionCallback: function(_registerServiceExtensionCallback) {
      this.WidgetInspectorService__registerServiceExtensionCallback = H.functionTypeCheck(_registerServiceExtensionCallback, {func: 1, ret: -1, named: {callback: {func: 1, ret: [P.Future, [P.Map, P.String,,]], args: [[P.Map, P.String, P.String]]}, name: P.String}});
    }
  };
  N.WidgetInspectorService.prototype = {
    registerServiceExtension$2$callback$name: function(callback, $name) {
      var t1;
      H.functionTypeCheck(callback, {func: 1, ret: [P.Future, [P.Map, P.String,,]], args: [[P.Map, P.String, P.String]]});
      t1 = "inspector." + $name;
      this.WidgetInspectorService__registerServiceExtensionCallback.call$2$callback$name(callback, t1);
    },
    _registerSignalServiceExtension$2$callback$name: function(callback, $name) {
      this.registerServiceExtension$2$callback$name(new N.WidgetInspectorService__registerSignalServiceExtension_closure(H.functionTypeCheck(callback, {func: 1, ret: {futureOr: 1, type: P.Object}})), $name);
    },
    _registerObjectGroupServiceExtension$2$callback$name: function(callback, $name) {
      this.registerServiceExtension$2$callback$name(new N.WidgetInspectorService__registerObjectGroupServiceExtension_closure(H.functionTypeCheck(callback, {func: 1, ret: {futureOr: 1, type: P.Object}, args: [P.String]})), $name);
    },
    _registerBoolServiceExtension$3$getter$name$setter: function(getter, $name, setter) {
      H.functionTypeCheck(getter, {func: 1, ret: [P.Future, P.bool]});
      this.registerServiceExtension$2$callback$name(new N.WidgetInspectorService__registerBoolServiceExtension_closure(this, H.functionTypeCheck(setter, {func: 1, ret: [P.Future, -1], args: [P.bool]}), $name, getter), $name);
    },
    _registerServiceExtensionWithArg$2$callback$name: function(callback, $name) {
      this.registerServiceExtension$2$callback$name(new N.WidgetInspectorService__registerServiceExtensionWithArg_closure(H.functionTypeCheck(callback, {func: 1, ret: {futureOr: 1, type: P.Object}, args: [P.String, P.String]})), $name);
    },
    _registerServiceExtensionVarArgs$2$callback$name: function(callback, $name) {
      this.registerServiceExtension$2$callback$name(new N.WidgetInspectorService__registerServiceExtensionVarArgs_closure(H.functionTypeCheck(callback, {func: 1, ret: {futureOr: 1, type: P.Object}, args: [[P.List, P.String]]})), $name);
    },
    forceRebuild$0: function() {
      var binding = $.WidgetsBinding__instance,
        t1 = binding.WidgetsBinding__renderViewElement;
      if (t1 != null) {
        binding.WidgetsBinding__buildOwner.reassemble$1(t1);
        return binding.get$endOfFrame();
      }
      t1 = new P._Future($.Zone__current, [-1]);
      t1._asyncComplete$1(null);
      return t1;
    },
    initServiceExtensions$1: function(registerServiceExtensionCallback) {
      var t1, t2, _this = this;
      _this.set$_registerServiceExtensionCallback(H.functionTypeCheck(registerServiceExtensionCallback, {func: 1, ret: -1, named: {callback: {func: 1, ret: [P.Future, [P.Map, P.String,,]], args: [[P.Map, P.String, P.String]]}, name: P.String}}));
      H.assertHelper(!$.WidgetInspectorService__debugServiceExtensionsRegistered);
      H.assertHelper(new N.WidgetInspectorService_initServiceExtensions_closure().call$0());
      t1 = $.SchedulerBinding__instance;
      t1.toString;
      t2 = H.functionTypeCheck(_this.get$_onFrameStart(), {func: 1, ret: -1, args: [P.Duration]});
      C.JSArray_methods.add$1(t1.SchedulerBinding__persistentCallbacks, t2);
      _this._registerBoolServiceExtension$3$getter$name$setter(new N.WidgetInspectorService_initServiceExtensions_closure0(), "show", new N.WidgetInspectorService_initServiceExtensions_closure1(_this));
      if (H.boolConversionCheck(_this.isWidgetCreationTracked$0())) {
        _this._registerBoolServiceExtension$3$getter$name$setter(new N.WidgetInspectorService_initServiceExtensions_closure2(_this), "trackRebuildDirtyWidgets", new N.WidgetInspectorService_initServiceExtensions_closure3(_this));
        _this._registerBoolServiceExtension$3$getter$name$setter(new N.WidgetInspectorService_initServiceExtensions_closure4(_this), "trackRepaintWidgets", new N.WidgetInspectorService_initServiceExtensions_closure5(_this));
      }
      _this._registerSignalServiceExtension$2$callback$name(_this.get$disposeAllGroups(), "disposeAllGroups");
      _this._registerObjectGroupServiceExtension$2$callback$name(_this.get$disposeGroup(), "disposeGroup");
      _this._registerSignalServiceExtension$2$callback$name(_this.get$isWidgetTreeReady(), "isWidgetTreeReady");
      _this._registerServiceExtensionWithArg$2$callback$name(_this.get$disposeId(), "disposeId");
      _this._registerServiceExtensionVarArgs$2$callback$name(_this.get$setPubRootDirectories(), "setPubRootDirectories");
      _this._registerServiceExtensionWithArg$2$callback$name(_this.get$setSelectionById(), "setSelectionById");
      _this._registerServiceExtensionWithArg$2$callback$name(_this.get$_getParentChain(), "getParentChain");
      _this._registerServiceExtensionWithArg$2$callback$name(_this.get$_getProperties(), "getProperties");
      _this._registerServiceExtensionWithArg$2$callback$name(_this.get$_getChildren(), "getChildren");
      _this._registerServiceExtensionWithArg$2$callback$name(_this.get$_getChildrenSummaryTree(), "getChildrenSummaryTree");
      _this._registerServiceExtensionWithArg$2$callback$name(_this.get$_getChildrenDetailsSubtree(), "getChildrenDetailsSubtree");
      _this._registerObjectGroupServiceExtension$2$callback$name(_this.get$_getRootWidget(), "getRootWidget");
      _this._registerObjectGroupServiceExtension$2$callback$name(_this.get$_getRootRenderObject(), "getRootRenderObject");
      _this._registerObjectGroupServiceExtension$2$callback$name(_this.get$_getRootWidgetSummaryTree(), "getRootWidgetSummaryTree");
      _this._registerServiceExtensionWithArg$2$callback$name(_this.get$_getDetailsSubtree(), "getDetailsSubtree");
      _this._registerServiceExtensionWithArg$2$callback$name(_this.get$_getSelectedRenderObject(), "getSelectedRenderObject");
      _this._registerServiceExtensionWithArg$2$callback$name(_this.get$_getSelectedWidget(), "getSelectedWidget");
      _this._registerServiceExtensionWithArg$2$callback$name(_this.get$_getSelectedSummaryWidget(), "getSelectedSummaryWidget");
      _this._registerSignalServiceExtension$2$callback$name(_this.get$isWidgetCreationTracked(), "isWidgetCreationTracked");
      _this.registerServiceExtension$2$callback$name(new N.WidgetInspectorService_initServiceExtensions_closure6(_this), "screenshot");
    },
    disposeAllGroups$0: function() {
      var _this = this;
      _this.WidgetInspectorService__groups.clear$0(0);
      _this.WidgetInspectorService__idToReferenceData.clear$0(0);
      _this.WidgetInspectorService__objectToId.clear$0(0);
      _this.WidgetInspectorService__nextId = 0;
    },
    disposeGroup$1: function($name) {
      var references = this.WidgetInspectorService__groups.remove$1(0, $name);
      if (references == null)
        return;
      references.forEach$1(0, this.get$_decrementReferenceCount());
    },
    _decrementReferenceCount$1: function(reference) {
      var id;
      H.interceptedTypeCheck(reference, "$is_InspectorReferenceData");
      H.assertHelper(--reference.count >= 0);
      if (reference.count === 0) {
        id = this.WidgetInspectorService__objectToId.remove$1(0, reference.object);
        H.assertHelper(id != null);
        this.WidgetInspectorService__idToReferenceData.remove$1(0, id);
      }
    },
    toId$2: function(object, groupName) {
      var group, t1, id, t2, referenceData, _this = this;
      if (object == null)
        return;
      group = _this.WidgetInspectorService__groups.putIfAbsent$2(groupName, new N.WidgetInspectorService_toId_closure());
      t1 = _this.WidgetInspectorService__objectToId;
      id = t1.$index(0, object);
      t2 = _this.WidgetInspectorService__idToReferenceData;
      if (id == null) {
        id = "inspector-" + _this.WidgetInspectorService__nextId;
        ++_this.WidgetInspectorService__nextId;
        t1.$indexSet(0, object, id);
        referenceData = new N._InspectorReferenceData(object);
        t2.$indexSet(0, id, referenceData);
        group.add$1(0, referenceData);
      } else {
        referenceData = t2.$index(0, id);
        if (group.add$1(0, referenceData))
          ++referenceData.count;
      }
      return id;
    },
    isWidgetTreeReady$1: function(groupName) {
      var t1 = $.WidgetsBinding__instance;
      return t1 != null && !t1.WidgetsBinding__needToReportFirstFrame;
    },
    isWidgetTreeReady$0: function() {
      return this.isWidgetTreeReady$1(null);
    },
    toObject$1: function(id) {
      var data;
      if (id == null)
        return;
      data = this.WidgetInspectorService__idToReferenceData.$index(0, id);
      if (data == null)
        throw H.wrapException(U.FlutterError$("Id does not exist."));
      return data.object;
    },
    disposeId$2: function(id, groupName) {
      var referenceData, t1;
      if (id == null)
        return;
      referenceData = this.WidgetInspectorService__idToReferenceData.$index(0, id);
      if (referenceData == null)
        throw H.wrapException(U.FlutterError$("Id does not exist"));
      t1 = this.WidgetInspectorService__groups.$index(0, groupName);
      if (!J.$eq$(t1 == null ? null : J.remove$1$ax(t1, referenceData), true))
        throw H.wrapException(U.FlutterError$("Id is not in group"));
      this._decrementReferenceCount$1(referenceData);
    },
    setPubRootDirectories$1: function(pubRootDirectories) {
      var t1, t2;
      H.assertSubtype(pubRootDirectories, "$isList", [P.Object], "$asList");
      t1 = P.String;
      t2 = H.getTypeArgumentByIndex(pubRootDirectories, 0);
      this.set$_pubRootDirectories(new H.MappedListIterable(pubRootDirectories, H.functionTypeCheck(new N.WidgetInspectorService_setPubRootDirectories_closure(), {func: 1, ret: t1, args: [t2]}), [t2, t1]).toList$0(0));
    },
    setSelectionById$2: function(id, groupName) {
      return this.setSelection$2(this.toObject$1(id), groupName);
    },
    setSelectionById$1: function(id) {
      return this.setSelectionById$2(id, null);
    },
    setSelection$2: function(object, groupName) {
      var t3, t4, t5, entry, t6, newCapacity, newQueue,
        t1 = J.getInterceptor$(object),
        t2 = !!t1.$isElement;
      if (t2 || !!t1.$isRenderObject) {
        if (t2) {
          t1 = this.WidgetInspectorService_selection;
          if (object.$eq(0, t1._currentElement))
            return false;
          if (!J.$eq$(t1._currentElement, object)) {
            t1._currentElement = object;
            t1._widget_inspector$_current = object.get$renderObject();
          }
        } else {
          t2 = this.WidgetInspectorService_selection;
          if (t1.$eq(object, t2._widget_inspector$_current))
            return false;
          H.interceptedTypeCheck(object, "$isRenderObject");
          if (t2._widget_inspector$_current != object) {
            t2._widget_inspector$_current = object;
            t2._currentElement = object.debugCreator.element;
          }
        }
        t1 = this.WidgetInspectorService_selectionChangedCallback;
        if (t1 != null) {
          t2 = $.SchedulerBinding__instance;
          if (t2.SchedulerBinding__schedulerPhase === C.SchedulerPhase_0)
            t1.call$0();
          else {
            t3 = -1;
            t2.toString;
            H.functionTypeCheck(t1, {func: 1, ret: t3});
            t4 = t2.SchedulerBinding__taskQueue;
            t5 = t4._length;
            entry = N._TaskEntry$(t1, 200000, null, null, t3);
            t3 = H.getTypeArgumentByIndex(t4, 0);
            H.assertSubtypeOfRuntimeType(entry, t3);
            t1 = t4._length;
            t6 = t4._priority_queue$_queue.length;
            if (t1 === t6) {
              newCapacity = t6 * 2 + 1;
              if (newCapacity < 7)
                newCapacity = 7;
              t1 = new Array(newCapacity);
              t1.fixed$length = Array;
              newQueue = H.setRuntimeTypeInfo(t1, [t3]);
              C.JSArray_methods.setRange$3(newQueue, 0, t4._length, t4._priority_queue$_queue);
              t4.set$_priority_queue$_queue(newQueue);
            }
            t4._bubbleUp$2(entry, t4._length++);
            if (t5 === 0 && t2._lockCount <= 0)
              t2._ensureEventLoopCallback$0();
            entry.completer.future;
          }
        }
        return true;
      }
      return false;
    },
    _getParentChain$2: function(id, groupName) {
      var path, t2, _this = this,
        value = _this.toObject$1(id),
        t1 = J.getInterceptor$(value);
      if (!!t1.$isRenderObject)
        path = _this._getRenderObjectParentChain$2(value, groupName);
      else if (!!t1.$isElement)
        path = N._followDiagnosticableChain(_this._getRawElementParentChain$2$numLocalParents(value, null));
      else
        throw H.wrapException(U.FlutterError$("Cannot get parent chain for node of type " + t1.get$runtimeType(value).toString$0(0)));
      t1 = P.Object;
      t2 = H.getTypeArgumentByIndex(path, 0);
      return new H.MappedListIterable(path, H.functionTypeCheck(new N.WidgetInspectorService__getParentChain_closure(_this, groupName), {func: 1, ret: t1, args: [t2]}), [t2, t1]).toList$0(0);
    },
    _pathNodeToJson$2: function(pathNode, config) {
      if (pathNode == null)
        return;
      return P.LinkedHashMap_LinkedHashMap$_literal(["node", this._nodeToJson$2(pathNode.node, config), "children", this._nodesToJson$2(pathNode.children, config), "childIndex", pathNode.childIndex], P.String, P.Object);
    },
    _getRawElementParentChain$2$numLocalParents: function(element, numLocalParents) {
      var elements = element.debugGetDiagnosticChain$0(),
        t1 = new H.ReversedListIterable(elements, [H.getTypeArgumentByIndex(elements, 0)]);
      return t1.toList$0(0);
    },
    _getRenderObjectParentChain$2: function(renderObject, groupName) {
      var chain = H.setRuntimeTypeInfo([], [K.RenderObject]);
      for (; renderObject != null;) {
        C.JSArray_methods.add$1(chain, renderObject);
        renderObject = H.interceptedTypeCheck(renderObject._node$_parent, "$isRenderObject");
      }
      return N._followDiagnosticableChain(new H.ReversedListIterable(chain, [H.getTypeArgumentByIndex(chain, 0)]).toList$0(0));
    },
    _nodeToJson$2: function(node, config) {
      var json, value, t2, t3, t4, t5, _this = this,
        _s10_ = "properties",
        _s15_ = "valueProperties",
        t1 = {};
      if (node == null)
        return;
      json = node.toJsonMap$0();
      value = node.get$value();
      t2 = config.groupName;
      if (t2 != null) {
        json.$indexSet(0, "objectId", _this.toId$2(node, t2));
        json.$indexSet(0, "valueId", _this.toId$2(value, t2));
      }
      t3 = J.getInterceptor$(value);
      if (!!t3.$isElement) {
        if (!!value.$isStatefulElement)
          json.$indexSet(0, "stateful", true);
        t4 = H.getRti(value.get$widget());
        json.$indexSet(0, "widgetRuntimeType", new H.TypeImpl(t4).toString$0(0));
      }
      if (config.summaryTree)
        json.$indexSet(0, "summaryTree", true);
      N._getCreationLocation(value);
      t1.createdByLocalProject = false;
      if (config.subtreeDepth <= 0)
        t4 = false;
      else
        t4 = true;
      if (t4) {
        t4 = _this._getChildrenFiltered$2(node, config);
        t4 = H.setRuntimeTypeInfo(t4.slice(0), [H.getTypeArgumentByIndex(t4, 0)]);
        json.$indexSet(0, "children", _this._nodesToJson$2(t4, config));
      }
      if (config.includeProperties) {
        t4 = node.getProperties$0();
        t5 = H.getTypeArgumentByIndex(t4, 0);
        json.$indexSet(0, _s10_, _this._nodesToJson$2(new H.WhereIterable(t4, H.functionTypeCheck(new N.WidgetInspectorService__nodeToJson_closure(t1), {func: 1, ret: P.bool, args: [t5]}), [t5]), N._SerializeConfig$(true, t2, false, 1, false)));
      }
      if (!!node.$isDiagnosticsProperty) {
        if (!!t3.$isColor) {
          t1 = value.value;
          json.$indexSet(0, _s15_, P.LinkedHashMap_LinkedHashMap$_literal(["red", (16711680 & t1) >>> 16, "green", (65280 & t1) >>> 8, "blue", (255 & t1) >>> 0, "alpha", (4278190080 & t1) >>> 24], P.String, P.Object));
        } else if (!!t3.$isIconData)
          json.$indexSet(0, _s15_, P.LinkedHashMap_LinkedHashMap$_literal(["codePoint", value.codePoint], P.String, P.Object));
        if (config.expandPropertyValues && !!t3.$isDiagnosticable) {
          t1 = value.toDiagnosticsNode$0().get$_builder().properties;
          t3 = H.getTypeArgumentByIndex(t1, 0);
          json.$indexSet(0, _s10_, _this._nodesToJson$2(new H.WhereIterable(t1, H.functionTypeCheck(new N.WidgetInspectorService__nodeToJson_closure0(), {func: 1, ret: P.bool, args: [t3]}), [t3]), N._SerializeConfig$(false, t2, false, 0, false)));
        }
      }
      return json;
    },
    _isValueCreatedByLocalProject$1: function(value) {
      N._getCreationLocation(value);
      return false;
    },
    _nodesToJson$2: function(nodes, config) {
      H.assertSubtype(nodes, "$isIterable", [Y.DiagnosticsNode], "$asIterable");
      return J.map$1$1$ax(nodes, new N.WidgetInspectorService__nodesToJson_closure(this, config), [P.Map, P.String, P.Object]).toList$0(0);
    },
    _getProperties$2: function(diagnosticsNodeId, groupName) {
      var node = H.interceptedTypeCheck(this.toObject$1(diagnosticsNodeId), "$isDiagnosticsNode"),
        t1 = node == null ? C.List_empty : node.getProperties$0();
      return this._nodesToJson$2(t1, N._SerializeConfig$(true, groupName, false, 1, false));
    },
    _getChildren$2: function(diagnosticsNodeId, groupName) {
      var t1,
        node = H.interceptedTypeCheck(this.toObject$1(diagnosticsNodeId), "$isDiagnosticsNode"),
        config = N._SerializeConfig$(true, groupName, false, 1, false);
      if (node == null)
        t1 = C.List_empty;
      else {
        t1 = this._getChildrenFiltered$2(node, config);
        t1 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
      }
      return this._nodesToJson$2(t1, config);
    },
    _getChildrenSummaryTree$2: function(diagnosticsNodeId, groupName) {
      var t1,
        node = H.interceptedTypeCheck(this.toObject$1(diagnosticsNodeId), "$isDiagnosticsNode"),
        config = N._SerializeConfig$(true, groupName, false, 1, true);
      if (node == null)
        t1 = C.List_empty;
      else {
        t1 = this._getChildrenFiltered$2(node, config);
        t1 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
      }
      return this._nodesToJson$2(t1, config);
    },
    _getChildrenDetailsSubtree$2: function(diagnosticsNodeId, groupName) {
      var t1,
        node = H.interceptedTypeCheck(this.toObject$1(diagnosticsNodeId), "$isDiagnosticsNode"),
        config = N._SerializeConfig$(true, groupName, true, 1, false);
      if (node == null)
        t1 = C.List_empty;
      else {
        t1 = this._getChildrenFiltered$2(node, config);
        t1 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
      }
      return this._nodesToJson$2(t1, config);
    },
    _shouldShowInSummaryTree$1: function(node) {
      var value = node.get$value();
      if (!J.getInterceptor$(value).$isDiagnosticable)
        return true;
      if (!value.$isElement || !H.boolConversionCheck(this.isWidgetCreationTracked$0()))
        return true;
      return this._isValueCreatedByLocalProject$1(value);
    },
    _getChildrenFiltered$2: function(node, config) {
      var t1, t2, t3, _i, child,
        children = H.setRuntimeTypeInfo([], [Y.DiagnosticsNode]);
      for (t1 = node.getChildren$0(), t2 = t1.length, t3 = config.summaryTree, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        child = t1[_i];
        if (!t3 || this._shouldShowInSummaryTree$1(child))
          C.JSArray_methods.add$1(children, child);
        else
          C.JSArray_methods.addAll$1(children, this._getChildrenFiltered$2(child, config));
      }
      return children;
    },
    _getRootWidget$1: function(groupName) {
      var _null = null,
        t1 = $.WidgetsBinding__instance;
      t1 = t1 == null ? _null : t1.WidgetsBinding__renderViewElement;
      t1 = t1 == null ? _null : new Y._DiagnosticableTreeNode(t1, _null, true, true, _null);
      return this._nodeToJson$2(t1, N._SerializeConfig$(true, groupName, false, 1, false));
    },
    _getRootWidgetSummaryTree$1: function(groupName) {
      var _null = null,
        t1 = $.WidgetsBinding__instance;
      t1 = t1 == null ? _null : t1.WidgetsBinding__renderViewElement;
      t1 = t1 == null ? _null : new Y._DiagnosticableTreeNode(t1, _null, true, true, _null);
      return this._nodeToJson$2(t1, N._SerializeConfig$(true, groupName, false, 1000000, true));
    },
    _getRootRenderObject$1: function(groupName) {
      var _null = null,
        t1 = $.RendererBinding__instance;
      t1 = t1 == null ? _null : t1.RendererBinding__pipelineOwner._rootNode;
      t1 = t1 == null ? _null : new Y._DiagnosticableTreeNode(t1, _null, true, true, _null);
      return this._nodeToJson$2(t1, N._SerializeConfig$(true, groupName, false, 1, false));
    },
    _getDetailsSubtree$2: function(id, groupName) {
      var root = H.interceptedTypeCheck(this.toObject$1(id), "$isDiagnosticsNode");
      if (root == null)
        return;
      return this._nodeToJson$2(root, N._SerializeConfig$(true, groupName, true, 2, false));
    },
    _getSelectedRenderObject$2: function(previousSelectionId, groupName) {
      var t1, _null = null,
        previousSelection = H.interceptedTypeCheck(this.toObject$1(previousSelectionId), "$isDiagnosticsNode"),
        current = this.WidgetInspectorService_selection._widget_inspector$_current;
      if (current == null ? (previousSelection == null ? _null : previousSelection.get$value()) == null : current === (previousSelection == null ? _null : previousSelection.get$value()))
        t1 = previousSelection;
      else
        t1 = current == null ? _null : new Y._DiagnosticableTreeNode(current, _null, true, true, _null);
      return this._nodeToJson$2(t1, N._SerializeConfig$(true, groupName, false, 1, false));
    },
    screenshot$6$debugPaint$height$margin$maxPixelRatio$width: function(object, debugPaint, height, margin, maxPixelRatio, width) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Image),
        $async$returnValue, renderObject, owner, renderBounds, t3, t4, t1, t2;
      var $async$screenshot$6$debugPaint$height$margin$maxPixelRatio$width = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = J.getInterceptor$(object);
              t2 = !!t1.$isElement;
              if (!t2 && !t1.$isRenderObject) {
                // goto return
                $async$goto = 1;
                break;
              }
              renderObject = H.interceptedTypeCheck(t2 ? object.get$renderObject() : object, "$isRenderObject");
              if (renderObject == null || renderObject._node$_owner == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              if (H.boolConversionCheck(renderObject.get$debugNeedsLayout())) {
                owner = H.interceptedTypeCheck(B.AbstractNode.prototype.get$owner.call(renderObject), "$isPipelineOwner");
                H.assertHelper(owner != null);
                H.assertHelper(!owner._debugDoingLayout);
                owner.flushLayout$0();
                owner.flushCompositingBits$0();
                owner.flushPaint$0();
                if (H.boolConversionCheck(renderObject.get$debugNeedsLayout())) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
              }
              t1 = new E.Matrix4(new Float64Array(16));
              t1.setIdentity$0();
              renderBounds = N._calculateSubtreeBoundsHelper(renderObject, t1);
              if (margin !== 0)
                renderBounds = renderBounds.inflate$1(margin);
              if (renderBounds.get$isEmpty(renderBounds)) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = renderBounds.right;
              t2 = renderBounds.left;
              if (typeof t1 !== "number") {
                $async$returnValue = t1.$sub();
                // goto return
                $async$goto = 1;
                break;
              }
              if (typeof t2 !== "number") {
                $async$returnValue = H.iae(t2);
                // goto return
                $async$goto = 1;
                break;
              }
              if (typeof width !== "number") {
                $async$returnValue = width.$div();
                // goto return
                $async$goto = 1;
                break;
              }
              t3 = renderBounds.bottom;
              t4 = renderBounds.top;
              if (typeof t3 !== "number") {
                $async$returnValue = t3.$sub();
                // goto return
                $async$goto = 1;
                break;
              }
              if (typeof t4 !== "number") {
                $async$returnValue = H.iae(t4);
                // goto return
                $async$goto = 1;
                break;
              }
              if (typeof height !== "number") {
                $async$returnValue = height.$div();
                // goto return
                $async$goto = 1;
                break;
              }
              t4 = Math.min(width / (t1 - t2), height / (t3 - t4));
              $async$returnValue = N._ScreenshotPaintingContext_toImage(renderObject, renderBounds, debugPaint, Math.min(H.checkNum(maxPixelRatio), t4));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$screenshot$6$debugPaint$height$margin$maxPixelRatio$width, $async$completer);
    },
    _getSelectedWidget$2: function(previousSelectionId, groupName) {
      var t1, _null = null,
        previousSelection = H.interceptedTypeCheck(this.toObject$1(previousSelectionId), "$isDiagnosticsNode"),
        current = this.WidgetInspectorService_selection._currentElement;
      if (J.$eq$(current, previousSelection == null ? _null : previousSelection.get$value()))
        t1 = previousSelection;
      else
        t1 = current == null ? _null : new Y._DiagnosticableTreeNode(current, _null, true, true, _null);
      return this._nodeToJson$2(t1, N._SerializeConfig$(true, groupName, false, 1, false));
    },
    _getSelectedSummaryWidget$2: function(previousSelectionId, groupName) {
      var previousSelection, current, firstLocal, t1, t2, _i, candidate, _this = this, _null = null;
      if (!H.boolConversionCheck(_this.isWidgetCreationTracked$0()))
        return _this._getSelectedWidget$2(previousSelectionId, groupName);
      previousSelection = H.interceptedTypeCheck(_this.toObject$1(previousSelectionId), "$isDiagnosticsNode");
      current = _this.WidgetInspectorService_selection._currentElement;
      if (current != null && !_this._isValueCreatedByLocalProject$1(current)) {
        t1 = current.debugGetDiagnosticChain$0();
        t2 = t1.length;
        _i = 0;
        while (true) {
          if (!(_i < t1.length)) {
            firstLocal = _null;
            break;
          }
          candidate = t1[_i];
          if (_this._isValueCreatedByLocalProject$1(candidate)) {
            firstLocal = candidate;
            break;
          }
          t1.length === t2 || (0, H.throwConcurrentModificationError)(t1);
          ++_i;
        }
        current = firstLocal;
      }
      if (J.$eq$(current, previousSelection == null ? _null : previousSelection.get$value()))
        t1 = previousSelection;
      else
        t1 = current == null ? _null : new Y._DiagnosticableTreeNode(current, _null, true, true, _null);
      return _this._nodeToJson$2(t1, N._SerializeConfig$(true, groupName, false, 1, false));
    },
    isWidgetCreationTracked$0: function() {
      var t1 = this.WidgetInspectorService__widgetCreationTracked;
      return t1 == null ? this.WidgetInspectorService__widgetCreationTracked = false : t1;
    },
    _onFrameStart$1: function(timeStamp) {
      var t1, t2;
      this.WidgetInspectorService__frameStart = H.interceptedTypeCheck(timeStamp, "$isDuration");
      t1 = $.SchedulerBinding__instance;
      t1.toString;
      t2 = H.functionTypeCheck(this.get$_onFrameEnd(), {func: 1, ret: -1, args: [P.Duration]});
      C.JSArray_methods.add$1(t1.SchedulerBinding__postFrameCallbacks, t2);
    },
    _onFrameEnd$1: function(timeStamp) {
      var t1, _this = this;
      H.interceptedTypeCheck(timeStamp, "$isDuration");
      if (_this.WidgetInspectorService__trackRebuildDirtyWidgets) {
        t1 = P.Object;
        P.postEvent("Flutter.RebuiltWidgets", H.assertSubtype(_this.WidgetInspectorService__rebuildStats.exportToJson$1(_this.WidgetInspectorService__frameStart), "$isMap", [t1, t1], "$asMap"));
      }
      if (_this.WidgetInspectorService__trackRepaintWidgets) {
        t1 = P.Object;
        P.postEvent("Flutter.RepaintWidgets", H.assertSubtype(_this.WidgetInspectorService__repaintStats.exportToJson$1(_this.WidgetInspectorService__frameStart), "$isMap", [t1, t1], "$asMap"));
      }
    },
    _onRebuildWidget$2: function(element, builtOnce) {
      this.WidgetInspectorService__rebuildStats.add$1(0, element);
    },
    _onPaint$1: function(renderObject) {
      var element, exception, stack, t1, exception0;
      try {
        t1 = renderObject.debugCreator;
        element = t1 == null ? null : t1.element;
        if (!(element instanceof N.RenderObjectElement))
          return;
        this.WidgetInspectorService__repaintStats.add$1(0, element);
        element.visitAncestorElements$1(new N.WidgetInspectorService__onPaint_closure(this));
      } catch (exception0) {
        exception = H.unwrapException(exception0);
        stack = H.getTraceFromException(exception0);
        U.FlutterError_reportError(U.FlutterErrorDetails$(null, exception, null, "Flutter framework", false, stack));
      }
    },
    set$selectionChangedCallback: function(selectionChangedCallback) {
      this.WidgetInspectorService_selectionChangedCallback = H.functionTypeCheck(selectionChangedCallback, {func: 1, ret: -1});
    },
    set$_pubRootDirectories: function(_pubRootDirectories) {
      this.WidgetInspectorService__pubRootDirectories = H.assertSubtype(_pubRootDirectories, "$isList", [P.String], "$asList");
    },
    set$_registerServiceExtensionCallback: function(_registerServiceExtensionCallback) {
      this.WidgetInspectorService__registerServiceExtensionCallback = H.functionTypeCheck(_registerServiceExtensionCallback, {func: 1, ret: -1, named: {callback: {func: 1, ret: [P.Future, [P.Map, P.String,,]], args: [[P.Map, P.String, P.String]]}, name: P.String}});
    }
  };
  N.WidgetInspectorService__registerSignalServiceExtension_closure.prototype = {
    call$1: function(parameters) {
      var t1 = P.String;
      return this.$call$body$WidgetInspectorService__registerSignalServiceExtension_closure(H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap"));
    },
    $call$body$WidgetInspectorService__registerSignalServiceExtension_closure: function(parameters) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String, P.Object]),
        $async$returnValue, $async$self = this, $async$temp1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = P;
              $async$goto = 3;
              return P._asyncAwait($async$self.callback.call$0(), $async$call$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.LinkedHashMap_LinkedHashMap$_literal(["result", $async$result], P.String, P.Object);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 19
  };
  N.WidgetInspectorService__registerObjectGroupServiceExtension_closure.prototype = {
    call$1: function(parameters) {
      var t1 = P.String;
      return this.$call$body$WidgetInspectorService__registerObjectGroupServiceExtension_closure(H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap"));
    },
    $call$body$WidgetInspectorService__registerObjectGroupServiceExtension_closure: function(parameters) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String, P.Object]),
        $async$returnValue, $async$self = this, $async$temp1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = P;
              $async$goto = 3;
              return P._asyncAwait($async$self.callback.call$1(parameters.$index(0, "objectGroup")), $async$call$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.LinkedHashMap_LinkedHashMap$_literal(["result", $async$result], P.String, P.Object);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 19
  };
  N.WidgetInspectorService__registerBoolServiceExtension_closure.prototype = {
    call$1: function(parameters) {
      var t1 = P.String;
      return this.$call$body$WidgetInspectorService__registerBoolServiceExtension_closure(H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap"));
    },
    $call$body$WidgetInspectorService__registerBoolServiceExtension_closure: function(parameters) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String,,]),
        $async$returnValue, $async$self = this, value, t1, $async$temp1, $async$temp2;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = parameters.containsKey$1("enabled") ? 3 : 4;
              break;
            case 3:
              // then
              value = J.$eq$(parameters.$index(0, "enabled"), "true");
              $async$goto = 5;
              return P._asyncAwait($async$self.setter.call$1(value), $async$call$1);
            case 5:
              // returning from await.
              t1 = P.Object;
              P.postEvent("Flutter.ServiceExtensionStateChanged", H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_literal(["extension", "ext.flutter.inspector." + $async$self.name, "value", value], P.String, null), "$isMap", [t1, t1], "$asMap"));
            case 4:
              // join
              $async$temp1 = P;
              $async$temp2 = H;
              $async$goto = 6;
              return P._asyncAwait($async$self.getter.call$0(), $async$call$1);
            case 6:
              // returning from await.
              $async$returnValue = $async$temp1.LinkedHashMap_LinkedHashMap$_literal(["enabled", $async$temp2.boolConversionCheck($async$result) ? "true" : "false"], P.String, null);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 8
  };
  N.WidgetInspectorService__registerServiceExtensionWithArg_closure.prototype = {
    call$1: function(parameters) {
      var t1 = P.String;
      return this.$call$body$WidgetInspectorService__registerServiceExtensionWithArg_closure(H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap"));
    },
    $call$body$WidgetInspectorService__registerServiceExtensionWithArg_closure: function(parameters) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String, P.Object]),
        $async$returnValue, $async$self = this, $async$temp1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              H.assertHelper(parameters.containsKey$1("objectGroup"));
              $async$temp1 = P;
              $async$goto = 3;
              return P._asyncAwait($async$self.callback.call$2(parameters.$index(0, "arg"), parameters.$index(0, "objectGroup")), $async$call$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.LinkedHashMap_LinkedHashMap$_literal(["result", $async$result], P.String, P.Object);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 19
  };
  N.WidgetInspectorService__registerServiceExtensionVarArgs_closure.prototype = {
    call$1: function(parameters) {
      var t1 = P.String;
      return this.$call$body$WidgetInspectorService__registerServiceExtensionVarArgs_closure(H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap"));
    },
    $call$body$WidgetInspectorService__registerServiceExtensionVarArgs_closure: function(parameters) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String, P.Object]),
        $async$returnValue, $async$self = this, t1, args, $async$temp1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = P.String;
              args = H.setRuntimeTypeInfo([], [t1]);
              parameters.forEach$1(0, new N.WidgetInspectorService__registerServiceExtensionVarArgs__closure("arg", args));
              $async$temp1 = P;
              $async$goto = 3;
              return P._asyncAwait($async$self.callback.call$1(args), $async$call$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.LinkedHashMap_LinkedHashMap$_literal(["result", $async$result], t1, P.Object);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 19
  };
  N.WidgetInspectorService__registerServiceExtensionVarArgs__closure.prototype = {
    call$2: function($name, value) {
      var t1, index, t2;
      H.stringTypeCheck($name);
      H.stringTypeCheck(value);
      t1 = this.argPrefix;
      if (J.getInterceptor$s($name).startsWith$1($name, t1)) {
        index = P.int_parse(C.JSString_methods.substring$1($name, t1.length), null, null);
        t1 = this.args;
        t2 = t1.length;
        if (typeof index !== "number")
          return index.$ge();
        if (index >= t2)
          C.JSArray_methods.set$length(t1, index + 1);
        C.JSArray_methods.$indexSet(t1, index, value);
      }
    },
    $signature: 183
  };
  N.WidgetInspectorService_initServiceExtensions_closure.prototype = {
    call$0: function() {
      return $.WidgetInspectorService__debugServiceExtensionsRegistered = true;
    },
    $signature: 0
  };
  N.WidgetInspectorService_initServiceExtensions_closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $.WidgetsApp_debugShowWidgetInspectorOverride;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 4
  };
  N.WidgetInspectorService_initServiceExtensions_closure1.prototype = {
    call$1: function(value) {
      var t1;
      if ($.WidgetsApp_debugShowWidgetInspectorOverride === value) {
        t1 = new P._Future($.Zone__current, [-1]);
        t1._asyncComplete$1(null);
        return t1;
      }
      $.WidgetsApp_debugShowWidgetInspectorOverride = value;
      return this.$this.forceRebuild$0();
    },
    $signature: 7
  };
  N.WidgetInspectorService_initServiceExtensions_closure2.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $async$self.$this.WidgetInspectorService__trackRebuildDirtyWidgets;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 4
  };
  N.WidgetInspectorService_initServiceExtensions_closure3.prototype = {
    call$1: function(value) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$returnValue, $async$self = this, t1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              if (value === t1.WidgetInspectorService__trackRebuildDirtyWidgets) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1.WidgetInspectorService__rebuildStats.resetCounts$0();
              t1.WidgetInspectorService__trackRebuildDirtyWidgets = value;
              $async$goto = value ? 3 : 5;
              break;
            case 3:
              // then
              H.assertHelper($.debugOnRebuildDirtyWidget == null);
              $.debugOnRebuildDirtyWidget = t1.get$_onRebuildWidget();
              $async$goto = 6;
              return P._asyncAwait(t1.forceRebuild$0(), $async$call$1);
            case 6:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$returnValue = $.debugOnRebuildDirtyWidget = null;
              // goto return
              $async$goto = 1;
              break;
            case 4:
              // join
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 36
  };
  N.WidgetInspectorService_initServiceExtensions_closure4.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $async$self.$this.WidgetInspectorService__trackRepaintWidgets;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 4
  };
  N.WidgetInspectorService_initServiceExtensions_closure5.prototype = {
    call$1: function(value) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$returnValue, $async$self = this, root, t1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              if (value === t1.WidgetInspectorService__trackRepaintWidgets) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1.WidgetInspectorService__repaintStats.resetCounts$0();
              t1.WidgetInspectorService__trackRepaintWidgets = value;
              if (value) {
                H.assertHelper($.debugOnProfilePaint == null);
                $.debugOnProfilePaint = t1.get$_onPaint();
                root = $.RendererBinding__instance.RendererBinding__pipelineOwner._rootNode;
                if (root != null)
                  new N.WidgetInspectorService_initServiceExtensions_closure_markTreeNeedsPaint().call$1(root);
              } else
                $.debugOnProfilePaint = null;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 36
  };
  N.WidgetInspectorService_initServiceExtensions_closure_markTreeNeedsPaint.prototype = {
    call$1: function(renderObject) {
      renderObject.markNeedsPaint$0();
      renderObject.visitChildren$1(this);
    },
    $signature: 33
  };
  N.WidgetInspectorService_initServiceExtensions_closure6.prototype = {
    call$1: function(parameters) {
      var t1 = P.String;
      return this.$call$body$WidgetInspectorService_initServiceExtensions_closure(H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap"));
    },
    $call$body$WidgetInspectorService_initServiceExtensions_closure: function(parameters) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String, P.Object]),
        $async$returnValue, $async$self = this, t1, t2, t3, t4, t5, t6;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              H.assertHelper(parameters.containsKey$1("id"));
              H.assertHelper(parameters.containsKey$1("width"));
              H.assertHelper(parameters.containsKey$1("height"));
              t1 = $async$self.$this;
              t2 = t1.toObject$1(parameters.$index(0, "id"));
              t3 = P.double_parse(parameters.$index(0, "width"));
              t4 = P.double_parse(parameters.$index(0, "height"));
              t5 = parameters.containsKey$1("margin") ? P.double_parse(parameters.$index(0, "margin")) : 0;
              t6 = parameters.containsKey$1("maxPixelRatio") ? P.double_parse(parameters.$index(0, "maxPixelRatio")) : 1;
              $async$goto = 3;
              return P._asyncAwait(t1.screenshot$6$debugPaint$height$margin$maxPixelRatio$width(t2, J.$eq$(parameters.$index(0, "debugPaint"), "true"), t4, t5, t6, t3), $async$call$1);
            case 3:
              // returning from await.
              t1 = P.LinkedHashMap_LinkedHashMap$_literal(["result", null], P.String, P.Object);
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 19
  };
  N.WidgetInspectorService_toId_closure.prototype = {
    call$0: function() {
      return new P._LinkedIdentityHashSet([N._InspectorReferenceData]);
    },
    $signature: 184
  };
  N.WidgetInspectorService_setPubRootDirectories_closure.prototype = {
    call$1: function(directory) {
      var t1 = P.Uri_parse(H.stringTypeCheck(directory));
      return t1.get$path(t1);
    },
    $signature: 185
  };
  N.WidgetInspectorService__getParentChain_closure.prototype = {
    call$1: function(node) {
      return this.$this._pathNodeToJson$2(H.interceptedTypeCheck(node, "$is_DiagnosticsPathNode"), N._SerializeConfig$(true, this.groupName, false, 1, false));
    },
    $signature: 186
  };
  N.WidgetInspectorService__nodeToJson_closure.prototype = {
    call$1: function(node) {
      var t1;
      H.interceptedTypeCheck(node, "$isDiagnosticsNode");
      t1 = this._box_0.createdByLocalProject ? C.DiagnosticLevel_1 : C.DiagnosticLevel_3;
      return node.get$level().index >= t1.index;
    },
    $signature: 18
  };
  N.WidgetInspectorService__nodeToJson_closure0.prototype = {
    call$1: function(node) {
      return H.interceptedTypeCheck(node, "$isDiagnosticsNode").get$level().index >= 3;
    },
    $signature: 18
  };
  N.WidgetInspectorService__nodesToJson_closure.prototype = {
    call$1: function(node) {
      var t1, t2;
      H.interceptedTypeCheck(node, "$isDiagnosticsNode");
      t1 = this.$this;
      t2 = this.config;
      return t1._nodeToJson$2(node, t2.summaryTree || t2.subtreeDepth > 1 || t1._shouldShowInSummaryTree$1(node) ? N._SerializeConfig$merge(t2, null, t2.subtreeDepth - 1) : t2);
    },
    $signature: 187
  };
  N.WidgetInspectorService__onPaint_closure.prototype = {
    call$1: function(ancestor) {
      if (!!ancestor.$isRenderObjectElement)
        return false;
      this.$this.WidgetInspectorService__repaintStats.add$1(0, ancestor);
      return true;
    },
    $signature: 22
  };
  N._LocationCount.prototype = {};
  N._ElementLocationStatsTracker.prototype = {
    add$1: function(_, element) {
      element.get$widget();
      return;
    },
    resetCounts$0: function() {
      var t1, t2, _i;
      for (t1 = this.active, t2 = t1.length, _i = 0; _i < t2; ++_i)
        t1[_i]._widget_inspector$_count = 0;
      C.JSArray_methods.set$length(t1, 0);
    },
    exportToJson$1: function(startTime) {
      var t2, j, _i, stat, j0, json, t3, locationsJson, entry, $location, jsonForFile,
        t1 = this.active,
        events = P.List_List$filled(t1.length * 2, 0, P.int);
      for (t2 = t1.length, j = 0, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        stat = t1[_i];
        j0 = j + 1;
        C.JSArray_methods.$indexSet(events, j, stat.id);
        j = j0 + 1;
        C.JSArray_methods.$indexSet(events, j0, stat._widget_inspector$_count);
      }
      t1 = P.String;
      json = P.LinkedHashMap_LinkedHashMap$_literal(["startTime", startTime._duration, "events", events], t1, null);
      t2 = this.newLocations;
      t3 = t2.length;
      if (t3 !== 0) {
        locationsJson = P.LinkedHashMap_LinkedHashMap$_empty(t1, [P.List, P.int]);
        for (_i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
          entry = t2[_i];
          $location = entry.location;
          jsonForFile = locationsJson.putIfAbsent$2($location.get$file(), new N._ElementLocationStatsTracker_exportToJson_closure());
          t1 = J.getInterceptor$ax(jsonForFile);
          t1.add$1(jsonForFile, entry.id);
          t1.add$1(jsonForFile, $location.get$line());
          t1.add$1(jsonForFile, $location.get$column());
        }
        json.$indexSet(0, "newLocations", locationsJson);
      }
      this.resetCounts$0();
      C.JSArray_methods.set$length(t2, 0);
      return json;
    }
  };
  N._ElementLocationStatsTracker_exportToJson_closure.prototype = {
    call$0: function() {
      return H.setRuntimeTypeInfo([], [P.int]);
    },
    $signature: 188
  };
  N.WidgetInspector.prototype = {
    createState$0: function() {
      return new N._WidgetInspectorState($.$get$WidgetInspectorService__instance().WidgetInspectorService_selection, new N.LabeledGlobalKey(null, [[N.State, N.StatefulWidget]]), C._StateLifecycle_0);
    },
    selectButtonBuilder$2: function(arg0, arg1) {
      return this.selectButtonBuilder.call$2(arg0, arg1);
    },
    get$child: function() {
      return this.child;
    }
  };
  N._WidgetInspectorState.prototype = {
    initState$0: function() {
      var _this = this;
      _this.super$State$initState();
      _this.set$_selectionChangedCallback(new N._WidgetInspectorState_initState_closure(_this));
      H.assertHelper($.$get$WidgetInspectorService__instance().WidgetInspectorService_selectionChangedCallback == null);
      $.$get$WidgetInspectorService__instance().set$selectionChangedCallback(_this._selectionChangedCallback);
    },
    dispose$0: function() {
      if (J.$eq$($.$get$WidgetInspectorService__instance().WidgetInspectorService_selectionChangedCallback, this._selectionChangedCallback))
        $.$get$WidgetInspectorService__instance().set$selectionChangedCallback(null);
      this.super$State$dispose();
    },
    _hitTestHelper$5: function(hits, edgeHits, position, object, transform) {
      var inverse, localPosition, children, i, hit, diagnostics, child, paintClip, childTransform, bounds,
        t1 = [K.RenderObject];
      H.assertSubtype(hits, "$isList", t1, "$asList");
      H.assertSubtype(edgeHits, "$isList", t1, "$asList");
      inverse = E.Matrix4_tryInvert(transform);
      if (inverse == null)
        return false;
      localPosition = T.MatrixUtils_transformPoint(inverse, position);
      children = object.debugDescribeChildren$0();
      for (i = children.length - 1, hit = false; i >= 0; --i) {
        if (i >= children.length)
          return H.ioore(children, i);
        diagnostics = children[i];
        if (diagnostics.get$style() === C.DiagnosticsTreeStyle_1 || !(diagnostics.get$value() instanceof K.RenderObject))
          continue;
        child = H.interceptedTypeCheck(diagnostics.get$value(), "$isRenderObject");
        paintClip = object.describeApproximatePaintClip$1(child);
        if (paintClip != null && !paintClip.contains$1(0, localPosition))
          continue;
        childTransform = new E.Matrix4(new Float64Array(16));
        childTransform.setFrom$1(transform);
        object.applyPaintTransform$2(child, childTransform);
        if (this._hitTestHelper$5(hits, edgeHits, position, child, childTransform))
          hit = true;
      }
      bounds = object.get$semanticBounds();
      if (bounds.contains$1(0, localPosition)) {
        if (!bounds.inflate$1(-2).contains$1(0, localPosition))
          C.JSArray_methods.add$1(edgeHits, object);
        hit = true;
      }
      if (hit)
        C.JSArray_methods.add$1(hits, object);
      return hit;
    },
    hitTest$2: function(position, root) {
      var hits,
        t1 = K.RenderObject,
        t2 = [t1],
        regularHits = H.setRuntimeTypeInfo([], t2),
        edgeHits = H.setRuntimeTypeInfo([], t2);
      this._hitTestHelper$5(regularHits, edgeHits, position, root, root.getTransformTo$1(null));
      C.JSArray_methods.sort$1(regularHits, new N._WidgetInspectorState_hitTest_closure(new N._WidgetInspectorState_hitTest__area()));
      hits = P.LinkedHashSet_LinkedHashSet$_empty(t1);
      hits.addAll$1(0, edgeHits);
      hits.addAll$1(0, regularHits);
      return hits.toList$0(0);
    },
    _inspectAt$1: function(position) {
      var _this = this;
      if (!_this.isSelectMode)
        return;
      _this.setState$1(new N._WidgetInspectorState__inspectAt_closure(_this, _this.hitTest$2(position, H.interceptedTypeCheck($.GlobalKey__registry.$index(0, _this._ignorePointerKey).get$renderObject(), "$isRenderIgnorePointer").RenderObjectWithChildMixin__child)));
    },
    _handlePanDown$1: function($event) {
      var t1 = H.interceptedTypeCheck($event, "$isDragDownDetails").globalPosition;
      this._lastPointerLocation = t1;
      this._inspectAt$1(t1);
    },
    _handlePanUpdate$1: function($event) {
      var t1 = H.interceptedTypeCheck($event, "$isDragUpdateDetails").globalPosition;
      this._lastPointerLocation = t1;
      this._inspectAt$1(t1);
    },
    _handlePanEnd$1: function(details) {
      var t1, t2;
      H.interceptedTypeCheck(details, "$isDragEndDetails");
      $.WidgetsBinding__instance.toString;
      $.$get$window().toString;
      t1 = C.Size_0_0.$div(0, 1);
      t2 = t1._dx;
      t1 = t1._dy;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (typeof t1 !== "number")
        return H.iae(t1);
      if (!new P.Rect(0, 0, 0 + t2, 0 + t1).inflate$1(-1).contains$1(0, this._lastPointerLocation))
        this.setState$1(new N._WidgetInspectorState__handlePanEnd_closure(this));
    },
    _handleTap$0: function() {
      var t1, _this = this;
      if (!_this.isSelectMode)
        return;
      t1 = _this._lastPointerLocation;
      if (t1 != null)
        _this._inspectAt$1(t1);
      _this.setState$1(new N._WidgetInspectorState__handleTap_closure(_this));
    },
    _handleEnableSelect$0: function() {
      this.setState$1(new N._WidgetInspectorState__handleEnableSelect_closure(this));
    },
    build$1: function(context) {
      var _this = this, _null = null,
        children = H.setRuntimeTypeInfo([], [N.Widget]),
        t1 = _this.isSelectMode;
      C.JSArray_methods.add$1(children, D.GestureDetector$(C.HitTestBehavior_1, T.IgnorePointer$(_this._widget.child, t1, false, _this._ignorePointerKey), C.DragStartBehavior_1, true, _null, _null, _null, _null, _null, _null, _null, _this.get$_handlePanDown(), _this.get$_handlePanEnd(), _this.get$_handlePanUpdate(), _this.get$_handleTap(), _null, _null, _null, _null));
      if (!_this.isSelectMode) {
        _this._widget.selectButtonBuilder;
        t1 = true;
      } else
        t1 = false;
      if (t1)
        C.JSArray_methods.add$1(children, T.Positioned$(10, _this._widget.selectButtonBuilder$2(context, _this.get$_handleEnableSelect()), _null, _null, 10, _null, _null, _null));
      C.JSArray_methods.add$1(children, new N._InspectorOverlay(_this.selection, _null));
      return T.Stack$(C.AlignmentDirectional_m1_m1, children, C.StackFit_0);
    },
    set$_selectionChangedCallback: function(_selectionChangedCallback) {
      this._selectionChangedCallback = H.functionTypeCheck(_selectionChangedCallback, {func: 1, ret: -1});
    },
    $asState: function() {
      return [N.WidgetInspector];
    }
  };
  N._WidgetInspectorState_initState_closure.prototype = {
    call$0: function() {
      this.$this.setState$1(new N._WidgetInspectorState_initState__closure());
    },
    $signature: 2
  };
  N._WidgetInspectorState_initState__closure.prototype = {
    call$0: function() {
    },
    $signature: 2
  };
  N._WidgetInspectorState_hitTest__area.prototype = {
    call$1: function(object) {
      var t4, size,
        t1 = object.get$semanticBounds(),
        t2 = t1.right,
        t3 = t1.left;
      if (typeof t2 !== "number")
        return t2.$sub();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = t1.bottom;
      t1 = t1.top;
      if (typeof t4 !== "number")
        return t4.$sub();
      if (typeof t1 !== "number")
        return H.iae(t1);
      size = new P.Size(t2 - t3, t4 - t1);
      t1 = size._dx;
      t2 = size._dy;
      if (typeof t1 !== "number")
        return t1.$mul();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t1 *= t2;
      return t1;
    },
    $signature: 190
  };
  N._WidgetInspectorState_hitTest_closure.prototype = {
    call$2: function(a, b) {
      var t1;
      H.interceptedTypeCheck(a, "$isRenderObject");
      H.interceptedTypeCheck(b, "$isRenderObject");
      t1 = this._area;
      return J.compareTo$1$ns(t1.call$1(a), t1.call$1(b));
    },
    $signature: 17
  };
  N._WidgetInspectorState__inspectAt_closure.prototype = {
    call$0: function() {
      var t1 = this.$this.selection;
      t1.set$_candidates(H.assertSubtype(this.selected, "$isList", [K.RenderObject], "$asList"));
      t1._widget_inspector$_index = 0;
      t1._computeCurrent$0();
    },
    $signature: 2
  };
  N._WidgetInspectorState__handlePanEnd_closure.prototype = {
    call$0: function() {
      var t1 = this.$this.selection;
      t1.set$_candidates(H.setRuntimeTypeInfo([], [K.RenderObject]));
      t1._widget_inspector$_index = 0;
      t1._computeCurrent$0();
    },
    $signature: 2
  };
  N._WidgetInspectorState__handleTap_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._widget.selectButtonBuilder;
      t1.isSelectMode = false;
    },
    $signature: 2
  };
  N._WidgetInspectorState__handleEnableSelect_closure.prototype = {
    call$0: function() {
      this.$this.isSelectMode = true;
    },
    $signature: 2
  };
  N.InspectorSelection.prototype = {
    _computeCurrent$0: function() {
      var _this = this,
        t1 = _this._widget_inspector$_index,
        t2 = _this._candidates;
      if (t1 < t2.length) {
        t1 = H.interceptedTypeCheck(t2[t1], "$isRenderObject");
        _this._widget_inspector$_current = t1;
        _this._currentElement = t1.debugCreator.element;
      } else
        _this._currentElement = _this._widget_inspector$_current = null;
    },
    set$_candidates: function(_candidates) {
      this._candidates = H.assertSubtype(_candidates, "$isList", [K.RenderObject], "$asList");
    }
  };
  N._InspectorOverlay.prototype = {
    createRenderObject$1: function(context) {
      var t1 = new N._RenderInspectorOverlay(this.selection);
      t1.get$isRepaintBoundary();
      t1.get$alwaysNeedsCompositing();
      t1._needsCompositing = true;
      return t1;
    },
    updateRenderObject$2: function(context, renderObject) {
      var t1;
      H.interceptedTypeCheck(renderObject, "$is_RenderInspectorOverlay");
      t1 = this.selection;
      if (t1 !== renderObject._selection)
        renderObject._selection = t1;
      renderObject.markNeedsPaint$0();
    }
  };
  N._RenderInspectorOverlay.prototype = {
    get$sizedByParent: function() {
      return true;
    },
    get$alwaysNeedsCompositing: function() {
      return true;
    },
    performResize$0: function() {
      this.set$size(K.RenderObject.prototype.get$constraints.call(this).constrain$1(C.Size_wjo));
    },
    paint$2: function(context, offset) {
      var t1, t2, t3, t4, _this = this;
      H.assertHelper(!_this._needsCompositingBitsUpdate);
      H.assertHelper(_this._needsCompositing);
      t1 = offset._dx;
      t2 = offset._dy;
      t3 = _this.get$size()._dx;
      t4 = _this.get$size()._dy;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (typeof t2 !== "number")
        return t2.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      t4 = N._InspectorOverlayLayer$(new P.Rect(t1, t2, t1 + t3, t2 + t4), _this._selection);
      context.stopRecordingIfNeeded$0();
      context.appendLayer$1(t4);
    }
  };
  N._TransformedRect.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(this))))
        return false;
      H.interceptedTypeCheck(other, "$is_TransformedRect");
      return this.rect.$eq(0, other.rect) && this.transform.$eq(0, other.transform);
    },
    get$hashCode: function(_) {
      return P.hashValues(this.rect, this.transform, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    }
  };
  N._InspectorOverlayRenderState.prototype = {
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (!J.get$runtimeType$(other).$eq(0, new H.TypeImpl(H.getRti(_this))))
        return false;
      H.interceptedTypeCheck(other, "$is_InspectorOverlayRenderState");
      return _this.overlayRect.$eq(0, other.overlayRect) && _this.selected.$eq(0, other.selected) && S.listEquals(_this.candidates, other.candidates, N._TransformedRect) && _this.tooltip === other.tooltip;
    },
    get$hashCode: function(_) {
      var _this = this;
      return P.hashValues(_this.overlayRect, _this.selected, P.hashList(_this.candidates), _this.tooltip, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    }
  };
  N._InspectorOverlayLayer.prototype = {
    _InspectorOverlayLayer$2$overlayRect$selection: function(overlayRect, selection, _box_0) {
      _box_0.inDebugMode = false;
      H.assertHelper(new N._InspectorOverlayLayer_closure(_box_0).call$0());
      if (!_box_0.inDebugMode)
        throw H.wrapException(U.FlutterError$("The inspector should never be used in production mode due to the negative performance impact."));
    },
    addToScene$2: function(builder, layerOffset) {
      var candidates, t3, t4, _i, candidate, state, _this = this,
        t1 = _this.selection,
        t2 = t1._widget_inspector$_current;
      if (!(t2 != null && t2._node$_owner != null))
        return;
      candidates = H.setRuntimeTypeInfo([], [N._TransformedRect]);
      for (t3 = t1._candidates, t4 = t3.length, _i = 0; _i < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i) {
        candidate = t3[_i];
        if (J.$eq$(candidate, t2) || candidate._node$_owner == null)
          continue;
        C.JSArray_methods.add$1(candidates, new N._TransformedRect(candidate.get$semanticBounds(), candidate.getTransformTo$1(null)));
      }
      state = new N._InspectorOverlayRenderState(_this.overlayRect, new N._TransformedRect(t2.get$semanticBounds(), t2.getTransformTo$1(null)), candidates, t1._currentElement.toStringShort$0(), C.TextDirection_1);
      if (!state.$eq(0, _this._lastState)) {
        _this._lastState = state;
        _this._widget_inspector$_picture = _this._buildPicture$1(state);
      }
      builder.addPicture$2(layerOffset, _this._widget_inspector$_picture);
    },
    addToScene$1: function(builder) {
      return this.addToScene$2(builder, C.Offset_0_0);
    },
    _buildPicture$1: function(state) {
      var fillPaint, borderPaint, selectedPaintRect,
        canvas = new P.Canvas(),
        t1 = state.overlayRect,
        t2 = t1.right,
        t3 = t1.left;
      if (typeof t2 !== "number")
        return t2.$sub();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t3 = t1.bottom;
      t1 = t1.top;
      if (typeof t3 !== "number")
        return t3.$sub();
      if (typeof t1 !== "number")
        return H.iae(t1);
      fillPaint = new P.Paint(new DataView(new ArrayBuffer(75)));
      fillPaint.set$style(C.PaintingStyle_0);
      fillPaint.set$color(C.Color_2155905279);
      borderPaint = new P.Paint(new DataView(new ArrayBuffer(75)));
      borderPaint.set$style(C.PaintingStyle_1);
      borderPaint.set$strokeWidth(1);
      borderPaint.set$color(C.Color_2151694464);
      selectedPaintRect = state.selected.rect.inflate$1(-0.5);
      canvas.save$0();
      canvas.transform$1(null);
      canvas.drawRect$2(selectedPaintRect, fillPaint);
      canvas.drawRect$2(selectedPaintRect, borderPaint);
      canvas.restore$0();
    },
    find$1$1: function(regionOffset) {
      return;
    }
  };
  N._InspectorOverlayLayer_closure.prototype = {
    call$0: function() {
      return this._box_0.inDebugMode = true;
    },
    $signature: 0
  };
  N.__WidgetInspectorState_State_WidgetsBindingObserver.prototype = {};
  F.MyApp.prototype = {
    build$1: function(context) {
      var _null = null;
      return new S.MaterialApp(new F.MyHomePage("Flutter Demo Home Page", _null), "Flutter Demo", X.ThemeData_ThemeData(_null, "Roboto", _null, C.MaterialColor_Map_JNwaj_4280391411, _null), _null);
    }
  };
  F.MyHomePage.prototype = {
    createState$0: function() {
      return new F._MyHomePageState(C._StateLifecycle_0);
    }
  };
  F._MyHomePageState.prototype = {
    _incrementCounter$0: function() {
      this.setState$1(new F._MyHomePageState__incrementCounter_closure(this));
    },
    build$1: function(context) {
      var _null = null,
        t1 = L.Text$(this._widget.title, _null);
      return new M.Scaffold(new E.AppBar(t1, new P.Size(1 / 0, 56), _null), new T.Center(C.Alignment_0_0, _null, _null, T.Column$(H.setRuntimeTypeInfo([L.Text$("You have pushed the button this many times:", _null), L.Text$("" + this._counter, K.Theme_of(context).textTheme.display1)], [N.Widget]), C.MainAxisAlignment_2), _null), E.FloatingActionButton$(L.Icon$(C.IconData_57669_MaterialIcons_false), false, this.get$_incrementCounter(), "Increment"), _null);
    },
    $asState: function() {
      return [F.MyHomePage];
    }
  };
  F._MyHomePageState__incrementCounter_closure.prototype = {
    call$0: function() {
      ++this.$this._counter;
    },
    $signature: 2
  };
  N._TypedDataBuffer.prototype = {
    get$length: function(_) {
      return this._typed_buffers$_length;
    },
    $index: function(_, index) {
      var t1;
      if (index >= this._typed_buffers$_length)
        throw H.wrapException(P.IndexError$(index, this, null, null, null));
      t1 = this._typed_buffers$_buffer;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $indexSet: function(_, index, value) {
      var _this = this;
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(_this, "_TypedDataBuffer", 0));
      if (index >= _this._typed_buffers$_length)
        throw H.wrapException(P.IndexError$(index, _this, null, null, null));
      C.NativeUint8List_methods.$indexSet(_this._typed_buffers$_buffer, index, value);
    },
    set$length: function(_, newLength) {
      var t2, t3, i, newBuffer, _this = this,
        t1 = _this._typed_buffers$_length;
      if (newLength < t1)
        for (t2 = _this._typed_buffers$_buffer, t3 = t2.length, i = newLength; i < t1; ++i) {
          if (i < 0 || i >= t3)
            return H.ioore(t2, i);
          t2[i] = 0;
        }
      else {
        t1 = _this._typed_buffers$_buffer.length;
        if (newLength > t1) {
          if (t1 === 0)
            newBuffer = new Uint8Array(newLength);
          else
            newBuffer = _this._createBiggerBuffer$1(newLength);
          C.NativeUint8List_methods.setRange$3(newBuffer, 0, _this._typed_buffers$_length, _this._typed_buffers$_buffer);
          _this.set$_typed_buffers$_buffer(newBuffer);
        }
      }
      _this._typed_buffers$_length = newLength;
    },
    _typed_buffers$_add$1: function(value) {
      var t1, _this = this;
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(_this, "_TypedDataBuffer", 0));
      t1 = _this._typed_buffers$_length;
      if (t1 === _this._typed_buffers$_buffer.length)
        _this._typed_buffers$_grow$1(t1);
      C.NativeUint8List_methods.$indexSet(_this._typed_buffers$_buffer, _this._typed_buffers$_length++, value);
    },
    add$1: function(_, value) {
      this._typed_buffers$_add$1(H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this, "_TypedDataBuffer", 0)));
    },
    addAll$3: function(_, values, start, end) {
      H.assertSubtype(values, "$isIterable", [H.getRuntimeTypeArgument(this, "_TypedDataBuffer", 0)], "$asIterable");
      P.RangeError_checkNotNegative(start, "start");
      if (end != null && start > end)
        throw H.wrapException(P.RangeError$range(end, start, null, "end", null));
      this._addAll$3(values, start, end);
    },
    addAll$1: function($receiver, values) {
      return this.addAll$3($receiver, values, 0, null);
    },
    _addAll$3: function(values, start, end) {
      H.assertSubtype(values, "$isIterable", [H.getRuntimeTypeArgument(this, "_TypedDataBuffer", 0)], "$asIterable");
      if (end == null)
        end = values.length;
      this._insertKnownLength$4(this._typed_buffers$_length, values, start, end);
      return;
    },
    _insertKnownLength$4: function(index, values, start, end) {
      var t1, valuesLength, newLength, t2, _this = this;
      H.assertSubtype(values, "$isIterable", [H.getRuntimeTypeArgument(_this, "_TypedDataBuffer", 0)], "$asIterable");
      t1 = values.length;
      if (start > t1 || end > t1)
        throw H.wrapException(P.StateError$("Too few elements"));
      valuesLength = end - start;
      newLength = _this._typed_buffers$_length + valuesLength;
      _this._ensureCapacity$1(newLength);
      t1 = _this._typed_buffers$_buffer;
      t2 = index + valuesLength;
      C.NativeUint8List_methods.setRange$4(t1, t2, _this._typed_buffers$_length + valuesLength, t1, index);
      C.NativeUint8List_methods.setRange$4(_this._typed_buffers$_buffer, index, t2, values, start);
      _this._typed_buffers$_length = newLength;
    },
    _ensureCapacity$1: function(requiredCapacity) {
      var newBuffer, _this = this;
      if (requiredCapacity <= _this._typed_buffers$_buffer.length)
        return;
      newBuffer = _this._createBiggerBuffer$1(requiredCapacity);
      C.NativeUint8List_methods.setRange$3(newBuffer, 0, _this._typed_buffers$_length, _this._typed_buffers$_buffer);
      _this.set$_typed_buffers$_buffer(newBuffer);
    },
    _createBiggerBuffer$1: function(requiredCapacity) {
      var t1,
        newLength = this._typed_buffers$_buffer.length * 2;
      if (requiredCapacity != null && newLength < requiredCapacity)
        newLength = requiredCapacity;
      else if (newLength < 8)
        newLength = 8;
      t1 = typeof newLength === "number" && Math.floor(newLength) === newLength ? newLength : H.throwExpression(P.ArgumentError$("Invalid length " + H.S(newLength)));
      return new Uint8Array(t1);
    },
    _typed_buffers$_grow$1: function($length) {
      var t1 = this._createBiggerBuffer$1(null);
      C.NativeUint8List_methods.setRange$3(t1, 0, $length, this._typed_buffers$_buffer);
      this.set$_typed_buffers$_buffer(t1);
    },
    set$_typed_buffers$_buffer: function(_buffer) {
      this._typed_buffers$_buffer = H.assertSubtype(_buffer, "$isList", [H.getRuntimeTypeArgument(this, "_TypedDataBuffer", 0)], "$asList");
    }
  };
  N._IntBuffer.prototype = {
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $asListMixin: function() {
      return [P.int];
    },
    $asIterable: function() {
      return [P.int];
    },
    $asList: function() {
      return [P.int];
    },
    $as_TypedDataBuffer: function() {
      return [P.int];
    }
  };
  N.Uint8Buffer.prototype = {};
  A.hashObjects_closure.prototype = {
    call$2: function(h, i) {
      var t1, hash;
      H.intTypeCheck(h);
      t1 = C.JSNumber_methods.get$hashCode(i);
      if (typeof h !== "number")
        return h.$add();
      hash = 536870911 & h + t1;
      hash = 536870911 & hash + ((524287 & hash) << 10);
      return hash ^ hash >>> 6;
    },
    $signature: 191
  };
  E.Matrix4.prototype = {
    setFrom$1: function(arg) {
      var argStorage = arg._m4storage,
        t1 = this._m4storage;
      t1[15] = argStorage[15];
      t1[14] = argStorage[14];
      t1[13] = argStorage[13];
      t1[12] = argStorage[12];
      t1[11] = argStorage[11];
      t1[10] = argStorage[10];
      t1[9] = argStorage[9];
      t1[8] = argStorage[8];
      t1[7] = argStorage[7];
      t1[6] = argStorage[6];
      t1[5] = argStorage[5];
      t1[4] = argStorage[4];
      t1[3] = argStorage[3];
      t1[2] = argStorage[2];
      t1[1] = argStorage[1];
      t1[0] = argStorage[0];
    },
    toString$0: function(_) {
      var _this = this;
      return "[0] " + _this.getRow$1(0).toString$0(0) + "\n[1] " + _this.getRow$1(1).toString$0(0) + "\n[2] " + _this.getRow$1(2).toString$0(0) + "\n[3] " + _this.getRow$1(3).toString$0(0) + "\n";
    },
    $index: function(_, i) {
      return C.NativeFloat64List_methods.$index(this._m4storage, i);
    },
    $eq: function(_, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      if (other instanceof E.Matrix4) {
        t1 = this._m4storage;
        t2 = t1[0];
        t3 = other._m4storage;
        t1 = t2 === t3[0] && t1[1] === t3[1] && t1[2] === t3[2] && t1[3] === t3[3] && t1[4] === t3[4] && t1[5] === t3[5] && t1[6] === t3[6] && t1[7] === t3[7] && t1[8] === t3[8] && t1[9] === t3[9] && t1[10] === t3[10] && t1[11] === t3[11] && t1[12] === t3[12] && t1[13] === t3[13] && t1[14] === t3[14] && t1[15] === t3[15];
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return A.hashObjects(this._m4storage);
    },
    getRow$1: function(row) {
      var t3,
        t1 = new Float64Array(4),
        t2 = this._m4storage;
      if (row >= 16)
        return H.ioore(t2, row);
      t1[0] = t2[row];
      t3 = 4 + row;
      if (t3 >= 16)
        return H.ioore(t2, t3);
      t1[1] = t2[t3];
      t3 = 8 + row;
      if (t3 >= 16)
        return H.ioore(t2, t3);
      t1[2] = t2[t3];
      t3 = 12 + row;
      if (t3 >= 16)
        return H.ioore(t2, t3);
      t1[3] = t2[t3];
      return new E.Vector4(t1);
    },
    $mul: function(_, arg) {
      var t1;
      if (typeof arg === "number") {
        t1 = new E.Matrix4(new Float64Array(16));
        t1.setFrom$1(this);
        t1.scale$3(arg, null, null);
        return t1;
      }
      throw H.wrapException(P.ArgumentError$(arg));
    },
    $add: function(_, arg) {
      var t1, t2, oStorage;
      H.interceptedTypeCheck(arg, "$isMatrix4");
      t1 = new Float64Array(16);
      t2 = new E.Matrix4(t1);
      t2.setFrom$1(this);
      oStorage = arg._m4storage;
      t1[0] = t1[0] + oStorage[0];
      t1[1] = t1[1] + oStorage[1];
      t1[2] = t1[2] + oStorage[2];
      t1[3] = t1[3] + oStorage[3];
      t1[4] = t1[4] + oStorage[4];
      t1[5] = t1[5] + oStorage[5];
      t1[6] = t1[6] + oStorage[6];
      t1[7] = t1[7] + oStorage[7];
      t1[8] = t1[8] + oStorage[8];
      t1[9] = t1[9] + oStorage[9];
      t1[10] = t1[10] + oStorage[10];
      t1[11] = t1[11] + oStorage[11];
      t1[12] = t1[12] + oStorage[12];
      t1[13] = t1[13] + oStorage[13];
      t1[14] = t1[14] + oStorage[14];
      t1[15] = t1[15] + oStorage[15];
      return t2;
    },
    $sub: function(_, arg) {
      var t1, t2, oStorage;
      H.interceptedTypeCheck(arg, "$isMatrix4");
      t1 = new Float64Array(16);
      t2 = new E.Matrix4(t1);
      t2.setFrom$1(this);
      oStorage = arg._m4storage;
      t1[0] = t1[0] - oStorage[0];
      t1[1] = t1[1] - oStorage[1];
      t1[2] = t1[2] - oStorage[2];
      t1[3] = t1[3] - oStorage[3];
      t1[4] = t1[4] - oStorage[4];
      t1[5] = t1[5] - oStorage[5];
      t1[6] = t1[6] - oStorage[6];
      t1[7] = t1[7] - oStorage[7];
      t1[8] = t1[8] - oStorage[8];
      t1[9] = t1[9] - oStorage[9];
      t1[10] = t1[10] - oStorage[10];
      t1[11] = t1[11] - oStorage[11];
      t1[12] = t1[12] - oStorage[12];
      t1[13] = t1[13] - oStorage[13];
      t1[14] = t1[14] - oStorage[14];
      t1[15] = t1[15] - oStorage[15];
      return t2;
    },
    translate$2: function(x, y) {
      var ty, tx, tz, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17;
      if (typeof x === "number") {
        ty = y;
        tx = x;
        tz = 0;
      } else {
        tx = null;
        ty = null;
        tz = null;
      }
      t1 = this._m4storage;
      t2 = t1[0];
      if (typeof tx !== "number")
        return H.iae(tx);
      t3 = t1[4];
      if (typeof ty !== "number")
        return H.iae(ty);
      t4 = t1[8];
      if (typeof tz !== "number")
        return H.iae(tz);
      t5 = t1[12];
      t6 = t1[1];
      t7 = t1[5];
      t8 = t1[9];
      t9 = t1[13];
      t10 = t1[2];
      t11 = t1[6];
      t12 = t1[10];
      t13 = t1[14];
      t14 = t1[3];
      t15 = t1[7];
      t16 = t1[11];
      t17 = t1[15];
      t1[12] = t2 * tx + t3 * ty + t4 * tz + t5;
      t1[13] = t6 * tx + t7 * ty + t8 * tz + t9;
      t1[14] = t10 * tx + t11 * ty + t12 * tz + t13;
      t1[15] = t14 * tx + t15 * ty + t16 * tz + t17;
    },
    scale$3: function(x, y, z) {
      var sy, sz, sx, t1, t2;
      if (typeof x === "number") {
        sy = y == null ? x : y;
        sz = z == null ? x : z;
        sx = x;
      } else {
        sx = null;
        sy = null;
        sz = null;
      }
      t1 = this._m4storage;
      t2 = t1[0];
      if (typeof sx !== "number")
        return H.iae(sx);
      t1[0] = t2 * sx;
      t1[1] = t1[1] * sx;
      t1[2] = t1[2] * sx;
      t1[3] = t1[3] * sx;
      t2 = t1[4];
      if (typeof sy !== "number")
        return H.iae(sy);
      t1[4] = t2 * sy;
      t1[5] = t1[5] * sy;
      t1[6] = t1[6] * sy;
      t1[7] = t1[7] * sy;
      t2 = t1[8];
      if (typeof sz !== "number")
        return H.iae(sz);
      t1[8] = t2 * sz;
      t1[9] = t1[9] * sz;
      t1[10] = t1[10] * sz;
      t1[11] = t1[11] * sz;
      t1[12] = t1[12];
      t1[13] = t1[13];
      t1[14] = t1[14];
      t1[15] = t1[15];
    },
    setIdentity$0: function() {
      var t1 = this._m4storage;
      t1[0] = 1;
      t1[1] = 0;
      t1[2] = 0;
      t1[3] = 0;
      t1[4] = 0;
      t1[5] = 1;
      t1[6] = 0;
      t1[7] = 0;
      t1[8] = 0;
      t1[9] = 0;
      t1[10] = 1;
      t1[11] = 0;
      t1[12] = 0;
      t1[13] = 0;
      t1[14] = 0;
      t1[15] = 1;
    },
    copyInverse$1: function(arg) {
      var invDet, t1, t2, t3,
        argStorage = arg._m4storage,
        a00 = argStorage[0],
        a01 = argStorage[1],
        a02 = argStorage[2],
        a03 = argStorage[3],
        a10 = argStorage[4],
        a11 = argStorage[5],
        a12 = argStorage[6],
        a13 = argStorage[7],
        a20 = argStorage[8],
        a21 = argStorage[9],
        a22 = argStorage[10],
        a23 = argStorage[11],
        a30 = argStorage[12],
        a31 = argStorage[13],
        a32 = argStorage[14],
        a33 = argStorage[15],
        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (det === 0) {
        this.setFrom$1(arg);
        return 0;
      }
      invDet = 1 / det;
      t1 = this._m4storage;
      t1[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
      t1[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
      t1[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
      t1[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
      t2 = -a10;
      t1[4] = (t2 * b11 + a12 * b08 - a13 * b07) * invDet;
      t1[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
      t3 = -a30;
      t1[6] = (t3 * b05 + a32 * b02 - a33 * b01) * invDet;
      t1[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
      t1[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
      t1[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
      t1[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
      t1[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
      t1[12] = (t2 * b09 + a11 * b07 - a12 * b06) * invDet;
      t1[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
      t1[14] = (t3 * b03 + a31 * b01 - a32 * b00) * invDet;
      t1[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
      return det;
    },
    multiply$1: function(arg) {
      var t1 = this._m4storage,
        m00 = t1[0],
        m01 = t1[4],
        m02 = t1[8],
        m03 = t1[12],
        m10 = t1[1],
        m11 = t1[5],
        m12 = t1[9],
        m13 = t1[13],
        m20 = t1[2],
        m21 = t1[6],
        m22 = t1[10],
        m23 = t1[14],
        m30 = t1[3],
        m31 = t1[7],
        m32 = t1[11],
        m33 = t1[15],
        argStorage = arg._m4storage,
        n00 = argStorage[0],
        n01 = argStorage[4],
        n02 = argStorage[8],
        n03 = argStorage[12],
        n10 = argStorage[1],
        n11 = argStorage[5],
        n12 = argStorage[9],
        n13 = argStorage[13],
        n20 = argStorage[2],
        n21 = argStorage[6],
        n22 = argStorage[10],
        n23 = argStorage[14],
        n30 = argStorage[3],
        n31 = argStorage[7],
        n32 = argStorage[11],
        n33 = argStorage[15];
      t1[0] = m00 * n00 + m01 * n10 + m02 * n20 + m03 * n30;
      t1[4] = m00 * n01 + m01 * n11 + m02 * n21 + m03 * n31;
      t1[8] = m00 * n02 + m01 * n12 + m02 * n22 + m03 * n32;
      t1[12] = m00 * n03 + m01 * n13 + m02 * n23 + m03 * n33;
      t1[1] = m10 * n00 + m11 * n10 + m12 * n20 + m13 * n30;
      t1[5] = m10 * n01 + m11 * n11 + m12 * n21 + m13 * n31;
      t1[9] = m10 * n02 + m11 * n12 + m12 * n22 + m13 * n32;
      t1[13] = m10 * n03 + m11 * n13 + m12 * n23 + m13 * n33;
      t1[2] = m20 * n00 + m21 * n10 + m22 * n20 + m23 * n30;
      t1[6] = m20 * n01 + m21 * n11 + m22 * n21 + m23 * n31;
      t1[10] = m20 * n02 + m21 * n12 + m22 * n22 + m23 * n32;
      t1[14] = m20 * n03 + m21 * n13 + m22 * n23 + m23 * n33;
      t1[3] = m30 * n00 + m31 * n10 + m32 * n20 + m33 * n30;
      t1[7] = m30 * n01 + m31 * n11 + m32 * n21 + m33 * n31;
      t1[11] = m30 * n02 + m31 * n12 + m32 * n22 + m33 * n32;
      t1[15] = m30 * n03 + m31 * n13 + m32 * n23 + m33 * n33;
    },
    transform3$1: function(arg) {
      var argStorage = arg._v3storage,
        t1 = this._m4storage,
        t2 = t1[0],
        t3 = argStorage[0],
        t4 = t1[4],
        t5 = argStorage[1],
        t6 = t1[8],
        t7 = argStorage[2],
        t8 = t1[12],
        t9 = t1[1],
        t10 = t1[5],
        t11 = t1[9],
        t12 = t1[13],
        t13 = t1[2],
        t14 = t1[6],
        t15 = t1[10];
      t1 = t1[14];
      argStorage[0] = t2 * t3 + t4 * t5 + t6 * t7 + t8;
      argStorage[1] = t9 * t3 + t10 * t5 + t11 * t7 + t12;
      argStorage[2] = t13 * t3 + t14 * t5 + t15 * t7 + t1;
      return arg;
    },
    transform$1: function(arg) {
      var argStorage = arg._v4storage,
        t1 = this._m4storage,
        t2 = t1[0],
        t3 = argStorage[0],
        t4 = t1[4],
        t5 = argStorage[1],
        t6 = t1[8],
        t7 = argStorage[2],
        t8 = t1[12],
        t9 = argStorage[3],
        t10 = t1[1],
        t11 = t1[5],
        t12 = t1[9],
        t13 = t1[13],
        t14 = t1[2],
        t15 = t1[6],
        t16 = t1[10],
        t17 = t1[14],
        t18 = t1[3],
        t19 = t1[7],
        t20 = t1[11];
      t1 = t1[15];
      argStorage[0] = t2 * t3 + t4 * t5 + t6 * t7 + t8 * t9;
      argStorage[1] = t10 * t3 + t11 * t5 + t12 * t7 + t13 * t9;
      argStorage[2] = t14 * t3 + t15 * t5 + t16 * t7 + t17 * t9;
      argStorage[3] = t18 * t3 + t19 * t5 + t20 * t7 + t1 * t9;
      return arg;
    },
    perspectiveTransform$1: function(arg) {
      var argStorage = arg._v3storage,
        t1 = this._m4storage,
        t2 = t1[0],
        t3 = argStorage[0],
        t4 = t1[4],
        t5 = argStorage[1],
        t6 = t1[8],
        t7 = argStorage[2],
        t8 = t1[12],
        t9 = t1[1],
        t10 = t1[5],
        t11 = t1[9],
        t12 = t1[13],
        t13 = t1[2],
        t14 = t1[6],
        t15 = t1[10],
        t16 = t1[14],
        w_ = 1 / (t1[3] * t3 + t1[7] * t5 + t1[11] * t7 + t1[15]);
      argStorage[0] = (t2 * t3 + t4 * t5 + t6 * t7 + t8) * w_;
      argStorage[1] = (t9 * t3 + t10 * t5 + t11 * t7 + t12) * w_;
      argStorage[2] = (t13 * t3 + t14 * t5 + t15 * t7 + t16) * w_;
      return arg;
    }
  };
  E.Vector3.prototype = {
    setValues$3: function(x_, y_, z_) {
      var t1 = this._v3storage;
      C.NativeFloat64List_methods.$indexSet(t1, 0, x_);
      C.NativeFloat64List_methods.$indexSet(t1, 1, y_);
      t1[2] = z_;
    },
    setFrom$1: function(other) {
      var otherStorage = other._v3storage,
        t1 = this._v3storage;
      t1[0] = otherStorage[0];
      t1[1] = otherStorage[1];
      t1[2] = otherStorage[2];
    },
    toString$0: function(_) {
      var t1 = this._v3storage;
      return "[" + H.S(t1[0]) + "," + H.S(t1[1]) + "," + H.S(t1[2]) + "]";
    },
    $eq: function(_, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      if (other instanceof E.Vector3) {
        t1 = this._v3storage;
        t2 = t1[0];
        t3 = other._v3storage;
        t1 = t2 === t3[0] && t1[1] === t3[1] && t1[2] === t3[2];
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return A.hashObjects(this._v3storage);
    },
    $sub: function(_, other) {
      var t1, t2, argStorage;
      H.interceptedTypeCheck(other, "$isVector3");
      t1 = new Float64Array(3);
      t2 = new E.Vector3(t1);
      t2.setFrom$1(this);
      argStorage = other._v3storage;
      t1[0] = t1[0] - argStorage[0];
      t1[1] = t1[1] - argStorage[1];
      t1[2] = t1[2] - argStorage[2];
      return t2;
    },
    $add: function(_, other) {
      var t1, t2, argStorage;
      H.interceptedTypeCheck(other, "$isVector3");
      t1 = new Float64Array(3);
      t2 = new E.Vector3(t1);
      t2.setFrom$1(this);
      argStorage = other._v3storage;
      t1[0] = t1[0] + argStorage[0];
      t1[1] = t1[1] + argStorage[1];
      t1[2] = t1[2] + argStorage[2];
      return t2;
    },
    $mul: function(_, scale) {
      var t3,
        t1 = new Float64Array(3),
        t2 = new E.Vector3(t1);
      t2.setFrom$1(this);
      t3 = t1[2];
      if (typeof scale !== "number")
        return H.iae(scale);
      t1[2] = t3 * scale;
      t1[1] = t1[1] * scale;
      t1[0] = t1[0] * scale;
      return t2;
    },
    $index: function(_, i) {
      return C.NativeFloat64List_methods.$index(this._v3storage, i);
    },
    get$length: function(_) {
      var t1 = this._v3storage,
        t2 = t1[0],
        t3 = t1[1];
      t1 = t1[2];
      return Math.sqrt(t2 * t2 + t3 * t3 + t1 * t1);
    },
    dot$1: function(other) {
      var otherStorage = other._v3storage,
        t1 = this._v3storage;
      return t1[0] * otherStorage[0] + t1[1] * otherStorage[1] + t1[2] * otherStorage[2];
    },
    scaled$1: function(arg) {
      var t3,
        t1 = new Float64Array(3),
        t2 = new E.Vector3(t1);
      t2.setFrom$1(this);
      t3 = t1[2];
      if (typeof arg !== "number")
        return H.iae(arg);
      t1[2] = t3 * arg;
      t1[1] = t1[1] * arg;
      t1[0] = t1[0] * arg;
      return t2;
    }
  };
  E.Vector4.prototype = {
    setFrom$1: function(other) {
      var otherStorage = other._v4storage,
        t1 = this._v4storage;
      t1[3] = otherStorage[3];
      t1[2] = otherStorage[2];
      t1[1] = otherStorage[1];
      t1[0] = otherStorage[0];
    },
    toString$0: function(_) {
      var t1 = this._v4storage;
      return H.S(t1[0]) + "," + H.S(t1[1]) + "," + H.S(t1[2]) + "," + H.S(t1[3]);
    },
    $eq: function(_, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      if (other instanceof E.Vector4) {
        t1 = this._v4storage;
        t2 = t1[0];
        t3 = other._v4storage;
        t1 = t2 === t3[0] && t1[1] === t3[1] && t1[2] === t3[2] && t1[3] === t3[3];
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return A.hashObjects(this._v4storage);
    },
    $sub: function(_, other) {
      var t1, t2, argStorage;
      H.interceptedTypeCheck(other, "$isVector4");
      t1 = new Float64Array(4);
      t2 = new E.Vector4(t1);
      t2.setFrom$1(this);
      argStorage = other._v4storage;
      t1[0] = t1[0] - argStorage[0];
      t1[1] = t1[1] - argStorage[1];
      t1[2] = t1[2] - argStorage[2];
      t1[3] = t1[3] - argStorage[3];
      return t2;
    },
    $add: function(_, other) {
      var t1, t2, argStorage;
      H.interceptedTypeCheck(other, "$isVector4");
      t1 = new Float64Array(4);
      t2 = new E.Vector4(t1);
      t2.setFrom$1(this);
      argStorage = other._v4storage;
      t1[0] = t1[0] + argStorage[0];
      t1[1] = t1[1] + argStorage[1];
      t1[2] = t1[2] + argStorage[2];
      t1[3] = t1[3] + argStorage[3];
      return t2;
    },
    $mul: function(_, scale) {
      var t3,
        t1 = new Float64Array(4),
        t2 = new E.Vector4(t1);
      t2.setFrom$1(this);
      t3 = t1[0];
      if (typeof scale !== "number")
        return H.iae(scale);
      t1[0] = t3 * scale;
      t1[1] = t1[1] * scale;
      t1[2] = t1[2] * scale;
      t1[3] = t1[3] * scale;
      return t2;
    },
    $index: function(_, i) {
      var t1 = this._v4storage;
      if (i >= 4)
        return H.ioore(t1, i);
      return t1[i];
    },
    get$length: function(_) {
      var t1 = this._v4storage,
        t2 = t1[0],
        t3 = t1[1],
        t4 = t1[2];
      t1 = t1[3];
      return Math.sqrt(t2 * t2 + t3 * t3 + t4 * t4 + t1 * t1);
    }
  };
  (function aliases() {
    var _ = J.JavaScriptObject.prototype;
    _.super$JavaScriptObject$toString = _.toString$0;
    _ = P.ListMixin.prototype;
    _.super$ListMixin$setRange = _.setRange$4;
    _ = P.Color.prototype;
    _.super$Color$$eq = _.$eq;
    _.super$Color$toString = _.toString$0;
    _ = X.Animation.prototype;
    _.super$Animation$toStringDetails = _.toStringDetails$0;
    _ = S.AnimationEagerListenerMixin.prototype;
    _.super$AnimationEagerListenerMixin$dispose = _.dispose$0;
    _ = N.BindingBase.prototype;
    _.super$BindingBase$initInstances = _.initInstances$0;
    _.super$BindingBase$initServiceExtensions = _.initServiceExtensions$0;
    _.super$BindingBase$unlocked = _.unlocked$0;
    _.super$BindingBase$performReassemble = _.performReassemble$0;
    _ = B.ChangeNotifier.prototype;
    _.super$ChangeNotifier$dispose = _.dispose$0;
    _ = Y.DiagnosticsNode.prototype;
    _.super$DiagnosticsNode$toJsonMap = _.toJsonMap$0;
    _ = Y.DiagnosticsProperty.prototype;
    _.super$DiagnosticsProperty$toJsonMap = _.toJsonMap$0;
    _.super$DiagnosticsProperty$valueToString = _.valueToString$1$parentConfiguration;
    _ = Y.Diagnosticable.prototype;
    _.super$Diagnosticable$debugFillProperties = _.debugFillProperties$1;
    _ = Y.DiagnosticableTreeMixin.prototype;
    _.super$DiagnosticableTreeMixin$toStringShallow = _.toStringShallow$2$joiner$minLevel;
    _.super$DiagnosticableTreeMixin$toStringDeep = _.toStringDeep$3$minLevel$prefixLineOne$prefixOtherLines;
    _.super$DiagnosticableTreeMixin$toStringShort = _.toStringShort$0;
    _.super$DiagnosticableTreeMixin$debugFillProperties = _.debugFillProperties$1;
    _ = B.AbstractNode.prototype;
    _.super$AbstractNode$attach = _.attach$1;
    _.super$AbstractNode$detach = _.detach$0;
    _.super$AbstractNode$adoptChild = _.adoptChild$1;
    _.super$AbstractNode$dropChild = _.dropChild$1;
    _ = N.GestureBinding.prototype;
    _.super$GestureBinding$hitTest = _.hitTest$2;
    _ = F.PointerEvent.prototype;
    _.super$PointerEvent$debugFillProperties = _.debugFillProperties$1;
    _ = S.GestureRecognizer.prototype;
    _.super$GestureRecognizer$dispose = _.dispose$0;
    _.super$GestureRecognizer$debugFillProperties = _.debugFillProperties$1;
    _ = S.OneSequenceGestureRecognizer.prototype;
    _.super$OneSequenceGestureRecognizer$resolve = _.resolve$1;
    _.super$OneSequenceGestureRecognizer$dispose = _.dispose$0;
    _ = S.PrimaryPointerGestureRecognizer.prototype;
    _.super$PrimaryPointerGestureRecognizer$acceptGesture = _.acceptGesture$1;
    _.super$PrimaryPointerGestureRecognizer$rejectGesture = _.rejectGesture$1;
    _.super$PrimaryPointerGestureRecognizer$debugFillProperties = _.debugFillProperties$1;
    _ = R.__InkResponseState_State_AutomaticKeepAliveClientMixin.prototype;
    _.super$__InkResponseState_State_AutomaticKeepAliveClientMixin$deactivate = _.deactivate$0;
    _ = M.InkFeature.prototype;
    _.super$InkFeature$dispose = _.dispose$0;
    _ = M._ScaffoldState_State_TickerProviderStateMixin.prototype;
    _.super$_ScaffoldState_State_TickerProviderStateMixin$dispose = _.dispose$0;
    _.super$_ScaffoldState_State_TickerProviderStateMixin$didChangeDependencies = _.didChangeDependencies$0;
    _ = M.__FloatingActionButtonTransitionState_State_TickerProviderStateMixin.prototype;
    _.super$__FloatingActionButtonTransitionState_State_TickerProviderStateMixin$dispose = _.dispose$0;
    _ = S.__TooltipState_State_SingleTickerProviderStateMixin.prototype;
    _.super$__TooltipState_State_SingleTickerProviderStateMixin$dispose = _.dispose$0;
    _ = K.BorderRadiusGeometry.prototype;
    _.super$BorderRadiusGeometry$subtract = _.subtract$1;
    _.super$BorderRadiusGeometry$add = _.add$1;
    _ = Y.ShapeBorder.prototype;
    _.super$ShapeBorder$lerpFrom = _.lerpFrom$2;
    _.super$ShapeBorder$lerpTo = _.lerpTo$2;
    _ = Z.Decoration.prototype;
    _.super$Decoration$lerpFrom = _.lerpFrom$2;
    _.super$Decoration$lerpTo = _.lerpTo$2;
    _ = Z.BoxPainter.prototype;
    _.super$BoxPainter$dispose = _.dispose$0;
    _ = V.EdgeInsetsGeometry.prototype;
    _.super$EdgeInsetsGeometry$add = _.add$1;
    _ = N.RendererBinding.prototype;
    _.super$RendererBinding$handleMetricsChanged = _.handleMetricsChanged$0;
    _.super$RendererBinding$handleTextScaleFactorChanged = _.handleTextScaleFactorChanged$0;
    _.super$RendererBinding$handlePlatformBrightnessChanged = _.handlePlatformBrightnessChanged$0;
    _.super$RendererBinding$drawFrame = _.drawFrame$0;
    _ = S.BoxConstraints.prototype;
    _.super$BoxConstraints$$eq = _.$eq;
    _ = S.BoxParentData.prototype;
    _.super$BoxParentData$toString = _.toString$0;
    _ = S.RenderBox.prototype;
    _.super$RenderBox$computeDistanceToActualBaseline = _.computeDistanceToActualBaseline$1;
    _.super$RenderBox$hitTest = _.hitTest$2$position;
    _.super$RenderBox$debugPaintSize = _.debugPaintSize$2;
    _.super$RenderBox$debugFillProperties = _.debugFillProperties$1;
    _ = T.Layer.prototype;
    _.super$Layer$updateSubtreeNeedsAddToScene = _.updateSubtreeNeedsAddToScene$0;
    _.super$Layer$debugFillProperties = _.debugFillProperties$1;
    _ = T.ContainerLayer.prototype;
    _.super$ContainerLayer$find = _.find$1$1;
    _ = T.OffsetLayer.prototype;
    _.super$OffsetLayer$find = _.find$1$1;
    _.super$OffsetLayer$debugFillProperties = _.debugFillProperties$1;
    _ = K.ParentData.prototype;
    _.super$ParentData$detach = _.detach$0;
    _ = K.PaintingContext.prototype;
    _.super$PaintingContext$paintChild = _.paintChild$2;
    _.super$PaintingContext$appendLayer = _.appendLayer$1;
    _.super$PaintingContext$stopRecordingIfNeeded = _.stopRecordingIfNeeded$0;
    _.super$PaintingContext$createChildContext = _.createChildContext$2;
    _ = K.RenderObject.prototype;
    _.super$RenderObject$reassemble = _.reassemble$0;
    _.super$RenderObject$attach = _.attach$1;
    _.super$RenderObject$markNeedsLayout = _.markNeedsLayout$0;
    _.super$RenderObject$applyPaintTransform = _.applyPaintTransform$2;
    _.super$RenderObject$describeSemanticsConfiguration = _.describeSemanticsConfiguration$1;
    _.super$RenderObject$clearSemantics = _.clearSemantics$0;
    _.super$RenderObject$visitChildrenForSemantics = _.visitChildrenForSemantics$1;
    _.super$RenderObject$assembleSemanticsNode = _.assembleSemanticsNode$3;
    _.super$RenderObject$handleEvent = _.handleEvent$2;
    _.super$RenderObject$toStringShort = _.toStringShort$0;
    _.super$RenderObject$debugFillProperties = _.debugFillProperties$1;
    _ = K.ContainerRenderObjectMixin.prototype;
    _.super$ContainerRenderObjectMixin$redepthChildren = _.redepthChildren$0;
    _.super$ContainerRenderObjectMixin$visitChildren = _.visitChildren$1;
    _ = E.RenderProxyBoxMixin.prototype;
    _.super$RenderProxyBoxMixin$performLayout = _.performLayout$0;
    _.super$RenderProxyBoxMixin$hitTestChildren = _.hitTestChildren$2$position;
    _.super$RenderProxyBoxMixin$paint = _.paint$2;
    _ = E.RenderProxyBoxWithHitTestBehavior.prototype;
    _.super$RenderProxyBoxWithHitTestBehavior$debugFillProperties = _.debugFillProperties$1;
    _ = E._RenderCustomClip.prototype;
    _.super$_RenderCustomClip$debugPaintSize = _.debugPaintSize$2;
    _ = E._RenderPhysicalModelBase.prototype;
    _.super$_RenderPhysicalModelBase$debugFillProperties = _.debugFillProperties$1;
    _ = E._RenderProxyBox_RenderBox_RenderObjectWithChildMixin.prototype;
    _.super$_RenderProxyBox_RenderBox_RenderObjectWithChildMixin$attach = _.attach$1;
    _.super$_RenderProxyBox_RenderBox_RenderObjectWithChildMixin$detach = _.detach$0;
    _ = E._RenderProxyBox_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin.prototype;
    _.super$_RenderProxyBox_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin$computeDistanceToActualBaseline = _.computeDistanceToActualBaseline$1;
    _ = T.RenderAligningShiftedBox.prototype;
    _.super$RenderAligningShiftedBox$debugFillProperties = _.debugFillProperties$1;
    _ = T._RenderShiftedBox_RenderBox_RenderObjectWithChildMixin.prototype;
    _.super$_RenderShiftedBox_RenderBox_RenderObjectWithChildMixin$attach = _.attach$1;
    _.super$_RenderShiftedBox_RenderBox_RenderObjectWithChildMixin$detach = _.detach$0;
    _ = N.SchedulerBinding.prototype;
    _.super$SchedulerBinding$handleAppLifecycleStateChanged = _.handleAppLifecycleStateChanged$1;
    _ = M.Ticker.prototype;
    _.super$Ticker$dispose = _.dispose$0;
    _ = N.SemanticsBinding.prototype;
    _.super$SemanticsBinding$handleAccessibilityFeaturesChanged = _.handleAccessibilityFeaturesChanged$0;
    _ = Q.AssetBundle.prototype;
    _.super$AssetBundle$loadString = _.loadString$2$cache;
    _ = N.ServicesBinding.prototype;
    _.super$ServicesBinding$evict = _.evict$1;
    _ = A.MethodChannel.prototype;
    _.super$MethodChannel$invokeMethod = _.invokeMethod$1$2;
    _ = L.AutomaticKeepAliveClientMixin.prototype;
    _.super$AutomaticKeepAliveClientMixin$build = _.build$1;
    _ = N._WidgetsFlutterBinding_BindingBase_GestureBinding.prototype;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding$initInstances = _.initInstances$0;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding$unlocked = _.unlocked$0;
    _ = N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding.prototype;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding$initInstances = _.initInstances$0;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding$initServiceExtensions = _.initServiceExtensions$0;
    _ = N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding.prototype;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding$initInstances = _.initInstances$0;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding$initServiceExtensions = _.initServiceExtensions$0;
    _ = N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding.prototype;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding$initInstances = _.initInstances$0;
    _ = N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding.prototype;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding$initInstances = _.initInstances$0;
    _ = N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding.prototype;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding$initInstances = _.initInstances$0;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding$initServiceExtensions = _.initServiceExtensions$0;
    _.super$_WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding$performReassemble = _.performReassemble$0;
    _ = O.FocusNode.prototype;
    _.super$FocusNode$debugFillProperties = _.debugFillProperties$1;
    _ = N.Widget.prototype;
    _.super$Widget$debugFillProperties = _.debugFillProperties$1;
    _ = N.State.prototype;
    _.super$State$initState = _.initState$0;
    _.super$State$didUpdateWidget = _.didUpdateWidget$1;
    _.super$State$deactivate = _.deactivate$0;
    _.super$State$dispose = _.dispose$0;
    _.super$State$didChangeDependencies = _.didChangeDependencies$0;
    _.super$State$debugFillProperties = _.debugFillProperties$1;
    _ = N.Element.prototype;
    _.super$Element$reassemble = _.reassemble$0;
    _.super$Element$mount = _.mount$2;
    _.super$Element$update = _.update$1;
    _.super$Element$_updateSlot = _._updateSlot$1;
    _.super$Element$activate = _.activate$0;
    _.super$Element$deactivate = _.deactivate$0;
    _.super$Element$debugDeactivated = _.debugDeactivated$0;
    _.super$Element$unmount = _.unmount$0;
    _.super$Element$inheritFromElement = _.inheritFromElement$2$aspect;
    _.super$Element$didChangeDependencies = _.didChangeDependencies$0;
    _.super$Element$debugFillProperties = _.debugFillProperties$1;
    _ = N.ComponentElement.prototype;
    _.super$ComponentElement$mount = _.mount$2;
    _.super$ComponentElement$_firstBuild = _._firstBuild$0;
    _ = N.ProxyElement.prototype;
    _.super$ProxyElement$build = _.build$0;
    _.super$ProxyElement$update = _.update$1;
    _.super$ProxyElement$updated = _.updated$1;
    _ = N.InheritedElement.prototype;
    _.super$InheritedElement$notifyClients = _.notifyClients$1;
    _ = N.RenderObjectElement.prototype;
    _.super$RenderObjectElement$mount = _.mount$2;
    _.super$RenderObjectElement$update = _.update$1;
    _.super$RenderObjectElement$performRebuild = _.performRebuild$0;
    _ = N.RootRenderObjectElement.prototype;
    _.super$RootRenderObjectElement$mount = _.mount$2;
    _ = G.ImplicitlyAnimatedWidget.prototype;
    _.super$ImplicitlyAnimatedWidget$debugFillProperties = _.debugFillProperties$1;
    _ = G.ImplicitlyAnimatedWidgetState.prototype;
    _.super$ImplicitlyAnimatedWidgetState$initState = _.initState$0;
    _ = G._ImplicitlyAnimatedWidgetState_State_SingleTickerProviderStateMixin.prototype;
    _.super$_ImplicitlyAnimatedWidgetState_State_SingleTickerProviderStateMixin$dispose = _.dispose$0;
    _.super$_ImplicitlyAnimatedWidgetState_State_SingleTickerProviderStateMixin$debugFillProperties = _.debugFillProperties$1;
    _ = K.Route.prototype;
    _.super$Route$install = _.install$1;
    _.super$Route$willPop = _.willPop$0;
    _.super$Route$didPop = _.didPop$1;
    _.super$Route$didPopNext = _.didPopNext$1;
    _.super$Route$didChangeNext = _.didChangeNext$1;
    _.super$Route$didChangePrevious = _.didChangePrevious$1;
    _.super$Route$changedInternalState = _.changedInternalState$0;
    _.super$Route$changedExternalState = _.changedExternalState$0;
    _.super$Route$dispose = _.dispose$0;
    _ = K._NavigatorState_State_TickerProviderStateMixin.prototype;
    _.super$_NavigatorState_State_TickerProviderStateMixin$dispose = _.dispose$0;
    _ = X._OverlayState_State_TickerProviderStateMixin.prototype;
    _.super$_OverlayState_State_TickerProviderStateMixin$debugFillProperties = _.debugFillProperties$1;
    _ = X.__RenderTheatre_RenderBox_RenderObjectWithChildMixin.prototype;
    _.super$__RenderTheatre_RenderBox_RenderObjectWithChildMixin$attach = _.attach$1;
    _.super$__RenderTheatre_RenderBox_RenderObjectWithChildMixin$detach = _.detach$0;
    _ = T.OverlayRoute.prototype;
    _.super$OverlayRoute$install = _.install$1;
    _.super$OverlayRoute$didPop = _.didPop$1;
    _.super$OverlayRoute$dispose = _.dispose$0;
    _ = T.TransitionRoute.prototype;
    _.super$TransitionRoute$createAnimationController = _.createAnimationController$0;
    _.super$TransitionRoute$install = _.install$1;
    _.super$TransitionRoute$didPush = _.didPush$0;
    _.super$TransitionRoute$didPop = _.didPop$1;
    _ = T._ModalRoute_TransitionRoute_LocalHistoryRoute.prototype;
    _.super$_ModalRoute_TransitionRoute_LocalHistoryRoute$willPop = _.willPop$0;
  })();
  (function installTearOffs() {
    var _static_2 = hunkHelpers._static_2,
      _static_0 = hunkHelpers._static_0,
      _static_1 = hunkHelpers._static_1,
      _instance = hunkHelpers.installInstanceTearOff,
      _instance_1_u = hunkHelpers._instance_1u,
      _instance_2_u = hunkHelpers._instance_2u,
      _instance_0_u = hunkHelpers._instance_0u,
      _static = hunkHelpers.installStaticTearOff,
      _instance_1_i = hunkHelpers._instance_1i;
    _static_2(J, "_interceptors_JSArray__compareAny$closure", "JSArray__compareAny", 45);
    _static_0(H, "_js_helper_Primitives_dateNow$closure", "Primitives_dateNow", 54);
    _static_1(P, "async__AsyncRun__scheduleImmediateJsOverride$closure", "_AsyncRun__scheduleImmediateJsOverride", 30);
    _static_1(P, "async__AsyncRun__scheduleImmediateWithSetImmediate$closure", "_AsyncRun__scheduleImmediateWithSetImmediate", 30);
    _static_1(P, "async__AsyncRun__scheduleImmediateWithTimer$closure", "_AsyncRun__scheduleImmediateWithTimer", 30);
    _static_0(P, "async___startMicrotaskLoop$closure", "_startMicrotaskLoop", 1);
    _instance(P._Completer.prototype, "get$completeError", 0, 1, null, ["call$2", "call$1"], ["completeError$2", "completeError$1"], 39, 0);
    _instance(P._SyncCompleter.prototype, "get$complete", 0, 0, null, ["call$1", "call$0"], ["complete$1", "complete$0"], 43, 0);
    _instance(P._Future.prototype, "get$_completeError", 0, 1, null, ["call$2", "call$1"], ["_completeError$2", "_completeError$1"], 39, 0);
    var _;
    _instance_1_u(_ = P._StreamController.prototype, "get$_async$_add", "_async$_add$1", 85);
    _instance_2_u(_, "get$_addError", "_addError$2", 64);
    _instance_0_u(_, "get$_close", "_close$0", 1);
    _instance_0_u(_ = P._ControllerSubscription.prototype, "get$_onPause", "_onPause$0", 1);
    _instance_0_u(_, "get$_onResume", "_onResume$0", 1);
    _instance_0_u(_ = P._BufferingStreamSubscription.prototype, "get$_onPause", "_onPause$0", 1);
    _instance_0_u(_, "get$_onResume", "_onResume$0", 1);
    _static_2(P, "collection___dynamicCompare$closure", "_dynamicCompare", 45);
    _static_1(P, "convert___defaultToEncodable$closure", "_defaultToEncodable", 23);
    _static_2(P, "core_Comparable_compare$closure", "Comparable_compare", 194);
    _instance(P.StringBuffer.prototype, "get$writeln", 0, 0, null, ["call$1", "call$0"], ["writeln$1", "writeln$0"], 43, 0);
    _instance(_ = G.AnimationController.prototype, "get$reverse", 0, 0, null, ["call$1$from", "call$0"], ["reverse$1$from", "reverse$0"], 108, 0);
    _instance_1_u(_, "get$_tick", "_tick$1", 13);
    _instance_1_u(S.ReverseAnimation.prototype, "get$_statusChangeHandler", "_statusChangeHandler$1", 5);
    _instance_1_u(S.CurvedAnimation.prototype, "get$_updateCurveDirection", "_updateCurveDirection$1", 5);
    _instance_1_u(_ = S.TrainHoppingAnimation.prototype, "get$_statusChangeHandler", "_statusChangeHandler$1", 5);
    _instance_0_u(_, "get$_valueChangeHandler", "_valueChangeHandler$0", 1);
    _instance_1_u(_ = S.CompoundAnimation.prototype, "get$_maybeNotifyStatusListeners", "_maybeNotifyStatusListeners$1", 5);
    _instance_0_u(_, "get$_maybeNotifyListeners", "_maybeNotifyListeners$0", 1);
    _instance_0_u(S.AnimationLocalListenersMixin.prototype, "get$notifyListeners", "notifyListeners$0", 1);
    _instance_1_u(S.AnimationLocalStatusListenersMixin.prototype, "get$notifyStatusListeners", "notifyStatusListeners$1", 5);
    _instance_1_u(_ = D._CupertinoBackGestureDetectorState.prototype, "get$_handleDragStart", "_handleDragStart$1", 66);
    _instance_1_u(_, "get$_handleDragUpdate", "_handleDragUpdate$1", 24);
    _instance_1_u(_, "get$_handleDragEnd", "_handleDragEnd$1", 40);
    _instance_0_u(_, "get$_handleDragCancel", "_handleDragCancel$0", 1);
    _instance_1_u(_, "get$_route$_handlePointerDown", "_route$_handlePointerDown$1", 29);
    _static(U, "assertions_FlutterError_dumpErrorToConsole$closure", 1, null, ["call$2$forceReport", "call$1"], ["FlutterError_dumpErrorToConsole", function(details) {
      return U.FlutterError_dumpErrorToConsole(details, false);
    }], 195, 0);
    _static_0(N, "binding0___exitApplication$closure", "_exitApplication", 6);
    _instance_0_u(_ = N.BindingBase.prototype, "get$reassembleApplication", "reassembleApplication$0", 6);
    _instance(_, "get$registerServiceExtension", 0, 0, null, ["call$2$callback$name", "call$0"], ["registerServiceExtension$2$callback$name", "registerServiceExtension$0"], 90, 0);
    _instance_1_i(Y.DiagnosticPropertiesBuilder.prototype, "get$add", "add$1", 101);
    _static(F, "isolates___spawn$closure", 1, null, ["call$2$1", "call$1"], ["_spawn", function(configuration) {
      return F._spawn(configuration, null, null);
    }], 196, 0);
    _instance_1_u(B.AbstractNode.prototype, "get$redepthChild", "redepthChild$1", 112);
    _static(D, "print__debugPrintThrottled$closure", 1, null, ["call$2$wrapWidth", "call$1"], ["debugPrintThrottled", function(message) {
      return D.debugPrintThrottled(message, null);
    }], 197, 0);
    _static_0(D, "print___debugPrintTask$closure", "_debugPrintTask", 1);
    _instance_1_u(_ = N.GestureBinding.prototype, "get$_handlePointerDataPacket", "_handlePointerDataPacket$1", 139);
    _instance_1_u(_, "get$cancelPointer", "cancelPointer$1", 42);
    _instance_0_u(_, "get$_flushPointerEventQueue", "_flushPointerEventQueue$0", 1);
    _instance_0_u(T.LongPressGestureRecognizer.prototype, "get$didExceedDeadline", "didExceedDeadline$0", 1);
    _instance_1_u(O.DragGestureRecognizer.prototype, "get$handleEvent", "handleEvent$1", 14);
    _instance_1_u(Y.MouseTracker.prototype, "get$_mouse_tracking$_handleEvent", "_mouse_tracking$_handleEvent$1", 14);
    _instance_0_u(F._CountdownZoned.prototype, "get$_onTimeout", "_onTimeout$0", 1);
    _instance_1_u(_ = F.DoubleTapGestureRecognizer.prototype, "get$_handleEvent", "_handleEvent$1", 14);
    _instance_1_u(_, "get$_reject", "_reject$1", 193);
    _instance_0_u(_, "get$_reset", "_reset$0", 1);
    _instance_1_u(_ = S.PrimaryPointerGestureRecognizer.prototype, "get$handleEvent", "handleEvent$1", 14);
    _instance_0_u(_, "get$didExceedDeadline", "didExceedDeadline$0", 1);
    _instance_0_u(N.TapGestureRecognizer.prototype, "get$didExceedDeadline", "didExceedDeadline$0", 1);
    _instance_2_u(S._MaterialAppState.prototype, "get$_createRectTween", "_createRectTween$2", 60);
    _instance_0_u(_ = E._AppBarState.prototype, "get$_handleDrawerButton", "_handleDrawerButton$0", 1);
    _instance_0_u(_, "get$_handleDrawerButtonEnd", "_handleDrawerButtonEnd$0", 1);
    _instance_1_u(Z._RawMaterialButtonState.prototype, "get$_handleHighlightChanged", "_handleHighlightChanged$1", 38);
    _instance_1_u(Y.InkHighlight.prototype, "get$_handleAlphaStatusChanged", "_handleAlphaStatusChanged$1", 5);
    _instance_1_u(U.InkSplash.prototype, "get$_ink_splash$_handleAlphaStatusChanged", "_ink_splash$_handleAlphaStatusChanged$1", 5);
    _instance_0_u(_ = R._InkResponseState.prototype, "get$_handleInkHighlightRemoval", "_handleInkHighlightRemoval$0", 1);
    _instance_1_u(_, "get$_handleTapDown", "_handleTapDown$1", 69);
    _instance_0_u(_, "get$_handleTapCancel", "_handleTapCancel$0", 1);
    _instance_1_u(_ = M._FloatingActionButtonTransitionState.prototype, "get$_handlePreviousAnimationStatusChanged", "_handlePreviousAnimationStatusChanged$1", 5);
    _instance_0_u(_, "get$_onProgressChanged", "_onProgressChanged$0", 1);
    _instance_0_u(M.ScaffoldState.prototype, "get$_handleStatusBarTap", "_handleStatusBarTap$0", 1);
    _instance_1_u(_ = S._TooltipState.prototype, "get$_handleStatusChanged", "_handleStatusChanged$1", 5);
    _instance_1_u(_, "get$_tooltip$_handlePointerEvent", "_tooltip$_handlePointerEvent$1", 14);
    _instance_0_u(_, "get$_handleLongPress", "_handleLongPress$0", 1);
    _instance_0_u(_ = N.RendererBinding.prototype, "get$_handleSemanticsEnabledChanged", "_handleSemanticsEnabledChanged$0", 1);
    _instance(_, "get$_handleSemanticsAction", 0, 3, null, ["call$3"], ["_handleSemanticsAction$3"], 87, 0);
    _instance_0_u(_, "get$_handleSemanticsOwnerCreated", "_handleSemanticsOwnerCreated$0", 1);
    _instance_0_u(_, "get$_handleSemanticsOwnerDisposed", "_handleSemanticsOwnerDisposed$0", 1);
    _instance_1_u(_, "get$_handlePersistentFrameCallback", "_handlePersistentFrameCallback$1", 13);
    _instance_2_u(S.RenderBoxContainerDefaultsMixin.prototype, "get$defaultPaint", "defaultPaint$2", 32);
    _instance_1_u(B.MultiChildLayoutDelegate.prototype, "get$_debugDescribeChild", "_debugDescribeChild$1", 93);
    _instance_0_u(_ = K.RenderObject.prototype, "get$markNeedsPaint", "markNeedsPaint$0", 1);
    _instance(_, "get$showOnScreen", 0, 0, null, ["call$4$curve$descendant$duration$rect", "call$0"], ["showOnScreen$4$curve$descendant$duration$rect", "showOnScreen$0"], 95, 0);
    _instance_2_u(E.RenderProxyBoxMixin.prototype, "get$paint", "paint$2", 32);
    _instance_0_u(E.RenderAnimatedOpacity.prototype, "get$_updateOpacity", "_updateOpacity$0", 1);
    _instance_0_u(_ = E.RenderSemanticsGestureHandler.prototype, "get$_performSemanticScrollLeft", "_performSemanticScrollLeft$0", 1);
    _instance_0_u(_, "get$_performSemanticScrollRight", "_performSemanticScrollRight$0", 1);
    _instance_0_u(_, "get$_performSemanticScrollUp", "_performSemanticScrollUp$0", 1);
    _instance_0_u(_, "get$_performSemanticScrollDown", "_performSemanticScrollDown$0", 1);
    _instance_0_u(E.RenderSemanticsAnnotations.prototype, "get$_performDismiss", "_performDismiss$0", 1);
    _instance_2_u(K.RenderStack.prototype, "get$paintStack", "paintStack$2", 32);
    _static_2(N, "binding_SchedulerBinding__taskSorter$closure", "SchedulerBinding__taskSorter", 198);
    _static(N, "binding__defaultSchedulingStrategy$closure", 0, null, ["call$2$priority$scheduler", "call$0"], ["defaultSchedulingStrategy", function() {
      return N.defaultSchedulingStrategy(null, null);
    }], 199, 0);
    _instance_1_u(_ = N.SchedulerBinding.prototype, "get$_handleLifecycleMessage", "_handleLifecycleMessage$1", 98);
    _instance_0_u(_, "get$_runTasks", "_runTasks$0", 1);
    _instance_0_u(_, "get$ensureVisualUpdate", "ensureVisualUpdate$0", 1);
    _instance_1_u(_, "get$_handleBeginFrame", "_handleBeginFrame$1", 13);
    _instance_0_u(_, "get$_handleDrawFrame", "_handleDrawFrame$0", 1);
    _instance_1_u(M.Ticker.prototype, "get$_ticker$_tick", "_ticker$_tick$1", 13);
    _static_1(Q, "asset_bundle_AssetBundle__utf8decode$closure", "AssetBundle__utf8decode", 200);
    _static_1(N, "binding1_ServicesBinding__parseLicenses$closure", "ServicesBinding__parseLicenses", 201);
    _instance_0_u(N.ServicesBinding.prototype, "get$_addLicenses", "_addLicenses$0", 111);
    _static(B, "platform_messages_BinaryMessages_handlePlatformMessage$closure", 3, null, ["call$3"], ["BinaryMessages_handlePlatformMessage"], 202, 0);
    _instance_1_u(B.RawKeyboard.prototype, "get$_handleKeyEvent", "_handleKeyEvent$1", 114);
    _instance_1_u(_ = S._WidgetsAppState.prototype, "get$_onGenerateRoute", "_onGenerateRoute$1", 49);
    _instance_1_u(_, "get$_onUnknownRoute", "_onUnknownRoute$1", 49);
    _instance_0_u(_ = N.WidgetsBinding.prototype, "get$handleLocaleChanged", "handleLocaleChanged$0", 1);
    _instance_1_u(_, "get$_handleNavigationInvocation", "_handleNavigationInvocation$1", 126);
    _instance_1_u(_, "get$_handleSystemMessage", "_handleSystemMessage$1", 127);
    _instance_0_u(_, "get$_handleBuildScheduled", "_handleBuildScheduled$0", 1);
    _instance_0_u(_ = N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding.prototype, "get$handleMetricsChanged", "handleMetricsChanged$0", 1);
    _instance_0_u(_, "get$handleTextScaleFactorChanged", "handleTextScaleFactorChanged$0", 1);
    _instance_0_u(_, "get$handlePlatformBrightnessChanged", "handlePlatformBrightnessChanged$0", 1);
    _instance_0_u(_, "get$handleAccessibilityFeaturesChanged", "handleAccessibilityFeaturesChanged$0", 1);
    _instance_0_u(_, "get$performReassemble", "performReassemble$0", 6);
    _instance_1_u(_ = O.FocusManager.prototype, "get$_handleRawKeyEvent", "_handleRawKeyEvent$1", 132);
    _instance_0_u(_, "get$_applyFocusChange", "_applyFocusChange$0", 1);
    _instance_0_u(L._FocusState.prototype, "get$_handleFocusChanged", "_handleFocusChanged$0", 1);
    _static_2(N, "framework_Element__sort$closure", "Element__sort", 135);
    _static_1(N, "framework_Element__activateRecursively$closure", "Element__activateRecursively", 9);
    _instance_1_u(_ = N._InactiveElements.prototype, "get$_unmount", "_unmount$1", 9);
    _instance_1_u(_, "get$_deactivateRecursively", "_deactivateRecursively$1", 9);
    _instance_1_u(_ = D.RawGestureDetectorState.prototype, "get$_gesture_detector$_handlePointerDown", "_gesture_detector$_handlePointerDown$1", 29);
    _instance_0_u(_, "get$_handleSemanticsTap", "_handleSemanticsTap$0", 1);
    _instance_0_u(_, "get$_handleSemanticsLongPress", "_handleSemanticsLongPress$0", 1);
    _instance_1_u(_, "get$_handleSemanticsHorizontalDragUpdate", "_handleSemanticsHorizontalDragUpdate$1", 24);
    _instance_1_u(_, "get$_handleSemanticsVerticalDragUpdate", "_handleSemanticsVerticalDragUpdate$1", 24);
    _instance_1_u(_ = T._HeroFlight.prototype, "get$_buildOverlay", "_buildOverlay$1", 11);
    _instance_1_u(_, "get$_handleAnimationUpdate", "_handleAnimationUpdate$1", 5);
    _instance_1_u(T.HeroController.prototype, "get$_handleFlightEnded", "_handleFlightEnded$1", 159);
    _instance_0_u(G.AnimatedWidgetBaseState.prototype, "get$_handleAnimationChanged", "_handleAnimationChanged$0", 1);
    _instance_0_u(S._InheritedNotifierElement.prototype, "get$_handleUpdate", "_handleUpdate$0", 1);
    _instance(_ = K.NavigatorState.prototype, "get$push", 0, 1, null, ["call$1$1", "call$1"], ["push$1$1", "push$1"], 170, 0);
    _instance_1_u(_, "get$_handlePointerDown", "_handlePointerDown$1", 29);
    _instance_1_u(_, "get$_handlePointerUpOrCancel", "_handlePointerUpOrCancel$1", 14);
    _instance_1_u(U.Notification.prototype, "get$visitAncestor", "visitAncestor$1", 22);
    _instance_1_u(T.TransitionRoute.prototype, "get$_routes$_handleStatusChanged", "_routes$_handleStatusChanged$1", 5);
    _instance_1_u(_ = T.ModalRoute.prototype, "get$_buildModalBarrier", "_buildModalBarrier$1", 11);
    _instance_1_u(_, "get$_buildModalScope", "_buildModalScope$1", 11);
    _instance_0_u(K._AnimatedState.prototype, "get$_handleChange", "_handleChange$0", 1);
    _instance_0_u(_ = N.WidgetInspectorService.prototype, "get$disposeAllGroups", "disposeAllGroups$0", 1);
    _instance_1_u(_, "get$disposeGroup", "disposeGroup$1", 41);
    _instance_1_u(_, "get$_decrementReferenceCount", "_decrementReferenceCount$1", 173);
    _instance(_, "get$isWidgetTreeReady", 0, 0, null, ["call$1", "call$0"], ["isWidgetTreeReady$1", "isWidgetTreeReady$0"], 174, 0);
    _instance_2_u(_, "get$disposeId", "disposeId$2", 175);
    _instance_1_u(_, "get$setPubRootDirectories", "setPubRootDirectories$1", 176);
    _instance(_, "get$setSelectionById", 0, 1, null, ["call$2", "call$1"], ["setSelectionById$2", "setSelectionById$1"], 177, 0);
    _instance_2_u(_, "get$_getParentChain", "_getParentChain$2", 20);
    _instance_2_u(_, "get$_getProperties", "_getProperties$2", 20);
    _instance_2_u(_, "get$_getChildren", "_getChildren$2", 20);
    _instance_2_u(_, "get$_getChildrenSummaryTree", "_getChildrenSummaryTree$2", 20);
    _instance_2_u(_, "get$_getChildrenDetailsSubtree", "_getChildrenDetailsSubtree$2", 20);
    _instance_1_u(_, "get$_getRootWidget", "_getRootWidget$1", 37);
    _instance_1_u(_, "get$_getRootWidgetSummaryTree", "_getRootWidgetSummaryTree$1", 37);
    _instance_1_u(_, "get$_getRootRenderObject", "_getRootRenderObject$1", 37);
    _instance_2_u(_, "get$_getDetailsSubtree", "_getDetailsSubtree$2", 26);
    _instance_2_u(_, "get$_getSelectedRenderObject", "_getSelectedRenderObject$2", 26);
    _instance_2_u(_, "get$_getSelectedWidget", "_getSelectedWidget$2", 26);
    _instance_2_u(_, "get$_getSelectedSummaryWidget", "_getSelectedSummaryWidget$2", 26);
    _instance_0_u(_, "get$isWidgetCreationTracked", "isWidgetCreationTracked$0", 0);
    _instance_1_u(_, "get$_onFrameStart", "_onFrameStart$1", 13);
    _instance_1_u(_, "get$_onFrameEnd", "_onFrameEnd$1", 13);
    _instance_2_u(_, "get$_onRebuildWidget", "_onRebuildWidget$2", 181);
    _instance_1_u(_, "get$_onPaint", "_onPaint$1", 33);
    _instance_1_u(_ = N._WidgetInspectorState.prototype, "get$_handlePanDown", "_handlePanDown$1", 189);
    _instance_1_u(_, "get$_handlePanUpdate", "_handlePanUpdate$1", 24);
    _instance_1_u(_, "get$_handlePanEnd", "_handlePanEnd$1", 40);
    _instance_0_u(_, "get$_handleTap", "_handleTap$0", 1);
    _instance_0_u(_, "get$_handleEnableSelect", "_handleEnableSelect$0", 1);
    _instance_0_u(F._MyHomePageState.prototype, "get$_incrementCounter", "_incrementCounter$0", 1);
  })();
  (function inheritance() {
    var _mixin = hunkHelpers.mixin,
      _inherit = hunkHelpers.inherit,
      _inheritMany = hunkHelpers.inheritMany;
    _inherit(P.Object, null);
    _inheritMany(P.Object, [H.JS_CONST, J.Interceptor, J.JSObject, J.ArrayIterator, P.Iterable, H.ListIterator, P.Iterator, H.ExpandIterator, H.EmptyIterator, H.WhereTypeIterator, H.FixedLengthListMixin, H.ConstantMap, H.Closure, H.TypeErrorDecoder, P.Error, H.ExceptionAndStackTrace, H._StackTrace, H.TypeImpl, P.MapMixin, H.LinkedHashMapCell, H.LinkedHashMapKeyIterator, H.JSSyntaxRegExp, H._MatchImplementation, H.StringMatch, P._TimerImpl, P._AsyncAwaitCompleter, P._AsyncStarStreamController, P._IterationMarker, P._SyncStarIterator, P.Future, P._Completer, P._FutureListener, P._Future, P._AsyncCallbackEntry, P.Stream, P.StreamTransformerBase, P._StreamController, P._AsyncStreamControllerDispatch, P._BufferingStreamSubscription, P._AddStreamState, P._PendingEvents, P._DelayedEvent, P._DelayedDone, P._StreamIterator, P.AsyncError, P._Zone, P._HashMapKeyIterator, P._SetBase, P._HashSetIterator, P._LinkedHashSetCell, P._LinkedHashSetIterator, P.HashSet, P.IterableMixin, P.LinkedHashSet, P._ListBase_Object_ListMixin, P.ListMixin, P._ListQueueIterator, P.SetMixin, P._SplayTreeNode, P._SplayTree, P._SplayTreeIterator, P.Codec, P._JsonStringifier, P._Utf8Encoder, P._Utf8Decoder, P.bool, P.Comparable, P.num, P.Duration, P.OutOfMemoryError, P.StackOverflowError, P._Exception, P.FormatException, P.List, P.Map, P.Null, P.StackTrace, P.Stopwatch, P.String, P.StringBuffer, P.Type, P._Uri, P.UriData, P._SimpleUri, P.ServiceExtensionResponse, P.Flow, P._SyncBlock, P.ByteBuffer, P.Endian, P.ByteData, P.Int8List, P.Uint8List, P.Uint16List, P.Int32List, P.Float64List, P.SceneBuilder, P.OffsetBase, P.Rect, P.Radius, P.RRect, P._HashEnd, P.Color, P.BlendMode, P.FilterQuality, P.StrokeCap, P.StrokeJoin, P.PaintingStyle, P.Clip, P.Paint, P.Image, P.PathFillType, P.PathOperation, P.Path, P.BlurStyle, P.MaskFilter, P.ColorFilter, P.Shader, P.TileMode, P.ClipOp, P.Canvas, P.PictureRecorder, P.Shadow, P.PointerDeviceKind, P.PointerSignalKind, P.PointerData, P.PointerDataPacket, P.SemanticsAction, P.SemanticsFlag, P.SemanticsUpdateBuilder, P.FontStyle, P.FontWeight, P.TextAlign, P.TextBaseline, P.TextDecoration, P.TextDecorationStyle, P.TextStyle, P.ParagraphStyle, P.TextDirection, P.TextAffinity, P.ParagraphConstraints, P.ParagraphBuilder, P.AppLifecycleState, P.WindowPadding, P.Locale, P.Window, P.Brightness, Y.HeapPriorityQueue, X.AnimationStatus, B.Listenable, G._AnimationDirection, G.AnimationBehavior, T.Simulation, S.AnimationWithParentMixin, S._TrainHoppingMode, Z.Curve, S.AnimationLazyListenerMixin, S.AnimationEagerListenerMixin, S.AnimationLocalListenersMixin, S.AnimationLocalStatusListenersMixin, R.Animatable, L.CupertinoLocalizations, L.LocalizationsDelegate, L.DefaultCupertinoLocalizations, Y.Diagnosticable, D._CupertinoBackGestureController, Z.BoxPainter, U.FlutterErrorDetails, N.BindingBase, B.ChangeNotifier, Y.DiagnosticLevel, Y.DiagnosticsTreeStyle, Y.TextTreeConfiguration, Y._PrefixedStringBuilder, Y._NoDefaultValue, Y.DiagnosticsNode, Y.DiagnosticPropertiesBuilder, Y.DiagnosticableTreeMixin, F._IsolateConfiguration, D.Key, D._TypeLiteral, F.LicenseEntry, B.AbstractNode, T.TargetPlatform, D._WordWrapParseMode, G.WriteBuffer, G.ReadBuffer, O.SynchronousFuture, D.GestureDisposition, D.GestureArenaMember, D.GestureArenaEntry, D._GestureArena, D.GestureArenaManager, N.GestureBinding, G._PointerState, O.DragDownDetails, O.DragStartDetails, O.DragUpdateDetails, O.DragEndDetails, O.HitTestEntry, O.HitTestResult, T.LongPressStartDetails, T.LongPressMoveUpdateDetails, T.LongPressEndDetails, B._Vector, B._Matrix, B.PolynomialFit, B.LeastSquaresSolver, O._DragState, Y.MouseTrackerAnnotation, Y._TrackedAnnotation, Y.MouseTracker, F._CountdownZoned, F._TapTracker, O.PointerRouter, G.PointerSignalResolver, S.DragStartBehavior, S.GestureRecognizerState, N.TapDownDetails, N.TapUpDetails, R.Velocity, R.VelocityEstimate, R._PointAtTime, R.VelocityTracker, K.ScrollBehavior, T.SingleChildLayoutDelegate, D._CornerId, D._Diagonal, M.ButtonTextTheme, M.ButtonBarLayoutBehavior, E._DefaultHeroTag, A.FloatingActionButtonLocation, A.FloatingActionButtonAnimator, M.InkFeature, R.InteractiveInkFeatureFactory, Y.ShapeBorder, M.MaterialType, U.MaterialLocalizations, U.DefaultMaterialLocalizations, K.Route, K.PageTransitionsBuilder, M._ScaffoldSlot, M.ScaffoldPrelayoutGeometry, M.ScaffoldGeometry, K.Constraints, B.MultiChildLayoutDelegate, M.ScaffoldFeatureController, Q.ShowValueIndicator, Q.SliderTrackShape, Q.SliderTickMarkShape, Q.SliderComponentShape, Q.BaseSliderTrackShape, N.SnackBarClosedReason, K.SnackBarBehavior, X.MaterialTapTargetSize, X._IdentityThemeDataCacheKey, X._FifoCache, U.ScriptCategory, K.AlignmentGeometry, G.RenderComparison, G.Axis, G.VerticalDirection, N.PaintingBinding, K.BorderRadiusGeometry, Y.BorderStyle, Y.BorderSide, F.BoxShape, Z.ClipContext, E.HSVColor, X.DecorationImage, V.EdgeInsetsGeometry, T._ColorsAndStops, T.Gradient, E.ImageCache, E._CachedImage, E._PendingImage, M.ImageConfiguration, V.NotchedShape, D.ShaderWarmUp, U.TextPainter, N.Tolerance, N.RendererBinding, K.ParentData, S._IntrinsicDimensionsCacheEntry, S.RenderBoxContainerDefaultsMixin, V.CustomPainterSemantics, T._OverflowSide, T._OverflowRegionData, T.DebugOverflowIndicatorMixin, F.FlexFit, F.MainAxisSize, F.MainAxisAlignment, F.CrossAxisAlignment, K.PipelineOwner, K.RenderObjectWithChildMixin, K.ContainerParentDataMixin, K.ContainerRenderObjectMixin, K._SemanticsFragment, K._SemanticsGeometry, Q.TextOverflow, E.RenderProxyBoxMixin, E.HitTestBehavior, E.CustomClipper, E.DecorationPosition, K.RelativeRect, K.StackFit, K.Overflow, A.ViewConfiguration, N._TaskEntry, N._FrameCallbackEntry, N.SchedulerPhase, N.SchedulerBinding, M.Ticker, M.TickerFuture, N.SemanticsBinding, A.SemanticsTag, A.CustomSemanticsAction, A._BoxEdge, A._TraversalSortNode, A.SemanticsConfiguration, A.DebugSemanticsDumpOrder, E.SemanticsEvent, Q.AssetBundle, N.ServicesBinding, F.MethodCall, F.PlatformException, F.MissingPluginException, U.StringCodec, U.JSONMessageCodec, U.JSONMethodCodec, U.StandardMessageCodec, A.BasicMessageChannel, A.MethodChannel, B.KeyboardSide, B.ModifierKey, B.RawKeyEventData, B.RawKeyEvent, B.RawKeyboard, O.KeyHelper, O._GLFWKeyHelper_Object_KeyHelper, X.ApplicationSwitcherDescription, X.SystemUiOverlayStyle, V.SystemSoundType, X.TextRange, U.Notification, L.AutomaticKeepAliveClientMixin, A.BannerLocation, N.WidgetsBindingObserver, N.WidgetsBinding, O.FocusAttachment, O._FocusNode_Object_DiagnosticableTreeMixin, O._FocusManager_Object_DiagnosticableTreeMixin, N.TypeMatcher, N._StateLifecycle, N._ElementLifecycle, N._InactiveElements, N.BuildContext, N.BuildOwner, N._DebugCreator, D.GestureRecognizerFactory, T.HeroFlightDirection, T._HeroFlightManifest, T._HeroFlight, K.NavigatorObserver, X.IconData, L._Pending, L.WidgetsLocalizations, L.DefaultWidgetsLocalizations, F.MediaQueryData, E._ToolbarSlot, K.RoutePopDisposition, K.RouteSettings, X.OverlayEntry, S.PageStorageBucket, T.LocalHistoryEntry, T.LocalHistoryRoute, U.SingleTickerProviderStateMixin, U.TickerProviderStateMixin, N._MulticastCanvas, N._ScreenshotData, N._DiagnosticsPathNode, N._InspectorReferenceData, N._SerializeConfig, N._WidgetInspectorService, N.WidgetInspectorService, N._LocationCount, N._ElementLocationStatsTracker, N.InspectorSelection, N._TransformedRect, N._InspectorOverlayRenderState, E.Matrix4, E.Vector3, E.Vector4]);
    _inheritMany(J.Interceptor, [J.JSBool, J.JSNull, J.JavaScriptObject, J.JSArray, J.JSNumber, J.JSString, H.NativeByteBuffer, H.NativeTypedData, W.DomException]);
    _inheritMany(J.JavaScriptObject, [J.PlainJavaScriptObject, J.UnknownJavaScriptObject, J.JavaScriptFunction]);
    _inherit(J.JSUnmodifiableArray, J.JSArray);
    _inheritMany(J.JSNumber, [J.JSInt, J.JSDouble]);
    _inheritMany(P.Iterable, [H.EfficientLengthIterable, H.MappedIterable, H.WhereIterable, H.ExpandIterable, H.WhereTypeIterable, H._ConstantMapKeyIterable, P.IterableBase, R.ObserverList]);
    _inheritMany(H.EfficientLengthIterable, [H.ListIterable, H.LinkedHashMapKeyIterable, P._HashMapKeyIterable, P.Set]);
    _inheritMany(H.ListIterable, [H.SubListIterable, H.MappedListIterable, H.ReversedListIterable, P.ListQueue, P._JsonMapKeyIterable]);
    _inherit(H.EfficientLengthMappedIterable, H.MappedIterable);
    _inheritMany(P.Iterator, [H.MappedIterator, H.WhereIterator]);
    _inheritMany(H.ConstantMap, [H.ConstantStringMap, H.GeneralConstantMap]);
    _inheritMany(H.Closure, [H.ConstantStringMap_values_closure, H.Instantiation, H.Primitives_initTicker_closure, H.unwrapException_saveStackTrace, H.TearOffClosure, H.JsLinkedHashMap_values_closure, H.JsLinkedHashMap_containsValue_closure, H.JsLinkedHashMap_addAll_closure, H.initHooks_closure, H.initHooks_closure0, H.initHooks_closure1, P._AsyncRun__initializeScheduleImmediate_internalCallback, P._AsyncRun__initializeScheduleImmediate_closure, P._AsyncRun__scheduleImmediateJsOverride_internalCallback, P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback, P._TimerImpl_internalCallback, P._AsyncAwaitCompleter_complete_closure, P._AsyncAwaitCompleter_completeError_closure, P._awaitOnObject_closure, P._awaitOnObject_closure0, P._wrapJsFunctionForAsync_closure, P._asyncStarHelper_closure, P._asyncStarHelper_closure0, P._AsyncStarStreamController__resumeBody, P._AsyncStarStreamController__resumeBody_closure, P._AsyncStarStreamController_closure, P._AsyncStarStreamController_closure0, P._AsyncStarStreamController_closure1, P._AsyncStarStreamController__closure, P.Future_Future$delayed_closure, P.Future_wait_handleError, P.Future_wait_closure, P._Future__addListener_closure, P._Future__prependListeners_closure, P._Future__chainForeignFuture_closure, P._Future__chainForeignFuture_closure0, P._Future__chainForeignFuture_closure1, P._Future__asyncComplete_closure, P._Future__chainFuture_closure, P._Future__asyncCompleteError_closure, P._Future__propagateToListeners_handleWhenCompleteCallback, P._Future__propagateToListeners_handleWhenCompleteCallback_closure, P._Future__propagateToListeners_handleValueCallback, P._Future__propagateToListeners_handleError, P.Stream_Stream$fromIterable_closure, P.Stream_length_closure, P.Stream_length_closure0, P.Stream_isEmpty_closure, P.Stream_isEmpty_closure0, P._StreamController__subscribe_closure, P._StreamController__recordCancel_complete, P._AddStreamState_cancel_closure, P._BufferingStreamSubscription__sendError_sendError, P._BufferingStreamSubscription__sendDone_sendDone, P._PendingEvents_schedule_closure, P._cancelAndValue_closure, P._rootHandleUncaughtError_closure, P._RootZone_bindCallback_closure, P._RootZone_bindCallbackGuarded_closure, P._HashMap_addAll_closure, P.HashMap_HashMap$from_closure, P.LinkedHashMap_LinkedHashMap$from_closure, P.MapBase_mapToString_closure, P.SplayTreeSet_closure, P._JsonMap_addAll_closure, P._JsonStringifier_writeMap_closure, P.Duration_toString_sixDigits, P.Duration_toString_twoDigits, P.Uri__parseIPv4Address_error, P.Uri_parseIPv6Address_error, P.Uri_parseIPv6Address_parseHex, P._Uri__Uri$notSimple_closure, P._Uri__makePath_closure, P._createTables_closure, P._createTables_build, P._createTables_setChars, P._createTables_setRange, G.AnimationController_forward_closure, G.AnimationController_reverse_closure, G.AnimationController__animateToInternal_closure, G.AnimationController_dispose_closure, S.CurvedAnimation_value_closure, S.AnimationLocalListenersMixin_notifyListeners_closure, S.AnimationLocalStatusListenersMixin_notifyStatusListeners_closure, D.CupertinoPageRoute_buildPageTransitions_closure, D.CupertinoPageRoute_buildPageTransitions_closure0, D._CupertinoBackGestureController_dragEnd_closure, U.FlutterError_dumpErrorToConsole_closure, N.BindingBase_initInstances_closure, N.BindingBase_initServiceExtensions_closure, N.BindingBase_initServiceExtensions_closure0, N.BindingBase_initServiceExtensions_closure1, N.BindingBase_initServiceExtensions__closure, N.BindingBase_initServiceExtensions_closure2, N.BindingBase_lockEvents_closure, N.BindingBase_registerSignalServiceExtension_closure, N.BindingBase_registerBoolServiceExtension_closure, N.BindingBase_registerNumericServiceExtension_closure, N.BindingBase_registerStringServiceExtension_closure, N.BindingBase_registerServiceExtension_closure, N.BindingBase_registerServiceExtension__closure, N.BindingBase_registerServiceExtension__closure0, B.ChangeNotifier__debugAssertNotDisposed_closure, B.ChangeNotifier_notifyListeners_closure, E.debugInstrumentAction_closure, E.debugInstrumentAction_closure0, Y.DiagnosticsNode_toStringDeep_closure, Y.IterableProperty_toJsonMap_closure, Y.Diagnosticable_toString_closure, Y.DiagnosticableTreeMixin_toStringShallow_closure, F._spawn_closure, F._spawn_closure0, B.AbstractNode_adoptChild_closure, T.defaultTargetPlatform_closure, D.debugPrintThrottled_closure, O.SynchronousFuture_whenComplete_closure, D._GestureArena_toString_closure, D.GestureArenaManager_add_closure, D.GestureArenaManager__tryToResolveArena_closure, D.GestureArenaManager__debugLogDiagnostic_closure, N.GestureBinding__handlePointerEvent_closure, N.GestureBinding__handlePointerEvent_closure0, N.GestureBinding_dispatchEvent_closure, N.GestureBinding_dispatchEvent_closure0, G.PointerEventConverter__ensureStateForPointer_closure, O.DragGestureRecognizer_addAllowedPointer_closure, O.DragGestureRecognizer_handleEvent_closure, O.DragGestureRecognizer_acceptGesture_closure, O.DragGestureRecognizer_acceptGesture_closure0, O.DragGestureRecognizer_didStopTrackingLastPointer_closure, O.DragGestureRecognizer_didStopTrackingLastPointer_closure0, O.DragGestureRecognizer_didStopTrackingLastPointer_closure1, O.DragGestureRecognizer_didStopTrackingLastPointer_closure2, Y.MouseTracker__scheduleMousePositionCheck_closure, Y.MouseTracker_collectMousePositions_exitAnnotation, Y.MouseTracker_collectMousePositions_exitAllDevices, O.PointerRouter_addRoute_closure, O.PointerRouter__dispatch_closure, S.GestureRecognizer_invokeCallback_closure, S.GestureRecognizer_invokeCallback_closure0, N.TapGestureRecognizer__checkDown_closure, S._MaterialAppState_build_closure, S._MaterialAppState_build_closure0, S._MaterialAppState_build_closure1, S._MaterialAppState_build_closure2, D.MaterialPointArcTween__initialize_sweepAngle, D.MaterialRectArcTween__initialize_closure, R.BackButton_build_closure, Z._RawMaterialButtonState__handleHighlightChanged_closure, E.debugCheckHasMaterial_closure, E.debugCheckHasMaterial__closure, E.debugCheckHasMaterialLocalizations_closure, E.debugCheckHasMaterialLocalizations__closure, U._getClipCallback_closure, R._InkResponseState__createInkFeature_onRemoved, R._InkResponseState_build_closure, M._MaterialState_build_closure, M.InkFeature_dispose_closure, M._MaterialInteriorState_forEachTween_closure, M._MaterialInteriorState_forEachTween_closure0, M._MaterialInteriorState_forEachTween_closure1, M.__MaterialState_State_TickerProviderStateMixin_dispose_closure, V.MaterialPageRoute_buildPage_closure, K.PageTransitionsTheme__all_closure, M._FloatingActionButtonTransitionState__handlePreviousAnimationStatusChanged_closure, M.ScaffoldState_build_closure, M._ScaffoldState_State_TickerProviderStateMixin_dispose_closure, M.__FloatingActionButtonTransitionState_State_TickerProviderStateMixin_dispose_closure, K._AnimatedThemeState_forEachTween_closure, X.ThemeData_localize_closure, S._TooltipState_ensureTooltipVisible_closure, S.__TooltipState_State_SingleTickerProviderStateMixin_dispose_closure, Y._CompoundBorder_dimensions_closure, Y._CompoundBorder_scale_closure, Y._CompoundBorder_toString_closure, O.BoxShadow_toPaint_closure, Z.ClipContext_clipRectAndPaint_closure, T._sample_closure, T._interpolateColorsAndStops_closure, T.LinearGradient_scale_closure, U.TextPainter_paint_closure, Q.TextSpan_toPlainText_closure, Q.TextSpan_debugAssertIsValid_closure, Q.TextSpan_debugAssertIsValid__closure, Q.TextSpan_debugDescribeChildren_closure, A.TextStyle_copyWith_closure, A.TextStyle_apply_closure, A.TextStyle_merge_closure, A.TextStyle_lerp_closure, A.TextStyle_debugFillProperties_closure, N.RendererBinding__createMouseTracker_closure, N.RendererBinding__forceRepaint_closure, S.BoxConstraints__debugPropagateDebugSize_closure, S.BoxConstraints_constrain_closure, S.BoxConstraints_debugAssertIsValid_closure, S.BoxConstraints_debugAssertIsValid_closure_throwError, S.BoxConstraints_toString_describe, S.RenderBox_size_closure, S.RenderBox_size_closure0, S.RenderBox_size_closure1, S.RenderBox_size_closure2, S.RenderBox_debugAdoptSize_closure, S.RenderBox_getDistanceToBaseline_closure, S.RenderBox_getDistanceToActualBaseline_closure, S.RenderBox_debugAssertDoesMeetConstraints_closure, S.RenderBox_performLayout_closure, S.RenderBox_hitTest_closure, S.RenderBox_applyPaintTransform_closure, S.RenderBox_debugHandleEvent_closure, S.RenderBox_debugPaint_closure, S.RenderBox_debugPaintSize_closure, S.RenderBox_debugPaintBaselines_closure, B.MultiChildLayoutDelegate_layoutChild_closure, B.MultiChildLayoutDelegate_positionChild_closure, B.MultiChildLayoutDelegate__callPerformLayout_closure, B.MultiChildLayoutDelegate__callPerformLayout_closure0, B.MultiChildLayoutDelegate__callPerformLayout_closure1, B.MultiChildLayoutDelegate__callPerformLayout_closure2, B.MultiChildLayoutDelegate__callPerformLayout_closure3, V.RenderCustomPaint__paintWithPainter_closure, V.RenderCustomPaint__paintWithPainter_closure0, V.RenderCustomPaint_assembleSemanticsNode_closure, V.RenderCustomPaint__updateSemanticsChildren_closure, V.RenderCustomPaint__updateSemanticsChildren_closure0, E.debugPaintPadding_closure, T.DebugOverflowIndicatorMixin__reportOverflow_closure, F._RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin_DebugOverflowIndicatorMixin_reassemble_closure, F.RenderFlex_performLayout_closure, F.RenderFlex_performLayout_closure0, F.RenderFlex_paint_closure, T.ContainerLayer_append_closure, T.OffsetLayer_buildScene_closure, T.ClipRectLayer_addToScene_closure, T.OpacityLayer_addToScene_closure, K.PaintingContext__repaintCompositedChild_closure, K.PaintingContext__repaintCompositedChild_closure0, K.PaintingContext_debugInstrumentRepaintCompositedChild_closure, K.PaintingContext_paintChild_closure, K.PaintingContext_paintChild_closure0, K.PaintingContext__compositeChild_closure, K.PaintingContext__isRecording_closure, K.PaintingContext_stopRecordingIfNeeded_closure, K.PaintingContext_pushClipRect_closure, K.SemanticsHandle_dispose_closure, K.PipelineOwner_flushLayout_closure, K.PipelineOwner_flushLayout_closure0, K.PipelineOwner_flushLayout_closure1, K.PipelineOwner_flushCompositingBits_closure, K.PipelineOwner_flushPaint_closure, K.PipelineOwner_flushPaint_closure0, K.PipelineOwner_flushPaint_closure1, K.PipelineOwner_flushSemantics_closure, K.PipelineOwner_flushSemantics_closure0, K.PipelineOwner_flushSemantics_closure1, K.RenderObject_reassemble_closure, K.RenderObject__debugReportException_closure, K.RenderObject__debugReportException_closure_visitor, K.RenderObject__debugCanPerformMutations_closure, K.RenderObject_debugNeedsLayout_closure, K.RenderObject_markNeedsLayout_closure, K.RenderObject__cleanRelayoutBoundary_closure, K.RenderObject_scheduleInitialLayout_closure, K.RenderObject__layoutWithoutResize_closure, K.RenderObject__layoutWithoutResize_closure0, K.RenderObject_layout_closure, K.RenderObject_layout_closure0, K.RenderObject_layout_closure1, K.RenderObject_layout_closure2, K.RenderObject_layout_closure3, K.RenderObject_layout_closure4, K.RenderObject_layout_closure5, K.RenderObject_layout_closure6, K.RenderObject_layout_closure7, K.RenderObject_layout_closure8, K.RenderObject_debugLayer_closure, K.RenderObject_markNeedsCompositingBitsUpdate_closure, K.RenderObject__updateCompositingBits_closure, K.RenderObject_markNeedsPaint_closure, K.RenderObject_markNeedsPaint_closure0, K.RenderObject__paintWithContext_closure, K.RenderObject__paintWithContext_closure0, K.RenderObject__paintWithContext_closure1, K.RenderObject__paintWithContext_closure2, K.RenderObject_debugSemantics_closure, K.RenderObject_clearSemantics_closure, K.RenderObject__getSemanticsForParent_closure, K.RenderObject_toStringDeep_closure, K.RenderObject_toStringDeep_closure0, K.RenderObject_toStringShallow_closure, K.RenderObject_toStringShallow_closure0, K.RenderObjectWithChildMixin_debugValidateChild_closure, K.ContainerRenderObjectMixin_debugValidateChild_closure, Q.RenderParagraph_paint_closure, Q.RenderParagraph_describeSemanticsConfiguration_closure, Q.RenderParagraph_assembleSemanticsNode_buildSemanticsConfig, E.RenderConstrainedBox_debugPaintSize_closure, E._RenderCustomClip_debugPaintSize_closure, E.RenderClipRect_debugPaintSize_closure, E.RenderClipPath_debugPaintSize_closure, E.RenderDecoratedBox_paint_closure, E.RenderDecoratedBox_paint_closure0, E.RenderRepaintBoundary_debugRegisterRepaintBoundaryPaint_closure, E.RenderRepaintBoundary_debugFillProperties_closure, T.RenderPadding_debugPaintSize_closure, T.RenderPositionedBox_debugPaintSize_closure, A.RenderView_debugFillProperties_closure, N._TaskEntry_closure, N._TaskEntry_run_closure, N._FrameCallbackEntry_closure, N._FrameCallbackEntry__closure, N.SchedulerBinding_handleEventLoopCallback_closure, N.SchedulerBinding_handleEventLoopCallback_closure0, N.SchedulerBinding_endOfFrame_closure, N.SchedulerBinding_scheduleFrame_closure, N.SchedulerBinding_scheduleForcedFrame_closure, N.SchedulerBinding_scheduleWarmUpFrame_closure, N.SchedulerBinding_scheduleWarmUpFrame_closure0, N.SchedulerBinding_scheduleWarmUpFrame_closure1, N.SchedulerBinding_handleBeginFrame_closure, N.SchedulerBinding_handleBeginFrame_closure0, N.SchedulerBinding_handleDrawFrame_closure, N.SchedulerBinding__invokeFrameCallback_closure, N.SchedulerBinding__invokeFrameCallback_closure0, N.SchedulerBinding__invokeFrameCallback_closure1, M.Ticker_closure, M.Ticker_start_closure, M.Ticker_dispose_closure, M.Ticker_toString_closure, M.Ticker_toString_closure0, N.SemanticsBinding_disableAnimations_closure, A.SemanticsData_debugFillProperties_closure, A.SemanticsNode__replaceChildren_closure, A.SemanticsNode__replaceChildren_closure0, A.SemanticsNode__replaceChildren__closure, A.SemanticsNode__replaceChildren__closure0, A.SemanticsNode__replaceChildren_closure1, A.SemanticsNode_getSemanticsData_closure, A.SemanticsNode__childrenInTraversalOrder_closure, A.SemanticsNode_debugFillProperties_closure, A.SemanticsNode_debugFillProperties_closure0, A.SemanticsNode_debugFillProperties_closure1, A.SemanticsNode_debugFillProperties_closure2, A.SemanticsNode_debugFillProperties_closure3, A.SemanticsNode_debugDescribeChildren_closure, A._SemanticsSortGroup_sortedWithinKnot_closure, A._SemanticsSortGroup_sortedWithinKnot_search, A._SemanticsSortGroup_sortedWithinKnot_closure0, A._SemanticsSortGroup_sortedWithinKnot_closure1, A.SemanticsOwner_sendSemanticsUpdate_closure, A.SemanticsOwner_sendSemanticsUpdate_closure0, A.SemanticsOwner_sendSemanticsUpdate_closure1, A.SemanticsOwner__getSemanticsActionHandlerForId_closure, A.SemanticsConfiguration__addArgumentlessAction_closure, A.SemanticsConfiguration_onMoveCursorForwardByCharacter_closure, A.SemanticsConfiguration_onMoveCursorBackwardByCharacter_closure, A.SemanticsConfiguration_onSetSelection_closure, N.ServicesBinding__addLicenses_closure, N.ServicesBinding__addLicenses_closure0, U.StandardMessageCodec_writeValue_closure, A.BasicMessageChannel_setMessageHandler_closure, A.MethodChannel_setMethodCallHandler_closure, B.BinaryMessages__sendPlatformMessage_closure, Q.RawKeyEventDataAndroid_getModifierSide_findSide, Q.RawKeyEventDataFuchsia_getModifierSide_findSide, B.RawKeyEventDataMacOs_getModifierSide_findSide, S._WidgetsAppState__onGenerateRoute_closure, S._WidgetsAppState__onUnknownRoute_closure, S._WidgetsAppState__onUnknownRoute_closure0, S._WidgetsAppState_didChangeLocales_closure, S._WidgetsAppState_didChangeAccessibilityFeatures_closure, S._WidgetsAppState_didChangeMetrics_closure, S._WidgetsAppState_didChangeTextScaleFactor_closure, S._WidgetsAppState_didChangePlatformBrightness_closure, S._WidgetsAppState__debugCheckLocalizations_closure, S._WidgetsAppState__debugCheckLocalizations__closure, S._WidgetsAppState__debugCheckLocalizations__closure0, S._WidgetsAppState_build_closure, S._WidgetsAppState_build_closure0, A.CheckedModeBanner_build_closure, A.CheckedModeBanner_debugFillProperties_closure, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure0, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure1, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure2, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure3, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure4, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure5, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure6, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions__closure7, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure0, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure1, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_initServiceExtensions_closure2, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_initServiceExtensions_closure0, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_initServiceExtensions_closure, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_initServiceExtensions__closure, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_initServiceExtensions__closure0, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure0, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure1, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure2, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure3, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure4, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions_closure5, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure0, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure1, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_initServiceExtensions__closure2, N.WidgetsBinding__handleBuildScheduled_closure, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_drawFrame_closure, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_drawFrame_closure0, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_performReassemble_closure, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding_performReassemble_closure0, N.debugDumpApp_closure, N.RenderObjectToWidgetAdapter_attachToRenderTree_closure, N.RenderObjectToWidgetAdapter_attachToRenderTree_closure0, E.debugCheckHasMediaQuery_closure, E.debugCheckHasDirectionality_closure, E.debugWidgetBuilderValue_closure, O.FocusNode_debugLabel_closure, O.FocusNode_enclosingScope_closure, O.FocusNode_enclosingScope_closure0, O.FocusNode_debugDescribeChildren_closure, O.FocusManager__handleRawKeyEvent_allNodes, L._FocusState__handleFocusChanged_closure, N.GlobalKey__register_closure, N.GlobalKey__unregister_closure, N.GlobalKey__debugReserveFor_closure, N.GlobalKey__debugVerifyIllFatedPopulation_closure, N.GlobalKey__debugVerifyIllFatedPopulation__closure, N.State_setState_closure, N.State_setState_closure0, N.State_dispose_closure, N.State_debugFillProperties_closure, N._InactiveElements__unmount_closure, N._InactiveElements__unmount_closure0, N._InactiveElements__deactivateRecursively_closure, N.BuildOwner_scheduleBuildFor_closure, N.BuildOwner_scheduleBuildFor_closure0, N.BuildOwner_scheduleBuildFor_closure1, N.BuildOwner_lockState_closure, N.BuildOwner_lockState_closure0, N.BuildOwner_buildScope_closure, N.BuildOwner_buildScope_closure0, N.BuildOwner_buildScope_closure1, N.BuildOwner_buildScope_closure2, N.BuildOwner_buildScope_closure3, N.BuildOwner_buildScope__closure, N.BuildOwner_buildScope_closure4, N.BuildOwner__debugTrackElementThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans_closure, N.BuildOwner_finalizeTree_closure, N.BuildOwner_finalizeTree_closure0, N.BuildOwner_finalizeTree__closure, N.BuildOwner_finalizeTree__closure0, N.BuildOwner_finalizeTree__closure1, N.BuildOwner_finalizeTree__closure2, N.Element_reassemble_closure, N.Element_renderObject_visit, N.Element_visitChildElements_closure, N.Element_updateChild_closure, N.Element_updateChild_closure0, N.Element_mount_closure, N.Element_updateSlotForChild_visit, N.Element__updateDepth_closure, N.Element_detachRenderObject_closure, N.Element_attachRenderObject_closure, N.Element__retakeInactiveElement_closure, N.Element__retakeInactiveElement_closure0, N.Element_inflateWidget_closure, N.Element_inflateWidget_closure0, N.Element__debugCheckForCycles_closure, N.Element_deactivateChild_closure, N.Element__activateWithParent_closure, N.Element_activate_closure, N.Element_deactivate_closure, N.Element_unmount_closure, N.Element_size_closure, N.Element_size_closure0, N.Element__debugCheckStateIsActiveForAncestorLookup_closure, N.Element__debugCheckOwnerBuildTargetExists_closure, N.Element_debugFillProperties_closure, N.Element_debugDescribeChildren_closure, N.Element_markNeedsBuild_closure, N.Element_rebuild_closure, N.Element_rebuild_closure0, N.Element_rebuild_closure1, N.ErrorWidget_closure, N.StatefulElement_closure, N.StatefulElement__firstBuild_closure, N.StatefulElement__firstBuild_closure0, N.StatefulElement__firstBuild_closure1, N.StatefulElement_update_closure, N.StatefulElement_unmount_closure, N.StatefulElement_inheritFromElement_closure, N.ParentDataElement_mount_closure, N.ParentDataElement__applyParentData_applyParentDataToChild, N.InheritedElement_debugDeactivated_closure, N.InheritedElement_notifyClients_closure, N.RenderObjectElement_mount_closure, N.RenderObjectElement_update_closure, N.RenderObjectElement__debugUpdateRenderObjectOwner_closure, N.RenderObjectElement_updateChildren_replaceWithNullIfForgotten, D.GestureDetector_build_closure, D.GestureDetector_build_closure0, D.GestureDetector_build_closure1, D.GestureDetector_build_closure2, D.GestureDetector_build_closure3, D.GestureDetector_build_closure4, D.GestureDetector_build_closure5, D.GestureDetector_build_closure6, D.GestureDetector_build_closure7, D.GestureDetector_build_closure8, D.GestureDetector_build_closure9, D.GestureDetector_build_closure10, D.RawGestureDetectorState_debugFillProperties_closure, T.Hero__allHeroesFor_addHero, T.Hero__allHeroesFor_addHero_closure, T.Hero__allHeroesFor_visitor, T._HeroState_startFlight_closure, T._HeroState_endFlight_closure, T._HeroFlight__buildOverlay_closure, T._HeroFlight_start_closure, T.HeroController__maybeStartHeroTransition_closure, T.HeroController_closure, Y.IconTheme_merge_closure, G.ImplicitlyAnimatedWidgetState_didUpdateWidget_closure, G.ImplicitlyAnimatedWidgetState__constructTweens_closure, G.AnimatedWidgetBaseState__handleAnimationChanged_closure, G._AnimatedDefaultTextStyleState_forEachTween_closure, G._AnimatedPhysicalModelState_forEachTween_closure, G._AnimatedPhysicalModelState_forEachTween_closure0, G._AnimatedPhysicalModelState_forEachTween_closure1, G._AnimatedPhysicalModelState_forEachTween_closure2, G._ImplicitlyAnimatedWidgetState_State_SingleTickerProviderStateMixin_dispose_closure, L._loadAll_closure, L._loadAll_closure0, L._loadAll_closure1, L._LocalizationsState_load_closure, L._LocalizationsState_load_closure0, L._LocalizationsState_load__closure, X.ModalBarrier_build_closure, K.Navigator_of_closure, K.NavigatorState_initState_closure, K.NavigatorState_dispose_closure, K.NavigatorState_dispose_closure0, K.NavigatorState__routeNamed_closure, K.NavigatorState__routeNamed_closure0, K.NavigatorState_push_closure, K.NavigatorState_push_closure0, K.NavigatorState_pop_closure, K.NavigatorState_pop_closure0, K.NavigatorState_pop_closure1, K.NavigatorState_pop_closure2, K.NavigatorState__cancelActivePointers_closure, K._NavigatorState_State_TickerProviderStateMixin_dispose_closure, X.OverlayEntry_remove_closure, X._OverlayEntryState__markNeedsBuild_closure, X.Overlay_of_closure, X.OverlayState_insert_closure, X.OverlayState_insertAll_closure, X.OverlayState_insertAll_closure0, X.OverlayState_insertAll_closure1, X.OverlayState__remove_closure, X.OverlayState__didChangeEntryOpacity_closure, X._OverlayState_State_TickerProviderStateMixin_dispose_closure, T.TransitionRoute__updateSecondaryAnimation_closure, T._ModalScopeState__forceRebuildPage_closure, T._ModalScopeState_build_closure0, T._ModalScopeState_build_closure, T.ModalRoute_offstage_closure, T.ModalRoute_changedInternalState_closure, U.SingleTickerProviderStateMixin_createTicker_closure, K._AnimatedState__handleChange_closure, N._calculateSubtreeBoundsHelper_closure, N._ScreenshotPaintingContext__isScreenshotRecording_closure, N.WidgetInspectorService__registerSignalServiceExtension_closure, N.WidgetInspectorService__registerObjectGroupServiceExtension_closure, N.WidgetInspectorService__registerBoolServiceExtension_closure, N.WidgetInspectorService__registerServiceExtensionWithArg_closure, N.WidgetInspectorService__registerServiceExtensionVarArgs_closure, N.WidgetInspectorService__registerServiceExtensionVarArgs__closure, N.WidgetInspectorService_initServiceExtensions_closure, N.WidgetInspectorService_initServiceExtensions_closure0, N.WidgetInspectorService_initServiceExtensions_closure1, N.WidgetInspectorService_initServiceExtensions_closure2, N.WidgetInspectorService_initServiceExtensions_closure3, N.WidgetInspectorService_initServiceExtensions_closure4, N.WidgetInspectorService_initServiceExtensions_closure5, N.WidgetInspectorService_initServiceExtensions_closure_markTreeNeedsPaint, N.WidgetInspectorService_initServiceExtensions_closure6, N.WidgetInspectorService_toId_closure, N.WidgetInspectorService_setPubRootDirectories_closure, N.WidgetInspectorService__getParentChain_closure, N.WidgetInspectorService__nodeToJson_closure, N.WidgetInspectorService__nodeToJson_closure0, N.WidgetInspectorService__nodesToJson_closure, N.WidgetInspectorService__onPaint_closure, N._ElementLocationStatsTracker_exportToJson_closure, N._WidgetInspectorState_initState_closure, N._WidgetInspectorState_initState__closure, N._WidgetInspectorState_hitTest__area, N._WidgetInspectorState_hitTest_closure, N._WidgetInspectorState__inspectAt_closure, N._WidgetInspectorState__handlePanEnd_closure, N._WidgetInspectorState__handleTap_closure, N._WidgetInspectorState__handleEnableSelect_closure, N._InspectorOverlayLayer_closure, F._MyHomePageState__incrementCounter_closure, A.hashObjects_closure]);
    _inheritMany(H.Instantiation, [H.Instantiation1, H.Instantiation2]);
    _inheritMany(P.Error, [H.NullError, H.JsNoSuchMethodError, H.UnknownJsTypeError, H.TypeErrorImplementation, H.RuntimeError, P.AssertionError, P.JsonUnsupportedObjectError, P.NullThrownError, P.ArgumentError, P.UnsupportedError, P.UnimplementedError, P.StateError, P.ConcurrentModificationError, P.CyclicInitializationError]);
    _inheritMany(H.TearOffClosure, [H.StaticClosure, H.BoundClosure]);
    _inheritMany(P.AssertionError, [H._AssertionError, U.FlutterError]);
    _inherit(P.MapBase, P.MapMixin);
    _inheritMany(P.MapBase, [H.JsLinkedHashMap, P._HashMap, P._JsonMap]);
    _inheritMany(H.NativeTypedData, [H.NativeByteData, H.NativeTypedArray]);
    _inheritMany(H.NativeTypedArray, [H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin, H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin]);
    _inherit(H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin, H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin);
    _inherit(H.NativeTypedArrayOfDouble, H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin);
    _inherit(H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin, H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin);
    _inherit(H.NativeTypedArrayOfInt, H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin);
    _inherit(H.NativeFloat64List, H.NativeTypedArrayOfDouble);
    _inheritMany(H.NativeTypedArrayOfInt, [H.NativeInt32List, H.NativeInt8List, H.NativeUint16List, H.NativeUint8List]);
    _inherit(P._SyncStarIterable, P.IterableBase);
    _inheritMany(P._Completer, [P._AsyncCompleter, P._SyncCompleter]);
    _inherit(P._AsyncStreamController, P._StreamController);
    _inheritMany(P.Stream, [P._StreamImpl, P._ReceivePortImpl]);
    _inheritMany(P._StreamImpl, [P._ControllerStream, P._GeneratedStreamImpl]);
    _inherit(P._ControllerSubscription, P._BufferingStreamSubscription);
    _inherit(P._StreamControllerAddStreamState, P._AddStreamState);
    _inheritMany(P._PendingEvents, [P._IterablePendingEvents, P._StreamImplEvents]);
    _inheritMany(P._DelayedEvent, [P._DelayedData, P._DelayedError]);
    _inherit(P._RootZone, P._Zone);
    _inherit(P._LinkedIdentityHashMap, H.JsLinkedHashMap);
    _inheritMany(P._SetBase, [P._HashSet, P._LinkedHashSet]);
    _inherit(P._LinkedIdentityHashSet, P._LinkedHashSet);
    _inherit(P.ListBase, P._ListBase_Object_ListMixin);
    _inherit(P._SplayTreeKeyIterator, P._SplayTreeIterator);
    _inherit(P._SplayTreeSet__SplayTree_IterableMixin, P._SplayTree);
    _inherit(P._SplayTreeSet__SplayTree_IterableMixin_SetMixin, P._SplayTreeSet__SplayTree_IterableMixin);
    _inherit(P.SplayTreeSet, P._SplayTreeSet__SplayTree_IterableMixin_SetMixin);
    _inheritMany(P.Codec, [P.Base64Codec, P.Encoding, P.JsonCodec]);
    _inherit(P.Converter, P.StreamTransformerBase);
    _inheritMany(P.Converter, [P.Base64Encoder, P.JsonEncoder, P.JsonDecoder, P.Utf8Encoder, P.Utf8Decoder]);
    _inherit(P.JsonCyclicError, P.JsonUnsupportedObjectError);
    _inherit(P._JsonStringStringifier, P._JsonStringifier);
    _inherit(P.Utf8Codec, P.Encoding);
    _inheritMany(P.num, [P.double, P.int]);
    _inheritMany(P.ArgumentError, [P.RangeError, P.IndexError]);
    _inherit(P._DataUri, P._Uri);
    _inheritMany(P.OffsetBase, [P.Offset, P.Size]);
    _inherit(P.Gradient0, P.Shader);
    _inheritMany(B.Listenable, [X.Animation, B._MergingListenable, V.CustomPainter]);
    _inheritMany(X.Animation, [G._AnimationController_Animation_AnimationEagerListenerMixin, S._AlwaysCompleteAnimation, S._AlwaysDismissedAnimation, S._ProxyAnimation_Animation_AnimationLazyListenerMixin, S._ReverseAnimation_Animation_AnimationLazyListenerMixin, S._CurvedAnimation_Animation_AnimationWithParentMixin, S._TrainHoppingAnimation_Animation_AnimationEagerListenerMixin, S._CompoundAnimation_Animation_AnimationLazyListenerMixin, R.__AnimatedEvaluation_Animation_AnimationWithParentMixin]);
    _inherit(G._AnimationController_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin, G._AnimationController_Animation_AnimationEagerListenerMixin);
    _inherit(G._AnimationController_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin, G._AnimationController_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin);
    _inherit(G.AnimationController, G._AnimationController_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin);
    _inherit(G._InterpolationSimulation, T.Simulation);
    _inherit(S._ProxyAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin, S._ProxyAnimation_Animation_AnimationLazyListenerMixin);
    _inherit(S._ProxyAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin, S._ProxyAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin);
    _inherit(S.ProxyAnimation, S._ProxyAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin);
    _inherit(S._ReverseAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalStatusListenersMixin, S._ReverseAnimation_Animation_AnimationLazyListenerMixin);
    _inherit(S.ReverseAnimation, S._ReverseAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalStatusListenersMixin);
    _inherit(S.CurvedAnimation, S._CurvedAnimation_Animation_AnimationWithParentMixin);
    _inherit(S._TrainHoppingAnimation_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin, S._TrainHoppingAnimation_Animation_AnimationEagerListenerMixin);
    _inherit(S._TrainHoppingAnimation_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin, S._TrainHoppingAnimation_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin);
    _inherit(S.TrainHoppingAnimation, S._TrainHoppingAnimation_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin);
    _inherit(S._CompoundAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin, S._CompoundAnimation_Animation_AnimationLazyListenerMixin);
    _inherit(S._CompoundAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin, S._CompoundAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin);
    _inherit(S.CompoundAnimation, S._CompoundAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin);
    _inheritMany(S.CompoundAnimation, [S.AnimationMin, A._AnimationSwap]);
    _inheritMany(Z.Curve, [Z._Linear, Z.Interval, Z.Threshold, Z.Cubic, Z.FlippedCurve]);
    _inherit(R._AnimatedEvaluation, R.__AnimatedEvaluation_Animation_AnimationWithParentMixin);
    _inheritMany(R.Animatable, [R._ChainedEvaluation, R.Tween, R.CurveTween]);
    _inheritMany(R.Tween, [R.ReverseTween, R.ColorTween, R.RectTween, R.IntTween, D.MaterialPointArcTween, M.ShapeBorderTween, K.ThemeDataTween, G.DecorationTween, G.BorderRadiusTween, G.TextStyleTween]);
    _inheritMany(L.LocalizationsDelegate, [L._CupertinoLocalizationsDelegate, U._MaterialLocalizationsDelegate, L._WidgetsLocalizationsDelegate]);
    _inheritMany(Y.Diagnosticable, [Y.DiagnosticableTree, N.State, Z.Decoration, R.CupertinoTextThemeData, K.CupertinoThemeData, F.PointerEvent, V.AppBarTheme, D.BottomAppBarTheme, M.ButtonThemeData, A.CardTheme, K.ChipThemeData, A.ColorScheme, Y.DialogTheme, S.FloatingActionButtonThemeData, L.InputDecorationTheme, K.PageTransitionsTheme, Q.SliderThemeData, K.SnackBarThemeData, U.TabBarTheme, R.TextTheme, X.ThemeData, U.Typography, A.TextStyle0, A.SemanticsData, A.SemanticsSortKey, G.LogicalKeyboardKey, G.PhysicalKeyboardKey, T.IconThemeData]);
    _inheritMany(Y.DiagnosticableTree, [N.Widget, Q.TextSpan, A.SemanticsHintOverrides, A.SemanticsProperties, N.Element]);
    _inheritMany(N.Widget, [N.StatelessWidget, N.StatefulWidget, N.ProxyWidget, N.RenderObjectWidget]);
    _inheritMany(N.StatelessWidget, [D.CupertinoPageTransition, K.CupertinoTheme, R.BackButtonIcon, R.BackButton, E.FloatingActionButton, B.IconButton, M._ShapeBorderPaint, K._FadeUpwardsPageTransition, N.SnackBar, K.Theme, S._TooltipOverlay, A.Banner, A.CheckedModeBanner, T.PositionedDirectional, T.KeyedSubtree, T.Builder, M.Container, D.GestureDetector, L.Icon, X.ModalBarrier, E.NavigationToolbar, U.NotificationListener, S.PageStorage, Q.SafeArea, L.Text, U.Title, F.MyApp]);
    _inheritMany(N.StatefulWidget, [D._CupertinoBackGestureDetector, S.MaterialApp, E.AppBar, Z.RawMaterialButton, Z.DrawerController, R.InkResponse, M.Material, G.ImplicitlyAnimatedWidget, M._FloatingActionButtonTransition, M.Scaffold, M._StandardBottomSheet, S.Tooltip, S.WidgetsApp, L.Focus, D.RawGestureDetector, T.Hero, L.Localizations, K.Navigator, X._OverlayEntry, X.Overlay, T._ModalScope, K.AnimatedWidget, N.WidgetInspector, F.MyHomePage]);
    _inheritMany(N.State, [D._CupertinoBackGestureDetectorState, S._MaterialAppState, E._AppBarState, Z._RawMaterialButtonState, Z._DrawerControllerState_State_SingleTickerProviderStateMixin, R.__InkResponseState_State_AutomaticKeepAliveClientMixin, M.__MaterialState_State_TickerProviderStateMixin, G._ImplicitlyAnimatedWidgetState_State_SingleTickerProviderStateMixin, M.__FloatingActionButtonTransitionState_State_TickerProviderStateMixin, M._ScaffoldState_State_TickerProviderStateMixin, S.__TooltipState_State_SingleTickerProviderStateMixin, S._WidgetsAppState, L._FocusState, D.RawGestureDetectorState, T._HeroState, L._LocalizationsState, K._NavigatorState_State_TickerProviderStateMixin, X._OverlayEntryState, X._OverlayState_State_TickerProviderStateMixin, T._ModalScopeState, K._AnimatedState, N.__WidgetInspectorState_State_WidgetsBindingObserver, F._MyHomePageState]);
    _inheritMany(Z.Decoration, [D._CupertinoEdgeShadowDecoration, S.BoxDecoration]);
    _inheritMany(Z.BoxPainter, [D._CupertinoEdgeShadowPainter, S._BoxDecorationPainter]);
    _inheritMany(N.ProxyWidget, [N.InheritedWidget, N.ParentDataWidget]);
    _inheritMany(N.InheritedWidget, [K._InheritedCupertinoTheme, Z.FlexibleSpaceBarSettings, M._ScaffoldScope, K._InheritedTheme, T.Directionality, T.DefaultAssetBundle, S.InheritedNotifier, Y.IconTheme, L._LocalizationsScope, F.MediaQuery, E.PrimaryScrollController, T._ModalScopeStatus, K.ScrollConfiguration, L.DefaultTextStyle, U.TickerMode]);
    _inheritMany(Y.DiagnosticsNode, [Y.DiagnosticsProperty, Y.DiagnosticableNode]);
    _inheritMany(Y.DiagnosticsProperty, [Y.MessageProperty, Y.StringProperty, Y._NumProperty, Y.FlagProperty, Y.IterableProperty, Y.EnumProperty, Y.ObjectFlagProperty, T.TransformProperty]);
    _inheritMany(Y._NumProperty, [Y.DoubleProperty, Y.IntProperty]);
    _inherit(Y.PercentProperty, Y.DoubleProperty);
    _inheritMany(Y.DiagnosticableNode, [Y._DiagnosticableTreeNode, A._SemanticsDiagnosticableNode]);
    _inheritMany(D.Key, [D.LocalKey, N.GlobalKey]);
    _inheritMany(D.LocalKey, [D.ValueKey, N.UniqueKey]);
    _inherit(F.LicenseEntryWithLineBreaks, F.LicenseEntry);
    _inheritMany(U.FlutterErrorDetails, [N.FlutterErrorDetailsForPointerEventDispatcher, O.FlutterErrorDetailsForPointerRouter, K.FlutterErrorDetailsForRendering]);
    _inheritMany(F.PointerEvent, [F.PointerHoverEvent, F.PointerEnterEvent, F.PointerExitEvent, F.PointerDownEvent, F.PointerMoveEvent, F.PointerUpEvent, F.PointerSignalEvent, F.PointerCancelEvent]);
    _inherit(F.PointerScrollEvent, F.PointerSignalEvent);
    _inherit(S._GestureRecognizer_GestureArenaMember_DiagnosticableTreeMixin, D.GestureArenaMember);
    _inherit(S.GestureRecognizer, S._GestureRecognizer_GestureArenaMember_DiagnosticableTreeMixin);
    _inheritMany(S.GestureRecognizer, [S.OneSequenceGestureRecognizer, F.DoubleTapGestureRecognizer]);
    _inheritMany(S.OneSequenceGestureRecognizer, [S.PrimaryPointerGestureRecognizer, O.DragGestureRecognizer]);
    _inheritMany(S.PrimaryPointerGestureRecognizer, [T.LongPressGestureRecognizer, N.TapGestureRecognizer]);
    _inheritMany(O.DragGestureRecognizer, [O.VerticalDragGestureRecognizer, O.HorizontalDragGestureRecognizer, O.PanGestureRecognizer]);
    _inherit(S._MaterialScrollBehavior, K.ScrollBehavior);
    _inheritMany(T.SingleChildLayoutDelegate, [E._ToolbarContainerLayout, S._TooltipPositionDelegate]);
    _inherit(D.MaterialRectArcTween, R.RectTween);
    _inheritMany(N.RenderObjectWidget, [N.SingleChildRenderObjectWidget, N.MultiChildRenderObjectWidget, N.LeafRenderObjectWidget, N.RenderObjectToWidgetAdapter, X._Theatre]);
    _inheritMany(N.SingleChildRenderObjectWidget, [Z._InputPadding, M._InkFeatures, X.AnnotatedRegion, T.Opacity, T.CustomPaint, T.ClipRect, T.ClipPath, T.PhysicalModel, T.PhysicalShape, T.Transform, T.FractionalTranslation, T.Padding, T.Align, T.CustomSingleChildLayout, T.SizedBox, T.ConstrainedBox, T.LimitedBox, T.Offstage, T.Listener, T.RepaintBoundary, T.IgnorePointer, T.AbsorbPointer, T.Semantics, T.MergeSemantics, T.BlockSemantics, T.ExcludeSemantics, M.DecoratedBox, D._GestureSemantics, K.FadeTransition]);
    _inheritMany(B.AbstractNode, [K._RenderObject_AbstractNode_DiagnosticableTreeMixin, T._Layer_AbstractNode_DiagnosticableTreeMixin, A._SemanticsNode_AbstractNode_DiagnosticableTreeMixin]);
    _inherit(K.RenderObject, K._RenderObject_AbstractNode_DiagnosticableTreeMixin);
    _inheritMany(K.RenderObject, [S.RenderBox, A._RenderView_RenderObject_RenderObjectWithChildMixin]);
    _inheritMany(S.RenderBox, [T._RenderShiftedBox_RenderBox_RenderObjectWithChildMixin, E._RenderProxyBox_RenderBox_RenderObjectWithChildMixin, B._RenderCustomMultiChildLayoutBox_RenderBox_ContainerRenderObjectMixin, V.RenderErrorBox, F._RenderFlex_RenderBox_ContainerRenderObjectMixin, Q.RenderParagraph, L.RenderPerformanceOverlay, K._RenderStack_RenderBox_ContainerRenderObjectMixin, X.__RenderTheatre_RenderBox_RenderObjectWithChildMixin, N._RenderInspectorOverlay]);
    _inherit(T.RenderShiftedBox, T._RenderShiftedBox_RenderBox_RenderObjectWithChildMixin);
    _inheritMany(T.RenderShiftedBox, [Z._RenderInputPadding, T.RenderPadding, T.RenderAligningShiftedBox, T.RenderCustomSingleChildLayoutBox]);
    _inherit(E.ColorSwatch, P.Color);
    _inherit(E.MaterialColor, E.ColorSwatch);
    _inherit(Z.DrawerControllerState, Z._DrawerControllerState_State_SingleTickerProviderStateMixin);
    _inherit(A._EndFloatFloatingActionButtonLocation, A.FloatingActionButtonLocation);
    _inherit(A._ScalingFabMotionAnimator, A.FloatingActionButtonAnimator);
    _inherit(R.InteractiveInkFeature, M.InkFeature);
    _inheritMany(R.InteractiveInkFeature, [Y.InkHighlight, U.InkSplash]);
    _inherit(U._InkSplashFactory, R.InteractiveInkFeatureFactory);
    _inherit(R._InkResponseState, R.__InkResponseState_State_AutomaticKeepAliveClientMixin);
    _inherit(R.InkWell, R.InkResponse);
    _inheritMany(Y.ShapeBorder, [F.InputBorder, Y._CompoundBorder, F.BoxBorder, X.CircleBorder, X.RoundedRectangleBorder, X._RoundedRectangleToCircleBorder, S.StadiumBorder, S._StadiumToCircleBorder, S._StadiumToRoundedRectangleBorder]);
    _inherit(M._MaterialState, M.__MaterialState_State_TickerProviderStateMixin);
    _inherit(E._RenderProxyBox_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin, E._RenderProxyBox_RenderBox_RenderObjectWithChildMixin);
    _inherit(E.RenderProxyBox, E._RenderProxyBox_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin);
    _inheritMany(E.RenderProxyBox, [M._RenderInkFeatures, V.RenderCustomPaint, E.RenderProxyBoxWithHitTestBehavior, E.RenderConstrainedBox, E.RenderLimitedBox, E.RenderOpacity, E.RenderAnimatedOpacity, E._RenderCustomClip, E.RenderDecoratedBox, E.RenderTransform, E.RenderFractionalTranslation, E.RenderRepaintBoundary, E.RenderIgnorePointer, E.RenderOffstage, E.RenderAbsorbPointer, E.RenderSemanticsGestureHandler, E.RenderSemanticsAnnotations, E.RenderBlockSemantics, E.RenderMergeSemantics, E.RenderExcludeSemantics, E.RenderAnnotatedRegion]);
    _inheritMany(G.ImplicitlyAnimatedWidget, [M._MaterialInterior, K.AnimatedTheme, G.AnimatedDefaultTextStyle, G.AnimatedPhysicalModel]);
    _inherit(G.ImplicitlyAnimatedWidgetState, G._ImplicitlyAnimatedWidgetState_State_SingleTickerProviderStateMixin);
    _inherit(G.AnimatedWidgetBaseState, G.ImplicitlyAnimatedWidgetState);
    _inheritMany(G.AnimatedWidgetBaseState, [M._MaterialInteriorState, K._AnimatedThemeState, G._AnimatedDefaultTextStyleState, G._AnimatedPhysicalModelState]);
    _inheritMany(V.CustomPainter, [M._ShapeBorderPainter, A.BannerPainter]);
    _inherit(T.OverlayRoute, K.Route);
    _inherit(T.TransitionRoute, T.OverlayRoute);
    _inherit(T._ModalRoute_TransitionRoute_LocalHistoryRoute, T.TransitionRoute);
    _inherit(T.ModalRoute, T._ModalRoute_TransitionRoute_LocalHistoryRoute);
    _inherit(V.PageRoute, T.ModalRoute);
    _inherit(V.MaterialPageRoute, V.PageRoute);
    _inheritMany(K.PageTransitionsBuilder, [K.FadeUpwardsPageTransitionsBuilder, K.CupertinoPageTransitionsBuilder]);
    _inheritMany(B.ChangeNotifier, [M._ScaffoldGeometryNotifier, N.ViewportOffset, A.SemanticsOwner, L.KeepAliveHandle, F.ScrollController]);
    _inherit(S.BoxConstraints, K.Constraints);
    _inherit(M._BodyBoxConstraints, S.BoxConstraints);
    _inheritMany(B.MultiChildLayoutDelegate, [M._ScaffoldLayout, E._ToolbarLayout]);
    _inherit(M._FloatingActionButtonTransitionState, M.__FloatingActionButtonTransitionState_State_TickerProviderStateMixin);
    _inherit(M.ScaffoldState, M._ScaffoldState_State_TickerProviderStateMixin);
    _inherit(Q._RoundedRectSliderTrackShape_SliderTrackShape_BaseSliderTrackShape, Q.SliderTrackShape);
    _inherit(Q.RoundedRectSliderTrackShape, Q._RoundedRectSliderTrackShape_SliderTrackShape_BaseSliderTrackShape);
    _inherit(Q.RoundSliderTickMarkShape, Q.SliderTickMarkShape);
    _inheritMany(Q.SliderComponentShape, [Q.RoundSliderThumbShape, Q.RoundSliderOverlayShape, Q.PaddleSliderValueIndicatorShape]);
    _inherit(X.MaterialBasedCupertinoThemeData, K.CupertinoThemeData);
    _inherit(S._TooltipState, S.__TooltipState_State_SingleTickerProviderStateMixin);
    _inheritMany(K.AlignmentGeometry, [K.Alignment, K.AlignmentDirectional, K._MixedAlignment]);
    _inheritMany(K.BorderRadiusGeometry, [K.BorderRadius, K._MixedBorderRadius]);
    _inheritMany(F.BoxBorder, [F.Border, F.BorderDirectional]);
    _inherit(O.BoxShadow, P.Shadow);
    _inheritMany(V.EdgeInsetsGeometry, [V.EdgeInsets, V.EdgeInsetsDirectional, V._MixedEdgeInsets]);
    _inherit(T.LinearGradient, T.Gradient);
    _inherit(D.DefaultShaderWarmUp, D.ShaderWarmUp);
    _inherit(S._DebugSize, P.Size);
    _inherit(S.BoxHitTestEntry, O.HitTestEntry);
    _inherit(S.BoxParentData, K.ParentData);
    _inherit(S._ContainerBoxParentData_BoxParentData_ContainerParentDataMixin, S.BoxParentData);
    _inherit(S.ContainerBoxParentData, S._ContainerBoxParentData_BoxParentData_ContainerParentDataMixin);
    _inheritMany(S.ContainerBoxParentData, [B.MultiChildLayoutParentData, F.FlexParentData, K.StackParentData]);
    _inherit(B._RenderCustomMultiChildLayoutBox_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin, B._RenderCustomMultiChildLayoutBox_RenderBox_ContainerRenderObjectMixin);
    _inherit(B.RenderCustomMultiChildLayoutBox, B._RenderCustomMultiChildLayoutBox_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin);
    _inherit(F._RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin, F._RenderFlex_RenderBox_ContainerRenderObjectMixin);
    _inherit(F._RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin_DebugOverflowIndicatorMixin, F._RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin);
    _inherit(F.RenderFlex, F._RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin_DebugOverflowIndicatorMixin);
    _inherit(T.Layer, T._Layer_AbstractNode_DiagnosticableTreeMixin);
    _inheritMany(T.Layer, [T.PictureLayer, T.PerformanceOverlayLayer, T.ContainerLayer, N._ProxyLayer, N._InspectorOverlayLayer]);
    _inheritMany(T.ContainerLayer, [T.OffsetLayer, T.ClipRectLayer, T.OpacityLayer, T.PhysicalModelLayer, T.AnnotatedRegionLayer]);
    _inheritMany(T.OffsetLayer, [T.TransformLayer, N._ScreenshotContainerLayer]);
    _inherit(K.PaintingContext, Z.ClipContext);
    _inheritMany(K._SemanticsFragment, [K._ContainerSemanticsFragment, K._InterestingSemanticsFragment]);
    _inheritMany(K._InterestingSemanticsFragment, [K._RootSemanticsFragment, K._SwitchableSemanticsFragment, K._AbortingSemanticsFragment]);
    _inherit(E.ShapeBorderClipper, E.CustomClipper);
    _inheritMany(E._RenderCustomClip, [E.RenderClipRect, E.RenderClipPath, E._RenderPhysicalModelBase]);
    _inheritMany(E._RenderPhysicalModelBase, [E.RenderPhysicalModel, E.RenderPhysicalShape]);
    _inherit(E.RenderPointerListener, E.RenderProxyBoxWithHitTestBehavior);
    _inherit(T.RenderPositionedBox, T.RenderAligningShiftedBox);
    _inherit(K._RenderStack_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin, K._RenderStack_RenderBox_ContainerRenderObjectMixin);
    _inherit(K.RenderStack, K._RenderStack_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin);
    _inherit(A.RenderView, A._RenderView_RenderObject_RenderObjectWithChildMixin);
    _inherit(A.SemanticsNode, A._SemanticsNode_AbstractNode_DiagnosticableTreeMixin);
    _inherit(A._SemanticsSortGroup, P.Comparable);
    _inheritMany(E.SemanticsEvent, [E.TooltipSemanticsEvent, E.LongPressSemanticsEvent, E.TapSemanticEvent]);
    _inherit(Q.CachingAssetBundle, Q.AssetBundle);
    _inherit(Q.PlatformAssetBundle, Q.CachingAssetBundle);
    _inherit(A.OptionalMethodChannel, A.MethodChannel);
    _inheritMany(B.RawKeyEvent, [B.RawKeyDownEvent, B.RawKeyUpEvent]);
    _inheritMany(B.RawKeyEventData, [Q.RawKeyEventDataAndroid, Q.RawKeyEventDataFuchsia, O.RawKeyEventDataLinux, B.RawKeyEventDataMacOs]);
    _inherit(O.GLFWKeyHelper, O._GLFWKeyHelper_Object_KeyHelper);
    _inherit(X.TextSelection, X.TextRange);
    _inheritMany(U.Notification, [L.KeepAliveNotification, U.LayoutChangedNotification]);
    _inherit(T.Center, T.Align);
    _inheritMany(N.ParentDataWidget, [T.LayoutId, T.Positioned]);
    _inheritMany(N.MultiChildRenderObjectWidget, [T.CustomMultiChildLayout, T.Stack, T.Flex]);
    _inheritMany(N.Element, [N.RenderObjectElement, N.ComponentElement]);
    _inheritMany(N.RenderObjectElement, [N.SingleChildRenderObjectElement, N.RootRenderObjectElement, N.LeafRenderObjectElement, N.MultiChildRenderObjectElement, X._TheatreElement]);
    _inherit(T._OffstageElement, N.SingleChildRenderObjectElement);
    _inherit(T.Column, T.Flex);
    _inheritMany(N.LeafRenderObjectWidget, [T.RichText, N.ErrorWidget, L.PerformanceOverlay, N._InspectorOverlay]);
    _inherit(N.RenderObjectToWidgetElement, N.RootRenderObjectElement);
    _inherit(N._WidgetsFlutterBinding_BindingBase_GestureBinding, N.BindingBase);
    _inherit(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding, N._WidgetsFlutterBinding_BindingBase_GestureBinding);
    _inherit(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding);
    _inherit(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding);
    _inherit(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding);
    _inherit(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding);
    _inherit(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding);
    _inherit(N.WidgetsFlutterBinding, N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding);
    _inherit(O._FocusNode_Object_DiagnosticableTreeMixin_ChangeNotifier, O._FocusNode_Object_DiagnosticableTreeMixin);
    _inherit(O.FocusNode, O._FocusNode_Object_DiagnosticableTreeMixin_ChangeNotifier);
    _inherit(O.FocusScopeNode, O.FocusNode);
    _inherit(O.FocusManager, O._FocusManager_Object_DiagnosticableTreeMixin);
    _inherit(L.FocusScope, L.Focus);
    _inherit(L._FocusScopeState, L._FocusState);
    _inherit(L._FocusMarker, S.InheritedNotifier);
    _inheritMany(N.GlobalKey, [N.LabeledGlobalKey, N.GlobalObjectKey]);
    _inheritMany(N.ComponentElement, [N.StatelessElement, N.StatefulElement, N.ProxyElement]);
    _inheritMany(N.ProxyElement, [N.ParentDataElement, N.InheritedElement]);
    _inherit(D.GestureRecognizerFactoryWithHandlers, D.GestureRecognizerFactory);
    _inherit(T.HeroController, K.NavigatorObserver);
    _inherit(S._InheritedNotifierElement, N.InheritedElement);
    _inherit(K.NavigatorState, K._NavigatorState_State_TickerProviderStateMixin);
    _inherit(X.OverlayState, X._OverlayState_State_TickerProviderStateMixin);
    _inherit(X.__RenderTheatre_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin, X.__RenderTheatre_RenderBox_RenderObjectWithChildMixin);
    _inherit(X.__RenderTheatre_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin_ContainerRenderObjectMixin, X.__RenderTheatre_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin);
    _inherit(X._RenderTheatre, X.__RenderTheatre_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin_ContainerRenderObjectMixin);
    _inherit(A._ScrollPosition_ViewportOffset_ScrollMetrics, N.ViewportOffset);
    _inherit(A.ScrollPosition, A._ScrollPosition_ViewportOffset_ScrollMetrics);
    _inherit(U._WidgetTicker, M.Ticker);
    _inheritMany(K.AnimatedWidget, [K.SlideTransition, K.ScaleTransition, K.RotationTransition, K.DecoratedBoxTransition, K.AnimatedBuilder]);
    _inherit(N._ScreenshotPaintingContext, K.PaintingContext);
    _inherit(N._WidgetInspectorState, N.__WidgetInspectorState_State_WidgetsBindingObserver);
    _inherit(N._TypedDataBuffer, P.ListBase);
    _inherit(N._IntBuffer, N._TypedDataBuffer);
    _inherit(N.Uint8Buffer, N._IntBuffer);
    _mixin(H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin, P.ListMixin);
    _mixin(H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin, H.FixedLengthListMixin);
    _mixin(H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin, P.ListMixin);
    _mixin(H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin, H.FixedLengthListMixin);
    _mixin(P._AsyncStreamController, P._AsyncStreamControllerDispatch);
    _mixin(P._ListBase_Object_ListMixin, P.ListMixin);
    _mixin(P._SplayTreeSet__SplayTree_IterableMixin, P.IterableMixin);
    _mixin(P._SplayTreeSet__SplayTree_IterableMixin_SetMixin, P.SetMixin);
    _mixin(G._AnimationController_Animation_AnimationEagerListenerMixin, S.AnimationEagerListenerMixin);
    _mixin(G._AnimationController_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin, S.AnimationLocalListenersMixin);
    _mixin(G._AnimationController_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin, S.AnimationLocalStatusListenersMixin);
    _mixin(S._CompoundAnimation_Animation_AnimationLazyListenerMixin, S.AnimationLazyListenerMixin);
    _mixin(S._CompoundAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin, S.AnimationLocalListenersMixin);
    _mixin(S._CompoundAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin, S.AnimationLocalStatusListenersMixin);
    _mixin(S._CurvedAnimation_Animation_AnimationWithParentMixin, S.AnimationWithParentMixin);
    _mixin(S._ProxyAnimation_Animation_AnimationLazyListenerMixin, S.AnimationLazyListenerMixin);
    _mixin(S._ProxyAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin, S.AnimationLocalListenersMixin);
    _mixin(S._ProxyAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin, S.AnimationLocalStatusListenersMixin);
    _mixin(S._ReverseAnimation_Animation_AnimationLazyListenerMixin, S.AnimationLazyListenerMixin);
    _mixin(S._ReverseAnimation_Animation_AnimationLazyListenerMixin_AnimationLocalStatusListenersMixin, S.AnimationLocalStatusListenersMixin);
    _mixin(S._TrainHoppingAnimation_Animation_AnimationEagerListenerMixin, S.AnimationEagerListenerMixin);
    _mixin(S._TrainHoppingAnimation_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin, S.AnimationLocalListenersMixin);
    _mixin(S._TrainHoppingAnimation_Animation_AnimationEagerListenerMixin_AnimationLocalListenersMixin_AnimationLocalStatusListenersMixin, S.AnimationLocalStatusListenersMixin);
    _mixin(R.__AnimatedEvaluation_Animation_AnimationWithParentMixin, S.AnimationWithParentMixin);
    _mixin(S._GestureRecognizer_GestureArenaMember_DiagnosticableTreeMixin, Y.DiagnosticableTreeMixin);
    _mixin(R.__InkResponseState_State_AutomaticKeepAliveClientMixin, L.AutomaticKeepAliveClientMixin);
    _mixin(M.__MaterialState_State_TickerProviderStateMixin, U.TickerProviderStateMixin);
    _mixin(M._ScaffoldState_State_TickerProviderStateMixin, U.TickerProviderStateMixin);
    _mixin(M.__FloatingActionButtonTransitionState_State_TickerProviderStateMixin, U.TickerProviderStateMixin);
    _mixin(Q._RoundedRectSliderTrackShape_SliderTrackShape_BaseSliderTrackShape, Q.BaseSliderTrackShape);
    _mixin(S.__TooltipState_State_SingleTickerProviderStateMixin, U.SingleTickerProviderStateMixin);
    _mixin(S._ContainerBoxParentData_BoxParentData_ContainerParentDataMixin, K.ContainerParentDataMixin);
    _mixin(B._RenderCustomMultiChildLayoutBox_RenderBox_ContainerRenderObjectMixin, K.ContainerRenderObjectMixin);
    _mixin(B._RenderCustomMultiChildLayoutBox_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin, S.RenderBoxContainerDefaultsMixin);
    _mixin(F._RenderFlex_RenderBox_ContainerRenderObjectMixin, K.ContainerRenderObjectMixin);
    _mixin(F._RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin, S.RenderBoxContainerDefaultsMixin);
    _mixin(F._RenderFlex_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin_DebugOverflowIndicatorMixin, T.DebugOverflowIndicatorMixin);
    _mixin(T._Layer_AbstractNode_DiagnosticableTreeMixin, Y.DiagnosticableTreeMixin);
    _mixin(K._RenderObject_AbstractNode_DiagnosticableTreeMixin, Y.DiagnosticableTreeMixin);
    _mixin(E._RenderProxyBox_RenderBox_RenderObjectWithChildMixin, K.RenderObjectWithChildMixin);
    _mixin(E._RenderProxyBox_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin, E.RenderProxyBoxMixin);
    _mixin(T._RenderShiftedBox_RenderBox_RenderObjectWithChildMixin, K.RenderObjectWithChildMixin);
    _mixin(K._RenderStack_RenderBox_ContainerRenderObjectMixin, K.ContainerRenderObjectMixin);
    _mixin(K._RenderStack_RenderBox_ContainerRenderObjectMixin_RenderBoxContainerDefaultsMixin, S.RenderBoxContainerDefaultsMixin);
    _mixin(A._RenderView_RenderObject_RenderObjectWithChildMixin, K.RenderObjectWithChildMixin);
    _mixin(A._SemanticsNode_AbstractNode_DiagnosticableTreeMixin, Y.DiagnosticableTreeMixin);
    _mixin(O._GLFWKeyHelper_Object_KeyHelper, O.KeyHelper);
    _mixin(N._WidgetsFlutterBinding_BindingBase_GestureBinding, N.GestureBinding);
    _mixin(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding, N.ServicesBinding);
    _mixin(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding, N.SchedulerBinding);
    _mixin(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding, N.PaintingBinding);
    _mixin(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding, N.SemanticsBinding);
    _mixin(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding, N.RendererBinding);
    _mixin(N._WidgetsFlutterBinding_BindingBase_GestureBinding_ServicesBinding_SchedulerBinding_PaintingBinding_SemanticsBinding_RendererBinding_WidgetsBinding, N.WidgetsBinding);
    _mixin(O._FocusManager_Object_DiagnosticableTreeMixin, Y.DiagnosticableTreeMixin);
    _mixin(O._FocusNode_Object_DiagnosticableTreeMixin, Y.DiagnosticableTreeMixin);
    _mixin(O._FocusNode_Object_DiagnosticableTreeMixin_ChangeNotifier, B.ChangeNotifier);
    _mixin(G._ImplicitlyAnimatedWidgetState_State_SingleTickerProviderStateMixin, U.SingleTickerProviderStateMixin);
    _mixin(K._NavigatorState_State_TickerProviderStateMixin, U.TickerProviderStateMixin);
    _mixin(X._OverlayState_State_TickerProviderStateMixin, U.TickerProviderStateMixin);
    _mixin(X.__RenderTheatre_RenderBox_RenderObjectWithChildMixin, K.RenderObjectWithChildMixin);
    _mixin(X.__RenderTheatre_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin, E.RenderProxyBoxMixin);
    _mixin(X.__RenderTheatre_RenderBox_RenderObjectWithChildMixin_RenderProxyBoxMixin_ContainerRenderObjectMixin, K.ContainerRenderObjectMixin);
    _mixin(T._ModalRoute_TransitionRoute_LocalHistoryRoute, T.LocalHistoryRoute);
    _mixin(N._WidgetInspectorService, N.WidgetInspectorService);
    _mixin(N.__WidgetInspectorState_State_WidgetsBindingObserver, N.WidgetsBindingObserver);
  })();
  (function constants() {
    var makeConstList = hunkHelpers.makeConstList;
    C.Interceptor_methods = J.Interceptor.prototype;
    C.JSArray_methods = J.JSArray.prototype;
    C.JSBool_methods = J.JSBool.prototype;
    C.JSDouble_methods = J.JSDouble.prototype;
    C.JSInt_methods = J.JSInt.prototype;
    C.JSNull_methods = J.JSNull.prototype;
    C.JSNumber_methods = J.JSNumber.prototype;
    C.JSString_methods = J.JSString.prototype;
    C.JavaScriptFunction_methods = J.JavaScriptFunction.prototype;
    C.NativeByteBuffer_methods = H.NativeByteBuffer.prototype;
    C.NativeByteData_methods = H.NativeByteData.prototype;
    C.NativeFloat64List_methods = H.NativeFloat64List.prototype;
    C.NativeInt32List_methods = H.NativeInt32List.prototype;
    C.NativeUint8List_methods = H.NativeUint8List.prototype;
    C.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
    C.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
    C.AlignmentDirectional_m1_m1 = new K.AlignmentDirectional(-1, -1);
    C.Alignment_0_0 = new K.Alignment(0, 0);
    C.Alignment_0_1 = new K.Alignment(0, 1);
    C.Alignment_0_m1 = new K.Alignment(0, -1);
    C.Alignment_1_0 = new K.Alignment(1, 0);
    C.Alignment_m1_0 = new K.Alignment(-1, 0);
    C.AnimationBehavior_0 = new G.AnimationBehavior("AnimationBehavior.normal");
    C.AnimationBehavior_1 = new G.AnimationBehavior("AnimationBehavior.preserve");
    C.AnimationStatus_0 = new X.AnimationStatus("AnimationStatus.dismissed");
    C.AnimationStatus_1 = new X.AnimationStatus("AnimationStatus.forward");
    C.AnimationStatus_2 = new X.AnimationStatus("AnimationStatus.reverse");
    C.AnimationStatus_3 = new X.AnimationStatus("AnimationStatus.completed");
    C.AppBarTheme_ccN = new V.AppBarTheme(null, null, null, null, null, null);
    C.AppLifecycleState_0 = new P.AppLifecycleState("AppLifecycleState.resumed");
    C.AppLifecycleState_1 = new P.AppLifecycleState("AppLifecycleState.inactive");
    C.AppLifecycleState_2 = new P.AppLifecycleState("AppLifecycleState.paused");
    C.AppLifecycleState_3 = new P.AppLifecycleState("AppLifecycleState.suspending");
    C.Axis_0 = new G.Axis("Axis.horizontal");
    C.Axis_1 = new G.Axis("Axis.vertical");
    C.BackButtonIcon_null = new R.BackButtonIcon(null);
    C.BackButton_null = new R.BackButton(null);
    C.BannerLocation_0 = new A.BannerLocation("BannerLocation.topStart");
    C.BannerLocation_1 = new A.BannerLocation("BannerLocation.topEnd");
    C.BannerLocation_2 = new A.BannerLocation("BannerLocation.bottomStart");
    C.BannerLocation_3 = new A.BannerLocation("BannerLocation.bottomEnd");
    C.C_StandardMessageCodec = new U.StandardMessageCodec();
    C.BasicMessageChannel_8hp = new A.BasicMessageChannel("flutter/accessibility", C.C_StandardMessageCodec, [null]);
    C.C_JSONMessageCodec = new U.JSONMessageCodec();
    C.BasicMessageChannel_Cfi = new A.BasicMessageChannel("flutter/keyevent", C.C_JSONMessageCodec, [null]);
    C.C_StringCodec = new U.StringCodec();
    C.BasicMessageChannel_No7 = new A.BasicMessageChannel("flutter/lifecycle", C.C_StringCodec, [P.String]);
    C.BasicMessageChannel_Qma = new A.BasicMessageChannel("flutter/system", C.C_JSONMessageCodec, [null]);
    C.BlendMode_13 = new P.BlendMode(13, "BlendMode.modulate");
    C.BlurStyle_0 = new P.BlurStyle(0, "BlurStyle.normal");
    C.Radius_0_0 = new P.Radius(0, 0);
    C.BorderRadius_tLn = new K.BorderRadius(C.Radius_0_0, C.Radius_0_0, C.Radius_0_0, C.Radius_0_0);
    C.Color_4278190080 = new P.Color(4278190080);
    C.BorderStyle_0 = new Y.BorderStyle("BorderStyle.none");
    C.BorderSide_m7u = new Y.BorderSide(C.Color_4278190080, 0, C.BorderStyle_0);
    C.BorderStyle_1 = new Y.BorderStyle("BorderStyle.solid");
    C.BottomAppBarTheme_null_null_null = new D.BottomAppBarTheme(null, null, null);
    C.BoxConstraints_40_40_40_40 = new S.BoxConstraints(40, 40, 40, 40);
    C.BoxConstraints_56_56_56_56 = new S.BoxConstraints(56, 56, 56, 56);
    C.BoxConstraints_ALM = new S.BoxConstraints(1 / 0, 1 / 0, 1 / 0, 1 / 0);
    C.BoxConstraints_EcO = new S.BoxConstraints(56, 56, 0, 1 / 0);
    C.BoxConstraints_mlX0 = new S.BoxConstraints(0, 1 / 0, 0, 1 / 0);
    C.BoxConstraints_mlX = new S.BoxConstraints(48, 1 / 0, 48, 1 / 0);
    C.Color_2130706432 = new P.Color(2130706432);
    C.Offset_0_0 = new P.Offset(0, 0);
    C.BoxShadow_y5m = new O.BoxShadow(0, C.Color_2130706432, C.Offset_0_0, 6);
    C.BoxShape_0 = new F.BoxShape("BoxShape.rectangle");
    C.BoxShape_1 = new F.BoxShape("BoxShape.circle");
    C.Brightness_0 = new P.Brightness("Brightness.dark");
    C.Brightness_1 = new P.Brightness("Brightness.light");
    C.ButtonBarLayoutBehavior_1 = new M.ButtonBarLayoutBehavior("ButtonBarLayoutBehavior.padded");
    C.ButtonTextTheme_0 = new M.ButtonTextTheme("ButtonTextTheme.normal");
    C.ButtonTextTheme_1 = new M.ButtonTextTheme("ButtonTextTheme.accent");
    C.ButtonTextTheme_2 = new M.ButtonTextTheme("ButtonTextTheme.primary");
    C.ButtonThemeData_2Vk = new M.ButtonThemeData(88, 36, C.ButtonTextTheme_0, C.ButtonBarLayoutBehavior_1, null, null, false, null, null, null, null, null, null);
    C.C_Base64Encoder = new P.Base64Encoder();
    C.C_Base64Codec = new P.Base64Codec();
    C.C_DefaultCupertinoLocalizations = new L.DefaultCupertinoLocalizations();
    C.C_DefaultMaterialLocalizations = new U.DefaultMaterialLocalizations();
    C.C_DefaultShaderWarmUp = new D.DefaultShaderWarmUp();
    C.C_DefaultWidgetsLocalizations = new L.DefaultWidgetsLocalizations();
    C.C_EmptyIterator = new H.EmptyIterator([P.Null]);
    C.C_Endian0 = new P.Endian();
    C.C_Endian = new P.Endian();
    C.C_FadeUpwardsPageTransitionsBuilder = new K.FadeUpwardsPageTransitionsBuilder();
    C.C_InputDecorationTheme = new L.InputDecorationTheme();
    C.C_JS_CONST = function getTagFallback(o) {
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
    C.C_JS_CONST0 = function() {
  var toStringFunction = Object.prototype.toString;
  function getTag(o) {
    var s = toStringFunction.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = toStringFunction.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (self.HTMLElement && object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof navigator == "object";
  return {
    getTag: getTag,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
    C.C_JS_CONST6 = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var ua = navigator.userAgent;
    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;
    if (ua.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
    C.C_JS_CONST1 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
    C.C_JS_CONST2 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
    C.C_JS_CONST5 = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "Location": "!Location",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
    C.C_JS_CONST4 = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
    C.C_JS_CONST3 = function(hooks) { return hooks; }
;
    C.C_JsonCodec = new P.JsonCodec();
    C.C_Object = new P.Object();
    C.C_OutOfMemoryError = new P.OutOfMemoryError();
    C.C_PaddleSliderValueIndicatorShape = new Q.PaddleSliderValueIndicatorShape();
    C.C_PageTransitionsTheme = new K.PageTransitionsTheme();
    C.C_RoundSliderOverlayShape = new Q.RoundSliderOverlayShape();
    C.C_RoundSliderThumbShape = new Q.RoundSliderThumbShape();
    C.C_RoundSliderTickMarkShape = new Q.RoundSliderTickMarkShape();
    C.C_RoundedRectSliderTrackShape = new Q.RoundedRectSliderTrackShape();
    C.C_TypeMatcher2 = new N.TypeMatcher([K.NavigatorState]);
    C.C_TypeMatcher = new N.TypeMatcher([X.OverlayState]);
    C.C_TypeMatcher1 = new N.TypeMatcher([E.RenderAbsorbPointer]);
    C.C_TypeMatcher3 = new N.TypeMatcher([M.ScaffoldState]);
    C.C_TypeMatcher0 = new N.TypeMatcher([M._RenderInkFeatures]);
    C.C_Utf8Codec = new P.Utf8Codec();
    C.C_Utf8Encoder = new P.Utf8Encoder();
    C.C__AlwaysCompleteAnimation = new S._AlwaysCompleteAnimation();
    C.C__AlwaysDismissedAnimation = new S._AlwaysDismissedAnimation();
    C.C__CupertinoLocalizationsDelegate = new L._CupertinoLocalizationsDelegate();
    C.C__DefaultHeroTag = new E._DefaultHeroTag();
    C.C__DelayedDone = new P._DelayedDone();
    C.C__EndFloatFloatingActionButtonLocation = new A._EndFloatFloatingActionButtonLocation();
    C.C__HashEnd = new P._HashEnd();
    C.C__InkSplashFactory = new U._InkSplashFactory();
    C.C__Linear = new Z._Linear();
    C.C__MaterialLocalizationsDelegate = new U._MaterialLocalizationsDelegate();
    C.C__NoDefaultValue = new Y._NoDefaultValue();
    C.C__RootZone = new P._RootZone();
    C.C__ScalingFabMotionAnimator = new A._ScalingFabMotionAnimator();
    C.C__ToolbarContainerLayout = new E._ToolbarContainerLayout();
    C.C__WidgetsLocalizationsDelegate = new L._WidgetsLocalizationsDelegate();
    C.CardTheme_eHw = new A.CardTheme(null, null, null, null, null);
    C.CircleBorder_61T = new X.CircleBorder(C.BorderSide_m7u);
    C.ClipOp_1 = new P.ClipOp("ClipOp.intersect");
    C.Clip_0 = new P.Clip("Clip.none");
    C.Clip_1 = new P.Clip("Clip.hardEdge");
    C.Clip_2 = new P.Clip("Clip.antiAlias");
    C.Clip_3 = new P.Clip("Clip.antiAliasWithSaveLayer");
    C.ColorFilter_null_null_null_3 = new P.ColorFilter(null, null, null, 3);
    C.ColorFilter_null_null_null_4 = new P.ColorFilter(null, null, null, 4);
    C.Color_0 = new P.Color(0);
    C.Color_1087163596 = new P.Color(1087163596);
    C.Color_1308622847 = new P.Color(1308622847);
    C.Color_1627389952 = new P.Color(1627389952);
    C.Color_1723645116 = new P.Color(1723645116);
    C.Color_1724434632 = new P.Color(1724434632);
    C.Color_2151694464 = new P.Color(2151694464);
    C.Color_2155905279 = new P.Color(2155905279);
    C.Color_2164260863 = new P.Color(2164260863);
    C.Color_2315255808 = new P.Color(2315255808);
    C.Color_2415956223 = new P.Color(2415956223);
    C.Color_2425393296 = new P.Color(2425393296);
    C.Color_2696354844 = new P.Color(2696354844);
    C.Color_3019898879 = new P.Color(3019898879);
    C.Color_3072401697 = new P.Color(3072401697);
    C.Color_3204448256 = new P.Color(3204448256);
    C.Color_3221225216 = new P.Color(3221225216);
    C.Color_3438868728 = new P.Color(3438868728);
    C.Color_4035969024 = new P.Color(4035969024);
    C.Color_4278221567 = new P.Color(4278221567);
    C.Color_4278227199 = new P.Color(4278227199);
    C.Color_4278255360 = new P.Color(4278255360);
    C.Color_4278255615 = new P.Color(4278255615);
    C.Color_4278290310 = new P.Color(4278290310);
    C.Color_4278442694 = new P.Color(4278442694);
    C.Color_4281794739 = new P.Color(4281794739);
    C.Color_4282549748 = new P.Color(4282549748);
    C.Color_4284612846 = new P.Color(4284612846);
    C.Color_4289724448 = new P.Color(4289724448);
    C.Color_4294902015 = new P.Color(4294902015);
    C.Color_4294939904 = new P.Color(4294939904);
    C.Color_4294955008 = new P.Color(4294955008);
    C.Color_4294967040 = new P.Color(4294967040);
    C.Color_4294967142 = new P.Color(4294967142);
    C.Color_4294967295 = new P.Color(4294967295);
    C.Color_520093696 = new P.Color(520093696);
    C.Color_536870911 = new P.Color(536870911);
    C.CrossAxisAlignment_0 = new F.CrossAxisAlignment("CrossAxisAlignment.start");
    C.CrossAxisAlignment_1 = new F.CrossAxisAlignment("CrossAxisAlignment.end");
    C.CrossAxisAlignment_2 = new F.CrossAxisAlignment("CrossAxisAlignment.center");
    C.CrossAxisAlignment_3 = new F.CrossAxisAlignment("CrossAxisAlignment.stretch");
    C.CrossAxisAlignment_4 = new F.CrossAxisAlignment("CrossAxisAlignment.baseline");
    C.Cubic_2Vk = new Z.Cubic(0.18, 1, 0.04, 1);
    C.Cubic_JUR0 = new Z.Cubic(0.25, 0.1, 0.25, 1);
    C.Cubic_JUR = new Z.Cubic(0.42, 0, 1, 1);
    C.Cubic_OcD = new Z.Cubic(0.67, 0.03, 0.65, 0.09);
    C.Cubic_ifx = new Z.Cubic(0.4, 0, 0.2, 1);
    C.Cubic_izR = new Z.Cubic(0.35, 0.91, 0.33, 0.97);
    C.CupertinoThemeData_MFd = new K.CupertinoThemeData(null, null, null, null, null, null);
    C.DebugSemanticsDumpOrder_0 = new A.DebugSemanticsDumpOrder("DebugSemanticsDumpOrder.inverseHitTest");
    C.DebugSemanticsDumpOrder_1 = new A.DebugSemanticsDumpOrder("DebugSemanticsDumpOrder.traversalOrder");
    C.DecorationPosition_0 = new E.DecorationPosition("DecorationPosition.background");
    C.DecorationPosition_1 = new E.DecorationPosition("DecorationPosition.foreground");
    C.TextStyle_gc6 = new A.TextStyle0(true, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    C.TextOverflow_0 = new Q.TextOverflow("TextOverflow.clip");
    C.DefaultTextStyle_mN7 = new L.DefaultTextStyle(C.TextStyle_gc6, null, true, C.TextOverflow_0, null, null, null);
    C.DiagnosticLevel_0 = new Y.DiagnosticLevel(0, "DiagnosticLevel.hidden");
    C.DiagnosticLevel_1 = new Y.DiagnosticLevel(1, "DiagnosticLevel.fine");
    C.DiagnosticLevel_2 = new Y.DiagnosticLevel(2, "DiagnosticLevel.debug");
    C.DiagnosticLevel_3 = new Y.DiagnosticLevel(3, "DiagnosticLevel.info");
    C.DiagnosticLevel_4 = new Y.DiagnosticLevel(4, "DiagnosticLevel.warning");
    C.DiagnosticLevel_5 = new Y.DiagnosticLevel(5, "DiagnosticLevel.error");
    C.DiagnosticsTreeStyle_0 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.sparse");
    C.DiagnosticsTreeStyle_1 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.offstage");
    C.DiagnosticsTreeStyle_2 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.dense");
    C.DiagnosticsTreeStyle_3 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.transition");
    C.DiagnosticsTreeStyle_4 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.whitespace");
    C.DiagnosticsTreeStyle_5 = new Y.DiagnosticsTreeStyle("DiagnosticsTreeStyle.singleLine");
    C.DialogTheme_maI = new Y.DialogTheme(null, null, null, null, null);
    C.DragStartBehavior_0 = new S.DragStartBehavior("DragStartBehavior.down");
    C.DragStartBehavior_1 = new S.DragStartBehavior("DragStartBehavior.start");
    C.Duration_0 = new P.Duration(0);
    C.Duration_100000 = new P.Duration(100000);
    C.Duration_1000000 = new P.Duration(1000000);
    C.Duration_1500000 = new P.Duration(1500000);
    C.Duration_200000 = new P.Duration(200000);
    C.Duration_300000 = new P.Duration(300000);
    C.Duration_40000 = new P.Duration(40000);
    C.Duration_500000 = new P.Duration(500000);
    C.EdgeInsets_0_0_0_0 = new V.EdgeInsets(0, 0, 0, 0);
    C.EdgeInsets_16_0_16_0 = new V.EdgeInsets(16, 0, 16, 0);
    C.EdgeInsets_24_0_24_0 = new V.EdgeInsets(24, 0, 24, 0);
    C.EdgeInsets_4_4_4_4 = new V.EdgeInsets(4, 4, 4, 4);
    C.EdgeInsets_8_0_8_0 = new V.EdgeInsets(8, 0, 8, 0);
    C.EdgeInsets_8_8_8_8 = new V.EdgeInsets(8, 8, 8, 8);
    C.FilterQuality_0 = new P.FilterQuality("FilterQuality.none");
    C.FlexFit_0 = new F.FlexFit("FlexFit.tight");
    C.FlexFit_1 = new F.FlexFit("FlexFit.loose");
    C.FloatingActionButtonThemeData_OQe = new S.FloatingActionButtonThemeData(null, null, null, null, null, null);
    C.FontWeight_6 = new P.FontWeight(6);
    C.FormatException_oCg = new P.FormatException("Message corrupted", null, null);
    C.GestureDisposition_0 = new D.GestureDisposition("GestureDisposition.accepted");
    C.GestureDisposition_1 = new D.GestureDisposition("GestureDisposition.rejected");
    C.GestureRecognizerState_0 = new S.GestureRecognizerState("GestureRecognizerState.ready");
    C.GestureRecognizerState_1 = new S.GestureRecognizerState("GestureRecognizerState.possible");
    C.GestureRecognizerState_2 = new S.GestureRecognizerState("GestureRecognizerState.defunct");
    C.HSVColor_8eb = new E.HSVColor(0.4, 60, 1, 1);
    C.HeroFlightDirection_0 = new T.HeroFlightDirection("HeroFlightDirection.push");
    C.HeroFlightDirection_1 = new T.HeroFlightDirection("HeroFlightDirection.pop");
    C.HitTestBehavior_0 = new E.HitTestBehavior("HitTestBehavior.deferToChild");
    C.HitTestBehavior_1 = new E.HitTestBehavior("HitTestBehavior.opaque");
    C.HitTestBehavior_2 = new E.HitTestBehavior("HitTestBehavior.translucent");
    C.IconData_57669_MaterialIcons_false = new X.IconData(57669, "MaterialIcons", false);
    C.IconData_58820_MaterialIcons_true = new X.IconData(58820, "MaterialIcons", true);
    C.IconData_58848_MaterialIcons_true = new X.IconData(58848, "MaterialIcons", true);
    C.Color_3707764736 = new P.Color(3707764736);
    C.IconThemeData_Color_3707764736_null_null = new T.IconThemeData(C.Color_3707764736, null, null);
    C.IconThemeData_Color_4278190080_1_24 = new T.IconThemeData(C.Color_4278190080, 1, 24);
    C.IconThemeData_Color_4278190080_null_null = new T.IconThemeData(C.Color_4278190080, null, null);
    C.IconThemeData_Color_4294967295_null_null = new T.IconThemeData(C.Color_4294967295, null, null);
    C.IconData_58834_MaterialIcons_false = new X.IconData(58834, "MaterialIcons", false);
    C.Icon_0 = new L.Icon(C.IconData_58834_MaterialIcons_false, null);
    C.IconData_59574_MaterialIcons_false = new X.IconData(59574, "MaterialIcons", false);
    C.Icon_INY = new L.Icon(C.IconData_59574_MaterialIcons_false, null);
    C.Interval_75R = new Z.Interval(0, 0.1, C.C__Linear);
    C.Interval_E4y = new Z.Interval(0.5, 1, C.Cubic_JUR0);
    C.JsonDecoder_null = new P.JsonDecoder(null);
    C.JsonEncoder_null = new P.JsonEncoder(null);
    C.KeyboardSide_0 = new B.KeyboardSide("KeyboardSide.any");
    C.KeyboardSide_1 = new B.KeyboardSide("KeyboardSide.left");
    C.KeyboardSide_2 = new B.KeyboardSide("KeyboardSide.right");
    C.KeyboardSide_3 = new B.KeyboardSide("KeyboardSide.all");
    C.ModifierKey_0 = new B.ModifierKey("ModifierKey.controlModifier");
    C.ModifierKey_1 = new B.ModifierKey("ModifierKey.shiftModifier");
    C.ModifierKey_2 = new B.ModifierKey("ModifierKey.altModifier");
    C.ModifierKey_3 = new B.ModifierKey("ModifierKey.metaModifier");
    C.ModifierKey_4 = new B.ModifierKey("ModifierKey.capsLockModifier");
    C.ModifierKey_5 = new B.ModifierKey("ModifierKey.numLockModifier");
    C.ModifierKey_6 = new B.ModifierKey("ModifierKey.scrollLockModifier");
    C.ModifierKey_7 = new B.ModifierKey("ModifierKey.functionModifier");
    C.ModifierKey_8 = new B.ModifierKey("ModifierKey.symbolModifier");
    C.List_0 = H.setRuntimeTypeInfo(makeConstList([C.ModifierKey_0, C.ModifierKey_1, C.ModifierKey_2, C.ModifierKey_3, C.ModifierKey_4, C.ModifierKey_5, C.ModifierKey_6, C.ModifierKey_7, C.ModifierKey_8]), [B.ModifierKey]);
    C.List_127_2047_65535_1114111 = H.setRuntimeTypeInfo(makeConstList([127, 2047, 65535, 1114111]), [P.int]);
    C.FontWeight_0 = new P.FontWeight(0);
    C.FontWeight_1 = new P.FontWeight(1);
    C.FontWeight_2 = new P.FontWeight(2);
    C.FontWeight_3 = new P.FontWeight(3);
    C.FontWeight_4 = new P.FontWeight(4);
    C.FontWeight_5 = new P.FontWeight(5);
    C.FontWeight_7 = new P.FontWeight(7);
    C.FontWeight_8 = new P.FontWeight(8);
    C.List_27p = H.setRuntimeTypeInfo(makeConstList([C.FontWeight_0, C.FontWeight_1, C.FontWeight_2, C.FontWeight_3, C.FontWeight_4, C.FontWeight_5, C.FontWeight_6, C.FontWeight_7, C.FontWeight_8]), [P.FontWeight]);
    C.BlendMode_0 = new P.BlendMode(0, "BlendMode.clear");
    C.BlendMode_1 = new P.BlendMode(1, "BlendMode.src");
    C.BlendMode_2 = new P.BlendMode(2, "BlendMode.dst");
    C.BlendMode_3 = new P.BlendMode(3, "BlendMode.srcOver");
    C.BlendMode_4 = new P.BlendMode(4, "BlendMode.dstOver");
    C.BlendMode_5 = new P.BlendMode(5, "BlendMode.srcIn");
    C.BlendMode_6 = new P.BlendMode(6, "BlendMode.dstIn");
    C.BlendMode_7 = new P.BlendMode(7, "BlendMode.srcOut");
    C.BlendMode_8 = new P.BlendMode(8, "BlendMode.dstOut");
    C.BlendMode_9 = new P.BlendMode(9, "BlendMode.srcATop");
    C.BlendMode_10 = new P.BlendMode(10, "BlendMode.dstATop");
    C.BlendMode_11 = new P.BlendMode(11, "BlendMode.xor");
    C.BlendMode_12 = new P.BlendMode(12, "BlendMode.plus");
    C.BlendMode_14 = new P.BlendMode(14, "BlendMode.screen");
    C.BlendMode_15 = new P.BlendMode(15, "BlendMode.overlay");
    C.BlendMode_16 = new P.BlendMode(16, "BlendMode.darken");
    C.BlendMode_17 = new P.BlendMode(17, "BlendMode.lighten");
    C.BlendMode_18 = new P.BlendMode(18, "BlendMode.colorDodge");
    C.BlendMode_19 = new P.BlendMode(19, "BlendMode.colorBurn");
    C.BlendMode_20 = new P.BlendMode(20, "BlendMode.hardLight");
    C.BlendMode_21 = new P.BlendMode(21, "BlendMode.softLight");
    C.BlendMode_22 = new P.BlendMode(22, "BlendMode.difference");
    C.BlendMode_23 = new P.BlendMode(23, "BlendMode.exclusion");
    C.BlendMode_24 = new P.BlendMode(24, "BlendMode.multiply");
    C.BlendMode_25 = new P.BlendMode(25, "BlendMode.hue");
    C.BlendMode_26 = new P.BlendMode(26, "BlendMode.saturation");
    C.BlendMode_27 = new P.BlendMode(27, "BlendMode.color");
    C.BlendMode_28 = new P.BlendMode(28, "BlendMode.luminosity");
    C.List_2TY = H.setRuntimeTypeInfo(makeConstList([C.BlendMode_0, C.BlendMode_1, C.BlendMode_2, C.BlendMode_3, C.BlendMode_4, C.BlendMode_5, C.BlendMode_6, C.BlendMode_7, C.BlendMode_8, C.BlendMode_9, C.BlendMode_10, C.BlendMode_11, C.BlendMode_12, C.BlendMode_13, C.BlendMode_14, C.BlendMode_15, C.BlendMode_16, C.BlendMode_17, C.BlendMode_18, C.BlendMode_19, C.BlendMode_20, C.BlendMode_21, C.BlendMode_22, C.BlendMode_23, C.BlendMode_24, C.BlendMode_25, C.BlendMode_26, C.BlendMode_27, C.BlendMode_28]), [P.BlendMode]);
    C.List_2Vk = H.setRuntimeTypeInfo(makeConstList([0, 0, 32776, 33792, 1, 10240, 0, 0]), [P.int]);
    C.StrokeJoin_0 = new P.StrokeJoin("StrokeJoin.miter");
    C.StrokeJoin_1 = new P.StrokeJoin("StrokeJoin.round");
    C.StrokeJoin_2 = new P.StrokeJoin("StrokeJoin.bevel");
    C.List_6FR = H.setRuntimeTypeInfo(makeConstList([C.StrokeJoin_0, C.StrokeJoin_1, C.StrokeJoin_2]), [P.StrokeJoin]);
    C.List_CVk = H.setRuntimeTypeInfo(makeConstList([0, 0, 65490, 45055, 65535, 34815, 65534, 18431]), [P.int]);
    C.BlurStyle_1 = new P.BlurStyle(1, "BlurStyle.solid");
    C.BlurStyle_2 = new P.BlurStyle(2, "BlurStyle.outer");
    C.BlurStyle_3 = new P.BlurStyle(3, "BlurStyle.inner");
    C.List_DVN = H.setRuntimeTypeInfo(makeConstList([C.BlurStyle_0, C.BlurStyle_1, C.BlurStyle_2, C.BlurStyle_3]), [P.BlurStyle]);
    C.FontStyle_0 = new P.FontStyle(0, "FontStyle.normal");
    C.FontStyle_1 = new P.FontStyle(1, "FontStyle.italic");
    C.List_FontStyle_0_FontStyle_1 = H.setRuntimeTypeInfo(makeConstList([C.FontStyle_0, C.FontStyle_1]), [P.FontStyle]);
    C.List_JYB = H.setRuntimeTypeInfo(makeConstList([0, 0, 26624, 1023, 65534, 2047, 65534, 2047]), [P.int]);
    C.Locale_en_US = new P.Locale("en", "US");
    C.List_Locale_en_US = H.setRuntimeTypeInfo(makeConstList([C.Locale_en_US]), [P.Locale]);
    C.PaintingStyle_0 = new P.PaintingStyle(0, "PaintingStyle.fill");
    C.PaintingStyle_1 = new P.PaintingStyle(1, "PaintingStyle.stroke");
    C.List_PaintingStyle_0_PaintingStyle_1 = H.setRuntimeTypeInfo(makeConstList([C.PaintingStyle_0, C.PaintingStyle_1]), [P.PaintingStyle]);
    C.TextBaseline_0 = new P.TextBaseline(0, "TextBaseline.alphabetic");
    C.TextBaseline_1 = new P.TextBaseline(1, "TextBaseline.ideographic");
    C.List_TextBaseline_0_TextBaseline_1 = H.setRuntimeTypeInfo(makeConstList([C.TextBaseline_0, C.TextBaseline_1]), [P.TextBaseline]);
    C.TextDirection_0 = new P.TextDirection(0, "TextDirection.rtl");
    C.TextDirection_1 = new P.TextDirection(1, "TextDirection.ltr");
    C.List_TextDirection_0_TextDirection_1 = H.setRuntimeTypeInfo(makeConstList([C.TextDirection_0, C.TextDirection_1]), [P.TextDirection]);
    C.TargetPlatform_0 = new T.TargetPlatform("TargetPlatform.android");
    C.TargetPlatform_1 = new T.TargetPlatform("TargetPlatform.fuchsia");
    C.TargetPlatform_2 = new T.TargetPlatform("TargetPlatform.iOS");
    C.List_U0W = H.setRuntimeTypeInfo(makeConstList([C.TargetPlatform_0, C.TargetPlatform_1, C.TargetPlatform_2]), [T.TargetPlatform]);
    C.TextAlign_0 = new P.TextAlign(0, "TextAlign.left");
    C.TextAlign_1 = new P.TextAlign(1, "TextAlign.right");
    C.TextAlign_2 = new P.TextAlign(2, "TextAlign.center");
    C.TextAlign_3 = new P.TextAlign(3, "TextAlign.justify");
    C.TextAlign_4 = new P.TextAlign(4, "TextAlign.start");
    C.TextAlign_5 = new P.TextAlign(5, "TextAlign.end");
    C.List_WPl = H.setRuntimeTypeInfo(makeConstList([C.TextAlign_0, C.TextAlign_1, C.TextAlign_2, C.TextAlign_3, C.TextAlign_4, C.TextAlign_5]), [P.TextAlign]);
    C.FilterQuality_1 = new P.FilterQuality("FilterQuality.low");
    C.FilterQuality_2 = new P.FilterQuality("FilterQuality.medium");
    C.FilterQuality_3 = new P.FilterQuality("FilterQuality.high");
    C.List_cOY = H.setRuntimeTypeInfo(makeConstList([C.FilterQuality_0, C.FilterQuality_1, C.FilterQuality_2, C.FilterQuality_3]), [P.FilterQuality]);
    C.List_cg9 = H.setRuntimeTypeInfo(makeConstList(["dart:async-patch", "dart:async", "package:stack_trace"]), [P.String]);
    C.List_empty3 = H.setRuntimeTypeInfo(makeConstList([]), [V.CustomPainterSemantics]);
    C.List_empty = H.setRuntimeTypeInfo(makeConstList([]), [Y.DiagnosticsNode]);
    C.List_empty1 = H.setRuntimeTypeInfo(makeConstList([]), [K.NavigatorObserver]);
    C.List_empty0 = H.setRuntimeTypeInfo(makeConstList([]), [P.Null]);
    C.List_empty2 = H.setRuntimeTypeInfo(makeConstList([]), [A.SemanticsNode]);
    C.List_empty4 = H.setRuntimeTypeInfo(makeConstList([]), [N.Widget]);
    C.List_gRj = H.setRuntimeTypeInfo(makeConstList([0, 0, 32722, 12287, 65534, 34815, 65534, 18431]), [P.int]);
    C.StrokeCap_0 = new P.StrokeCap("StrokeCap.butt");
    C.StrokeCap_1 = new P.StrokeCap("StrokeCap.round");
    C.StrokeCap_2 = new P.StrokeCap("StrokeCap.square");
    C.List_gap = H.setRuntimeTypeInfo(makeConstList([C.StrokeCap_0, C.StrokeCap_1, C.StrokeCap_2]), [P.StrokeCap]);
    C.List_gnE = H.setRuntimeTypeInfo(makeConstList([0, 0, 65498, 45055, 65535, 34815, 65534, 18431]), [P.int]);
    C.List_ifn = H.setRuntimeTypeInfo(makeConstList(["_AssertionError", "_FakeAsync", "_FrameCallbackEntry"]), [P.String]);
    C.List_null = H.setRuntimeTypeInfo(makeConstList(["null"]), [P.String]);
    C.List_nxB = H.setRuntimeTypeInfo(makeConstList([0, 0, 24576, 1023, 65534, 34815, 65534, 18431]), [P.int]);
    C.List_qNA = H.setRuntimeTypeInfo(makeConstList([0, 0, 32754, 11263, 65534, 34815, 65534, 18431]), [P.int]);
    C.List_qg40 = H.setRuntimeTypeInfo(makeConstList([0, 0, 32722, 12287, 65535, 34815, 65534, 18431]), [P.int]);
    C.List_qg4 = H.setRuntimeTypeInfo(makeConstList([0, 0, 65490, 12287, 65535, 34815, 65534, 18431]), [P.int]);
    C.TextDecorationStyle_0 = new P.TextDecorationStyle(0, "TextDecorationStyle.solid");
    C.TextDecorationStyle_1 = new P.TextDecorationStyle(1, "TextDecorationStyle.double");
    C.TextDecorationStyle_2 = new P.TextDecorationStyle(2, "TextDecorationStyle.dotted");
    C.TextDecorationStyle_3 = new P.TextDecorationStyle(3, "TextDecorationStyle.dashed");
    C.TextDecorationStyle_4 = new P.TextDecorationStyle(4, "TextDecorationStyle.wavy");
    C.List_yGF = H.setRuntimeTypeInfo(makeConstList([C.TextDecorationStyle_0, C.TextDecorationStyle_1, C.TextDecorationStyle_2, C.TextDecorationStyle_3, C.TextDecorationStyle_4]), [P.TextDecorationStyle]);
    C._CornerId_0 = new D._CornerId("_CornerId.topLeft");
    C._CornerId_3 = new D._CornerId("_CornerId.bottomRight");
    C._Diagonal__CornerId_0__CornerId_3 = new D._Diagonal(C._CornerId_0, C._CornerId_3);
    C._Diagonal__CornerId_3__CornerId_0 = new D._Diagonal(C._CornerId_3, C._CornerId_0);
    C._CornerId_1 = new D._CornerId("_CornerId.topRight");
    C._CornerId_2 = new D._CornerId("_CornerId.bottomLeft");
    C._Diagonal__CornerId_1__CornerId_2 = new D._Diagonal(C._CornerId_1, C._CornerId_2);
    C._Diagonal__CornerId_2__CornerId_1 = new D._Diagonal(C._CornerId_2, C._CornerId_1);
    C.List_yvP = H.setRuntimeTypeInfo(makeConstList([C._Diagonal__CornerId_0__CornerId_3, C._Diagonal__CornerId_3__CornerId_0, C._Diagonal__CornerId_1__CornerId_2, C._Diagonal__CornerId_2__CornerId_1]), [D._Diagonal]);
    C.LongPressSemanticsEvent_longPress = new E.LongPressSemanticsEvent("longPress");
    C.MainAxisAlignment_0 = new F.MainAxisAlignment("MainAxisAlignment.start");
    C.MainAxisAlignment_1 = new F.MainAxisAlignment("MainAxisAlignment.end");
    C.MainAxisAlignment_2 = new F.MainAxisAlignment("MainAxisAlignment.center");
    C.MainAxisAlignment_3 = new F.MainAxisAlignment("MainAxisAlignment.spaceBetween");
    C.MainAxisAlignment_4 = new F.MainAxisAlignment("MainAxisAlignment.spaceAround");
    C.MainAxisAlignment_5 = new F.MainAxisAlignment("MainAxisAlignment.spaceEvenly");
    C.MainAxisSize_1 = new F.MainAxisSize("MainAxisSize.max");
    C.LogicalKeyboardKey_4294967296_None_null = new G.LogicalKeyboardKey(4294967296, "None", null);
    C.LogicalKeyboardKey_4294967314_Fn_null = new G.LogicalKeyboardKey(4294967314, "Fn", null);
    C.LogicalKeyboardKey_4295032962_Sleep_null = new G.LogicalKeyboardKey(4295032962, "Sleep", null);
    C.LogicalKeyboardKey_owA = new G.LogicalKeyboardKey(4295032963, "Wake Up", null);
    C.LogicalKeyboardKey_7G2 = new G.LogicalKeyboardKey(97, "Key A", "a");
    C.LogicalKeyboardKey_jjv = new G.LogicalKeyboardKey(98, "Key B", "b");
    C.LogicalKeyboardKey_mF8 = new G.LogicalKeyboardKey(99, "Key C", "c");
    C.LogicalKeyboardKey_ICU = new G.LogicalKeyboardKey(100, "Key D", "d");
    C.LogicalKeyboardKey_AaU = new G.LogicalKeyboardKey(101, "Key E", "e");
    C.LogicalKeyboardKey_2jN = new G.LogicalKeyboardKey(102, "Key F", "f");
    C.LogicalKeyboardKey_cKo = new G.LogicalKeyboardKey(103, "Key G", "g");
    C.LogicalKeyboardKey_QhK = new G.LogicalKeyboardKey(104, "Key H", "h");
    C.LogicalKeyboardKey_swi = new G.LogicalKeyboardKey(105, "Key I", "i");
    C.LogicalKeyboardKey_CG7 = new G.LogicalKeyboardKey(106, "Key J", "j");
    C.LogicalKeyboardKey_3jH = new G.LogicalKeyboardKey(107, "Key K", "k");
    C.LogicalKeyboardKey_4iU = new G.LogicalKeyboardKey(108, "Key L", "l");
    C.LogicalKeyboardKey_oe4 = new G.LogicalKeyboardKey(109, "Key M", "m");
    C.LogicalKeyboardKey_OLv = new G.LogicalKeyboardKey(110, "Key N", "n");
    C.LogicalKeyboardKey_sav = new G.LogicalKeyboardKey(111, "Key O", "o");
    C.LogicalKeyboardKey_M6L = new G.LogicalKeyboardKey(112, "Key P", "p");
    C.LogicalKeyboardKey_Ods = new G.LogicalKeyboardKey(113, "Key Q", "q");
    C.LogicalKeyboardKey_qsN = new G.LogicalKeyboardKey(114, "Key R", "r");
    C.LogicalKeyboardKey_fLj = new G.LogicalKeyboardKey(115, "Key S", "s");
    C.LogicalKeyboardKey_V86 = new G.LogicalKeyboardKey(116, "Key T", "t");
    C.LogicalKeyboardKey_Tng = new G.LogicalKeyboardKey(117, "Key U", "u");
    C.LogicalKeyboardKey_6Ng = new G.LogicalKeyboardKey(118, "Key V", "v");
    C.LogicalKeyboardKey_XaR = new G.LogicalKeyboardKey(119, "Key W", "w");
    C.LogicalKeyboardKey_ifx = new G.LogicalKeyboardKey(120, "Key X", "x");
    C.LogicalKeyboardKey_kQR = new G.LogicalKeyboardKey(121, "Key Y", "y");
    C.LogicalKeyboardKey_W2D = new G.LogicalKeyboardKey(122, "Key Z", "z");
    C.LogicalKeyboardKey_4AN = new G.LogicalKeyboardKey(49, "Digit 1", "1");
    C.LogicalKeyboardKey_mmo = new G.LogicalKeyboardKey(50, "Digit 2", "2");
    C.LogicalKeyboardKey_a7X = new G.LogicalKeyboardKey(51, "Digit 3", "3");
    C.LogicalKeyboardKey_e9s = new G.LogicalKeyboardKey(52, "Digit 4", "4");
    C.LogicalKeyboardKey_43h = new G.LogicalKeyboardKey(53, "Digit 5", "5");
    C.LogicalKeyboardKey_CmI = new G.LogicalKeyboardKey(54, "Digit 6", "6");
    C.LogicalKeyboardKey_Db0 = new G.LogicalKeyboardKey(55, "Digit 7", "7");
    C.LogicalKeyboardKey_GZG = new G.LogicalKeyboardKey(56, "Digit 8", "8");
    C.LogicalKeyboardKey_86y = new G.LogicalKeyboardKey(57, "Digit 9", "9");
    C.LogicalKeyboardKey_0 = new G.LogicalKeyboardKey(48, "Digit 0", "0");
    C.LogicalKeyboardKey_4295426088_Enter_null = new G.LogicalKeyboardKey(4295426088, "Enter", null);
    C.LogicalKeyboardKey_4295426089_Escape_null = new G.LogicalKeyboardKey(4295426089, "Escape", null);
    C.LogicalKeyboardKey_4295426090_Backspace_null = new G.LogicalKeyboardKey(4295426090, "Backspace", null);
    C.LogicalKeyboardKey_4295426091_Tab_null = new G.LogicalKeyboardKey(4295426091, "Tab", null);
    C.LogicalKeyboardKey_YdN = new G.LogicalKeyboardKey(32, "Space", " ");
    C.LogicalKeyboardKey_oEN = new G.LogicalKeyboardKey(45, "Minus", "-");
    C.LogicalKeyboardKey_wrE = new G.LogicalKeyboardKey(61, "Equal", "=");
    C.LogicalKeyboardKey_TLI = new G.LogicalKeyboardKey(91, "Bracket Left", "[");
    C.LogicalKeyboardKey_awJ = new G.LogicalKeyboardKey(93, "Bracket Right", "]");
    C.LogicalKeyboardKey_cdS = new G.LogicalKeyboardKey(92, "Backslash", "\\");
    C.LogicalKeyboardKey_atK = new G.LogicalKeyboardKey(59, "Semicolon", ";");
    C.LogicalKeyboardKey_Qo8 = new G.LogicalKeyboardKey(39, "Quote", "'");
    C.LogicalKeyboardKey_7FR = new G.LogicalKeyboardKey(96, "Backquote", "`");
    C.LogicalKeyboardKey_71T = new G.LogicalKeyboardKey(44, "Comma", ",");
    C.LogicalKeyboardKey_h8g = new G.LogicalKeyboardKey(46, "Period", ".");
    C.LogicalKeyboardKey_ouN = new G.LogicalKeyboardKey(47, "Slash", "/");
    C.LogicalKeyboardKey_OWF = new G.LogicalKeyboardKey(4295426105, "Caps Lock", null);
    C.LogicalKeyboardKey_4295426106_F1_null = new G.LogicalKeyboardKey(4295426106, "F1", null);
    C.LogicalKeyboardKey_4295426107_F2_null = new G.LogicalKeyboardKey(4295426107, "F2", null);
    C.LogicalKeyboardKey_4295426108_F3_null = new G.LogicalKeyboardKey(4295426108, "F3", null);
    C.LogicalKeyboardKey_4295426109_F4_null = new G.LogicalKeyboardKey(4295426109, "F4", null);
    C.LogicalKeyboardKey_4295426110_F5_null = new G.LogicalKeyboardKey(4295426110, "F5", null);
    C.LogicalKeyboardKey_4295426111_F6_null = new G.LogicalKeyboardKey(4295426111, "F6", null);
    C.LogicalKeyboardKey_4295426112_F7_null = new G.LogicalKeyboardKey(4295426112, "F7", null);
    C.LogicalKeyboardKey_4295426113_F8_null = new G.LogicalKeyboardKey(4295426113, "F8", null);
    C.LogicalKeyboardKey_4295426114_F9_null = new G.LogicalKeyboardKey(4295426114, "F9", null);
    C.LogicalKeyboardKey_4295426115_F10_null = new G.LogicalKeyboardKey(4295426115, "F10", null);
    C.LogicalKeyboardKey_4295426116_F11_null = new G.LogicalKeyboardKey(4295426116, "F11", null);
    C.LogicalKeyboardKey_4295426117_F12_null = new G.LogicalKeyboardKey(4295426117, "F12", null);
    C.LogicalKeyboardKey_wAl = new G.LogicalKeyboardKey(4295426118, "Print Screen", null);
    C.LogicalKeyboardKey_ujM = new G.LogicalKeyboardKey(4295426119, "Scroll Lock", null);
    C.LogicalKeyboardKey_4295426120_Pause_null = new G.LogicalKeyboardKey(4295426120, "Pause", null);
    C.LogicalKeyboardKey_4295426121_Insert_null = new G.LogicalKeyboardKey(4295426121, "Insert", null);
    C.LogicalKeyboardKey_4295426122_Home_null = new G.LogicalKeyboardKey(4295426122, "Home", null);
    C.LogicalKeyboardKey_mgB = new G.LogicalKeyboardKey(4295426123, "Page Up", null);
    C.LogicalKeyboardKey_4295426124_Delete_null = new G.LogicalKeyboardKey(4295426124, "Delete", null);
    C.LogicalKeyboardKey_4295426125_End_null = new G.LogicalKeyboardKey(4295426125, "End", null);
    C.LogicalKeyboardKey_wYn = new G.LogicalKeyboardKey(4295426126, "Page Down", null);
    C.LogicalKeyboardKey_CzM = new G.LogicalKeyboardKey(4295426127, "Arrow Right", null);
    C.LogicalKeyboardKey_muk = new G.LogicalKeyboardKey(4295426128, "Arrow Left", null);
    C.LogicalKeyboardKey_O7X = new G.LogicalKeyboardKey(4295426129, "Arrow Down", null);
    C.LogicalKeyboardKey_gCR = new G.LogicalKeyboardKey(4295426130, "Arrow Up", null);
    C.LogicalKeyboardKey_uHn = new G.LogicalKeyboardKey(4295426131, "Num Lock", null);
    C.LogicalKeyboardKey_Npb = new G.LogicalKeyboardKey(4295426132, "Numpad Divide", "/");
    C.LogicalKeyboardKey_iOn = new G.LogicalKeyboardKey(4295426133, "Numpad Multiply", "*");
    C.LogicalKeyboardKey_7xV = new G.LogicalKeyboardKey(4295426134, "Numpad Subtract", "-");
    C.LogicalKeyboardKey_YaH = new G.LogicalKeyboardKey(4295426135, "Numpad Add", "+");
    C.LogicalKeyboardKey_U2J = new G.LogicalKeyboardKey(4295426136, "Numpad Enter", null);
    C.LogicalKeyboardKey_qsT = new G.LogicalKeyboardKey(4295426137, "Numpad 1", "1");
    C.LogicalKeyboardKey_ka2 = new G.LogicalKeyboardKey(4295426138, "Numpad 2", "2");
    C.LogicalKeyboardKey_Ddz = new G.LogicalKeyboardKey(4295426139, "Numpad 3", "3");
    C.LogicalKeyboardKey_YGD = new G.LogicalKeyboardKey(4295426140, "Numpad 4", "4");
    C.LogicalKeyboardKey_s0r = new G.LogicalKeyboardKey(4295426141, "Numpad 5", "5");
    C.LogicalKeyboardKey_atK0 = new G.LogicalKeyboardKey(4295426142, "Numpad 6", "6");
    C.LogicalKeyboardKey_3bB = new G.LogicalKeyboardKey(4295426143, "Numpad 7", "7");
    C.LogicalKeyboardKey_sx4 = new G.LogicalKeyboardKey(4295426144, "Numpad 8", "8");
    C.LogicalKeyboardKey_4IJ = new G.LogicalKeyboardKey(4295426145, "Numpad 9", "9");
    C.LogicalKeyboardKey_KQb = new G.LogicalKeyboardKey(4295426146, "Numpad 0", "0");
    C.LogicalKeyboardKey_iXq = new G.LogicalKeyboardKey(4295426147, "Numpad Decimal", ".");
    C.LogicalKeyboardKey_nDU = new G.LogicalKeyboardKey(4295426149, "Context Menu", null);
    C.LogicalKeyboardKey_4295426150_Power_null = new G.LogicalKeyboardKey(4295426150, "Power", null);
    C.LogicalKeyboardKey_G2v = new G.LogicalKeyboardKey(4295426151, "Numpad Equal", "=");
    C.LogicalKeyboardKey_4295426165_Help_null = new G.LogicalKeyboardKey(4295426165, "Help", null);
    C.LogicalKeyboardKey_4295426171_Cut_null = new G.LogicalKeyboardKey(4295426171, "Cut", null);
    C.LogicalKeyboardKey_4295426172_Copy_null = new G.LogicalKeyboardKey(4295426172, "Copy", null);
    C.LogicalKeyboardKey_4295426173_Paste_null = new G.LogicalKeyboardKey(4295426173, "Paste", null);
    C.LogicalKeyboardKey_MjO = new G.LogicalKeyboardKey(4295426175, "Audio Volume Mute", null);
    C.LogicalKeyboardKey_gap = new G.LogicalKeyboardKey(4295426176, "Audio Volume Up", null);
    C.LogicalKeyboardKey_c9P = new G.LogicalKeyboardKey(4295426177, "Audio Volume Down", null);
    C.LogicalKeyboardKey_CLo = new G.LogicalKeyboardKey(4295426181, "Numpad Comma", ",");
    C.LogicalKeyboardKey_4295426186_Convert_null = new G.LogicalKeyboardKey(4295426186, "Convert", null);
    C.LogicalKeyboardKey_sBE = new G.LogicalKeyboardKey(4295426187, "Non Convert", null);
    C.LogicalKeyboardKey_wEo = new G.LogicalKeyboardKey(4295426230, "Numpad Paren Left", "(");
    C.LogicalKeyboardKey_8Nr = new G.LogicalKeyboardKey(4295426231, "Numpad Paren Right", ")");
    C.LogicalKeyboardKey_p6t = new G.LogicalKeyboardKey(4295426272, "Control Left", null);
    C.LogicalKeyboardKey_xok = new G.LogicalKeyboardKey(4295426273, "Shift Left", null);
    C.LogicalKeyboardKey_PD9 = new G.LogicalKeyboardKey(4295426274, "Alt Left", null);
    C.LogicalKeyboardKey_D0U = new G.LogicalKeyboardKey(4295426275, "Meta Left", null);
    C.LogicalKeyboardKey_ijl = new G.LogicalKeyboardKey(4295426276, "Control Right", null);
    C.LogicalKeyboardKey_QOu = new G.LogicalKeyboardKey(4295426277, "Shift Right", null);
    C.LogicalKeyboardKey_EtP = new G.LogicalKeyboardKey(4295426278, "Alt Right", null);
    C.LogicalKeyboardKey_O1c = new G.LogicalKeyboardKey(4295426279, "Meta Right", null);
    C.LogicalKeyboardKey_4295753824_Info_null = new G.LogicalKeyboardKey(4295753824, "Info", null);
    C.LogicalKeyboardKey_ccN = new G.LogicalKeyboardKey(4295753825, "Closed Caption Toggle", null);
    C.LogicalKeyboardKey_Djg = new G.LogicalKeyboardKey(4295753839, "Brightness Up", null);
    C.LogicalKeyboardKey_ECL = new G.LogicalKeyboardKey(4295753840, "Brightness Down", null);
    C.LogicalKeyboardKey_Pz5 = new G.LogicalKeyboardKey(4295753859, "Media Last", null);
    C.LogicalKeyboardKey_6QF = new G.LogicalKeyboardKey(4295753884, "Channel Up", null);
    C.LogicalKeyboardKey_3J4 = new G.LogicalKeyboardKey(4295753885, "Channel Down", null);
    C.LogicalKeyboardKey_Azp = new G.LogicalKeyboardKey(4295753904, "Media Play", null);
    C.LogicalKeyboardKey_8eb = new G.LogicalKeyboardKey(4295753906, "Media Record", null);
    C.LogicalKeyboardKey_eEX = new G.LogicalKeyboardKey(4295753907, "Media Fast Forward", null);
    C.LogicalKeyboardKey_kQR0 = new G.LogicalKeyboardKey(4295753908, "Media Rewind", null);
    C.LogicalKeyboardKey_n7o = new G.LogicalKeyboardKey(4295753909, "Media Track Next", null);
    C.LogicalKeyboardKey_kHV = new G.LogicalKeyboardKey(4295753910, "Media Track Previous", null);
    C.LogicalKeyboardKey_wfl = new G.LogicalKeyboardKey(4295753911, "Media Stop", null);
    C.LogicalKeyboardKey_4295753912_Eject_null = new G.LogicalKeyboardKey(4295753912, "Eject", null);
    C.LogicalKeyboardKey_Cu4 = new G.LogicalKeyboardKey(4295753933, "Media Play Pause", null);
    C.LogicalKeyboardKey_9gS = new G.LogicalKeyboardKey(4295754122, "Launch Mail", null);
    C.LogicalKeyboardKey_mqK = new G.LogicalKeyboardKey(4295754125, "Launch Contacts", null);
    C.LogicalKeyboardKey_k44 = new G.LogicalKeyboardKey(4295754126, "Launch Calendar", null);
    C.LogicalKeyboardKey_IQp = new G.LogicalKeyboardKey(4295754187, "Launch Assistant", null);
    C.LogicalKeyboardKey_4295754243_Close_null = new G.LogicalKeyboardKey(4295754243, "Close", null);
    C.LogicalKeyboardKey_EWB = new G.LogicalKeyboardKey(4295754273, "Browser Search", null);
    C.LogicalKeyboardKey_8pc = new G.LogicalKeyboardKey(4295754277, "Browser Forward", null);
    C.LogicalKeyboardKey_46S = new G.LogicalKeyboardKey(4295754282, "Browser Favorites", null);
    C.LogicalKeyboardKey_0Rr = new G.LogicalKeyboardKey(4295754285, "Zoom In", null);
    C.LogicalKeyboardKey_wIk = new G.LogicalKeyboardKey(4295754286, "Zoom Out", null);
    C.LogicalKeyboardKey_ijl0 = new G.LogicalKeyboardKey(4295754290, "Zoom Toggle", null);
    C.Map_0rYGk = new H.GeneralConstantMap([0, C.LogicalKeyboardKey_4294967296_None_null, 119, C.LogicalKeyboardKey_4294967314_Fn_null, 223, C.LogicalKeyboardKey_4295032962_Sleep_null, 224, C.LogicalKeyboardKey_owA, 29, C.LogicalKeyboardKey_7G2, 30, C.LogicalKeyboardKey_jjv, 31, C.LogicalKeyboardKey_mF8, 32, C.LogicalKeyboardKey_ICU, 33, C.LogicalKeyboardKey_AaU, 34, C.LogicalKeyboardKey_2jN, 35, C.LogicalKeyboardKey_cKo, 36, C.LogicalKeyboardKey_QhK, 37, C.LogicalKeyboardKey_swi, 38, C.LogicalKeyboardKey_CG7, 39, C.LogicalKeyboardKey_3jH, 40, C.LogicalKeyboardKey_4iU, 41, C.LogicalKeyboardKey_oe4, 42, C.LogicalKeyboardKey_OLv, 43, C.LogicalKeyboardKey_sav, 44, C.LogicalKeyboardKey_M6L, 45, C.LogicalKeyboardKey_Ods, 46, C.LogicalKeyboardKey_qsN, 47, C.LogicalKeyboardKey_fLj, 48, C.LogicalKeyboardKey_V86, 49, C.LogicalKeyboardKey_Tng, 50, C.LogicalKeyboardKey_6Ng, 51, C.LogicalKeyboardKey_XaR, 52, C.LogicalKeyboardKey_ifx, 53, C.LogicalKeyboardKey_kQR, 54, C.LogicalKeyboardKey_W2D, 8, C.LogicalKeyboardKey_4AN, 9, C.LogicalKeyboardKey_mmo, 10, C.LogicalKeyboardKey_a7X, 11, C.LogicalKeyboardKey_e9s, 12, C.LogicalKeyboardKey_43h, 13, C.LogicalKeyboardKey_CmI, 14, C.LogicalKeyboardKey_Db0, 15, C.LogicalKeyboardKey_GZG, 16, C.LogicalKeyboardKey_86y, 7, C.LogicalKeyboardKey_0, 66, C.LogicalKeyboardKey_4295426088_Enter_null, 111, C.LogicalKeyboardKey_4295426089_Escape_null, 67, C.LogicalKeyboardKey_4295426090_Backspace_null, 61, C.LogicalKeyboardKey_4295426091_Tab_null, 62, C.LogicalKeyboardKey_YdN, 69, C.LogicalKeyboardKey_oEN, 70, C.LogicalKeyboardKey_wrE, 71, C.LogicalKeyboardKey_TLI, 72, C.LogicalKeyboardKey_awJ, 73, C.LogicalKeyboardKey_cdS, 74, C.LogicalKeyboardKey_atK, 75, C.LogicalKeyboardKey_Qo8, 68, C.LogicalKeyboardKey_7FR, 55, C.LogicalKeyboardKey_71T, 56, C.LogicalKeyboardKey_h8g, 76, C.LogicalKeyboardKey_ouN, 115, C.LogicalKeyboardKey_OWF, 131, C.LogicalKeyboardKey_4295426106_F1_null, 132, C.LogicalKeyboardKey_4295426107_F2_null, 133, C.LogicalKeyboardKey_4295426108_F3_null, 134, C.LogicalKeyboardKey_4295426109_F4_null, 135, C.LogicalKeyboardKey_4295426110_F5_null, 136, C.LogicalKeyboardKey_4295426111_F6_null, 137, C.LogicalKeyboardKey_4295426112_F7_null, 138, C.LogicalKeyboardKey_4295426113_F8_null, 139, C.LogicalKeyboardKey_4295426114_F9_null, 140, C.LogicalKeyboardKey_4295426115_F10_null, 141, C.LogicalKeyboardKey_4295426116_F11_null, 142, C.LogicalKeyboardKey_4295426117_F12_null, 120, C.LogicalKeyboardKey_wAl, 116, C.LogicalKeyboardKey_ujM, 121, C.LogicalKeyboardKey_4295426120_Pause_null, 124, C.LogicalKeyboardKey_4295426121_Insert_null, 122, C.LogicalKeyboardKey_4295426122_Home_null, 92, C.LogicalKeyboardKey_mgB, 112, C.LogicalKeyboardKey_4295426124_Delete_null, 123, C.LogicalKeyboardKey_4295426125_End_null, 93, C.LogicalKeyboardKey_wYn, 22, C.LogicalKeyboardKey_CzM, 21, C.LogicalKeyboardKey_muk, 20, C.LogicalKeyboardKey_O7X, 19, C.LogicalKeyboardKey_gCR, 143, C.LogicalKeyboardKey_uHn, 154, C.LogicalKeyboardKey_Npb, 155, C.LogicalKeyboardKey_iOn, 156, C.LogicalKeyboardKey_7xV, 157, C.LogicalKeyboardKey_YaH, 160, C.LogicalKeyboardKey_U2J, 145, C.LogicalKeyboardKey_qsT, 146, C.LogicalKeyboardKey_ka2, 147, C.LogicalKeyboardKey_Ddz, 148, C.LogicalKeyboardKey_YGD, 149, C.LogicalKeyboardKey_s0r, 150, C.LogicalKeyboardKey_atK0, 151, C.LogicalKeyboardKey_3bB, 152, C.LogicalKeyboardKey_sx4, 153, C.LogicalKeyboardKey_4IJ, 144, C.LogicalKeyboardKey_KQb, 158, C.LogicalKeyboardKey_iXq, 82, C.LogicalKeyboardKey_nDU, 26, C.LogicalKeyboardKey_4295426150_Power_null, 161, C.LogicalKeyboardKey_G2v, 259, C.LogicalKeyboardKey_4295426165_Help_null, 277, C.LogicalKeyboardKey_4295426171_Cut_null, 278, C.LogicalKeyboardKey_4295426172_Copy_null, 279, C.LogicalKeyboardKey_4295426173_Paste_null, 164, C.LogicalKeyboardKey_MjO, 24, C.LogicalKeyboardKey_gap, 25, C.LogicalKeyboardKey_c9P, 159, C.LogicalKeyboardKey_CLo, 214, C.LogicalKeyboardKey_4295426186_Convert_null, 213, C.LogicalKeyboardKey_sBE, 162, C.LogicalKeyboardKey_wEo, 163, C.LogicalKeyboardKey_8Nr, 113, C.LogicalKeyboardKey_p6t, 59, C.LogicalKeyboardKey_xok, 57, C.LogicalKeyboardKey_PD9, 117, C.LogicalKeyboardKey_D0U, 114, C.LogicalKeyboardKey_ijl, 60, C.LogicalKeyboardKey_QOu, 58, C.LogicalKeyboardKey_EtP, 118, C.LogicalKeyboardKey_O1c, 165, C.LogicalKeyboardKey_4295753824_Info_null, 175, C.LogicalKeyboardKey_ccN, 221, C.LogicalKeyboardKey_Djg, 220, C.LogicalKeyboardKey_ECL, 229, C.LogicalKeyboardKey_Pz5, 166, C.LogicalKeyboardKey_6QF, 167, C.LogicalKeyboardKey_3J4, 126, C.LogicalKeyboardKey_Azp, 130, C.LogicalKeyboardKey_8eb, 90, C.LogicalKeyboardKey_eEX, 89, C.LogicalKeyboardKey_kQR0, 87, C.LogicalKeyboardKey_n7o, 88, C.LogicalKeyboardKey_kHV, 86, C.LogicalKeyboardKey_wfl, 129, C.LogicalKeyboardKey_4295753912_Eject_null, 85, C.LogicalKeyboardKey_Cu4, 65, C.LogicalKeyboardKey_9gS, 207, C.LogicalKeyboardKey_mqK, 208, C.LogicalKeyboardKey_k44, 219, C.LogicalKeyboardKey_IQp, 128, C.LogicalKeyboardKey_4295754243_Close_null, 84, C.LogicalKeyboardKey_EWB, 125, C.LogicalKeyboardKey_8pc, 174, C.LogicalKeyboardKey_46S, 168, C.LogicalKeyboardKey_0Rr, 169, C.LogicalKeyboardKey_wIk, 255, C.LogicalKeyboardKey_ijl0], [P.int, G.LogicalKeyboardKey]);
    C.List_mode = H.setRuntimeTypeInfo(makeConstList(["mode"]), [P.String]);
    C.Map_9aZ6I = new H.ConstantStringMap(1, {mode: "basic"}, C.List_mode, [P.String, P.String]);
    C.SemanticsAction_1 = new P.SemanticsAction(1);
    C.SemanticsAction_2 = new P.SemanticsAction(2);
    C.SemanticsAction_4 = new P.SemanticsAction(4);
    C.SemanticsAction_8 = new P.SemanticsAction(8);
    C.SemanticsAction_16 = new P.SemanticsAction(16);
    C.SemanticsAction_32 = new P.SemanticsAction(32);
    C.SemanticsAction_64 = new P.SemanticsAction(64);
    C.SemanticsAction_128 = new P.SemanticsAction(128);
    C.SemanticsAction_256 = new P.SemanticsAction(256);
    C.SemanticsAction_512 = new P.SemanticsAction(512);
    C.SemanticsAction_1024 = new P.SemanticsAction(1024);
    C.SemanticsAction_2048 = new P.SemanticsAction(2048);
    C.SemanticsAction_4096 = new P.SemanticsAction(4096);
    C.SemanticsAction_8192 = new P.SemanticsAction(8192);
    C.SemanticsAction_16384 = new P.SemanticsAction(16384);
    C.SemanticsAction_32768 = new P.SemanticsAction(32768);
    C.SemanticsAction_65536 = new P.SemanticsAction(65536);
    C.SemanticsAction_131072 = new P.SemanticsAction(131072);
    C.SemanticsAction_262144 = new P.SemanticsAction(262144);
    C.SemanticsAction_524288 = new P.SemanticsAction(524288);
    C.SemanticsAction_1048576 = new P.SemanticsAction(1048576);
    C.Map_EC0yd = new H.GeneralConstantMap([1, C.SemanticsAction_1, 2, C.SemanticsAction_2, 4, C.SemanticsAction_4, 8, C.SemanticsAction_8, 16, C.SemanticsAction_16, 32, C.SemanticsAction_32, 64, C.SemanticsAction_64, 128, C.SemanticsAction_128, 256, C.SemanticsAction_256, 512, C.SemanticsAction_512, 1024, C.SemanticsAction_1024, 2048, C.SemanticsAction_2048, 4096, C.SemanticsAction_4096, 8192, C.SemanticsAction_8192, 16384, C.SemanticsAction_16384, 32768, C.SemanticsAction_32768, 65536, C.SemanticsAction_65536, 131072, C.SemanticsAction_131072, 262144, C.SemanticsAction_262144, 524288, C.SemanticsAction_524288, 1048576, C.SemanticsAction_1048576], [P.int, P.SemanticsAction]);
    C.Map_F1QoB = new H.GeneralConstantMap([75, C.LogicalKeyboardKey_Npb, 67, C.LogicalKeyboardKey_iOn, 78, C.LogicalKeyboardKey_7xV, 69, C.LogicalKeyboardKey_YaH, 83, C.LogicalKeyboardKey_qsT, 84, C.LogicalKeyboardKey_ka2, 85, C.LogicalKeyboardKey_Ddz, 86, C.LogicalKeyboardKey_YGD, 87, C.LogicalKeyboardKey_s0r, 88, C.LogicalKeyboardKey_atK0, 89, C.LogicalKeyboardKey_3bB, 91, C.LogicalKeyboardKey_sx4, 92, C.LogicalKeyboardKey_4IJ, 82, C.LogicalKeyboardKey_KQb, 65, C.LogicalKeyboardKey_iXq, 81, C.LogicalKeyboardKey_G2v, 95, C.LogicalKeyboardKey_CLo], [P.int, G.LogicalKeyboardKey]);
    C.Color_4294638330 = new P.Color(4294638330);
    C.Color_4294309365 = new P.Color(4294309365);
    C.Color_4293848814 = new P.Color(4293848814);
    C.Color_4292927712 = new P.Color(4292927712);
    C.Color_4292269782 = new P.Color(4292269782);
    C.Color_4290624957 = new P.Color(4290624957);
    C.Color_4288585374 = new P.Color(4288585374);
    C.Color_4285887861 = new P.Color(4285887861);
    C.Color_4284572001 = new P.Color(4284572001);
    C.Color_4282532418 = new P.Color(4282532418);
    C.Color_4281348144 = new P.Color(4281348144);
    C.Color_4280361249 = new P.Color(4280361249);
    C.Map_HFpTk = new H.GeneralConstantMap([50, C.Color_4294638330, 100, C.Color_4294309365, 200, C.Color_4293848814, 300, C.Color_4292927712, 350, C.Color_4292269782, 400, C.Color_4290624957, 500, C.Color_4288585374, 600, C.Color_4285887861, 700, C.Color_4284572001, 800, C.Color_4282532418, 850, C.Color_4281348144, 900, C.Color_4280361249], [P.int, P.Color]);
    C.Color_4294962158 = new P.Color(4294962158);
    C.Color_4294954450 = new P.Color(4294954450);
    C.Color_4293892762 = new P.Color(4293892762);
    C.Color_4293227379 = new P.Color(4293227379);
    C.Color_4293874512 = new P.Color(4293874512);
    C.Color_4294198070 = new P.Color(4294198070);
    C.Color_4293212469 = new P.Color(4293212469);
    C.Color_4292030255 = new P.Color(4292030255);
    C.Color_4291176488 = new P.Color(4291176488);
    C.Color_4290190364 = new P.Color(4290190364);
    C.Map_JNc9P = new H.GeneralConstantMap([50, C.Color_4294962158, 100, C.Color_4294954450, 200, C.Color_4293892762, 300, C.Color_4293227379, 400, C.Color_4293874512, 500, C.Color_4294198070, 600, C.Color_4293212469, 700, C.Color_4292030255, 800, C.Color_4291176488, 900, C.Color_4290190364], [P.int, P.Color]);
    C.PhysicalKeyboardKey_c4y = new G.PhysicalKeyboardKey(458756, "Key A");
    C.PhysicalKeyboardKey_Ui9 = new G.PhysicalKeyboardKey(458757, "Key B");
    C.PhysicalKeyboardKey_oqy = new G.PhysicalKeyboardKey(458758, "Key C");
    C.PhysicalKeyboardKey_Aec = new G.PhysicalKeyboardKey(458759, "Key D");
    C.PhysicalKeyboardKey_e7M = new G.PhysicalKeyboardKey(458760, "Key E");
    C.PhysicalKeyboardKey_WjS = new G.PhysicalKeyboardKey(458761, "Key F");
    C.PhysicalKeyboardKey_cgs = new G.PhysicalKeyboardKey(458762, "Key G");
    C.PhysicalKeyboardKey_O9K = new G.PhysicalKeyboardKey(458763, "Key H");
    C.PhysicalKeyboardKey_ATp = new G.PhysicalKeyboardKey(458764, "Key I");
    C.PhysicalKeyboardKey_8Qj = new G.PhysicalKeyboardKey(458765, "Key J");
    C.PhysicalKeyboardKey_02V = new G.PhysicalKeyboardKey(458766, "Key K");
    C.PhysicalKeyboardKey_2jN = new G.PhysicalKeyboardKey(458767, "Key L");
    C.PhysicalKeyboardKey_Pdn = new G.PhysicalKeyboardKey(458768, "Key M");
    C.PhysicalKeyboardKey_sQd = new G.PhysicalKeyboardKey(458769, "Key N");
    C.PhysicalKeyboardKey_oYc = new G.PhysicalKeyboardKey(458770, "Key O");
    C.PhysicalKeyboardKey_ClL = new G.PhysicalKeyboardKey(458771, "Key P");
    C.PhysicalKeyboardKey_ON8 = new G.PhysicalKeyboardKey(458772, "Key Q");
    C.PhysicalKeyboardKey_kfn = new G.PhysicalKeyboardKey(458773, "Key R");
    C.PhysicalKeyboardKey_yXI = new G.PhysicalKeyboardKey(458774, "Key S");
    C.PhysicalKeyboardKey_86y = new G.PhysicalKeyboardKey(458775, "Key T");
    C.PhysicalKeyboardKey_3NL = new G.PhysicalKeyboardKey(458776, "Key U");
    C.PhysicalKeyboardKey_Sof = new G.PhysicalKeyboardKey(458777, "Key V");
    C.PhysicalKeyboardKey_gc6 = new G.PhysicalKeyboardKey(458778, "Key W");
    C.PhysicalKeyboardKey_XTH = new G.PhysicalKeyboardKey(458779, "Key X");
    C.PhysicalKeyboardKey_699 = new G.PhysicalKeyboardKey(458780, "Key Y");
    C.PhysicalKeyboardKey_geL = new G.PhysicalKeyboardKey(458781, "Key Z");
    C.PhysicalKeyboardKey_9kk = new G.PhysicalKeyboardKey(458782, "Digit 1");
    C.PhysicalKeyboardKey_gEY = new G.PhysicalKeyboardKey(458783, "Digit 2");
    C.PhysicalKeyboardKey_Ddv = new G.PhysicalKeyboardKey(458784, "Digit 3");
    C.PhysicalKeyboardKey_aNU = new G.PhysicalKeyboardKey(458785, "Digit 4");
    C.PhysicalKeyboardKey_gc60 = new G.PhysicalKeyboardKey(458786, "Digit 5");
    C.PhysicalKeyboardKey_wg4 = new G.PhysicalKeyboardKey(458787, "Digit 6");
    C.PhysicalKeyboardKey_Tkj = new G.PhysicalKeyboardKey(458788, "Digit 7");
    C.PhysicalKeyboardKey_GRf = new G.PhysicalKeyboardKey(458789, "Digit 8");
    C.PhysicalKeyboardKey_C4W = new G.PhysicalKeyboardKey(458790, "Digit 9");
    C.PhysicalKeyboardKey_eYS = new G.PhysicalKeyboardKey(458791, "Digit 0");
    C.PhysicalKeyboardKey_458792_Enter = new G.PhysicalKeyboardKey(458792, "Enter");
    C.PhysicalKeyboardKey_458793_Escape = new G.PhysicalKeyboardKey(458793, "Escape");
    C.PhysicalKeyboardKey_458794_Backspace = new G.PhysicalKeyboardKey(458794, "Backspace");
    C.PhysicalKeyboardKey_458795_Tab = new G.PhysicalKeyboardKey(458795, "Tab");
    C.PhysicalKeyboardKey_458796_Space = new G.PhysicalKeyboardKey(458796, "Space");
    C.PhysicalKeyboardKey_458797_Minus = new G.PhysicalKeyboardKey(458797, "Minus");
    C.PhysicalKeyboardKey_458798_Equal = new G.PhysicalKeyboardKey(458798, "Equal");
    C.PhysicalKeyboardKey_Dx1 = new G.PhysicalKeyboardKey(458799, "Bracket Left");
    C.PhysicalKeyboardKey_YIZ = new G.PhysicalKeyboardKey(458800, "Bracket Right");
    C.PhysicalKeyboardKey_458801_Backslash = new G.PhysicalKeyboardKey(458801, "Backslash");
    C.PhysicalKeyboardKey_458803_Semicolon = new G.PhysicalKeyboardKey(458803, "Semicolon");
    C.PhysicalKeyboardKey_458804_Quote = new G.PhysicalKeyboardKey(458804, "Quote");
    C.PhysicalKeyboardKey_458805_Backquote = new G.PhysicalKeyboardKey(458805, "Backquote");
    C.PhysicalKeyboardKey_458806_Comma = new G.PhysicalKeyboardKey(458806, "Comma");
    C.PhysicalKeyboardKey_458807_Period = new G.PhysicalKeyboardKey(458807, "Period");
    C.PhysicalKeyboardKey_458808_Slash = new G.PhysicalKeyboardKey(458808, "Slash");
    C.PhysicalKeyboardKey_eAf = new G.PhysicalKeyboardKey(458809, "Caps Lock");
    C.PhysicalKeyboardKey_458810_F1 = new G.PhysicalKeyboardKey(458810, "F1");
    C.PhysicalKeyboardKey_458811_F2 = new G.PhysicalKeyboardKey(458811, "F2");
    C.PhysicalKeyboardKey_458812_F3 = new G.PhysicalKeyboardKey(458812, "F3");
    C.PhysicalKeyboardKey_458813_F4 = new G.PhysicalKeyboardKey(458813, "F4");
    C.PhysicalKeyboardKey_458814_F5 = new G.PhysicalKeyboardKey(458814, "F5");
    C.PhysicalKeyboardKey_458815_F6 = new G.PhysicalKeyboardKey(458815, "F6");
    C.PhysicalKeyboardKey_458816_F7 = new G.PhysicalKeyboardKey(458816, "F7");
    C.PhysicalKeyboardKey_458817_F8 = new G.PhysicalKeyboardKey(458817, "F8");
    C.PhysicalKeyboardKey_458818_F9 = new G.PhysicalKeyboardKey(458818, "F9");
    C.PhysicalKeyboardKey_458819_F10 = new G.PhysicalKeyboardKey(458819, "F10");
    C.PhysicalKeyboardKey_458820_F11 = new G.PhysicalKeyboardKey(458820, "F11");
    C.PhysicalKeyboardKey_458821_F12 = new G.PhysicalKeyboardKey(458821, "F12");
    C.PhysicalKeyboardKey_458825_Insert = new G.PhysicalKeyboardKey(458825, "Insert");
    C.PhysicalKeyboardKey_458826_Home = new G.PhysicalKeyboardKey(458826, "Home");
    C.PhysicalKeyboardKey_gg9 = new G.PhysicalKeyboardKey(458827, "Page Up");
    C.PhysicalKeyboardKey_458828_Delete = new G.PhysicalKeyboardKey(458828, "Delete");
    C.PhysicalKeyboardKey_458829_End = new G.PhysicalKeyboardKey(458829, "End");
    C.PhysicalKeyboardKey_UCG = new G.PhysicalKeyboardKey(458830, "Page Down");
    C.PhysicalKeyboardKey_Q8r = new G.PhysicalKeyboardKey(458831, "Arrow Right");
    C.PhysicalKeyboardKey_4iW = new G.PhysicalKeyboardKey(458832, "Arrow Left");
    C.PhysicalKeyboardKey_G79 = new G.PhysicalKeyboardKey(458833, "Arrow Down");
    C.PhysicalKeyboardKey_ytW = new G.PhysicalKeyboardKey(458834, "Arrow Up");
    C.PhysicalKeyboardKey_A3V = new G.PhysicalKeyboardKey(458835, "Num Lock");
    C.PhysicalKeyboardKey_A4L = new G.PhysicalKeyboardKey(458836, "Numpad Divide");
    C.PhysicalKeyboardKey_cgN = new G.PhysicalKeyboardKey(458837, "Numpad Multiply");
    C.PhysicalKeyboardKey_43h = new G.PhysicalKeyboardKey(458838, "Numpad Subtract");
    C.PhysicalKeyboardKey_OGx = new G.PhysicalKeyboardKey(458839, "Numpad Add");
    C.PhysicalKeyboardKey_6dA = new G.PhysicalKeyboardKey(458840, "Numpad Enter");
    C.PhysicalKeyboardKey_si2 = new G.PhysicalKeyboardKey(458841, "Numpad 1");
    C.PhysicalKeyboardKey_si20 = new G.PhysicalKeyboardKey(458842, "Numpad 2");
    C.PhysicalKeyboardKey_si21 = new G.PhysicalKeyboardKey(458843, "Numpad 3");
    C.PhysicalKeyboardKey_si22 = new G.PhysicalKeyboardKey(458844, "Numpad 4");
    C.PhysicalKeyboardKey_CtV = new G.PhysicalKeyboardKey(458845, "Numpad 5");
    C.PhysicalKeyboardKey_CtV0 = new G.PhysicalKeyboardKey(458846, "Numpad 6");
    C.PhysicalKeyboardKey_CtV1 = new G.PhysicalKeyboardKey(458847, "Numpad 7");
    C.PhysicalKeyboardKey_U44 = new G.PhysicalKeyboardKey(458848, "Numpad 8");
    C.PhysicalKeyboardKey_U440 = new G.PhysicalKeyboardKey(458849, "Numpad 9");
    C.PhysicalKeyboardKey_U441 = new G.PhysicalKeyboardKey(458850, "Numpad 0");
    C.PhysicalKeyboardKey_s0y = new G.PhysicalKeyboardKey(458851, "Numpad Decimal");
    C.PhysicalKeyboardKey_jrj = new G.PhysicalKeyboardKey(458852, "Intl Backslash");
    C.PhysicalKeyboardKey_m5d = new G.PhysicalKeyboardKey(458853, "Context Menu");
    C.PhysicalKeyboardKey_izR = new G.PhysicalKeyboardKey(458855, "Numpad Equal");
    C.PhysicalKeyboardKey_458856_F13 = new G.PhysicalKeyboardKey(458856, "F13");
    C.PhysicalKeyboardKey_458857_F14 = new G.PhysicalKeyboardKey(458857, "F14");
    C.PhysicalKeyboardKey_458858_F15 = new G.PhysicalKeyboardKey(458858, "F15");
    C.PhysicalKeyboardKey_458859_F16 = new G.PhysicalKeyboardKey(458859, "F16");
    C.PhysicalKeyboardKey_458860_F17 = new G.PhysicalKeyboardKey(458860, "F17");
    C.PhysicalKeyboardKey_458861_F18 = new G.PhysicalKeyboardKey(458861, "F18");
    C.PhysicalKeyboardKey_458862_F19 = new G.PhysicalKeyboardKey(458862, "F19");
    C.PhysicalKeyboardKey_458863_F20 = new G.PhysicalKeyboardKey(458863, "F20");
    C.PhysicalKeyboardKey_042 = new G.PhysicalKeyboardKey(458879, "Audio Volume Mute");
    C.PhysicalKeyboardKey_yjH = new G.PhysicalKeyboardKey(458880, "Audio Volume Up");
    C.PhysicalKeyboardKey_2nP = new G.PhysicalKeyboardKey(458881, "Audio Volume Down");
    C.PhysicalKeyboardKey_AoG = new G.PhysicalKeyboardKey(458885, "Numpad Comma");
    C.PhysicalKeyboardKey_4OV = new G.PhysicalKeyboardKey(458887, "Intl Ro");
    C.PhysicalKeyboardKey_Yqx = new G.PhysicalKeyboardKey(458888, "Kana Mode");
    C.PhysicalKeyboardKey_y47 = new G.PhysicalKeyboardKey(458889, "Intl Yen");
    C.PhysicalKeyboardKey_wEo = new G.PhysicalKeyboardKey(458976, "Control Left");
    C.PhysicalKeyboardKey_Y3m = new G.PhysicalKeyboardKey(458977, "Shift Left");
    C.PhysicalKeyboardKey_CNh = new G.PhysicalKeyboardKey(458978, "Alt Left");
    C.PhysicalKeyboardKey_gg90 = new G.PhysicalKeyboardKey(458979, "Meta Left");
    C.PhysicalKeyboardKey_Q4j = new G.PhysicalKeyboardKey(458980, "Control Right");
    C.PhysicalKeyboardKey_fBD = new G.PhysicalKeyboardKey(458981, "Shift Right");
    C.PhysicalKeyboardKey_7FR = new G.PhysicalKeyboardKey(458982, "Alt Right");
    C.PhysicalKeyboardKey_INA = new G.PhysicalKeyboardKey(458983, "Meta Right");
    C.Map_QtQ1t = new H.GeneralConstantMap([0, C.PhysicalKeyboardKey_c4y, 11, C.PhysicalKeyboardKey_Ui9, 8, C.PhysicalKeyboardKey_oqy, 2, C.PhysicalKeyboardKey_Aec, 14, C.PhysicalKeyboardKey_e7M, 3, C.PhysicalKeyboardKey_WjS, 5, C.PhysicalKeyboardKey_cgs, 4, C.PhysicalKeyboardKey_O9K, 34, C.PhysicalKeyboardKey_ATp, 38, C.PhysicalKeyboardKey_8Qj, 40, C.PhysicalKeyboardKey_02V, 37, C.PhysicalKeyboardKey_2jN, 46, C.PhysicalKeyboardKey_Pdn, 45, C.PhysicalKeyboardKey_sQd, 31, C.PhysicalKeyboardKey_oYc, 35, C.PhysicalKeyboardKey_ClL, 12, C.PhysicalKeyboardKey_ON8, 15, C.PhysicalKeyboardKey_kfn, 1, C.PhysicalKeyboardKey_yXI, 17, C.PhysicalKeyboardKey_86y, 32, C.PhysicalKeyboardKey_3NL, 9, C.PhysicalKeyboardKey_Sof, 13, C.PhysicalKeyboardKey_gc6, 7, C.PhysicalKeyboardKey_XTH, 16, C.PhysicalKeyboardKey_699, 6, C.PhysicalKeyboardKey_geL, 18, C.PhysicalKeyboardKey_9kk, 19, C.PhysicalKeyboardKey_gEY, 20, C.PhysicalKeyboardKey_Ddv, 21, C.PhysicalKeyboardKey_aNU, 23, C.PhysicalKeyboardKey_gc60, 22, C.PhysicalKeyboardKey_wg4, 26, C.PhysicalKeyboardKey_Tkj, 28, C.PhysicalKeyboardKey_GRf, 25, C.PhysicalKeyboardKey_C4W, 29, C.PhysicalKeyboardKey_eYS, 36, C.PhysicalKeyboardKey_458792_Enter, 53, C.PhysicalKeyboardKey_458793_Escape, 51, C.PhysicalKeyboardKey_458794_Backspace, 48, C.PhysicalKeyboardKey_458795_Tab, 49, C.PhysicalKeyboardKey_458796_Space, 27, C.PhysicalKeyboardKey_458797_Minus, 24, C.PhysicalKeyboardKey_458798_Equal, 33, C.PhysicalKeyboardKey_Dx1, 30, C.PhysicalKeyboardKey_YIZ, 42, C.PhysicalKeyboardKey_458801_Backslash, 41, C.PhysicalKeyboardKey_458803_Semicolon, 39, C.PhysicalKeyboardKey_458804_Quote, 50, C.PhysicalKeyboardKey_458805_Backquote, 43, C.PhysicalKeyboardKey_458806_Comma, 47, C.PhysicalKeyboardKey_458807_Period, 44, C.PhysicalKeyboardKey_458808_Slash, 57, C.PhysicalKeyboardKey_eAf, 122, C.PhysicalKeyboardKey_458810_F1, 120, C.PhysicalKeyboardKey_458811_F2, 99, C.PhysicalKeyboardKey_458812_F3, 118, C.PhysicalKeyboardKey_458813_F4, 96, C.PhysicalKeyboardKey_458814_F5, 97, C.PhysicalKeyboardKey_458815_F6, 98, C.PhysicalKeyboardKey_458816_F7, 100, C.PhysicalKeyboardKey_458817_F8, 101, C.PhysicalKeyboardKey_458818_F9, 109, C.PhysicalKeyboardKey_458819_F10, 103, C.PhysicalKeyboardKey_458820_F11, 111, C.PhysicalKeyboardKey_458821_F12, 114, C.PhysicalKeyboardKey_458825_Insert, 115, C.PhysicalKeyboardKey_458826_Home, 116, C.PhysicalKeyboardKey_gg9, 117, C.PhysicalKeyboardKey_458828_Delete, 119, C.PhysicalKeyboardKey_458829_End, 121, C.PhysicalKeyboardKey_UCG, 124, C.PhysicalKeyboardKey_Q8r, 123, C.PhysicalKeyboardKey_4iW, 125, C.PhysicalKeyboardKey_G79, 126, C.PhysicalKeyboardKey_ytW, 71, C.PhysicalKeyboardKey_A3V, 75, C.PhysicalKeyboardKey_A4L, 67, C.PhysicalKeyboardKey_cgN, 78, C.PhysicalKeyboardKey_43h, 69, C.PhysicalKeyboardKey_OGx, 76, C.PhysicalKeyboardKey_6dA, 83, C.PhysicalKeyboardKey_si2, 84, C.PhysicalKeyboardKey_si20, 85, C.PhysicalKeyboardKey_si21, 86, C.PhysicalKeyboardKey_si22, 87, C.PhysicalKeyboardKey_CtV, 88, C.PhysicalKeyboardKey_CtV0, 89, C.PhysicalKeyboardKey_CtV1, 91, C.PhysicalKeyboardKey_U44, 92, C.PhysicalKeyboardKey_U440, 82, C.PhysicalKeyboardKey_U441, 65, C.PhysicalKeyboardKey_s0y, 10, C.PhysicalKeyboardKey_jrj, 110, C.PhysicalKeyboardKey_m5d, 81, C.PhysicalKeyboardKey_izR, 105, C.PhysicalKeyboardKey_458856_F13, 107, C.PhysicalKeyboardKey_458857_F14, 113, C.PhysicalKeyboardKey_458858_F15, 106, C.PhysicalKeyboardKey_458859_F16, 64, C.PhysicalKeyboardKey_458860_F17, 79, C.PhysicalKeyboardKey_458861_F18, 80, C.PhysicalKeyboardKey_458862_F19, 90, C.PhysicalKeyboardKey_458863_F20, 74, C.PhysicalKeyboardKey_042, 72, C.PhysicalKeyboardKey_yjH, 73, C.PhysicalKeyboardKey_2nP, 95, C.PhysicalKeyboardKey_AoG, 94, C.PhysicalKeyboardKey_4OV, 104, C.PhysicalKeyboardKey_Yqx, 93, C.PhysicalKeyboardKey_y47, 59, C.PhysicalKeyboardKey_wEo, 56, C.PhysicalKeyboardKey_Y3m, 58, C.PhysicalKeyboardKey_CNh, 55, C.PhysicalKeyboardKey_gg90, 62, C.PhysicalKeyboardKey_Q4j, 60, C.PhysicalKeyboardKey_fBD, 61, C.PhysicalKeyboardKey_7FR, 54, C.PhysicalKeyboardKey_INA], [P.int, G.PhysicalKeyboardKey]);
    C.List_empty5 = H.setRuntimeTypeInfo(makeConstList([]), [P.String]);
    C.Map_empty = new H.ConstantStringMap(0, {}, C.List_empty5, [P.String, {func: 1, ret: N.Widget, args: [N.BuildContext]}]);
    C.Map_empty1 = new H.ConstantStringMap(0, {}, C.List_empty5, [P.String, null]);
    C.List_empty6 = H.setRuntimeTypeInfo(makeConstList([]), [P.Type]);
    C.Map_empty0 = new H.ConstantStringMap(0, {}, C.List_empty6, [P.Type, S.GestureRecognizer]);
    C.Color_4289200107 = new P.Color(4289200107);
    C.Color_4284809178 = new P.Color(4284809178);
    C.Color_4280150454 = new P.Color(4280150454);
    C.Color_4278239141 = new P.Color(4278239141);
    C.Map_iTYZn = new H.GeneralConstantMap([100, C.Color_4289200107, 200, C.Color_4284809178, 400, C.Color_4280150454, 700, C.Color_4278239141], [P.int, P.Color]);
    C.LogicalKeyboardKey_4295426152_F13_null = new G.LogicalKeyboardKey(4295426152, "F13", null);
    C.LogicalKeyboardKey_4295426153_F14_null = new G.LogicalKeyboardKey(4295426153, "F14", null);
    C.LogicalKeyboardKey_4295426154_F15_null = new G.LogicalKeyboardKey(4295426154, "F15", null);
    C.LogicalKeyboardKey_4295426155_F16_null = new G.LogicalKeyboardKey(4295426155, "F16", null);
    C.LogicalKeyboardKey_4295426156_F17_null = new G.LogicalKeyboardKey(4295426156, "F17", null);
    C.LogicalKeyboardKey_4295426157_F18_null = new G.LogicalKeyboardKey(4295426157, "F18", null);
    C.LogicalKeyboardKey_4295426158_F19_null = new G.LogicalKeyboardKey(4295426158, "F19", null);
    C.LogicalKeyboardKey_4295426159_F20_null = new G.LogicalKeyboardKey(4295426159, "F20", null);
    C.LogicalKeyboardKey_4295426160_F21_null = new G.LogicalKeyboardKey(4295426160, "F21", null);
    C.LogicalKeyboardKey_4295426161_F22_null = new G.LogicalKeyboardKey(4295426161, "F22", null);
    C.LogicalKeyboardKey_4295426162_F23_null = new G.LogicalKeyboardKey(4295426162, "F23", null);
    C.Map_ifV1A = new H.GeneralConstantMap([65, C.LogicalKeyboardKey_7G2, 66, C.LogicalKeyboardKey_jjv, 67, C.LogicalKeyboardKey_mF8, 68, C.LogicalKeyboardKey_ICU, 69, C.LogicalKeyboardKey_AaU, 70, C.LogicalKeyboardKey_2jN, 71, C.LogicalKeyboardKey_cKo, 72, C.LogicalKeyboardKey_QhK, 73, C.LogicalKeyboardKey_swi, 74, C.LogicalKeyboardKey_CG7, 75, C.LogicalKeyboardKey_3jH, 76, C.LogicalKeyboardKey_4iU, 77, C.LogicalKeyboardKey_oe4, 78, C.LogicalKeyboardKey_OLv, 79, C.LogicalKeyboardKey_sav, 80, C.LogicalKeyboardKey_M6L, 81, C.LogicalKeyboardKey_Ods, 82, C.LogicalKeyboardKey_qsN, 83, C.LogicalKeyboardKey_fLj, 84, C.LogicalKeyboardKey_V86, 85, C.LogicalKeyboardKey_Tng, 86, C.LogicalKeyboardKey_6Ng, 87, C.LogicalKeyboardKey_XaR, 88, C.LogicalKeyboardKey_ifx, 89, C.LogicalKeyboardKey_kQR, 90, C.LogicalKeyboardKey_W2D, 49, C.LogicalKeyboardKey_4AN, 50, C.LogicalKeyboardKey_mmo, 51, C.LogicalKeyboardKey_a7X, 52, C.LogicalKeyboardKey_e9s, 53, C.LogicalKeyboardKey_43h, 54, C.LogicalKeyboardKey_CmI, 55, C.LogicalKeyboardKey_Db0, 56, C.LogicalKeyboardKey_GZG, 57, C.LogicalKeyboardKey_86y, 48, C.LogicalKeyboardKey_0, 257, C.LogicalKeyboardKey_4295426088_Enter_null, 256, C.LogicalKeyboardKey_4295426089_Escape_null, 259, C.LogicalKeyboardKey_4295426090_Backspace_null, 258, C.LogicalKeyboardKey_4295426091_Tab_null, 32, C.LogicalKeyboardKey_YdN, 45, C.LogicalKeyboardKey_oEN, 61, C.LogicalKeyboardKey_wrE, 91, C.LogicalKeyboardKey_TLI, 93, C.LogicalKeyboardKey_awJ, 92, C.LogicalKeyboardKey_cdS, 59, C.LogicalKeyboardKey_atK, 39, C.LogicalKeyboardKey_Qo8, 96, C.LogicalKeyboardKey_7FR, 44, C.LogicalKeyboardKey_71T, 46, C.LogicalKeyboardKey_h8g, 47, C.LogicalKeyboardKey_ouN, 280, C.LogicalKeyboardKey_OWF, 290, C.LogicalKeyboardKey_4295426106_F1_null, 291, C.LogicalKeyboardKey_4295426107_F2_null, 292, C.LogicalKeyboardKey_4295426108_F3_null, 293, C.LogicalKeyboardKey_4295426109_F4_null, 294, C.LogicalKeyboardKey_4295426110_F5_null, 295, C.LogicalKeyboardKey_4295426111_F6_null, 296, C.LogicalKeyboardKey_4295426112_F7_null, 297, C.LogicalKeyboardKey_4295426113_F8_null, 298, C.LogicalKeyboardKey_4295426114_F9_null, 299, C.LogicalKeyboardKey_4295426115_F10_null, 300, C.LogicalKeyboardKey_4295426116_F11_null, 301, C.LogicalKeyboardKey_4295426117_F12_null, 283, C.LogicalKeyboardKey_wAl, 284, C.LogicalKeyboardKey_4295426120_Pause_null, 260, C.LogicalKeyboardKey_4295426121_Insert_null, 268, C.LogicalKeyboardKey_4295426122_Home_null, 266, C.LogicalKeyboardKey_mgB, 261, C.LogicalKeyboardKey_4295426124_Delete_null, 269, C.LogicalKeyboardKey_4295426125_End_null, 267, C.LogicalKeyboardKey_wYn, 262, C.LogicalKeyboardKey_CzM, 263, C.LogicalKeyboardKey_muk, 264, C.LogicalKeyboardKey_O7X, 265, C.LogicalKeyboardKey_gCR, 282, C.LogicalKeyboardKey_uHn, 331, C.LogicalKeyboardKey_Npb, 332, C.LogicalKeyboardKey_iOn, 334, C.LogicalKeyboardKey_YaH, 335, C.LogicalKeyboardKey_U2J, 321, C.LogicalKeyboardKey_qsT, 322, C.LogicalKeyboardKey_ka2, 323, C.LogicalKeyboardKey_Ddz, 324, C.LogicalKeyboardKey_YGD, 325, C.LogicalKeyboardKey_s0r, 326, C.LogicalKeyboardKey_atK0, 327, C.LogicalKeyboardKey_3bB, 328, C.LogicalKeyboardKey_sx4, 329, C.LogicalKeyboardKey_4IJ, 320, C.LogicalKeyboardKey_KQb, 330, C.LogicalKeyboardKey_iXq, 348, C.LogicalKeyboardKey_nDU, 336, C.LogicalKeyboardKey_G2v, 302, C.LogicalKeyboardKey_4295426152_F13_null, 303, C.LogicalKeyboardKey_4295426153_F14_null, 304, C.LogicalKeyboardKey_4295426154_F15_null, 305, C.LogicalKeyboardKey_4295426155_F16_null, 306, C.LogicalKeyboardKey_4295426156_F17_null, 307, C.LogicalKeyboardKey_4295426157_F18_null, 308, C.LogicalKeyboardKey_4295426158_F19_null, 309, C.LogicalKeyboardKey_4295426159_F20_null, 310, C.LogicalKeyboardKey_4295426160_F21_null, 311, C.LogicalKeyboardKey_4295426161_F22_null, 312, C.LogicalKeyboardKey_4295426162_F23_null, 341, C.LogicalKeyboardKey_p6t, 340, C.LogicalKeyboardKey_xok, 342, C.LogicalKeyboardKey_PD9, 345, C.LogicalKeyboardKey_ijl, 344, C.LogicalKeyboardKey_QOu, 346, C.LogicalKeyboardKey_EtP], [P.int, G.LogicalKeyboardKey]);
    C.C_CupertinoPageTransitionsBuilder = new K.CupertinoPageTransitionsBuilder();
    C.Map_leqom = new H.GeneralConstantMap([C.TargetPlatform_0, C.C_FadeUpwardsPageTransitionsBuilder, C.TargetPlatform_2, C.C_CupertinoPageTransitionsBuilder], [T.TargetPlatform, K.PageTransitionsBuilder]);
    C.Map_s3kmC = new H.GeneralConstantMap([331, C.LogicalKeyboardKey_Npb, 332, C.LogicalKeyboardKey_iOn, 334, C.LogicalKeyboardKey_YaH, 321, C.LogicalKeyboardKey_qsT, 322, C.LogicalKeyboardKey_ka2, 323, C.LogicalKeyboardKey_Ddz, 324, C.LogicalKeyboardKey_YGD, 325, C.LogicalKeyboardKey_s0r, 326, C.LogicalKeyboardKey_atK0, 327, C.LogicalKeyboardKey_3bB, 328, C.LogicalKeyboardKey_sx4, 329, C.LogicalKeyboardKey_4IJ, 320, C.LogicalKeyboardKey_KQb, 330, C.LogicalKeyboardKey_iXq, 336, C.LogicalKeyboardKey_G2v], [P.int, G.LogicalKeyboardKey]);
    C.Map_uS2jN = new H.GeneralConstantMap([154, C.LogicalKeyboardKey_Npb, 155, C.LogicalKeyboardKey_iOn, 156, C.LogicalKeyboardKey_7xV, 157, C.LogicalKeyboardKey_YaH, 145, C.LogicalKeyboardKey_qsT, 146, C.LogicalKeyboardKey_ka2, 147, C.LogicalKeyboardKey_Ddz, 148, C.LogicalKeyboardKey_YGD, 149, C.LogicalKeyboardKey_s0r, 150, C.LogicalKeyboardKey_atK0, 151, C.LogicalKeyboardKey_3bB, 152, C.LogicalKeyboardKey_sx4, 153, C.LogicalKeyboardKey_4IJ, 144, C.LogicalKeyboardKey_KQb, 158, C.LogicalKeyboardKey_iXq, 161, C.LogicalKeyboardKey_G2v, 159, C.LogicalKeyboardKey_CLo, 162, C.LogicalKeyboardKey_wEo, 163, C.LogicalKeyboardKey_8Nr], [P.int, G.LogicalKeyboardKey]);
    C.SemanticsFlag_1 = new P.SemanticsFlag(1);
    C.SemanticsFlag_2 = new P.SemanticsFlag(2);
    C.SemanticsFlag_4 = new P.SemanticsFlag(4);
    C.SemanticsFlag_8 = new P.SemanticsFlag(8);
    C.SemanticsFlag_16 = new P.SemanticsFlag(16);
    C.SemanticsFlag_32 = new P.SemanticsFlag(32);
    C.SemanticsFlag_64 = new P.SemanticsFlag(64);
    C.SemanticsFlag_128 = new P.SemanticsFlag(128);
    C.SemanticsFlag_256 = new P.SemanticsFlag(256);
    C.SemanticsFlag_512 = new P.SemanticsFlag(512);
    C.SemanticsFlag_1024 = new P.SemanticsFlag(1024);
    C.SemanticsFlag_2048 = new P.SemanticsFlag(2048);
    C.SemanticsFlag_4096 = new P.SemanticsFlag(4096);
    C.SemanticsFlag_8192 = new P.SemanticsFlag(8192);
    C.SemanticsFlag_16384 = new P.SemanticsFlag(16384);
    C.SemanticsFlag_32768 = new P.SemanticsFlag(32768);
    C.SemanticsFlag_65536 = new P.SemanticsFlag(65536);
    C.SemanticsFlag_131072 = new P.SemanticsFlag(131072);
    C.SemanticsFlag_262144 = new P.SemanticsFlag(262144);
    C.Map_uSfdF = new H.GeneralConstantMap([1, C.SemanticsFlag_1, 2, C.SemanticsFlag_2, 4, C.SemanticsFlag_4, 8, C.SemanticsFlag_8, 16, C.SemanticsFlag_16, 32, C.SemanticsFlag_32, 64, C.SemanticsFlag_64, 128, C.SemanticsFlag_128, 256, C.SemanticsFlag_256, 512, C.SemanticsFlag_512, 1024, C.SemanticsFlag_1024, 2048, C.SemanticsFlag_2048, 4096, C.SemanticsFlag_4096, 8192, C.SemanticsFlag_8192, 16384, C.SemanticsFlag_16384, 32768, C.SemanticsFlag_32768, 65536, C.SemanticsFlag_65536, 131072, C.SemanticsFlag_131072, 262144, C.SemanticsFlag_262144], [P.int, P.SemanticsFlag]);
    C.LogicalKeyboardKey_4294967312_Hyper_null = new G.LogicalKeyboardKey(4294967312, "Hyper", null);
    C.LogicalKeyboardKey_No3 = new G.LogicalKeyboardKey(4294967313, "Super Key", null);
    C.LogicalKeyboardKey_wz6 = new G.LogicalKeyboardKey(4294967315, "Fn Lock", null);
    C.LogicalKeyboardKey_4294967316_Suspend_null = new G.LogicalKeyboardKey(4294967316, "Suspend", null);
    C.LogicalKeyboardKey_4294967317_Resume_null = new G.LogicalKeyboardKey(4294967317, "Resume", null);
    C.LogicalKeyboardKey_4294967318_Turbo_null = new G.LogicalKeyboardKey(4294967318, "Turbo", null);
    C.LogicalKeyboardKey_M6i = new G.LogicalKeyboardKey(4295033013, "Display Toggle Int Ext", null);
    C.LogicalKeyboardKey_8uL = new G.LogicalKeyboardKey(4295426048, "Usb Reserved", null);
    C.LogicalKeyboardKey_2nn = new G.LogicalKeyboardKey(4295426049, "Usb Error Roll Over", null);
    C.LogicalKeyboardKey_2bx = new G.LogicalKeyboardKey(4295426050, "Usb Post Fail", null);
    C.LogicalKeyboardKey_FYo = new G.LogicalKeyboardKey(4295426051, "Usb Error Undefined", null);
    C.LogicalKeyboardKey_6vi = new G.LogicalKeyboardKey(4295426148, "Intl Backslash", null);
    C.LogicalKeyboardKey_4295426163_F24_null = new G.LogicalKeyboardKey(4295426163, "F24", null);
    C.LogicalKeyboardKey_4295426164_Open_null = new G.LogicalKeyboardKey(4295426164, "Open", null);
    C.LogicalKeyboardKey_4295426167_Select_null = new G.LogicalKeyboardKey(4295426167, "Select", null);
    C.LogicalKeyboardKey_4295426169_Again_null = new G.LogicalKeyboardKey(4295426169, "Again", null);
    C.LogicalKeyboardKey_4295426170_Undo_null = new G.LogicalKeyboardKey(4295426170, "Undo", null);
    C.LogicalKeyboardKey_4295426174_Find_null = new G.LogicalKeyboardKey(4295426174, "Find", null);
    C.LogicalKeyboardKey_iDZ = new G.LogicalKeyboardKey(4295426183, "Intl Ro", null);
    C.LogicalKeyboardKey_aBa = new G.LogicalKeyboardKey(4295426184, "Kana Mode", null);
    C.LogicalKeyboardKey_c0h = new G.LogicalKeyboardKey(4295426185, "Intl Yen", null);
    C.LogicalKeyboardKey_nx9 = new G.LogicalKeyboardKey(4295426192, "Lang 1", null);
    C.LogicalKeyboardKey_nx90 = new G.LogicalKeyboardKey(4295426193, "Lang 2", null);
    C.LogicalKeyboardKey_nx91 = new G.LogicalKeyboardKey(4295426194, "Lang 3", null);
    C.LogicalKeyboardKey_nx92 = new G.LogicalKeyboardKey(4295426195, "Lang 4", null);
    C.LogicalKeyboardKey_nx93 = new G.LogicalKeyboardKey(4295426196, "Lang 5", null);
    C.LogicalKeyboardKey_4295426203_Abort_null = new G.LogicalKeyboardKey(4295426203, "Abort", null);
    C.LogicalKeyboardKey_4295426211_Props_null = new G.LogicalKeyboardKey(4295426211, "Props", null);
    C.LogicalKeyboardKey_MUx = new G.LogicalKeyboardKey(4295426235, "Numpad Backspace", null);
    C.LogicalKeyboardKey_2Zx = new G.LogicalKeyboardKey(4295426256, "Numpad Memory Store", null);
    C.LogicalKeyboardKey_qqh = new G.LogicalKeyboardKey(4295426257, "Numpad Memory Recall", null);
    C.LogicalKeyboardKey_CxF = new G.LogicalKeyboardKey(4295426258, "Numpad Memory Clear", null);
    C.LogicalKeyboardKey_I9f = new G.LogicalKeyboardKey(4295426259, "Numpad Memory Add", null);
    C.LogicalKeyboardKey_YQd = new G.LogicalKeyboardKey(4295426260, "Numpad Memory Subtract", null);
    C.LogicalKeyboardKey_75N = new G.LogicalKeyboardKey(4295426263, "Numpad Sign Change", null);
    C.LogicalKeyboardKey_U86 = new G.LogicalKeyboardKey(4295426264, "Numpad Clear", null);
    C.LogicalKeyboardKey_OBv = new G.LogicalKeyboardKey(4295426265, "Numpad Clear Entry", null);
    C.LogicalKeyboardKey_B8J = new G.LogicalKeyboardKey(4295753842, "Brightness Toggle", null);
    C.LogicalKeyboardKey_kc1 = new G.LogicalKeyboardKey(4295753843, "Brightness Minimum", null);
    C.LogicalKeyboardKey_kc10 = new G.LogicalKeyboardKey(4295753844, "Brightness Maximum", null);
    C.LogicalKeyboardKey_HDR = new G.LogicalKeyboardKey(4295753845, "Brightness Auto", null);
    C.LogicalKeyboardKey_Ak1 = new G.LogicalKeyboardKey(4295753868, "Launch Phone", null);
    C.LogicalKeyboardKey_wg3 = new G.LogicalKeyboardKey(4295753869, "Program Guide", null);
    C.LogicalKeyboardKey_4295753876_Exit_null = new G.LogicalKeyboardKey(4295753876, "Exit", null);
    C.LogicalKeyboardKey_Q5s = new G.LogicalKeyboardKey(4295753935, "Speech Input Toggle", null);
    C.LogicalKeyboardKey_qNA = new G.LogicalKeyboardKey(4295753957, "Bass Boost", null);
    C.LogicalKeyboardKey_oPr = new G.LogicalKeyboardKey(4295754115, "Media Select", null);
    C.LogicalKeyboardKey_2Ly = new G.LogicalKeyboardKey(4295754116, "Launch Word Processor", null);
    C.LogicalKeyboardKey_8Gl = new G.LogicalKeyboardKey(4295754118, "Launch Spreadsheet", null);
    C.LogicalKeyboardKey_00 = new G.LogicalKeyboardKey(4295754130, "Launch App2", null);
    C.LogicalKeyboardKey_01 = new G.LogicalKeyboardKey(4295754132, "Launch App1", null);
    C.LogicalKeyboardKey_zvr = new G.LogicalKeyboardKey(4295754134, "Launch Internet Browser", null);
    C.LogicalKeyboardKey_D6Y = new G.LogicalKeyboardKey(4295754140, "Log Off", null);
    C.LogicalKeyboardKey_jmM = new G.LogicalKeyboardKey(4295754142, "Lock Screen", null);
    C.LogicalKeyboardKey_9hT = new G.LogicalKeyboardKey(4295754143, "Launch Control Panel", null);
    C.LogicalKeyboardKey_Dns = new G.LogicalKeyboardKey(4295754146, "Select Task", null);
    C.LogicalKeyboardKey_MIo = new G.LogicalKeyboardKey(4295754151, "Launch Documents", null);
    C.LogicalKeyboardKey_oCX = new G.LogicalKeyboardKey(4295754155, "Spell Check", null);
    C.LogicalKeyboardKey_lCr = new G.LogicalKeyboardKey(4295754158, "Launch Keyboard Layout", null);
    C.LogicalKeyboardKey_MYz = new G.LogicalKeyboardKey(4295754161, "Launch Screen Saver", null);
    C.LogicalKeyboardKey_1oF = new G.LogicalKeyboardKey(4295754167, "Launch Audio Browser", null);
    C.LogicalKeyboardKey_YSm = new G.LogicalKeyboardKey(4295754241, "New Key", null);
    C.LogicalKeyboardKey_4295754247_Save_null = new G.LogicalKeyboardKey(4295754247, "Save", null);
    C.LogicalKeyboardKey_4295754248_Print_null = new G.LogicalKeyboardKey(4295754248, "Print", null);
    C.LogicalKeyboardKey_cEy = new G.LogicalKeyboardKey(4295754275, "Browser Home", null);
    C.LogicalKeyboardKey_kKc = new G.LogicalKeyboardKey(4295754276, "Browser Back", null);
    C.LogicalKeyboardKey_MYu = new G.LogicalKeyboardKey(4295754278, "Browser Stop", null);
    C.LogicalKeyboardKey_Un6 = new G.LogicalKeyboardKey(4295754279, "Browser Refresh", null);
    C.LogicalKeyboardKey_4295754361_Redo_null = new G.LogicalKeyboardKey(4295754361, "Redo", null);
    C.LogicalKeyboardKey_XHd = new G.LogicalKeyboardKey(4295754377, "Mail Reply", null);
    C.LogicalKeyboardKey_WpI = new G.LogicalKeyboardKey(4295754379, "Mail Forward", null);
    C.LogicalKeyboardKey_7aa = new G.LogicalKeyboardKey(4295754380, "Mail Send", null);
    C.LogicalKeyboardKey_7eO = new G.LogicalKeyboardKey(4295754399, "Show All Windows", null);
    C.Map_yHIsn = new H.GeneralConstantMap([4294967296, C.LogicalKeyboardKey_4294967296_None_null, 4294967312, C.LogicalKeyboardKey_4294967312_Hyper_null, 4294967313, C.LogicalKeyboardKey_No3, 4294967314, C.LogicalKeyboardKey_4294967314_Fn_null, 4294967315, C.LogicalKeyboardKey_wz6, 4294967316, C.LogicalKeyboardKey_4294967316_Suspend_null, 4294967317, C.LogicalKeyboardKey_4294967317_Resume_null, 4294967318, C.LogicalKeyboardKey_4294967318_Turbo_null, 4295032962, C.LogicalKeyboardKey_4295032962_Sleep_null, 4295032963, C.LogicalKeyboardKey_owA, 4295033013, C.LogicalKeyboardKey_M6i, 4295426048, C.LogicalKeyboardKey_8uL, 4295426049, C.LogicalKeyboardKey_2nn, 4295426050, C.LogicalKeyboardKey_2bx, 4295426051, C.LogicalKeyboardKey_FYo, 97, C.LogicalKeyboardKey_7G2, 98, C.LogicalKeyboardKey_jjv, 99, C.LogicalKeyboardKey_mF8, 100, C.LogicalKeyboardKey_ICU, 101, C.LogicalKeyboardKey_AaU, 102, C.LogicalKeyboardKey_2jN, 103, C.LogicalKeyboardKey_cKo, 104, C.LogicalKeyboardKey_QhK, 105, C.LogicalKeyboardKey_swi, 106, C.LogicalKeyboardKey_CG7, 107, C.LogicalKeyboardKey_3jH, 108, C.LogicalKeyboardKey_4iU, 109, C.LogicalKeyboardKey_oe4, 110, C.LogicalKeyboardKey_OLv, 111, C.LogicalKeyboardKey_sav, 112, C.LogicalKeyboardKey_M6L, 113, C.LogicalKeyboardKey_Ods, 114, C.LogicalKeyboardKey_qsN, 115, C.LogicalKeyboardKey_fLj, 116, C.LogicalKeyboardKey_V86, 117, C.LogicalKeyboardKey_Tng, 118, C.LogicalKeyboardKey_6Ng, 119, C.LogicalKeyboardKey_XaR, 120, C.LogicalKeyboardKey_ifx, 121, C.LogicalKeyboardKey_kQR, 122, C.LogicalKeyboardKey_W2D, 49, C.LogicalKeyboardKey_4AN, 50, C.LogicalKeyboardKey_mmo, 51, C.LogicalKeyboardKey_a7X, 52, C.LogicalKeyboardKey_e9s, 53, C.LogicalKeyboardKey_43h, 54, C.LogicalKeyboardKey_CmI, 55, C.LogicalKeyboardKey_Db0, 56, C.LogicalKeyboardKey_GZG, 57, C.LogicalKeyboardKey_86y, 48, C.LogicalKeyboardKey_0, 4295426088, C.LogicalKeyboardKey_4295426088_Enter_null, 4295426089, C.LogicalKeyboardKey_4295426089_Escape_null, 4295426090, C.LogicalKeyboardKey_4295426090_Backspace_null, 4295426091, C.LogicalKeyboardKey_4295426091_Tab_null, 32, C.LogicalKeyboardKey_YdN, 45, C.LogicalKeyboardKey_oEN, 61, C.LogicalKeyboardKey_wrE, 91, C.LogicalKeyboardKey_TLI, 93, C.LogicalKeyboardKey_awJ, 92, C.LogicalKeyboardKey_cdS, 59, C.LogicalKeyboardKey_atK, 39, C.LogicalKeyboardKey_Qo8, 96, C.LogicalKeyboardKey_7FR, 44, C.LogicalKeyboardKey_71T, 46, C.LogicalKeyboardKey_h8g, 47, C.LogicalKeyboardKey_ouN, 4295426105, C.LogicalKeyboardKey_OWF, 4295426106, C.LogicalKeyboardKey_4295426106_F1_null, 4295426107, C.LogicalKeyboardKey_4295426107_F2_null, 4295426108, C.LogicalKeyboardKey_4295426108_F3_null, 4295426109, C.LogicalKeyboardKey_4295426109_F4_null, 4295426110, C.LogicalKeyboardKey_4295426110_F5_null, 4295426111, C.LogicalKeyboardKey_4295426111_F6_null, 4295426112, C.LogicalKeyboardKey_4295426112_F7_null, 4295426113, C.LogicalKeyboardKey_4295426113_F8_null, 4295426114, C.LogicalKeyboardKey_4295426114_F9_null, 4295426115, C.LogicalKeyboardKey_4295426115_F10_null, 4295426116, C.LogicalKeyboardKey_4295426116_F11_null, 4295426117, C.LogicalKeyboardKey_4295426117_F12_null, 4295426118, C.LogicalKeyboardKey_wAl, 4295426119, C.LogicalKeyboardKey_ujM, 4295426120, C.LogicalKeyboardKey_4295426120_Pause_null, 4295426121, C.LogicalKeyboardKey_4295426121_Insert_null, 4295426122, C.LogicalKeyboardKey_4295426122_Home_null, 4295426123, C.LogicalKeyboardKey_mgB, 4295426124, C.LogicalKeyboardKey_4295426124_Delete_null, 4295426125, C.LogicalKeyboardKey_4295426125_End_null, 4295426126, C.LogicalKeyboardKey_wYn, 4295426127, C.LogicalKeyboardKey_CzM, 4295426128, C.LogicalKeyboardKey_muk, 4295426129, C.LogicalKeyboardKey_O7X, 4295426130, C.LogicalKeyboardKey_gCR, 4295426131, C.LogicalKeyboardKey_uHn, 4295426132, C.LogicalKeyboardKey_Npb, 4295426133, C.LogicalKeyboardKey_iOn, 4295426134, C.LogicalKeyboardKey_7xV, 4295426135, C.LogicalKeyboardKey_YaH, 4295426136, C.LogicalKeyboardKey_U2J, 4295426137, C.LogicalKeyboardKey_qsT, 4295426138, C.LogicalKeyboardKey_ka2, 4295426139, C.LogicalKeyboardKey_Ddz, 4295426140, C.LogicalKeyboardKey_YGD, 4295426141, C.LogicalKeyboardKey_s0r, 4295426142, C.LogicalKeyboardKey_atK0, 4295426143, C.LogicalKeyboardKey_3bB, 4295426144, C.LogicalKeyboardKey_sx4, 4295426145, C.LogicalKeyboardKey_4IJ, 4295426146, C.LogicalKeyboardKey_KQb, 4295426147, C.LogicalKeyboardKey_iXq, 4295426148, C.LogicalKeyboardKey_6vi, 4295426149, C.LogicalKeyboardKey_nDU, 4295426150, C.LogicalKeyboardKey_4295426150_Power_null, 4295426151, C.LogicalKeyboardKey_G2v, 4295426152, C.LogicalKeyboardKey_4295426152_F13_null, 4295426153, C.LogicalKeyboardKey_4295426153_F14_null, 4295426154, C.LogicalKeyboardKey_4295426154_F15_null, 4295426155, C.LogicalKeyboardKey_4295426155_F16_null, 4295426156, C.LogicalKeyboardKey_4295426156_F17_null, 4295426157, C.LogicalKeyboardKey_4295426157_F18_null, 4295426158, C.LogicalKeyboardKey_4295426158_F19_null, 4295426159, C.LogicalKeyboardKey_4295426159_F20_null, 4295426160, C.LogicalKeyboardKey_4295426160_F21_null, 4295426161, C.LogicalKeyboardKey_4295426161_F22_null, 4295426162, C.LogicalKeyboardKey_4295426162_F23_null, 4295426163, C.LogicalKeyboardKey_4295426163_F24_null, 4295426164, C.LogicalKeyboardKey_4295426164_Open_null, 4295426165, C.LogicalKeyboardKey_4295426165_Help_null, 4295426167, C.LogicalKeyboardKey_4295426167_Select_null, 4295426169, C.LogicalKeyboardKey_4295426169_Again_null, 4295426170, C.LogicalKeyboardKey_4295426170_Undo_null, 4295426171, C.LogicalKeyboardKey_4295426171_Cut_null, 4295426172, C.LogicalKeyboardKey_4295426172_Copy_null, 4295426173, C.LogicalKeyboardKey_4295426173_Paste_null, 4295426174, C.LogicalKeyboardKey_4295426174_Find_null, 4295426175, C.LogicalKeyboardKey_MjO, 4295426176, C.LogicalKeyboardKey_gap, 4295426177, C.LogicalKeyboardKey_c9P, 4295426181, C.LogicalKeyboardKey_CLo, 4295426183, C.LogicalKeyboardKey_iDZ, 4295426184, C.LogicalKeyboardKey_aBa, 4295426185, C.LogicalKeyboardKey_c0h, 4295426186, C.LogicalKeyboardKey_4295426186_Convert_null, 4295426187, C.LogicalKeyboardKey_sBE, 4295426192, C.LogicalKeyboardKey_nx9, 4295426193, C.LogicalKeyboardKey_nx90, 4295426194, C.LogicalKeyboardKey_nx91, 4295426195, C.LogicalKeyboardKey_nx92, 4295426196, C.LogicalKeyboardKey_nx93, 4295426203, C.LogicalKeyboardKey_4295426203_Abort_null, 4295426211, C.LogicalKeyboardKey_4295426211_Props_null, 4295426230, C.LogicalKeyboardKey_wEo, 4295426231, C.LogicalKeyboardKey_8Nr, 4295426235, C.LogicalKeyboardKey_MUx, 4295426256, C.LogicalKeyboardKey_2Zx, 4295426257, C.LogicalKeyboardKey_qqh, 4295426258, C.LogicalKeyboardKey_CxF, 4295426259, C.LogicalKeyboardKey_I9f, 4295426260, C.LogicalKeyboardKey_YQd, 4295426263, C.LogicalKeyboardKey_75N, 4295426264, C.LogicalKeyboardKey_U86, 4295426265, C.LogicalKeyboardKey_OBv, 4295426272, C.LogicalKeyboardKey_p6t, 4295426273, C.LogicalKeyboardKey_xok, 4295426274, C.LogicalKeyboardKey_PD9, 4295426275, C.LogicalKeyboardKey_D0U, 4295426276, C.LogicalKeyboardKey_ijl, 4295426277, C.LogicalKeyboardKey_QOu, 4295426278, C.LogicalKeyboardKey_EtP, 4295426279, C.LogicalKeyboardKey_O1c, 4295753824, C.LogicalKeyboardKey_4295753824_Info_null, 4295753825, C.LogicalKeyboardKey_ccN, 4295753839, C.LogicalKeyboardKey_Djg, 4295753840, C.LogicalKeyboardKey_ECL, 4295753842, C.LogicalKeyboardKey_B8J, 4295753843, C.LogicalKeyboardKey_kc1, 4295753844, C.LogicalKeyboardKey_kc10, 4295753845, C.LogicalKeyboardKey_HDR, 4295753859, C.LogicalKeyboardKey_Pz5, 4295753868, C.LogicalKeyboardKey_Ak1, 4295753869, C.LogicalKeyboardKey_wg3, 4295753876, C.LogicalKeyboardKey_4295753876_Exit_null, 4295753884, C.LogicalKeyboardKey_6QF, 4295753885, C.LogicalKeyboardKey_3J4, 4295753904, C.LogicalKeyboardKey_Azp, 4295753906, C.LogicalKeyboardKey_8eb, 4295753907, C.LogicalKeyboardKey_eEX, 4295753908, C.LogicalKeyboardKey_kQR0, 4295753909, C.LogicalKeyboardKey_n7o, 4295753910, C.LogicalKeyboardKey_kHV, 4295753911, C.LogicalKeyboardKey_wfl, 4295753912, C.LogicalKeyboardKey_4295753912_Eject_null, 4295753933, C.LogicalKeyboardKey_Cu4, 4295753935, C.LogicalKeyboardKey_Q5s, 4295753957, C.LogicalKeyboardKey_qNA, 4295754115, C.LogicalKeyboardKey_oPr, 4295754116, C.LogicalKeyboardKey_2Ly, 4295754118, C.LogicalKeyboardKey_8Gl, 4295754122, C.LogicalKeyboardKey_9gS, 4295754125, C.LogicalKeyboardKey_mqK, 4295754126, C.LogicalKeyboardKey_k44, 4295754130, C.LogicalKeyboardKey_00, 4295754132, C.LogicalKeyboardKey_01, 4295754134, C.LogicalKeyboardKey_zvr, 4295754140, C.LogicalKeyboardKey_D6Y, 4295754142, C.LogicalKeyboardKey_jmM, 4295754143, C.LogicalKeyboardKey_9hT, 4295754146, C.LogicalKeyboardKey_Dns, 4295754151, C.LogicalKeyboardKey_MIo, 4295754155, C.LogicalKeyboardKey_oCX, 4295754158, C.LogicalKeyboardKey_lCr, 4295754161, C.LogicalKeyboardKey_MYz, 4295754187, C.LogicalKeyboardKey_IQp, 4295754167, C.LogicalKeyboardKey_1oF, 4295754241, C.LogicalKeyboardKey_YSm, 4295754243, C.LogicalKeyboardKey_4295754243_Close_null, 4295754247, C.LogicalKeyboardKey_4295754247_Save_null, 4295754248, C.LogicalKeyboardKey_4295754248_Print_null, 4295754273, C.LogicalKeyboardKey_EWB, 4295754275, C.LogicalKeyboardKey_cEy, 4295754276, C.LogicalKeyboardKey_kKc, 4295754277, C.LogicalKeyboardKey_8pc, 4295754278, C.LogicalKeyboardKey_MYu, 4295754279, C.LogicalKeyboardKey_Un6, 4295754282, C.LogicalKeyboardKey_46S, 4295754285, C.LogicalKeyboardKey_0Rr, 4295754286, C.LogicalKeyboardKey_wIk, 4295754290, C.LogicalKeyboardKey_ijl0, 4295754361, C.LogicalKeyboardKey_4295754361_Redo_null, 4295754377, C.LogicalKeyboardKey_XHd, 4295754379, C.LogicalKeyboardKey_WpI, 4295754380, C.LogicalKeyboardKey_7aa, 4295754399, C.LogicalKeyboardKey_7eO], [P.int, G.LogicalKeyboardKey]);
    C.Map_yXAeS = new H.GeneralConstantMap([0, "FontWeight.w100", 1, "FontWeight.w200", 2, "FontWeight.w300", 3, "FontWeight.w400", 4, "FontWeight.w500", 5, "FontWeight.w600", 6, "FontWeight.w700", 7, "FontWeight.w800", 8, "FontWeight.w900"], [P.int, P.String]);
    C.Color_4293128957 = new P.Color(4293128957);
    C.Color_4290502395 = new P.Color(4290502395);
    C.Color_4287679225 = new P.Color(4287679225);
    C.Color_4284790262 = new P.Color(4284790262);
    C.Color_4282557941 = new P.Color(4282557941);
    C.Color_4280391411 = new P.Color(4280391411);
    C.Color_4280191205 = new P.Color(4280191205);
    C.Color_4279858898 = new P.Color(4279858898);
    C.Color_4279592384 = new P.Color(4279592384);
    C.Color_4279060385 = new P.Color(4279060385);
    C.Map_JNwaj = new H.GeneralConstantMap([50, C.Color_4293128957, 100, C.Color_4290502395, 200, C.Color_4287679225, 300, C.Color_4284790262, 400, C.Color_4282557941, 500, C.Color_4280391411, 600, C.Color_4280191205, 700, C.Color_4279858898, 800, C.Color_4279592384, 900, C.Color_4279060385], [P.int, P.Color]);
    C.MaterialColor_Map_JNwaj_4280391411 = new E.MaterialColor(C.Map_JNwaj, 4280391411);
    C.MaterialTapTargetSize_0 = new X.MaterialTapTargetSize("MaterialTapTargetSize.padded");
    C.MaterialTapTargetSize_1 = new X.MaterialTapTargetSize("MaterialTapTargetSize.shrinkWrap");
    C.MaterialType_0 = new M.MaterialType("MaterialType.canvas");
    C.MaterialType_1 = new M.MaterialType("MaterialType.card");
    C.MaterialType_2 = new M.MaterialType("MaterialType.circle");
    C.MaterialType_3 = new M.MaterialType("MaterialType.button");
    C.MaterialType_4 = new M.MaterialType("MaterialType.transparency");
    C.C_JSONMethodCodec = new U.JSONMethodCodec();
    C.MethodChannel_89P = new A.MethodChannel("flutter/navigation", C.C_JSONMethodCodec);
    C.Offset_0_1 = new P.Offset(0, 1);
    C.Offset_10_10 = new P.Offset(10, 10);
    C.Offset_1_0 = new P.Offset(1, 0);
    C.Offset_Oho = new P.Offset(-0.3333333333333333, 0);
    C.Offset_YLH = new P.Offset(8.5, 0);
    C.Offset_cMC = new P.Offset(0, 8.5);
    C.Offset_chs = new P.Offset(0, 0.25);
    C.OptionalMethodChannel_cWd = new A.OptionalMethodChannel("flutter/platform", C.C_JSONMethodCodec);
    C.Overflow_1 = new K.Overflow("Overflow.clip");
    C.PathFillType_1 = new P.PathFillType("PathFillType.evenOdd");
    C.PathOperation_1 = new P.PathOperation("PathOperation.intersect");
    C.PhysicalKeyboardKey_0_None = new G.PhysicalKeyboardKey(0, "None");
    C.PointerDeviceKind_0 = new P.PointerDeviceKind("PointerDeviceKind.touch");
    C.PointerDeviceKind_1 = new P.PointerDeviceKind("PointerDeviceKind.mouse");
    C.PointerDeviceKind_2 = new P.PointerDeviceKind("PointerDeviceKind.stylus");
    C.PointerDeviceKind_3 = new P.PointerDeviceKind("PointerDeviceKind.invertedStylus");
    C.PointerSignalKind_0 = new P.PointerSignalKind("PointerSignalKind.none");
    C.PointerSignalKind_1 = new P.PointerSignalKind("PointerSignalKind.scroll");
    C.PointerSignalKind_2 = new P.PointerSignalKind("PointerSignalKind.unknown");
    C.Rect_0_0_0_0 = new P.Rect(0, 0, 0, 0);
    C.RenderComparison_0 = new G.RenderComparison(0, "RenderComparison.identical");
    C.RenderComparison_1 = new G.RenderComparison(1, "RenderComparison.metadata");
    C.RenderComparison_2 = new G.RenderComparison(2, "RenderComparison.paint");
    C.RenderComparison_3 = new G.RenderComparison(3, "RenderComparison.layout");
    C.RoundedRectangleBorder_yx3 = new X.RoundedRectangleBorder(C.BorderSide_m7u, C.BorderRadius_tLn);
    C.Radius_2_2 = new P.Radius(2, 2);
    C.BorderRadius_tLn0 = new K.BorderRadius(C.Radius_2_2, C.Radius_2_2, C.Radius_2_2, C.Radius_2_2);
    C.RoundedRectangleBorder_yx30 = new X.RoundedRectangleBorder(C.BorderSide_m7u, C.BorderRadius_tLn0);
    C.Radius_4_4 = new P.Radius(4, 4);
    C.BorderRadius_tLn1 = new K.BorderRadius(C.Radius_4_4, C.Radius_4_4, C.Radius_4_4, C.Radius_4_4);
    C.RoundedRectangleBorder_yx31 = new X.RoundedRectangleBorder(C.BorderSide_m7u, C.BorderRadius_tLn1);
    C.RoutePopDisposition_0 = new K.RoutePopDisposition("RoutePopDisposition.pop");
    C.RoutePopDisposition_1 = new K.RoutePopDisposition("RoutePopDisposition.doNotPop");
    C.RoutePopDisposition_2 = new K.RoutePopDisposition("RoutePopDisposition.bubble");
    C.RouteSettings_null_false_null = new K.RouteSettings(null, false, null);
    C.ScaffoldGeometry_null_null = new M.ScaffoldGeometry(null, null);
    C.SchedulerPhase_0 = new N.SchedulerPhase(0, "SchedulerPhase.idle");
    C.SchedulerPhase_1 = new N.SchedulerPhase(1, "SchedulerPhase.transientCallbacks");
    C.SchedulerPhase_2 = new N.SchedulerPhase(2, "SchedulerPhase.midFrameMicrotasks");
    C.SchedulerPhase_3 = new N.SchedulerPhase(3, "SchedulerPhase.persistentCallbacks");
    C.SchedulerPhase_4 = new N.SchedulerPhase(4, "SchedulerPhase.postFrameCallbacks");
    C.ScriptCategory_0 = new U.ScriptCategory("ScriptCategory.englishLike");
    C.ScriptCategory_1 = new U.ScriptCategory("ScriptCategory.dense");
    C.ScriptCategory_2 = new U.ScriptCategory("ScriptCategory.tall");
    C.ShowValueIndicator_0 = new Q.ShowValueIndicator("ShowValueIndicator.onlyForDiscrete");
    C.Size_0_0 = new P.Size(0, 0);
    C.Size_100000_100000 = new P.Size(100000, 100000);
    C.Size_48_48 = new P.Size(48, 48);
    C.Size_wjo = new P.Size(1 / 0, 1 / 0);
    C.SliderThemeData_b1k = new Q.SliderThemeData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    C.SnackBarThemeData_cWd = new K.SnackBarThemeData(null, null, null, null, null, null);
    C.StackFit_0 = new K.StackFit("StackFit.loose");
    C.StackFit_1 = new K.StackFit("StackFit.expand");
    C.StackFit_2 = new K.StackFit("StackFit.passthrough");
    C.StadiumBorder_wjC = new S.StadiumBorder(C.BorderSide_m7u);
    C.SystemSoundType_0 = new V.SystemSoundType("SystemSoundType.click");
    C.SystemUiOverlayStyle_4EL = new X.SystemUiOverlayStyle(C.Color_4278190080, null, C.Brightness_1, null, C.Brightness_0, C.Brightness_1);
    C.SystemUiOverlayStyle_yjH = new X.SystemUiOverlayStyle(C.Color_4278190080, null, C.Brightness_1, null, C.Brightness_1, C.Brightness_0);
    C.TabBarTheme_Srx = new U.TabBarTheme(null, null, null, null, null, null, null);
    C.TapSemanticEvent_tap = new E.TapSemanticEvent("tap");
    C.TextAffinity_1 = new P.TextAffinity("TextAffinity.downstream");
    C.TextOverflow_2 = new Q.TextOverflow("TextOverflow.ellipsis");
    C.TextOverflow_3 = new Q.TextOverflow("TextOverflow.visible");
    C.TextStyle_IAx = new A.TextStyle0(true, C.Color_4294902015, null, null, null, null, 14, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    C.TextSpan_vxj = new Q.TextSpan(C.TextStyle_IAx, "\u2702", null);
    C.Color_3506372608 = new P.Color(3506372608);
    C.TextDecoration_1 = new P.TextDecoration(1);
    C.TextStyle_8aB = new A.TextStyle0(true, C.Color_3506372608, null, "monospace", null, null, 48, C.FontWeight_8, null, null, null, null, null, null, null, null, C.TextDecoration_1, C.Color_4294967040, C.TextDecorationStyle_1, null, "fallback style; consider putting your text in a Material", null);
    C.TextStyle_K13 = new A.TextStyle0(true, C.Color_4294967295, null, null, null, null, 10.2, C.FontWeight_8, null, null, null, null, 1, null, null, null, null, null, null, null, null, null);
    C.Color_4287627264 = new P.Color(4287627264);
    C.TextStyle_a56 = new A.TextStyle0(true, C.Color_4287627264, null, null, null, null, 7.5, C.FontWeight_7, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    C.TextDecoration_0 = new P.TextDecoration(0);
    C.TextStyle_uHn = new A.TextStyle0(true, C.Color_2315255808, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackMountainView display4", null);
    C.TextStyle_uHn0 = new A.TextStyle0(true, C.Color_2315255808, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackMountainView display3", null);
    C.TextStyle_uHn1 = new A.TextStyle0(true, C.Color_2315255808, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackMountainView display2", null);
    C.TextStyle_uHn2 = new A.TextStyle0(true, C.Color_2315255808, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackMountainView display1", null);
    C.TextStyle_RWp = new A.TextStyle0(true, C.Color_3707764736, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackMountainView headline", null);
    C.TextStyle_Oi3 = new A.TextStyle0(true, C.Color_3707764736, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackMountainView title", null);
    C.TextStyle_YxH = new A.TextStyle0(true, C.Color_3707764736, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackMountainView subhead", null);
    C.TextStyle_Jcx = new A.TextStyle0(true, C.Color_3707764736, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackMountainView body2", null);
    C.TextStyle_Jcx0 = new A.TextStyle0(true, C.Color_3707764736, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackMountainView body1", null);
    C.TextStyle_0ex = new A.TextStyle0(true, C.Color_2315255808, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackMountainView caption", null);
    C.TextStyle_S7B = new A.TextStyle0(true, C.Color_3707764736, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackMountainView button", null);
    C.TextStyle_PXr = new A.TextStyle0(true, C.Color_4278190080, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackMountainView subtitle", null);
    C.TextStyle_VWp = new A.TextStyle0(true, C.Color_4278190080, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackMountainView overline", null);
    C.TextTheme_9YE = new R.TextTheme(C.TextStyle_uHn, C.TextStyle_uHn0, C.TextStyle_uHn1, C.TextStyle_uHn2, C.TextStyle_RWp, C.TextStyle_Oi3, C.TextStyle_YxH, C.TextStyle_Jcx, C.TextStyle_Jcx0, C.TextStyle_0ex, C.TextStyle_S7B, C.TextStyle_PXr, C.TextStyle_VWp);
    C.TextStyle_nup = new A.TextStyle0(true, C.Color_2315255808, null, ".SF UI Display", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackCupertino display4", null);
    C.TextStyle_nup0 = new A.TextStyle0(true, C.Color_2315255808, null, ".SF UI Display", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackCupertino display3", null);
    C.TextStyle_nup1 = new A.TextStyle0(true, C.Color_2315255808, null, ".SF UI Display", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackCupertino display2", null);
    C.TextStyle_nup2 = new A.TextStyle0(true, C.Color_2315255808, null, ".SF UI Display", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackCupertino display1", null);
    C.TextStyle_Enq = new A.TextStyle0(true, C.Color_3707764736, null, ".SF UI Display", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackCupertino headline", null);
    C.TextStyle_B8J = new A.TextStyle0(true, C.Color_3707764736, null, ".SF UI Display", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackCupertino title", null);
    C.TextStyle_y1e = new A.TextStyle0(true, C.Color_3707764736, null, ".SF UI Text", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackCupertino subhead", null);
    C.TextStyle_n3c = new A.TextStyle0(true, C.Color_3707764736, null, ".SF UI Text", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackCupertino body2", null);
    C.TextStyle_n3c0 = new A.TextStyle0(true, C.Color_3707764736, null, ".SF UI Text", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackCupertino body1", null);
    C.TextStyle_6Sk = new A.TextStyle0(true, C.Color_2315255808, null, ".SF UI Text", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackCupertino caption", null);
    C.TextStyle_g9h = new A.TextStyle0(true, C.Color_3707764736, null, ".SF UI Text", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackCupertino button", null);
    C.TextStyle_QLc = new A.TextStyle0(true, C.Color_4278190080, null, ".SF UI Text", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackCupertino subtitle", null);
    C.TextStyle_86Z = new A.TextStyle0(true, C.Color_4278190080, null, ".SF UI Text", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "blackCupertino overline", null);
    C.TextTheme_Ab5 = new R.TextTheme(C.TextStyle_nup, C.TextStyle_nup0, C.TextStyle_nup1, C.TextStyle_nup2, C.TextStyle_Enq, C.TextStyle_B8J, C.TextStyle_y1e, C.TextStyle_n3c, C.TextStyle_n3c0, C.TextStyle_6Sk, C.TextStyle_g9h, C.TextStyle_QLc, C.TextStyle_86Z);
    C.TextStyle_V43 = new A.TextStyle0(false, null, null, null, null, null, 112, C.FontWeight_3, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "tall display4 2014", null);
    C.TextStyle_V430 = new A.TextStyle0(false, null, null, null, null, null, 56, C.FontWeight_3, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "tall display3 2014", null);
    C.TextStyle_V431 = new A.TextStyle0(false, null, null, null, null, null, 45, C.FontWeight_3, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "tall display2 2014", null);
    C.TextStyle_V432 = new A.TextStyle0(false, null, null, null, null, null, 34, C.FontWeight_3, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "tall display1 2014", null);
    C.TextStyle_4AN = new A.TextStyle0(false, null, null, null, null, null, 24, C.FontWeight_3, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "tall headline 2014", null);
    C.TextStyle_wMa = new A.TextStyle0(false, null, null, null, null, null, 21, C.FontWeight_6, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "tall title 2014", null);
    C.TextStyle_cc6 = new A.TextStyle0(false, null, null, null, null, null, 17, C.FontWeight_3, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "tall subhead 2014", null);
    C.TextStyle_pZX = new A.TextStyle0(false, null, null, null, null, null, 15, C.FontWeight_6, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "tall body2 2014", null);
    C.TextStyle_pZX0 = new A.TextStyle0(false, null, null, null, null, null, 15, C.FontWeight_3, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "tall body1 2014", null);
    C.TextStyle_EGa = new A.TextStyle0(false, null, null, null, null, null, 13, C.FontWeight_3, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "tall caption 2014", null);
    C.TextStyle_QGe = new A.TextStyle0(false, null, null, null, null, null, 15, C.FontWeight_6, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "tall button 2014", null);
    C.TextStyle_sSr = new A.TextStyle0(false, null, null, null, null, null, 15, C.FontWeight_4, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "tall subtitle 2014", null);
    C.TextStyle_Cu4 = new A.TextStyle0(false, null, null, null, null, null, 11, C.FontWeight_3, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "tall overline 2014", null);
    C.TextTheme_Cl7 = new R.TextTheme(C.TextStyle_V43, C.TextStyle_V430, C.TextStyle_V431, C.TextStyle_V432, C.TextStyle_4AN, C.TextStyle_wMa, C.TextStyle_cc6, C.TextStyle_pZX, C.TextStyle_pZX0, C.TextStyle_EGa, C.TextStyle_QGe, C.TextStyle_sSr, C.TextStyle_Cu4);
    C.TextStyle_KQR = new A.TextStyle0(false, null, null, null, null, null, 112, C.FontWeight_0, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "englishLike display4 2014", null);
    C.TextStyle_KQR0 = new A.TextStyle0(false, null, null, null, null, null, 56, C.FontWeight_3, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "englishLike display3 2014", null);
    C.TextStyle_KQR1 = new A.TextStyle0(false, null, null, null, null, null, 45, C.FontWeight_3, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "englishLike display2 2014", null);
    C.TextStyle_KQR2 = new A.TextStyle0(false, null, null, null, null, null, 34, C.FontWeight_3, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "englishLike display1 2014", null);
    C.TextStyle_3CK = new A.TextStyle0(false, null, null, null, null, null, 24, C.FontWeight_3, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "englishLike headline 2014", null);
    C.TextStyle_DFv = new A.TextStyle0(false, null, null, null, null, null, 20, C.FontWeight_4, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "englishLike title 2014", null);
    C.TextStyle_KIC = new A.TextStyle0(false, null, null, null, null, null, 16, C.FontWeight_3, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "englishLike subhead 2014", null);
    C.TextStyle_UVS = new A.TextStyle0(false, null, null, null, null, null, 14, C.FontWeight_4, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "englishLike body2 2014", null);
    C.TextStyle_UVS0 = new A.TextStyle0(false, null, null, null, null, null, 14, C.FontWeight_3, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "englishLike body1 2014", null);
    C.TextStyle_26J = new A.TextStyle0(false, null, null, null, null, null, 12, C.FontWeight_3, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "englishLike caption 2014", null);
    C.TextStyle_2Vk = new A.TextStyle0(false, null, null, null, null, null, 14, C.FontWeight_4, null, null, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "englishLike button 2014", null);
    C.TextStyle_0eG = new A.TextStyle0(false, null, null, null, null, null, 14, C.FontWeight_4, null, 0.1, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "englishLike subtitle 2014", null);
    C.TextStyle_IYr = new A.TextStyle0(false, null, null, null, null, null, 10, C.FontWeight_3, null, 1.5, null, C.TextBaseline_0, null, null, null, null, null, null, null, null, "englishLike overline 2014", null);
    C.TextTheme_OHV = new R.TextTheme(C.TextStyle_KQR, C.TextStyle_KQR0, C.TextStyle_KQR1, C.TextStyle_KQR2, C.TextStyle_3CK, C.TextStyle_DFv, C.TextStyle_KIC, C.TextStyle_UVS, C.TextStyle_UVS0, C.TextStyle_26J, C.TextStyle_2Vk, C.TextStyle_0eG, C.TextStyle_IYr);
    C.TextStyle_YOT = new A.TextStyle0(false, null, null, null, null, null, 112, C.FontWeight_0, null, null, null, C.TextBaseline_1, null, null, null, null, null, null, null, null, "dense display4 2014", null);
    C.TextStyle_YOT0 = new A.TextStyle0(false, null, null, null, null, null, 56, C.FontWeight_3, null, null, null, C.TextBaseline_1, null, null, null, null, null, null, null, null, "dense display3 2014", null);
    C.TextStyle_YOT1 = new A.TextStyle0(false, null, null, null, null, null, 45, C.FontWeight_3, null, null, null, C.TextBaseline_1, null, null, null, null, null, null, null, null, "dense display2 2014", null);
    C.TextStyle_YOT2 = new A.TextStyle0(false, null, null, null, null, null, 34, C.FontWeight_3, null, null, null, C.TextBaseline_1, null, null, null, null, null, null, null, null, "dense display1 2014", null);
    C.TextStyle_HzC = new A.TextStyle0(false, null, null, null, null, null, 24, C.FontWeight_3, null, null, null, C.TextBaseline_1, null, null, null, null, null, null, null, null, "dense headline 2014", null);
    C.TextStyle_uf8 = new A.TextStyle0(false, null, null, null, null, null, 21, C.FontWeight_4, null, null, null, C.TextBaseline_1, null, null, null, null, null, null, null, null, "dense title 2014", null);
    C.TextStyle_Iyy = new A.TextStyle0(false, null, null, null, null, null, 17, C.FontWeight_3, null, null, null, C.TextBaseline_1, null, null, null, null, null, null, null, null, "dense subhead 2014", null);
    C.TextStyle_MUw = new A.TextStyle0(false, null, null, null, null, null, 15, C.FontWeight_4, null, null, null, C.TextBaseline_1, null, null, null, null, null, null, null, null, "dense body2 2014", null);
    C.TextStyle_MUw0 = new A.TextStyle0(false, null, null, null, null, null, 15, C.FontWeight_3, null, null, null, C.TextBaseline_1, null, null, null, null, null, null, null, null, "dense body1 2014", null);
    C.TextStyle_kr3 = new A.TextStyle0(false, null, null, null, null, null, 13, C.FontWeight_3, null, null, null, C.TextBaseline_1, null, null, null, null, null, null, null, null, "dense caption 2014", null);
    C.TextStyle_Phi = new A.TextStyle0(false, null, null, null, null, null, 15, C.FontWeight_4, null, null, null, C.TextBaseline_1, null, null, null, null, null, null, null, null, "dense button 2014", null);
    C.TextStyle_WGX = new A.TextStyle0(false, null, null, null, null, null, 15, C.FontWeight_4, null, null, null, C.TextBaseline_1, null, null, null, null, null, null, null, null, "dense subtitle 2014", null);
    C.TextStyle_7eR = new A.TextStyle0(false, null, null, null, null, null, 11, C.FontWeight_3, null, null, null, C.TextBaseline_1, null, null, null, null, null, null, null, null, "dense overline 2014", null);
    C.TextTheme_Srw = new R.TextTheme(C.TextStyle_YOT, C.TextStyle_YOT0, C.TextStyle_YOT1, C.TextStyle_YOT2, C.TextStyle_HzC, C.TextStyle_uf8, C.TextStyle_Iyy, C.TextStyle_MUw, C.TextStyle_MUw0, C.TextStyle_kr3, C.TextStyle_Phi, C.TextStyle_WGX, C.TextStyle_7eR);
    C.TextStyle_fZb = new A.TextStyle0(true, C.Color_3019898879, null, ".SF UI Display", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteCupertino display4", null);
    C.TextStyle_fZb0 = new A.TextStyle0(true, C.Color_3019898879, null, ".SF UI Display", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteCupertino display3", null);
    C.TextStyle_fZb1 = new A.TextStyle0(true, C.Color_3019898879, null, ".SF UI Display", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteCupertino display2", null);
    C.TextStyle_fZb2 = new A.TextStyle0(true, C.Color_3019898879, null, ".SF UI Display", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteCupertino display1", null);
    C.TextStyle_Knl = new A.TextStyle0(true, C.Color_4294967295, null, ".SF UI Display", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteCupertino headline", null);
    C.TextStyle_gg4 = new A.TextStyle0(true, C.Color_4294967295, null, ".SF UI Display", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteCupertino title", null);
    C.TextStyle_M2I = new A.TextStyle0(true, C.Color_4294967295, null, ".SF UI Text", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteCupertino subhead", null);
    C.TextStyle_8aB0 = new A.TextStyle0(true, C.Color_4294967295, null, ".SF UI Text", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteCupertino body2", null);
    C.TextStyle_8aB1 = new A.TextStyle0(true, C.Color_4294967295, null, ".SF UI Text", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteCupertino body1", null);
    C.TextStyle_yPV = new A.TextStyle0(true, C.Color_3019898879, null, ".SF UI Text", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteCupertino caption", null);
    C.TextStyle_27I = new A.TextStyle0(true, C.Color_4294967295, null, ".SF UI Text", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteCupertino button", null);
    C.TextStyle_HYo = new A.TextStyle0(true, C.Color_4294967295, null, ".SF UI Text", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteCupertino subtitle", null);
    C.TextStyle_61T = new A.TextStyle0(true, C.Color_4294967295, null, ".SF UI Text", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteCupertino overline", null);
    C.TextTheme_nCA = new R.TextTheme(C.TextStyle_fZb, C.TextStyle_fZb0, C.TextStyle_fZb1, C.TextStyle_fZb2, C.TextStyle_Knl, C.TextStyle_gg4, C.TextStyle_M2I, C.TextStyle_8aB0, C.TextStyle_8aB1, C.TextStyle_yPV, C.TextStyle_27I, C.TextStyle_HYo, C.TextStyle_61T);
    C.TextStyle_c89 = new A.TextStyle0(true, C.Color_3019898879, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteMountainView display4", null);
    C.TextStyle_c890 = new A.TextStyle0(true, C.Color_3019898879, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteMountainView display3", null);
    C.TextStyle_c891 = new A.TextStyle0(true, C.Color_3019898879, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteMountainView display2", null);
    C.TextStyle_c892 = new A.TextStyle0(true, C.Color_3019898879, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteMountainView display1", null);
    C.TextStyle_AOY = new A.TextStyle0(true, C.Color_4294967295, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteMountainView headline", null);
    C.TextStyle_wsa = new A.TextStyle0(true, C.Color_4294967295, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteMountainView title", null);
    C.TextStyle_2qI = new A.TextStyle0(true, C.Color_4294967295, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteMountainView subhead", null);
    C.TextStyle_Ch9 = new A.TextStyle0(true, C.Color_4294967295, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteMountainView body2", null);
    C.TextStyle_Ch90 = new A.TextStyle0(true, C.Color_4294967295, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteMountainView body1", null);
    C.TextStyle_tsC = new A.TextStyle0(true, C.Color_3019898879, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteMountainView caption", null);
    C.TextStyle_i3t = new A.TextStyle0(true, C.Color_4294967295, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteMountainView button", null);
    C.TextStyle_SRn = new A.TextStyle0(true, C.Color_4294967295, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteMountainView subtitle", null);
    C.TextStyle_ZaB = new A.TextStyle0(true, C.Color_4294967295, null, "Roboto", null, null, null, null, null, null, null, null, null, null, null, null, C.TextDecoration_0, null, null, null, "whiteMountainView overline", null);
    C.TextTheme_ssJ = new R.TextTheme(C.TextStyle_c89, C.TextStyle_c890, C.TextStyle_c891, C.TextStyle_c892, C.TextStyle_AOY, C.TextStyle_wsa, C.TextStyle_2qI, C.TextStyle_Ch9, C.TextStyle_Ch90, C.TextStyle_tsC, C.TextStyle_i3t, C.TextStyle_SRn, C.TextStyle_ZaB);
    C.Threshold_znv = new Z.Threshold(0.5);
    C.TileMode_0 = new P.TileMode("TileMode.clamp");
    C.TileMode_1 = new P.TileMode("TileMode.repeated");
    C.Tolerance_Gdw = new N.Tolerance(0.001, 0.001);
    C.Type_ByteBuffer_RkP = H.createRuntimeType(P.ByteBuffer);
    C.Type_ByteData_zNC = H.createRuntimeType(P.ByteData);
    C.Type_DefaultAssetBundle_8cA = H.createRuntimeType(T.DefaultAssetBundle);
    C.Type_DefaultTextStyle_ird = H.createRuntimeType(L.DefaultTextStyle);
    C.Type_Directionality_8Om = H.createRuntimeType(T.Directionality);
    C.Type_DoubleTapGestureRecognizer_oyU = H.createRuntimeType(F.DoubleTapGestureRecognizer);
    C.Type_Float64List_LB7 = H.createRuntimeType(P.Float64List);
    C.Type_FocusScopeNode_cwF = H.createRuntimeType(O.FocusScopeNode);
    C.Type_Hero_qBr = H.createRuntimeType(T.Hero);
    C.Type_IconTheme_U8c = H.createRuntimeType(Y.IconTheme);
    C.Type_Int32List_O50 = H.createRuntimeType(P.Int32List);
    C.Type_Int8List_ekJ = H.createRuntimeType(P.Int8List);
    C.Type_JSObject_8k0 = H.createRuntimeType(J.JSObject);
    C.Type_LabeledGlobalKey_6TW = H.createRuntimeType([N.LabeledGlobalKey, [N.State, N.StatefulWidget]]);
    C.Type_LongPressGestureRecognizer_46y = H.createRuntimeType(T.LongPressGestureRecognizer);
    C.Type_MaterialLocalizations_flR = H.createRuntimeType(U.MaterialLocalizations);
    C.Type_Material_2bi = H.createRuntimeType(M.Material);
    C.Type_MediaQuery_nDB = H.createRuntimeType(F.MediaQuery);
    C.Type_Null_Yyn = H.createRuntimeType(P.Null);
    C.Type_PanGestureRecognizer_bbH = H.createRuntimeType(O.PanGestureRecognizer);
    C.Type_RenderObjectWidget_gmA = H.createRuntimeType(N.RenderObjectWidget);
    C.Type_ShapeBorderClipper_QWG = H.createRuntimeType(E.ShapeBorderClipper);
    C.Type_String_k8F = H.createRuntimeType(P.String);
    C.Type_TapGestureRecognizer_62h = H.createRuntimeType(N.TapGestureRecognizer);
    C.Type_TargetPlatform_ud1 = H.createRuntimeType(T.TargetPlatform);
    C.Type_TickerMode_zTp = H.createRuntimeType(U.TickerMode);
    C.Type_Uint16List_2bx = H.createRuntimeType(P.Uint16List);
    C.Type_Uint8List_WLA = H.createRuntimeType(P.Uint8List);
    C.Type_Vq1 = H.createRuntimeType(O.HorizontalDragGestureRecognizer);
    C.Type_WidgetsLocalizations_43h = H.createRuntimeType(L.WidgetsLocalizations);
    C.Type__FocusMarker_fgL = H.createRuntimeType(L._FocusMarker);
    C.Type__InheritedTheme_pIu = H.createRuntimeType(K._InheritedTheme);
    C.Type__LocalizationsScope_Lpb = H.createRuntimeType(L._LocalizationsScope);
    C.Type__ModalScopeState_Yap = H.createRuntimeType([T._ModalScopeState,,]);
    C.Type__ModalScopeStatus_sUr = H.createRuntimeType(T._ModalScopeStatus);
    C.Type_bool_lhE = H.createRuntimeType(P.bool);
    C.Type_double_K1J = H.createRuntimeType(P.double);
    C.Type_dynamic_0Rz = H.createRuntimeType(null);
    C.Type_int_tHn = H.createRuntimeType(P.int);
    C.Type_mLh = H.createRuntimeType(O.VerticalDragGestureRecognizer);
    C.Type_num_cv7 = H.createRuntimeType(P.num);
    C.Velocity_Offset_0_0 = new R.Velocity(C.Offset_0_0);
    C.VerticalDirection_0 = new G.VerticalDirection("VerticalDirection.up");
    C.VerticalDirection_1 = new G.VerticalDirection("VerticalDirection.down");
    C.WindowPadding_0_0_0_0 = new P.WindowPadding(0, 0, 0, 0);
    C._AnimationDirection_0 = new G._AnimationDirection("_AnimationDirection.forward");
    C._AnimationDirection_1 = new G._AnimationDirection("_AnimationDirection.reverse");
    C.Color_67108864 = new P.Color(67108864);
    C.Color_301989888 = new P.Color(301989888);
    C.Color_939524096 = new P.Color(939524096);
    C.List_S2N = H.setRuntimeTypeInfo(makeConstList([C.Color_0, C.Color_67108864, C.Color_301989888, C.Color_939524096]), [P.Color]);
    C.List_w61 = H.setRuntimeTypeInfo(makeConstList([0, 0.3, 0.6, 1]), [P.double]);
    C.AlignmentDirectional_Yr4 = new K.AlignmentDirectional(0.9, 0);
    C.AlignmentDirectional_1_0 = new K.AlignmentDirectional(1, 0);
    C.LinearGradient_Xsy = new T.LinearGradient(C.AlignmentDirectional_Yr4, C.AlignmentDirectional_1_0, C.TileMode_0, C.List_S2N, C.List_w61);
    C._CupertinoEdgeShadowDecoration_Igx = new D._CupertinoEdgeShadowDecoration(C.LinearGradient_Xsy);
    C._CupertinoEdgeShadowDecoration_null = new D._CupertinoEdgeShadowDecoration(null);
    C._DragState_0 = new O._DragState("_DragState.ready");
    C._DragState_1 = new O._DragState("_DragState.possible");
    C._DragState_2 = new O._DragState("_DragState.accepted");
    C._ElementLifecycle_0 = new N._ElementLifecycle("_ElementLifecycle.initial");
    C._ElementLifecycle_1 = new N._ElementLifecycle("_ElementLifecycle.active");
    C._ElementLifecycle_2 = new N._ElementLifecycle("_ElementLifecycle.inactive");
    C._ElementLifecycle_3 = new N._ElementLifecycle("_ElementLifecycle.defunct");
    C._IterationMarker_null_2 = new P._IterationMarker(null, 2);
    C._OverflowSide_0 = new T._OverflowSide(0, "_OverflowSide.left");
    C._OverflowSide_1 = new T._OverflowSide(1, "_OverflowSide.top");
    C._OverflowSide_2 = new T._OverflowSide(2, "_OverflowSide.bottom");
    C._OverflowSide_3 = new T._OverflowSide(3, "_OverflowSide.right");
    C._ScaffoldSlot_0 = new M._ScaffoldSlot("_ScaffoldSlot.body");
    C._ScaffoldSlot_1 = new M._ScaffoldSlot("_ScaffoldSlot.appBar");
    C._ScaffoldSlot_10 = new M._ScaffoldSlot("_ScaffoldSlot.statusBar");
    C._ScaffoldSlot_2 = new M._ScaffoldSlot("_ScaffoldSlot.bodyScrim");
    C._ScaffoldSlot_3 = new M._ScaffoldSlot("_ScaffoldSlot.bottomSheet");
    C._ScaffoldSlot_4 = new M._ScaffoldSlot("_ScaffoldSlot.snackBar");
    C._ScaffoldSlot_5 = new M._ScaffoldSlot("_ScaffoldSlot.persistentFooter");
    C._ScaffoldSlot_6 = new M._ScaffoldSlot("_ScaffoldSlot.bottomNavigationBar");
    C._ScaffoldSlot_7 = new M._ScaffoldSlot("_ScaffoldSlot.floatingActionButton");
    C._ScaffoldSlot_8 = new M._ScaffoldSlot("_ScaffoldSlot.drawer");
    C._ScaffoldSlot_9 = new M._ScaffoldSlot("_ScaffoldSlot.endDrawer");
    C._StateLifecycle_0 = new N._StateLifecycle("_StateLifecycle.created");
    C._StateLifecycle_1 = new N._StateLifecycle("_StateLifecycle.initialized");
    C._StateLifecycle_2 = new N._StateLifecycle("_StateLifecycle.ready");
    C._StateLifecycle_3 = new N._StateLifecycle("_StateLifecycle.defunct");
    C._ToolbarSlot_0 = new E._ToolbarSlot("_ToolbarSlot.leading");
    C._ToolbarSlot_1 = new E._ToolbarSlot("_ToolbarSlot.middle");
    C._ToolbarSlot_2 = new E._ToolbarSlot("_ToolbarSlot.trailing");
    C._TrainHoppingMode_0 = new S._TrainHoppingMode("_TrainHoppingMode.minimize");
    C._TrainHoppingMode_1 = new S._TrainHoppingMode("_TrainHoppingMode.maximize");
    C._WordWrapParseMode_0 = new D._WordWrapParseMode("_WordWrapParseMode.inSpace");
    C._WordWrapParseMode_1 = new D._WordWrapParseMode("_WordWrapParseMode.inWord");
    C._WordWrapParseMode_2 = new D._WordWrapParseMode("_WordWrapParseMode.atBreak");
  })();
  var init = {mangledGlobalNames: {int: "int", double: "double", num: "num", String: "String", bool: "bool", Null: "Null", List: "List"}, mangledNames: {}, getTypeFromName: getGlobalFromName, metadata: [], types: [{func: 1, ret: P.bool}, {func: 1, ret: -1}, {func: 1, ret: P.Null}, {func: 1, ret: P.Null, args: [P.StringBuffer]}, {func: 1, ret: [P.Future, P.bool]}, {func: 1, ret: -1, args: [X.AnimationStatus]}, {func: 1, ret: [P.Future, -1]}, {func: 1, ret: [P.Future, -1], args: [P.bool]}, {func: 1, ret: [P.Future, [P.Map, P.String,,]], args: [[P.Map, P.String, P.String]]}, {func: 1, ret: -1, args: [N.Element]}, {func: 1, ret: P.Null, args: [K.RenderObject]}, {func: 1, ret: N.Widget, args: [N.BuildContext]}, {func: 1, ret: P.Null, args: [,]}, {func: 1, ret: -1, args: [P.Duration]}, {func: 1, ret: -1, args: [F.PointerEvent]}, {func: 1, ret: P.Null, args: [N.Element]}, {func: 1, ret: P.bool, args: [A.SemanticsNode]}, {func: 1, ret: P.int, args: [K.RenderObject, K.RenderObject]}, {func: 1, ret: P.bool, args: [Y.DiagnosticsNode]}, {func: 1, ret: [P.Future, [P.Map, P.String, P.Object]], args: [[P.Map, P.String, P.String]]}, {func: 1, ret: [P.List, P.Object], args: [P.String, P.String]}, {func: 1, ret: P.Null, args: [,,]}, {func: 1, ret: P.bool, args: [N.Element]}, {func: 1, args: [,]}, {func: 1, ret: -1, args: [O.DragUpdateDetails]}, {func: 1, ret: [P.Future, P.Null]}, {func: 1, ret: [P.Map, P.String, P.Object], args: [P.String, P.String]}, {func: 1, ret: P.String, args: [P.int]}, {func: 1, ret: P.bool, args: [Q.TextSpan]}, {func: 1, ret: -1, args: [F.PointerDownEvent]}, {func: 1, ret: -1, args: [{func: 1, ret: -1}]}, {func: 1, ret: R.ColorTween, args: [,]}, {func: 1, ret: -1, args: [K.PaintingContext, P.Offset]}, {func: 1, ret: -1, args: [K.RenderObject]}, {func: 1, ret: P.Null, args: [P.Duration]}, {func: 1, ret: P.int, args: [A.SemanticsNode, A.SemanticsNode]}, {func: 1, ret: [P.Future, P.Null], args: [P.bool]}, {func: 1, ret: [P.Map, P.String, P.Object], args: [P.String]}, {func: 1, ret: -1, args: [P.bool]}, {func: 1, ret: -1, args: [P.Object], opt: [P.StackTrace]}, {func: 1, ret: -1, args: [O.DragEndDetails]}, {func: 1, ret: -1, args: [P.String]}, {func: 1, ret: -1, args: [P.int]}, {func: 1, ret: -1, opt: [P.Object]}, {func: 1, ret: P.String}, {func: 1, ret: P.int, args: [,,]}, {func: 1, ret: P.double}, {func: 1, ret: [P.Future, P.ByteData], args: [P.ByteData]}, {func: 1, ret: B.KeyboardSide, args: [P.int, P.int]}, {func: 1, ret: [K.Route,,], args: [K.RouteSettings]}, {func: 1, ret: -1, args: [P.Uint8List, P.String, P.int]}, {func: 1, ret: P.Null, args: [P.String, P.int]}, {func: 1, ret: [R.Tween,,], args: [[R.Tween,,],, {func: 1, ret: [R.Tween,,], args: [,]}]}, {func: 1, ret: P.bool, args: [X.OverlayEntry]}, {func: 1, ret: P.int}, {func: 1, ret: [R.Tween, P.double], args: [,]}, {func: 1, ret: P.String, args: [P.String]}, {func: 1, ret: P.Null, args: [, P.StackTrace]}, {func: 1, ret: P.Color, args: [P.double]}, {func: 1, ret: [P.LinkedHashSet, {func: 1, ret: -1, args: [F.PointerEvent]}]}, {func: 1, ret: R.RectTween, args: [P.Rect, P.Rect]}, {func: 1, bounds: [P.Object], ret: [V.MaterialPageRoute, 0], args: [K.RouteSettings, {func: 1, ret: N.Widget, args: [N.BuildContext]}]}, {func: 1, ret: K.AnimatedTheme, args: [N.BuildContext, N.Widget]}, {func: 1, ret: E.FloatingActionButton, args: [N.BuildContext, {func: 1, ret: -1}]}, {func: 1, ret: -1, args: [P.Object, P.StackTrace]}, {func: 1, ret: P.double, args: [D._Diagonal]}, {func: 1, ret: -1, args: [O.DragStartDetails]}, {func: 1, ret: P.Uint8List, args: [P.int]}, {func: 1, ret: P.Rect}, {func: 1, ret: -1, args: [N.TapDownDetails]}, {func: 1, ret: P.bool, args: [U.LayoutChangedNotification]}, {func: 1, ret: P.Uint8List, args: [,,]}, {func: 1, ret: P.Null, args: [P.String]}, {func: 1, ret: M.ShapeBorderTween, args: [,]}, {func: 1, ret: K.PageTransitionsBuilder, args: [T.TargetPlatform]}, {func: 1, ret: T.CustomMultiChildLayout, args: [N.BuildContext, N.Widget]}, {func: 1, ret: K.ThemeDataTween, args: [,]}, {func: 1, ret: X.ThemeData}, {func: 1, ret: P.Null, args: [X.AnimationStatus]}, {func: 1, ret: V.EdgeInsetsGeometry, args: [V.EdgeInsetsGeometry, Y.ShapeBorder]}, {func: 1, ret: Y.ShapeBorder, args: [Y.ShapeBorder]}, {func: 1, ret: P.String, args: [Y.ShapeBorder]}, {func: 1, ret: P.bool, args: [P.double]}, {func: 1, ret: -1, args: [P.String], opt: [,]}, {func: 1, ret: P.Color, args: [P.Color]}, {func: 1, ret: -1, args: [P.Object]}, {func: 1, ret: Y.DiagnosticsNode, args: [Q.TextSpan]}, {func: 1, ret: -1, args: [P.int, P.SemanticsAction, P.ByteData]}, {func: 1, ret: Y.MouseTrackerAnnotation, args: [P.Offset]}, {func: 1, ret: [P.Future,,]}, {func: 1, ret: -1, named: {callback: {func: 1, ret: [P.Future, [P.Map, P.String,,]], args: [[P.Map, P.String, P.String]]}, name: P.String}}, {func: 1, ret: P.String, args: [P.double, P.double, P.String]}, {func: 1, ret: [P._Future,,], args: [,]}, {func: 1, ret: P.String, args: [S.RenderBox]}, {func: 1, ret: P.Null, args: [P.int,,]}, {func: 1, ret: -1, named: {curve: Z.Curve, descendant: K.RenderObject, duration: P.Duration, rect: P.Rect}}, {func: 1, ret: [P.Future, P.ServiceExtensionResponse], args: [P.String, [P.Map, P.String, P.String]]}, {func: 1, ret: A.SemanticsConfiguration, args: [P.int, P.int]}, {func: 1, ret: [P.Future, P.String], args: [P.String]}, {func: 1, ret: P.Null, args: [,], opt: [P.StackTrace]}, {func: 1, ret: P.Null, args: [P.int, N._FrameCallbackEntry]}, {func: 1, ret: -1, args: [Y.DiagnosticsNode]}, {func: 1, ret: A.SemanticsNode, args: [A._TraversalSortNode]}, {func: 1, ret: P.String, args: [P.SemanticsAction]}, {func: 1, ret: P.String, args: [A.CustomSemanticsAction]}, {func: 1, ret: P.bool, args: [P.SemanticsFlag]}, {func: 1, ret: P.String, args: [P.SemanticsFlag]}, {func: 1, ret: Y.DiagnosticsNode, args: [A.SemanticsNode]}, {func: 1, ret: M.TickerFuture, named: {from: P.double}}, {func: 1, ret: P.int, args: [A.SemanticsNode]}, {func: 1, ret: A.SemanticsNode, args: [P.int]}, {func: 1, ret: [P.Stream, F.LicenseEntry]}, {func: 1, ret: -1, args: [B.AbstractNode]}, {func: 1, ret: P.Null, args: [P.ByteData]}, {func: 1, ret: [P.Future,,], args: [,]}, {func: 1, ret: [P.Iterable, P.String], args: [P.String]}, {func: 1, ret: B.KeyboardSide, args: [P.int, P.int, P.int]}, {func: 1, ret: P.String, args: [D.GestureArenaMember]}, {func: 1, ret: P.Type, args: [[L.LocalizationsDelegate,,]]}, {func: 1, ret: P.String, args: [P.Type]}, {func: 1, ret: -1, args: [,]}, {func: 1, ret: P.Null, args: [{func: 1, ret: -1}]}, {func: 1, ret: [P.Future, P.double]}, {func: 1, ret: [P.Future, P.Null], args: [P.double]}, {func: 1, ret: [P.Future, P.String]}, {func: 1, ret: [P.Future, P.Null], args: [P.String]}, {func: 1, ret: [P.Future,,], args: [F.MethodCall]}, {func: 1, ret: [P.Future, -1], args: [P.Object]}, {func: 1, ret: D._GestureArena}, {func: 1, ret: P.Null, args: [-1]}, {func: 1, ret: P.bool, args: [O.FocusNode]}, {func: 1, ret: Y.DiagnosticsNode, args: [O.FocusNode]}, {func: 1, ret: -1, args: [B.RawKeyEvent]}, {func: 1, ret: [P.Iterable, O.FocusNode], args: [O.FocusNode]}, {func: 1, ret: [P.HashSet, N.Element]}, {func: 1, ret: P.int, args: [N.Element, N.Element]}, {func: 1, args: [P.String]}, {func: 1, ret: [P.HashSet, [N.GlobalKey, [N.State, N.StatefulWidget]]]}, {func: 1, ret: P.String, args: [[N.GlobalKey, [N.State, N.StatefulWidget]]]}, {func: 1, ret: -1, args: [P.PointerDataPacket]}, {func: 1, ret: P.String, args: [N.Element]}, {func: 1, ret: Y.DiagnosticsNode, args: [N.InheritedElement]}, {func: 1, ret: N.ErrorWidget, args: [U.FlutterErrorDetails]}, {func: 1, ret: -1, args: [P.String, P.int]}, {func: 1, ret: N.TapGestureRecognizer}, {func: 1, ret: P.Null, args: [N.TapGestureRecognizer]}, {func: 1, ret: F.DoubleTapGestureRecognizer}, {func: 1, ret: P.Null, args: [F.DoubleTapGestureRecognizer]}, {func: 1, ret: T.LongPressGestureRecognizer}, {func: 1, ret: P.Null, args: [T.LongPressGestureRecognizer]}, {func: 1, ret: O.VerticalDragGestureRecognizer}, {func: 1, ret: P.Null, args: [O.VerticalDragGestureRecognizer]}, {func: 1, ret: O.HorizontalDragGestureRecognizer}, {func: 1, ret: P.Null, args: [O.HorizontalDragGestureRecognizer]}, {func: 1, ret: O.PanGestureRecognizer}, {func: 1, ret: P.Null, args: [O.PanGestureRecognizer]}, {func: 1, ret: P.String, args: [S.GestureRecognizer]}, {func: 1, ret: -1, args: [N.StatefulElement, P.Object]}, {func: 1, ret: T.Positioned, args: [N.BuildContext, N.Widget]}, {func: 1, ret: -1, args: [T._HeroFlight]}, {func: 1, ret: N.Widget, args: [N.BuildContext, [X.Animation, P.double], T.HeroFlightDirection, N.BuildContext, N.BuildContext]}, {func: 1, ret: Y.IconTheme, args: [N.BuildContext]}, {func: 1, ret: P.int, args: [P.int, P.int]}, {func: 1, ret: G.TextStyleTween, args: [,]}, {func: 1, ret: G.BorderRadiusTween, args: [,]}, {func: 1, ret: [P.Future,,], args: [L._Pending]}, {func: 1, ret: [P.Map, P.Type,,], args: [[P.List,,]]}, {func: 1, ret: [P.Map, P.Type,,], args: [[P.Map, P.Type,,]]}, {func: 1, ret: P.Null, args: [[P.Map, P.Type,,]]}, {func: 1, ret: P.Null, args: [N.TapDownDetails]}, {func: 1, bounds: [P.Object], ret: [P.Future, 0], args: [[K.Route, 0]]}, {func: 1, ret: G._PointerState}, {func: 1, ret: N.Widget, args: [N.BuildContext, N.Widget]}, {func: 1, ret: -1, args: [N._InspectorReferenceData]}, {func: 1, ret: P.bool, opt: [P.String]}, {func: 1, ret: -1, args: [P.String, P.String]}, {func: 1, ret: -1, args: [[P.List, P.Object]]}, {func: 1, ret: P.bool, args: [P.String], opt: [P.String]}, {func: 1, args: [, P.String]}, {func: 1, ret: P.Null, args: [P.String,,]}, {func: 1, ret: P.bool, args: [,]}, {func: 1, ret: -1, args: [N.Element, P.bool]}, {func: 1, ret: -1, args: [Y._TrackedAnnotation, P.int]}, {func: 1, ret: P.Null, args: [P.String, P.String]}, {func: 1, ret: [P.Set, N._InspectorReferenceData]}, {func: 1, ret: P.String, args: [P.Object]}, {func: 1, ret: [P.Map, P.String, P.Object], args: [N._DiagnosticsPathNode]}, {func: 1, ret: [P.Map, P.String, P.Object], args: [Y.DiagnosticsNode]}, {func: 1, ret: [P.List, P.int]}, {func: 1, ret: -1, args: [O.DragDownDetails]}, {func: 1, ret: P.double, args: [K.RenderObject]}, {func: 1, ret: P.int, args: [P.int, P.Object]}, {func: 1, ret: -1, args: [Y._TrackedAnnotation]}, {func: 1, ret: -1, args: [F._TapTracker]}, {func: 1, ret: P.int, args: [[P.Comparable,,], [P.Comparable,,]]}, {func: 1, ret: -1, args: [U.FlutterErrorDetails], named: {forceReport: P.bool}}, {func: 1, bounds: [P.Object, P.Object], ret: [P.Future, -1], args: [[F._IsolateConfiguration, 0, {futureOr: 1, type: 1}]]}, {func: 1, ret: -1, args: [P.String], named: {wrapWidth: P.int}}, {func: 1, ret: P.int, args: [[N._TaskEntry,,], [N._TaskEntry,,]]}, {func: 1, ret: P.bool, named: {priority: P.int, scheduler: N.SchedulerBinding}}, {func: 1, ret: P.String, args: [P.ByteData]}, {func: 1, ret: [P.List, F.LicenseEntry], args: [P.String]}, {func: 1, ret: [P.Future, -1], args: [P.String, P.ByteData, {func: 1, ret: -1, args: [P.ByteData]}]}, {func: 1, ret: N.Element, args: [N.Element]}], interceptorsByTag: null, leafTags: null};
  (function staticFields() {
    $.Primitives_timerFrequency = null;
    $.Primitives_timerTicks = null;
    $.Closure_functionCounter = 0;
    $.BoundClosure_selfFieldNameCache = null;
    $.BoundClosure_receiverFieldNameCache = null;
    $._inTypeAssertion = false;
    $.getTagFunction = null;
    $.alternateTagFunction = null;
    $.prototypeForTagFunction = null;
    $.dispatchRecordsForInstanceTags = null;
    $.interceptorsForUncacheableTags = null;
    $.initNativeDispatchFlag = null;
    $._nextCallback = null;
    $._lastCallback = null;
    $._lastPriorityCallback = null;
    $._isInCallbackLoop = false;
    $.Zone__current = C.C__RootZone;
    $._toStringVisiting = [];
    $.Stopwatch__frequency = null;
    $._Platform__environmentCache = null;
    $.FlutterError__errorCount = 0;
    $.BindingBase__debugInitialized = false;
    $.BindingBase__debugServiceExtensionsRegistered = false;
    $.LicenseRegistry__collectors = null;
    $.debugDefaultTargetPlatformOverride = null;
    $._debugPrintedCharacters = 0;
    $._debugPrintCompleter = null;
    $._debugPrintScheduled = false;
    $.GestureBinding__instance = null;
    $.PointerEventConverter__pointers = P.LinkedHashMap_LinkedHashMap$_empty(P.int, G._PointerState);
    $.RendererBinding__instance = null;
    $.RenderBox__debugDoingBaseline = false;
    $.debugPaintSizeEnabled = false;
    $.debugPaintBaselinesEnabled = false;
    $.debugRepaintRainbowEnabled = false;
    $.debugCheckElevationsEnabled = false;
    $.debugCurrentRepaintColor = C.HSVColor_8eb;
    $.debugOnProfilePaint = null;
    $.RenderObject__debugActiveLayout = null;
    $.RenderObject__debugActivePaint = null;
    $._timeDilation = 1;
    $._FrameCallbackEntry_debugCurrentCallbackStack = null;
    $.SchedulerBinding__instance = null;
    $.SemanticsBinding__instance = null;
    $.CustomSemanticsAction__nextId = 0;
    $.CustomSemanticsAction__actions = P.LinkedHashMap_LinkedHashMap$_empty(P.int, A.CustomSemanticsAction);
    $.CustomSemanticsAction__ids = P.LinkedHashMap_LinkedHashMap$_empty(A.CustomSemanticsAction, P.int);
    $.SemanticsNode__lastIdentifier = 0;
    $.BinaryMessages__handlers = P.LinkedHashMap_LinkedHashMap$_empty(P.String, {func: 1, ret: [P.Future, P.ByteData], args: [P.ByteData]});
    $.BinaryMessages__mockHandlers = P.LinkedHashMap_LinkedHashMap$_empty(P.String, {func: 1, ret: [P.Future, P.ByteData], args: [P.ByteData]});
    $.WidgetsApp_showPerformanceOverlayOverride = false;
    $.WidgetsApp_debugShowWidgetInspectorOverride = false;
    $.WidgetsApp_debugAllowBannerOverride = true;
    $.WidgetsBinding__instance = null;
    $.debugOnRebuildDirtyWidget = null;
    $.debugProfileBuildsEnabled = false;
    $.GlobalKey__registry = P.LinkedHashMap_LinkedHashMap$_empty([N.GlobalKey, [N.State, N.StatefulWidget]], N.Element);
    $.GlobalKey__debugReservations = P.LinkedHashMap_LinkedHashMap$_empty([N.GlobalKey, [N.State, N.StatefulWidget]], N.Element);
    $.Element__nextHashCode = 1;
    $.WidgetInspectorService__debugServiceExtensionsRegistered = false;
  })();
  (function lazyInitializers() {
    var _lazy = hunkHelpers.lazy;
    _lazy($, "DART_CLOSURE_PROPERTY_NAME", "$get$DART_CLOSURE_PROPERTY_NAME", function() {
      return H.getIsolateAffinityTag("_$dart_dartClosure");
    });
    _lazy($, "JS_INTEROP_INTERCEPTOR_TAG", "$get$JS_INTEROP_INTERCEPTOR_TAG", function() {
      return H.getIsolateAffinityTag("_$dart_js");
    });
    _lazy($, "TypeErrorDecoder_noSuchMethodPattern", "$get$TypeErrorDecoder_noSuchMethodPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({
        toString: function() {
          return "$receiver$";
        }
      }));
    });
    _lazy($, "TypeErrorDecoder_notClosurePattern", "$get$TypeErrorDecoder_notClosurePattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({$method$: null,
        toString: function() {
          return "$receiver$";
        }
      }));
    });
    _lazy($, "TypeErrorDecoder_nullCallPattern", "$get$TypeErrorDecoder_nullCallPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null));
    });
    _lazy($, "TypeErrorDecoder_nullLiteralCallPattern", "$get$TypeErrorDecoder_nullLiteralCallPattern", function() {
      return H.TypeErrorDecoder_extractPattern(function() {
        var $argumentsExpr$ = '$arguments$';
        try {
          null.$method$($argumentsExpr$);
        } catch (e) {
          return e.message;
        }
      }());
    });
    _lazy($, "TypeErrorDecoder_undefinedCallPattern", "$get$TypeErrorDecoder_undefinedCallPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0));
    });
    _lazy($, "TypeErrorDecoder_undefinedLiteralCallPattern", "$get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
      return H.TypeErrorDecoder_extractPattern(function() {
        var $argumentsExpr$ = '$arguments$';
        try {
          (void 0).$method$($argumentsExpr$);
        } catch (e) {
          return e.message;
        }
      }());
    });
    _lazy($, "TypeErrorDecoder_nullPropertyPattern", "$get$TypeErrorDecoder_nullPropertyPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null));
    });
    _lazy($, "TypeErrorDecoder_nullLiteralPropertyPattern", "$get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
      return H.TypeErrorDecoder_extractPattern(function() {
        try {
          null.$method$;
        } catch (e) {
          return e.message;
        }
      }());
    });
    _lazy($, "TypeErrorDecoder_undefinedPropertyPattern", "$get$TypeErrorDecoder_undefinedPropertyPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0));
    });
    _lazy($, "TypeErrorDecoder_undefinedLiteralPropertyPattern", "$get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
      return H.TypeErrorDecoder_extractPattern(function() {
        try {
          (void 0).$method$;
        } catch (e) {
          return e.message;
        }
      }());
    });
    _lazy($, "_AsyncRun__scheduleImmediateClosure", "$get$_AsyncRun__scheduleImmediateClosure", function() {
      return P._AsyncRun__initializeScheduleImmediate();
    });
    _lazy($, "Future__nullFuture", "$get$Future__nullFuture", function() {
      return P._Future$zoneValue(null, C.C__RootZone, P.Null);
    });
    _lazy($, "Utf8Decoder__decoder", "$get$Utf8Decoder__decoder", function() {
      return P.Utf8Decoder__makeDecoder();
    });
    _lazy($, "_Base64Decoder__inverseAlphabet", "$get$_Base64Decoder__inverseAlphabet", function() {
      return H.NativeInt8List__create1(H._ensureNativeList(H.setRuntimeTypeInfo([-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -2, -2, -2, -2, -2, 62, -2, 62, -2, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2, -1, -2, -2, -2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, 63, -2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2], [P.int])));
    });
    _lazy($, "_Uri__needsNoEncoding", "$get$_Uri__needsNoEncoding", function() {
      return P.RegExp_RegExp("^[\\-\\.0-9A-Z_a-z~]*$");
    });
    _lazy($, "_hasErrorStackProperty", "$get$_hasErrorStackProperty", function() {
      return new Error().stack != void 0;
    });
    _lazy($, "_scannerTables", "$get$_scannerTables", function() {
      return P._createTables();
    });
    _lazy($, "_extensions", "$get$_extensions", function() {
      return H.JsLinkedHashMap_JsLinkedHashMap$es6(P.String, {func: 1, ret: [P.Future, P.ServiceExtensionResponse], args: [P.String, [P.Map, P.String, P.String]]});
    });
    _lazy($, "Timeline__stack", "$get$Timeline__stack", function() {
      return H.setRuntimeTypeInfo([], [P._SyncBlock]);
    });
    _lazy($, "Platform__operatingSystem", "$get$Platform__operatingSystem", function() {
      return P._Platform_operatingSystem();
    });
    _lazy($, "Platform_isLinux", "$get$Platform_isLinux", function() {
      $.$get$Platform__operatingSystem();
      return false;
    });
    _lazy($, "Platform_isMacOS", "$get$Platform_isMacOS", function() {
      $.$get$Platform__operatingSystem();
      return false;
    });
    _lazy($, "Platform_isWindows", "$get$Platform_isWindows", function() {
      $.$get$Platform__operatingSystem();
      return false;
    });
    _lazy($, "Platform_isAndroid", "$get$Platform_isAndroid", function() {
      $.$get$Platform__operatingSystem();
      return false;
    });
    _lazy($, "Platform_isIOS", "$get$Platform_isIOS", function() {
      $.$get$Platform__operatingSystem();
      return false;
    });
    _lazy($, "Platform_isFuchsia", "$get$Platform_isFuchsia", function() {
      $.$get$Platform__operatingSystem();
      return false;
    });
    _lazy($, "Endian_host", "$get$Endian_host", function() {
      return P.ByteData_ByteData$view(H.NativeUint16List__create1(H._ensureNativeList(H.setRuntimeTypeInfo([1], [P.int]))).buffer, 0, null).getInt8(0) === 1 ? C.C_Endian : C.C_Endian0;
    });
    _lazy($, "Paint__kBlendModeDefault", "$get$Paint__kBlendModeDefault", function() {
      return 3;
    });
    _lazy($, "window", "$get$window", function() {
      return new P.Window();
    });
    _lazy($, "_kRightMiddleTween", "$get$_kRightMiddleTween", function() {
      return R.Tween$(C.Offset_1_0, C.Offset_0_0, P.Offset);
    });
    _lazy($, "_kMiddleLeftTween", "$get$_kMiddleLeftTween", function() {
      return R.Tween$(C.Offset_0_0, C.Offset_Oho, P.Offset);
    });
    _lazy($, "_kGradientShadowTween", "$get$_kGradientShadowTween", function() {
      return new G.DecorationTween(C._CupertinoEdgeShadowDecoration_null, C._CupertinoEdgeShadowDecoration_Igx);
    });
    _lazy($, "sparseTextConfiguration", "$get$sparseTextConfiguration", function() {
      return Y.TextTreeConfiguration$(true, "", ":", "", "", "", "", true, false, "\n", true, "\u2502", "\u2514\u2500", "\u251c\u2500", " ", " ", "\u2502 ", "  ", "", true);
    });
    _lazy($, "dashedTextConfiguration", "$get$dashedTextConfiguration", function() {
      return Y.TextTreeConfiguration$(true, "", ":", "", "", "", "", true, false, "\n", true, "\u254e", "\u2514\u254c", "\u254e\u254c", " ", " ", "\u2502 ", "  ", "", true);
    });
    _lazy($, "denseTextConfiguration", "$get$denseTextConfiguration", function() {
      return Y.TextTreeConfiguration$(false, "", ":", ")", "(", "", "", false, false, "\n", false, "\u2502", "\u2514", "\u251c", "", "", "\u2502", " ", ", ", true);
    });
    _lazy($, "transitionTextConfiguration", "$get$transitionTextConfiguration", function() {
      return Y.TextTreeConfiguration$(false, ":", " \u2550\u2550\u2550", "", "", "  ", " \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n", false, true, "\n", true, "\u2502", "\u2558\u2550\u2566\u2550\u2550 ", "\u255e\u2550\u2566\u2550\u2550 ", " \u2551 ", "", "", "", "", true);
    });
    _lazy($, "whitespaceTextConfiguration", "$get$whitespaceTextConfiguration", function() {
      return Y.TextTreeConfiguration$(false, ":", ":", "", "", "", "", false, false, "\n", true, " ", "", "", " ", "  ", "", "", "", true);
    });
    _lazy($, "singleLineTextConfiguration", "$get$singleLineTextConfiguration", function() {
      return Y.TextTreeConfiguration$(false, "", ":", ")", "(", "", "", true, false, "", false, "", "", "", "", "", "", "", ", ", false);
    });
    _lazy($, "_debugPrintBuffer", "$get$_debugPrintBuffer", function() {
      return P.ListQueue$(P.String);
    });
    _lazy($, "_debugPrintStopwatch", "$get$_debugPrintStopwatch", function() {
      return P.Stopwatch$();
    });
    _lazy($, "_indentPattern", "$get$_indentPattern", function() {
      return P.RegExp_RegExp("^ *(?:[-+*] |[0-9]+[.):] )?");
    });
    _lazy($, "_ScalingFabMotionAnimator__rotationTween", "$get$_ScalingFabMotionAnimator__rotationTween", function() {
      return R.Tween$(0.75, 1, P.double);
    });
    _lazy($, "_ScalingFabMotionAnimator__thresholdCenterTween", "$get$_ScalingFabMotionAnimator__thresholdCenterTween", function() {
      return R.CurveTween$(C.Threshold_znv);
    });
    _lazy($, "kMaterialEdges", "$get$kMaterialEdges", function() {
      return P.LinkedHashMap_LinkedHashMap$_literal([C.MaterialType_0, null, C.MaterialType_1, K.BorderRadius$circular(2), C.MaterialType_2, null, C.MaterialType_3, K.BorderRadius$circular(2), C.MaterialType_4, null], M.MaterialType, K.BorderRadius);
    });
    _lazy($, "_FadeUpwardsPageTransition__bottomUpTween", "$get$_FadeUpwardsPageTransition__bottomUpTween", function() {
      return R.Tween$(C.Offset_chs, C.Offset_0_0, P.Offset);
    });
    _lazy($, "_FadeUpwardsPageTransition__fastOutSlowInTween", "$get$_FadeUpwardsPageTransition__fastOutSlowInTween", function() {
      return R.CurveTween$(C.Cubic_ifx);
    });
    _lazy($, "_FadeUpwardsPageTransition__easeInTween", "$get$_FadeUpwardsPageTransition__easeInTween", function() {
      return R.CurveTween$(C.Cubic_JUR);
    });
    _lazy($, "_FloatingActionButtonTransitionState__entranceTurnTween", "$get$_FloatingActionButtonTransitionState__entranceTurnTween", function() {
      return R.Tween$(0.875, 1, P.double).chain$1(R.CurveTween$(C.Cubic_JUR));
    });
    _lazy($, "Theme__kFallbackTheme", "$get$Theme__kFallbackTheme", function() {
      return X.ThemeData_ThemeData$fallback();
    });
    _lazy($, "ThemeData__localizedThemeDataCache", "$get$ThemeData__localizedThemeDataCache", function() {
      var t1 = X._IdentityThemeDataCacheKey,
        t2 = X.ThemeData;
      return new X._FifoCache(P.LinkedHashMap_LinkedHashMap$_empty(t1, t2), 5, [t1, t2]);
    });
    _lazy($, "DebugOverflowIndicatorMixin__indicatorPaint", "$get$DebugOverflowIndicatorMixin__indicatorPaint", function() {
      var t1 = P.Paint$();
      t1.set$shader(P.Gradient$linear(C.Offset_0_0, C.Offset_10_10, H.setRuntimeTypeInfo([C.Color_3204448256, C.Color_3221225216, C.Color_3221225216, C.Color_3204448256], [P.Color]), H.setRuntimeTypeInfo([0.25, 0.25, 0.75, 0.75], [P.double]), C.TileMode_1));
      return t1;
    });
    _lazy($, "RenderErrorBox_textStyle", "$get$RenderErrorBox_textStyle", function() {
      var _null = null;
      return P.TextStyle$(_null, C.Color_4294967142, _null, _null, _null, _null, "monospace", _null, 14, _null, C.FontWeight_6, _null, _null, _null, _null, _null, _null, _null);
    });
    _lazy($, "RenderErrorBox_paragraphStyle", "$get$RenderErrorBox_paragraphStyle", function() {
      var _null = null;
      return P.ParagraphStyle$(_null, _null, _null, _null, _null, 1, _null, _null, _null, _null, _null);
    });
    _lazy($, "SemanticsNode__kEmptyConfig", "$get$SemanticsNode__kEmptyConfig", function() {
      return A.SemanticsConfiguration$();
    });
    _lazy($, "SemanticsNode__kEmptyChildList", "$get$SemanticsNode__kEmptyChildList", function() {
      return H.NativeInt32List_NativeInt32List(0);
    });
    _lazy($, "SemanticsNode__kEmptyCustomSemanticsActionsList", "$get$SemanticsNode__kEmptyCustomSemanticsActionsList", function() {
      return H.NativeInt32List_NativeInt32List(0);
    });
    _lazy($, "SemanticsNode__kIdentityTransform", "$get$SemanticsNode__kIdentityTransform", function() {
      return E.Matrix4_Matrix4$identity()._m4storage;
    });
    _lazy($, "rootBundle", "$get$rootBundle", function() {
      var t1 = P.String;
      return new Q.PlatformAssetBundle(P.LinkedHashMap_LinkedHashMap$_empty(t1, [P.Future, P.String]), P.LinkedHashMap_LinkedHashMap$_empty(t1, [P.Future,,]));
    });
    _lazy($, "RawKeyboard_instance", "$get$RawKeyboard_instance", function() {
      var t1 = new B.RawKeyboard(H.setRuntimeTypeInfo([], [{func: 1, ret: -1, args: [B.RawKeyEvent]}]), P.LinkedHashSet_LinkedHashSet$_empty(G.LogicalKeyboardKey));
      C.BasicMessageChannel_Cfi.setMessageHandler$1(t1.get$_handleKeyEvent());
      return t1;
    });
    _lazy($, "_kRect", "$get$_kRect", function() {
      return P.Rect$fromLTWH(-40, 28, 80, 12);
    });
    _lazy($, "GlobalKey__debugIllFatedElements", "$get$GlobalKey__debugIllFatedElements", function() {
      return P.HashSet_HashSet(N.Element);
    });
    _lazy($, "ErrorWidget_builder", "$get$ErrorWidget_builder", function() {
      return new N.ErrorWidget_closure();
    });
    _lazy($, "_HeroFlight__reverseTween", "$get$_HeroFlight__reverseTween", function() {
      return R.Tween$(1, 0, P.double);
    });
    _lazy($, "HeroController__defaultHeroFlightShuttleBuilder", "$get$HeroController__defaultHeroFlightShuttleBuilder", function() {
      return new T.HeroController_closure();
    });
    _lazy($, "_TheatreElement__onstageSlot", "$get$_TheatreElement__onstageSlot", function() {
      return new P.Object();
    });
    _lazy($, "WidgetInspectorService__instance", "$get$WidgetInspectorService__instance", function() {
      var t2, _null = null,
        t1 = new Array(20);
      t1.fixed$length = Array;
      t2 = P.String;
      return new N._WidgetInspectorService(H.setRuntimeTypeInfo(t1, [t2]), 0, new N.InspectorSelection(H.setRuntimeTypeInfo([], [K.RenderObject])), _null, P.LinkedHashMap_LinkedHashMap$_empty(t2, [P.Set, N._InspectorReferenceData]), P.LinkedHashMap_LinkedHashMap$_empty(t2, N._InspectorReferenceData), P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(P.Object, t2), 0, _null, false, false, _null, _null, _null, N._ElementLocationStatsTracker$(), N._ElementLocationStatsTracker$());
    });
  })();
  (function nativeSupport() {
    !function() {
      var intern = function(s) {
        var o = {};
        o[s] = 1;
        return Object.keys(hunkHelpers.convertToFastObject(o))[0];
      };
      init.getIsolateTag = function(name) {
        return intern("___dart_" + name + init.isolateTag);
      };
      var tableProperty = "___dart_isolate_tags_";
      var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
      var rootProperty = "_ZxYxX";
      for (var i = 0;; i++) {
        var property = intern(rootProperty + "_" + i + "_");
        if (!(property in usedProperties)) {
          usedProperties[property] = 1;
          init.isolateTag = property;
          break;
        }
      }
      init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
    }();
    hunkHelpers.setOrUpdateInterceptorsByTag({ApplicationCacheErrorEvent: J.Interceptor, DOMError: J.Interceptor, ErrorEvent: J.Interceptor, Event: J.Interceptor, InputEvent: J.Interceptor, MediaError: J.Interceptor, NavigatorUserMediaError: J.Interceptor, OverconstrainedError: J.Interceptor, PositionError: J.Interceptor, SensorErrorEvent: J.Interceptor, SpeechRecognitionError: J.Interceptor, SQLError: J.Interceptor, ArrayBuffer: H.NativeByteBuffer, ArrayBufferView: H.NativeTypedData, DataView: H.NativeByteData, Float64Array: H.NativeFloat64List, Int32Array: H.NativeInt32List, Int8Array: H.NativeInt8List, Uint16Array: H.NativeUint16List, Uint8Array: H.NativeUint8List, DOMException: W.DomException});
    hunkHelpers.setOrUpdateLeafTags({ApplicationCacheErrorEvent: true, DOMError: true, ErrorEvent: true, Event: true, InputEvent: true, MediaError: true, NavigatorUserMediaError: true, OverconstrainedError: true, PositionError: true, SensorErrorEvent: true, SpeechRecognitionError: true, SQLError: true, ArrayBuffer: true, ArrayBufferView: false, DataView: true, Float64Array: true, Int32Array: true, Int8Array: true, Uint16Array: true, Uint8Array: false, DOMException: true});
    H.NativeTypedArray.$nativeSuperclassTag = "ArrayBufferView";
    H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin.$nativeSuperclassTag = "ArrayBufferView";
    H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin.$nativeSuperclassTag = "ArrayBufferView";
    H.NativeTypedArrayOfDouble.$nativeSuperclassTag = "ArrayBufferView";
    H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin.$nativeSuperclassTag = "ArrayBufferView";
    H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin.$nativeSuperclassTag = "ArrayBufferView";
    H.NativeTypedArrayOfInt.$nativeSuperclassTag = "ArrayBufferView";
  })();
  convertAllToFastObject(holders);
  convertToFastObject($);
  (function(callback) {
    if (typeof document === "undefined") {
      callback(null);
      return;
    }
    if (typeof document.currentScript != 'undefined') {
      callback(document.currentScript);
      return;
    }
    var scripts = document.scripts;
    function onLoad(event) {
      for (var i = 0; i < scripts.length; ++i)
        scripts[i].removeEventListener("load", onLoad, false);
      callback(event.target);
    }
    for (var i = 0; i < scripts.length; ++i)
      scripts[i].addEventListener("load", onLoad, false);
  })(function(currentScript) {
    init.currentScript = currentScript;
    if (typeof dartMainRunner === "function")
      dartMainRunner(F.main, []);
    else
      F.main([]);
  });
})();

//# sourceMappingURL=main.dart.js.map
